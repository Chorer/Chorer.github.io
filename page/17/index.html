<!-- build time:Sun Sep 05 2021 14:32:58 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><span class="local-search local-search-plugin"><i class="fa fa-search"></i> <input type="search" placeholder="Search here......" id="local-search-input" class="local-search-input-cls"> <span class="local-search-border"></span><div id="local-search-result" class="local-search-result-cls"></div></span><div id="blog-down-reach"></div><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/09/08/F-Vue 生命周期/">Vue 生命周期与钩子函数</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-09-08&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp8 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/09/08/F-Vue 生命周期/"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-1.jpg"></p><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/Vue/">Vue</a></span></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/08/06/F-数据类型判断/">数据类型判断</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-08-06&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp840&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp3 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/08/06/F-数据类型判断/"><span id="more"></span><h2 id="typeof"><code>typeof</code></h2><p><code>typeof</code> 操作符返回一个表示数据类型的字符串，它可以应付常规场景下的数据类型判断。对基本数据类型 <code>undefined</code>, <code>boolean</code>, <code>string</code>, <code>number</code> 和引用数据类型 <code>function</code> 都可以正确判断，但是对 null，数组，对象则统一返回 &quot;object&quot;。也就是说，<code>typeof</code> 不适合用来判断引用数据类型。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">1</span>
<span class="kw">typeof</span> a <span class="co">// &quot;number&quot;</span>
<span class="kw">var</span> b <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]
<span class="kw">typeof</span> b <span class="co">// &quot;object&quot;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="op">&#123;&#125;</span>
<span class="kw">typeof</span> c <span class="co">// &quot;object&quot;</span></code></pre></div><h2 id="instanceof"><code>instanceof</code></h2><p><code>instanceof</code> 解决了上述问题，它的原理就是判断右操作数（通常是构造函数）的原型对象是否出现在左操作数（通常是实例）的原型链上，如果在则返回 <code>true</code>。据此可以判断引用数据类型具体是哪种类型。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> b <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]
b <span class="kw">instanceof</span> Array <span class="co">// true</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="op">&#123;&#125;</span>
c <span class="kw">instanceof</span> Object <span class="co">// true</span></code></pre></div><p>需要注意的是，<code>instanceof</code> 对于不是通过 new 创建的基本数据类型无法做出正确的判断：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">1</span>
a <span class="kw">instanceof</span> Number <span class="co">// false</span></code></pre></div><p>这是因为此时的 a 仅仅是一个基本类型的值，而不是实例对象，如果我们通过 new 创建 a，那么就能正确判断</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Number</span>(<span class="dv">1</span>)<span class="op">;</span>
a <span class="kw">instanceof</span> Number <span class="co">// true</span></code></pre></div><p>结合 <code>instanceof</code> 的原理其实就很好理解其中原因了。</p><p><code>&gt;&gt;</code> 另外要注意，<code>instanceof</code> 这个方法并非百试百灵 —— 假定脚本中有多个全局环境，例如 html 中有多个子 iframe，那么对于每一个全局环境而言，它都有自己版本的构造函数，进而有自己版本的原型链。<code>instanceof</code> 左右两边的操作数来自于不同全局环境时，即使实例和构造函数对应，也只会返回 false。</p><h2 id="object.getprototypeof"><code>Object.getPrototypeOf()</code></h2><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>]<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">Object</span>.<span class="at">getPrototypeOf</span>(arr) <span class="op">===</span> <span class="va">Array</span>.<span class="at">prototype</span>)<span class="op">;</span> <span class="co">// true</span></code></pre></div><p>利用原型链。存在同上问题。</p><h2 id="isprototypeof"><code>isPrototypeOf()</code></h2><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span>，<span class="dv">2</span>]<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">isPrototypeOf</span>(arr))<span class="op">;</span> <span class="co">// true</span></code></pre></div><p>利用原型链。存在同上问题。</p><h2 id="object.prototype.tostring.call"><code>Object.prototype.toString.call()</code></h2><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span>，<span class="dv">2</span>]<span class="op">;</span>
<span class="vs">`Object.prototype.toString.call(arr)`</span><span class="op">;</span> <span class="co">//&quot;[object Array]&quot;</span></code></pre></div><p>这个方法基本很完善，原理就是：在任何值上调用 <strong>Object 原生的 toString() 方法</strong>，都会返回一个格式为 [object NativeconstructorName] 的字符串。据此可以准确判断任何值的数据类型。</p><p>这里注意几个点：</p><ol style="list-style-type:decimal"><li><p>arr 作为对象，也是 Object 的一个实例，为什么不直接使用 <code>arr.toString()</code>？这是因为它的这个方法被重写了，即 <code>Array.prototype.toString()</code>。在使用 <code>arr.toString()</code> 的时候，它优先在原型链上找到并调用了重写的方法，最后输出的是 <code>&quot;1,2&quot;</code>。</p></li><li><p>对象字面量调用 <code>toString()</code> 的时候则依然输出 <code>&quot;[object Object]&quot;</code>，这是因为它没有重写这个方法，所以找到的是 <code>Object.prototype</code> 的该方法。</p></li><li><p>同样的，函数对象的 <code>toString()</code> 方法也被重写了，即 <code>Function.prototype.toString()</code>。调用的时候返回一个表示当前函数源代码的字符串。当对内置函数对象调用该方法时，返回如下格式的字符串：</p></li></ol><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">toString</span>()<span class="op">;</span>

<span class="co">// &quot;function Object() &#123;</span>
<span class="co">//    [native code]</span>
<span class="co">// &#125;&quot;</span>

<span class="va">Array</span>.<span class="at">toString</span>()<span class="op">;</span> 
<span class="co">// &quot;function Array() &#123; </span>
<span class="co">//    [native code] </span>
<span class="co">// &#125;&quot;</span></code></pre></div><p>实际上，这里的 Object 是构造函数，既然是函数，就可以看作是 Function 构造函数实例化的对象，因此这里相当于函数对象调用了 <code>toString()</code> 方法，也就是调用的 <code>Function.prototype.toString()</code> 方法。</p><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/数据类型/">数据类型</a></span></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/08/05/F-call() 和 apply() 的相关介绍和应用场景/">call() 和 apply() 的相关介绍和应用场景</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-08-05&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.7k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp6 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/08/05/F-call() 和 apply() 的相关介绍和应用场景/"><div class="figure"><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/callapplybind.jpg"></div><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/this/">this</a></span></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/07/11/F-解析赋值、浅拷贝和深拷贝/">解析赋值、浅拷贝和深拷贝</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-07-11&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp15 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/07/11/F-解析赋值、浅拷贝和深拷贝/"><div class="figure"><embed src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-1.webp"></div><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/06/30/T-关于大一下的总结/">关于大一下的总结</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-06-30&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp13 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/06/30/T-关于大一下的总结/"><p>本来应该是在年底做一些总结，然后写下明年的目标，但是我感觉这一年 —— 准确地说是这一学期过得太快，以至于给我一种好像 2019 年就要结束了的错觉。加上最近算是完成了一个阶段的学习，所以我想还是记录一下这个学期的事情。</p><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/06/24/Trs-更好的JavaScript条件式和匹配标准技巧/">「译」编写更好的 JavaScript 条件式和匹配条件的技巧</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-06-24&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.5k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp14 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/06/24/Trs-更好的JavaScript条件式和匹配标准技巧/"><blockquote><ul><li>原文地址：<a target="_blank" rel="noopener" href="https://devinduct.com/blogpost/35/tips-and-tricks-for-better-javascript-conditionals-and-match-criteria">Tips and Tricks for Better JavaScript Conditionals and Match Criteria</a></li><li>原文作者：Milos Protic</li><li>译者：Chor<div class="default">阅读全文......</div></li></ul></blockquote></a></div></article></section><nav class="pager-nav"><a class="extend prev" rel="prev" href="/page/16/">« Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/18/">Next »</a></nav></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->