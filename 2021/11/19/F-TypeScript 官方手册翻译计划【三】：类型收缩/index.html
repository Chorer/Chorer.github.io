<!-- build time:Sun Nov 28 2021 17:39:49 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/prism.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">TypeScript 官方手册翻译计划【三】：类型收缩</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-11-19&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp24 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/TypeScript/">TypeScript</a> <a href="/tags/documentation/">documentation</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/TypeScript%20%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/banner.jpeg" alt=""></p><span id="more"></span><blockquote><ul><li><strong>说明</strong>：目前网上没有 TypeScript 最新官方文档的中文翻译，所以有了这么一个翻译计划。因为我也是 TypeScript 的初学者，所以无法保证翻译百分之百准确，若有错误，欢迎评论区指出；</li><li><strong>翻译内容</strong>：暂定翻译内容为 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/intro.html">TypeScript Handbook</a>，后续有空会补充翻译文档的其它部分；</li><li><strong>项目地址</strong>：<a target="_blank" rel="noopener" href="https://github.com/Chorer/TypeScript-Doc-Zh">TypeScript-Doc-Zh</a>，如果对你有帮助，可以点一个 star ~</li></ul></blockquote><p>本章节官方文档地址：<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">Narrowing</a></p><h2 id="类型收缩"><a class="markdownIt-Anchor" href="#类型收缩"></a> 类型收缩</h2><p>假设现在有一个叫做 <code>padLeft</code> 的函数：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string): string &#123;
    trjow new Error(&#39;Not implemented yet!&#39;)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果 <code>padding</code> 是 <code>number</code> 类型，那么它将作为 <code>input</code> 前缀空格的个数，如果它是 <code>string</code> 类型，那么它将直接作为 <code>input</code> 的前缀。现在我们尝试实现一下相关的逻辑，假定要给 <code>padLeft</code> 传入 <code>number</code> 类型的 <code>padding</code> 参数。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string) &#123;
  return &quot; &quot;.repeat(padding) + input;
&#x2F;&#x2F; Argument of type &#39;string | number&#39; is not assignable to parameter of type &#39;number&#39;.
&#x2F;&#x2F;  Type &#39;string&#39; is not assignable to type &#39;number&#39;.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>啊这，传入 <code>padding</code> 参数的时候报错了。TypeScript 警告我们，将 <code>number</code> 添加给 <code>number | string</code> 可能会得到期望之外的结果，事实上也的确如此。换句话说，我们没有在一开始显式检查 <code>padding</code> 是否是一个 <code>number</code>，同时我们也没有处理它是 <code>string</code> 的情况。所以我们来改进一下代码吧。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string) &#123;
  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;
    return &quot; &quot;.repeat(padding) + input;
  &#125;
  return padding + input;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你觉得这看起来和无趣的 JavaScript 代码一样，那你可说到点上了。除了我们添加的类型注解之外，这些 TypeScript 代码看起来确实很像 JavaScript。这里的重点在于， TypeScript 的类型系统旨在让开发者尽可能轻松地编写常规的 JavaScript 代码，而不必为了获得类型安全而费尽心思。</p><p>虽然看起来可能不多，但实际上这个过程藏着很多秘密。就像 TypeScript 如何使用静态类型分析运行时的值一样，它将类型分析覆盖在类似于 <code>if/else</code> 这样的 JavaScript 运行时控制流结构上，同时还包括了三元表达式、循环、真值检查等，这些都能对类型产生影响。</p><p>在 <code>if</code> 条件检查语句中，TypeScript 发现了 <code>typeof padding === &quot;number&quot;</code>，并将其视为一种称之为“类型保护”的特殊代码结构。TypeScript 遵循我们的程序可能到达的执行路径，并在给定的位置分析某个值可能取到的最具体类型。它会查看这些特殊的检查语句（也就是“类型保护”）和赋值语句，并将声明的类型精炼为更具体的类型，这就是所谓的“类型收缩”。在很多编辑器中，我们可以观察到这些类型的变化。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string) &#123;
  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;
    return &quot; &quot;.repeat(padding) + input;
      			             ^^^^^                      
				   &#x2F;&#x2F; (parameter) padding: number
  &#125;
  return padding + input;
         ^^^^^^^  
	    &#x2F;&#x2F; (parameter) padding: string
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TypeScript 可以理解几种不同的用于收缩类型的构造。</p><h3 id="typeof-类型保护"><a class="markdownIt-Anchor" href="#typeof-类型保护"></a> <code>typeof</code> 类型保护</h3><p>正如我们所看到的，JavaScript 支持的 <code>typeof</code> 运算符可以给出关于运行时值的类型的基本信息。同样的，TypeScript 期望该运算符可以返回如下确定的字符串：</p><ul><li><code>&quot;string&quot;</code></li><li><code>&quot;number&quot;</code></li><li><code>&quot;bigint&quot;</code></li><li><code>&quot;boolean&quot;</code></li><li><code>&quot;symbol&quot;</code></li><li><code>&quot;undefined&quot;</code></li><li><code>&quot;object&quot;</code></li><li><code>&quot;function&quot;</code></li></ul><p>就像我们在 <code>padLeft</code> 中看到的，这个运算符经常出现在大量的 JavaScript 库中，而 TypeScript 也能理解这个运算符，从而在不同的分支中收缩类型。</p><p>在 TypeScript 中，检查 <code>typeof</code> 的返回值就是一种类型保护的方式。因为 TypeScript 可以编码 <code>typeof</code> 对不同值的操作方式，所以它也知道这个运算符在 JavaScript 中的一些怪异表现。举个例子，注意看上面的列表，<code>typeof</code> 没有返回字符串 <code>&quot;null&quot;</code>。再看下面的例子：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printAll(strs: string | string[] | null) &#123;
  if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;
    for (const s of strs) &#123;
                    ^^^^	
		&#x2F;&#x2F; Object is possibly &#39;null&#39;.
      console.log(s);
    &#125;
  &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;
    console.log(strs);
  &#125; else &#123;
    &#x2F;&#x2F; do nothing
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>printAll</code> 函数中，我们试图检查 <code>strs</code> 是否是一个对象，从而判断它是不是数组类型（在 JavaScript 中，数组也属于对象类型）。但在 JavaScript 中，<code>typeof null</code> 实际上会返回 <code>&quot;object&quot;</code>！这是历史遗留 bug 中的其中一个。</p><p>有充足经验的开发者可能不会感到很惊讶，但并不是每一个人都曾在 JavaScript 中遇到这个问题。幸运的是，TypeScript 让我们知道 <code>strs</code> 只是收缩到 <code>string[] | null</code> 类型而不是 <code>string[]</code> 类型。</p><p>这可能是讲解“真值”检查的一个不错的引子。</p><h3 id="真值收缩"><a class="markdownIt-Anchor" href="#真值收缩"></a> 真值收缩</h3><p>Truthiness 这个词可能在词典中找不到，但你一定在 JavaScript 中听过这个东西。</p><p>在 JavaScript 中，我们可以在条件语句中使用任意的表达式，比如 <code>&amp;&amp;</code>、<code>||</code>、<code>if</code> 语句、布尔值取反（<code>!</code>）等。举个例子，<code>if</code> 语句并没有要求它的条件一定是 <code>boolean</code> 类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getUsersOnlineMessage(numUsersOnline: number) &#123;
  if (numUsersOnline) &#123;
    return &#96;There are $&#123;numUsersOnline&#125; online now!&#96;;
  &#125;
  return &quot;Nobody&#39;s here. :(&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 JavaScript 中，类似 <code>if</code> 这样的结构会首先将条件“强制转化为”一个 <code>boolean</code> 类型的值，从而确保接受的参数是合理的，之后基于结果是 <code>true</code> 还是 <code>false</code>，会选择对应的分支。</p><p>类似下面这样的值经过转化后都会成为 <code>false</code>：</p><ul><li><code>0</code></li><li><code>NaN</code></li><li><code>&quot;&quot;</code> （空字符串）</li><li><code>0n</code> (0 的 <code>bigint</code> 版本)</li><li><code>null</code></li><li><code>undefined</code></li></ul><p>除此之外的其他值经过转化后都会成为 <code>true</code>。你总可以通过调用 <code>Boolean</code> 函数将值转化为 <code>boolean</code> 类型，或者使用更加简短的 <code>!!</code>。（后者的优势在于，TypeScript 可以将其推断为一个更具体的字面量布尔值类型 <code>true</code>，而前者只能被推断为 <code>boolean</code>）</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 下面的结果都是 true
Boolean(&quot;hello&quot;); &#x2F;&#x2F; type: boolean, value: true
!!&quot;world&quot;; &#x2F;&#x2F; type: true,    value: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在编码中经常会用到这个特性，尤其多用于防止出现像 <code>null</code> 或者 <code>undefined</code> 这样的值。举个例子，我们尝试在 <code>printAll</code> 函数中使用：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printAll(strs: string | string[] | null) &#123;
  if (strs &amp;&amp; typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;
    for (const s of strs) &#123;
      console.log(s);
    &#125;
  &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;
    console.log(strs);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，通过检查 <code>strs</code> 是否是真值，我们成功摆脱了之前出现的报错。这至少可以防止出现像下面这样令人害怕的错误：</p><pre class="line-numbers language-none"><code class="language-none">TypeError: null is not iterable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是请记住，对原始类型的真值检查常常容易出错。举个例子，我们尝试像下面这样改写 <code>printAll</code>：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printAll(strs: string | string[] | null) &#123;
  &#x2F;&#x2F; !!!!!!!!!!!!!!!!
  &#x2F;&#x2F;  不要这样写！
  &#x2F;&#x2F; !!!!!!!!!!!!!!!!
  if (strs) &#123;
    if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;
      for (const s of strs) &#123;
        console.log(s);
      &#125;
    &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;
      console.log(strs);
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们将整个函数体包裹在一个真值检查中，但这样做其实有一个潜在的问题：我们可能再也无法正确地处理空字符串的情况。</p><p>TypeScript 在这里并不会给出报错提示，但如果你不熟悉 JavaScript 的话，这是一个值得关注的事情。TypeScript 总是能够帮助你提前捕获 bug，但如果你选择对某个值不做任何处理，那么在确保不过度约束的前提下，TypeScript 能做的也就只有这么多了。如果你需要的话，可以用一个 linter 确保自己正确处理了类似这样的情况。</p><p>关于真值收缩，最后一点要说明的是，布尔值取反 <code>!</code> 可以筛选出否定分支：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function multiplyAll(
  values: number[] | undefined,
  factor: number
): number[] | undefined &#123;
  if (!values) &#123;
    return values;
  &#125; else &#123;
    return values.map((x) &#x3D;&gt; x * factor);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="相等性收缩"><a class="markdownIt-Anchor" href="#相等性收缩"></a> 相等性收缩</h3><p>TypeScript 也使用 <code>switch</code> 语句和诸如 <code>===</code>、<code>!==</code>、<code>==</code> 和 <code>!=</code> 这样的相等性检查来收缩类型。举个例子：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function example(x: string | number, y: string | boolean) &#123;
  if (x &#x3D;&#x3D;&#x3D; y) &#123;
    &#x2F;&#x2F; We can now call any &#39;string&#39; method on &#39;x&#39; or &#39;y&#39;.
    x.toUpperCase();
      ^^^^^^^^^^^^^    
    &#x2F;&#x2F;(method) String.toUpperCase(): string
    y.toLowerCase();
      ^^^^^^^^^^^^^^      
    &#x2F;&#x2F;(method) String.toLowerCase(): string
  &#125; else &#123;
    console.log(x);
    		   ^^	           
               &#x2F;&#x2F;(parameter) x: string | number
    console.log(y);
                ^^
               &#x2F;&#x2F;(parameter) y: string | boolean
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述例子中，当我们通过检查得知 <code>x</code> 和 <code>y</code> 是相等的时候，TypeScript 知道它们的类型也必须是相等的。由于 <code>string</code> 是 <code>x</code> 和 <code>y</code> 共有的类型，所以 TypeScript 知道 <code>x</code> 和 <code>y</code> 在第一个逻辑分支中肯定都是 <code>string</code> 类型。</p><p>同样的，我们也可以检查特定的字面量值（和变量相对）。在前面讲解真值收缩的例子中，我们编写的 <code>printAll</code> 函数存在潜在的错误，因为它没有适当地处理空字符串的情况。不妨换一种思路，我们通过一个特定的检查排除 <code>null</code>，这样 TypeScript 也仍然可以将 <code>null</code> 从 <code>strs</code> 的类型中正确地移除。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printAll(strs: string | string[] | null) &#123;
  if (strs !&#x3D;&#x3D; null) &#123;
    if (typeof strs &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;
      for (const s of strs) &#123;
                      ^^^^
                     &#x2F;&#x2F; (parameter) strs: string[]
        console.log(s);
      &#125;
    &#125; else if (typeof strs &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;
      console.log(strs);
                  ^^^^ 
                 &#x2F;&#x2F; (parameter) strs: string
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JavaScript 的松散相等性检查 <code>==</code> 和 <code>!=</code> 同样也可以正确地收缩类型。可能你还不太熟悉，检查某个值是否<code>== null</code> 的时候，不仅仅是在检查这个值是否确切地等于 <code>null</code>，也是在检查这个值是否是潜在的 <code>undefined</code>。对于 <code>== undefined</code> 也同理：它会检查这个值是否等于 <code>null</code> 或者 <code>undefined</code>。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Container &#123;
  value: number | null | undefined;
&#125;
 
function multiplyValue(container: Container, factor: number) &#123;
  &#x2F;&#x2F; 这个检查可以同时移除 null 和 undefined
  if (container.value !&#x3D; null) &#123;
    console.log(container.value);
                          ^^^^^^   
                        &#x2F;&#x2F; (property) Container.value: number
 
    &#x2F;&#x2F; 现在可以安全地进行计算
    container.value *&#x3D; factor;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="in-操作符收缩"><a class="markdownIt-Anchor" href="#in-操作符收缩"></a> <code>in</code> 操作符收缩</h3><p>JavaScript 的 <code>in</code> 操作符可以判断对象是否有某个属性。TypeScript 将其视为一种收缩潜在类型的方式。</p><p>举个例子，假定有代码 <code>&quot;value&quot; in x</code>，<code>&quot;value&quot;</code> 是一个字符串字面量，<code>x</code> 是一个联合类型。那么结果为 <code>true</code> 的分支会将 <code>x</code> 收缩为具有可选属性或必需属性 <code>value</code> 的类型，而结果为 <code>false</code> 的分支则会将 <code>x</code> 收缩为具有可选属性或缺失属性 <code>value</code> 的类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Fish &#x3D; &#123; swim: () &#x3D;&gt; void &#125;;
type Bird &#x3D; &#123; fly: () &#x3D;&gt; void &#125;;
 
function move(animal: Fish | Bird) &#123;
  if (&quot;swim&quot; in animal) &#123;
    return animal.swim();
  &#125;
 
  return animal.fly();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次重申，可选的属性在收缩时会同时出现在两个分支中。举个例子，人类既能游泳也能飞（我指的是通过交通工具），因此在 <code>in</code> 检查中，这个类型会同时出现在两个分支中：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Fish &#x3D; &#123; swim: () &#x3D;&gt; void &#125;;
type Bird &#x3D; &#123; fly: () &#x3D;&gt; void &#125;;
type Human &#x3D; &#123; swim?: () &#x3D;&gt; void; fly?: () &#x3D;&gt; void &#125;;
 
function move(animal: Fish | Bird | Human) &#123;
  if (&quot;swim&quot; in animal) &#123;
    animal;
    ^^^^^^  
   &#x2F;&#x2F; (parameter) animal: Fish | Human
  &#125; else &#123;
    animal;
    ^^^^^^   
   &#x2F;&#x2F; (parameter) animal: Bird | Human
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="instanceof-收缩"><a class="markdownIt-Anchor" href="#instanceof-收缩"></a> <code>instanceof</code> 收缩</h3><p>JavaScript 有一个操作符可以检查某个值是否是另一个值的实例。更具体地说，在 JavaScript 中，<code>x instanceof Foo</code> 可以检查 <code>x</code> 的原型链上是否包含 <code>Foo.prototype</code>。虽然我们在这里不会深入探讨，而且后续讲解类的时候会涉及更多这方面的内容，但它对大多数可以由 <code>new</code> 构造的值来说仍然很有用。你可能已经猜到了，<code>instanceof</code> 也是类型保护的一种方式，TypeScript 可以在由 <code>instanceof</code> 保护的分支里收缩类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function logValue(x: Date | string) &#123;
  if (x instanceof Date) &#123;
    console.log(x.toUTCString());
                ^
              &#x2F;&#x2F; (parameter) x: Date
  &#125; else &#123;
    console.log(x.toUpperCase());
                ^
              &#x2F;&#x2F; (parameter) x: string
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值"><a class="markdownIt-Anchor" href="#赋值"></a> 赋值</h3><p>正如我们先前提到的，当我们给任意变量赋值的时候，TypeScript 会查看赋值语句右部，对左部的变量类型进行合适的收缩。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let x &#x3D; Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;;
 	^  
   &#x2F;&#x2F; let x: string | number
x &#x3D; 1;
 
console.log(x);
            ^     
          &#x2F;&#x2F; let x: number
x &#x3D; &quot;goodbye!&quot;;
 
console.log(x);
            ^ 
          &#x2F;&#x2F; let x: string<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这些赋值语句都是有效的。虽然在第一次赋值之后，<code>x</code> 的可观察类型变成了 <code>number</code>，但我们仍然可以给它赋值 <code>string</code> 类型的值。这是因为 <code>x</code> 的声明类型 —— 也就是 <code>x</code> 的初始类型，是 <code>string | number</code>，而可赋值性总是会基于声明类型进行检查。</p><p>如果我们赋值给 <code>x</code> 一个 <code>boolean</code> 类型的值，那么就会抛出一个错误，因为在声明类型中并不存在 <code>boolean</code> 类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let x &#x3D; Math.random() &lt; 0.5 ? 10 : &quot;hello world!&quot;;
    ^
  &#x2F;&#x2F; let x: string | number
x &#x3D; 1;
 
console.log(x);
 		   ^	          
          &#x2F;&#x2F; let x: number
x &#x3D; true;
^
&#x2F;&#x2F; Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.
 
console.log(x);
            ^        
           &#x2F;&#x2F; let x: string | number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="控制流分析"><a class="markdownIt-Anchor" href="#控制流分析"></a> 控制流分析</h3><p>到目前为止，我们已经通过一些基本的例子讲解了 TypeScript 是如何在具体的分支中收缩类型的。但除了分析每个变量，在 <code>if</code>、<code>while</code> 等条件语句中查找类型保护之外，TypeScript 还做了不少其他工作。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function padLeft(padding: number | string, input: string) &#123;
  if (typeof padding &#x3D;&#x3D;&#x3D; &quot;number&quot;) &#123;
    return &quot; &quot;.repeat(padding) + input;
  &#125;
  return padding + input;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>padLeft</code> 在第一个 <code>if</code> 块中返回。TypeScript 可以对这段代码进行分析，并发现函数体的剩余部分（<code>return padding + input;</code>）在 <code>padding</code> 为 <code>number</code> 的时候是不可达的。最后，针对函数体的剩余部分，它可以将 <code>number</code> 从 <code>padding</code> 的类型中移除（也就是将类型 <code>string | number</code> 收缩为 <code>string</code>）。</p><p>这种基于可达性的代码分析称为“控制流分析”。在遇到类型保护和赋值语句的时候，TypeScript 会使用这种流分析去收缩类型。当分析一个变量的时候，控制流可以不断被拆开与重新合并，而我们也可以观察到变量在每个节点有不同的类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function example() &#123;
  let x: string | number | boolean;
 
  x &#x3D; Math.random() &lt; 0.5;
 
  console.log(x);
              ^
             &#x2F;&#x2F; let x: boolean
 
  if (Math.random() &lt; 0.5) &#123;
    x &#x3D; &quot;hello&quot;;
    console.log(x);
                ^
               &#x2F;&#x2F; let x: string
  &#125; else &#123;
    x &#x3D; 100;
    console.log(x);
                ^ 
              &#x2F;&#x2F; let x: number
  &#125;
 
  return x;
         ^
        &#x2F;&#x2F; let x: string | number
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用类型谓词"><a class="markdownIt-Anchor" href="#使用类型谓词"></a> 使用类型谓词</h3><p>目前为止，我们都是使用现成的 JavaScript 结构去处理类型收缩，但有时候，你可能想要更加直接地去控制类型在代码中的变化。</p><p>要实现一个用户自定义的类型保护，我们只需要定义一个返回类型谓词的函数即可：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function isFish(pet: Fish | Bird): pet is Fish &#123;
  return (pet as Fish).swim !&#x3D;&#x3D; undefined;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在本例中，<code>pet is Fish</code> 就是一个类型谓词。类型谓词的形式是 <code>paramenterName is Type</code>，<code>parameterName</code> 必须是当前函数签名的参数名。</p><p>任何时候，只要给 <code>isFish</code> 传递参数并调用它，TypeScript 就会在该类型兼容初始类型的时候，将变量类型收缩为该具体的类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 对 swim 和 fly 的调用都是可以的
let pet &#x3D; getSmallPet();
 
if (isFish(pet)) &#123;
  pet.swim();
&#125; else &#123;
  pet.fly();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，TypeScript 不仅知道在 <code>if</code> 分支中 <code>pet</code> 是 <code>Fish</code>，也知道在 <code>else</code> 分支中其对应的类型，因为不是 <code>Fish</code> 那就肯定是 <code>Bird</code> 了。</p><p>你也可以使用 <code>isFish</code> 这个类型保护从一个 <code>Fish | Bird</code> 类型的数组中筛选出一个仅包含 <code>Fish</code> 类型的数组：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const zoo: (Fish | Bird)[] &#x3D; [getSmallPet(), getSmallPet(), getSmallPet()];
const underWater1: Fish[] &#x3D; zoo.filter(isFish);
&#x2F;&#x2F; 或者使用
const underWater2: Fish[] &#x3D; zoo.filter(isFish) as Fish[];
 
&#x2F;&#x2F; 在更复杂的例子中，可能需要重复类型谓词
const underWater3: Fish[] &#x3D; zoo.filter((pet): pet is Fish &#x3D;&gt; &#123;
  if (pet.name &#x3D;&#x3D;&#x3D; &quot;sharkey&quot;) return false;
  return isFish(pet);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，类可以使用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/classes.html#this-based-type-guards">this is Type</a> 去收缩类型。</p><h3 id="可辨识的联合类型"><a class="markdownIt-Anchor" href="#可辨识的联合类型"></a> 可辨识的联合类型</h3><p>目前为止，我们看到的大多数例子都是将单个变量收缩为简单类型，诸如 <code>string</code>、<code>boolean</code> 和 <code>number</code> 等。虽然这很常见，但在 JavaScript 中，我们很多时候需要处理稍微复杂一些的结构。</p><p>假设我们现在需要编码表示圆形和正方形的形状，圆形需要用到半径，正方形需要用到边长。我们会使用 <code>kind</code> 域表明当前正在处理的形状。以下是第一种定义 <code>Shape</code> 的方式：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Shape &#123;
    kind: &quot;circle&quot; | &quot;square&quot;;
    radius?: number;
    sideLength?: number;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意我们这里使用了字符串字面量类型的联合： <code>&quot;circle&quot;</code> 和 <code>&quot;square&quot;</code>。它可以告诉我们当前正在处理的形状是圆形还是正方形。通过使用 <code>&quot;circle&quot; | &quot;square&quot;</code> 而不是 <code>string</code>，我们可以避免拼写错误。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function handleShape(shape: Shape) &#123;
  &#x2F;&#x2F; oops!
  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;rect&quot;) &#123;
&#x2F;&#x2F; 该条件始终返回 false，因为类型 &quot;circle&quot; | &quot;square&quot; 和类型 &quot;rect&quot; 不存在重叠。
    &#x2F;&#x2F; ...
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以编写一个 <code>getArea</code> 函数，它可以基于当前处理的形状的类型使用对应的逻辑。首先我们来处理一下圆形：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;
  return Math.PI * shape.radius ** 2;
&#x2F;&#x2F; 对象可能是 &#39;undefined&#39;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在启用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictNullChecks">strictNullChecks</a> 的情况下会抛出一个错误 —— 这是合理的，毕竟 <code>radius</code> 可能没有定义。但如果我们对 <code>kind</code> 属性进行合理的检查呢？</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;
  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;
    return Math.PI * shape.radius ** 2;
   &#x2F;&#x2F; Object might be &#39;undefined&#39;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>emm，TypeScript 仍然无从下手。我们这里刚好遇到了一个场景，那就是我们掌握的关于这个值的信息比类型检查器要多。因此，这里可以使用一个非空值断言（给 <code>shape.radius</code> 添加后缀 <code>!</code>）表明 <code>radius</code> 一定是存在的。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;
  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;
    return Math.PI * shape.radius! ** 2;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这种处理方式似乎不是很理想。我们不得不给类型检查器添加大量的非空值断言（<code>!</code>），让它确信 <code>shape.radius</code> 已经被定义好了，但如果把代码移除，这些断言就很容易造成错误。此外，在禁用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictNullChecks">strictNullChecks</a> 的情况下，我们可能会意外地访问到其它域（毕竟读取可选属性的时候，TypeScript 会假定它们是存在的）。总而言之，应当有更好的处理方式。</p><p><code>Shape</code> 的编码方式的问题在于，类型检查器完全无法基于 <code>kind</code> 属性去判断 <code>radius</code> 和 <code>sideLength</code> 是否存在。我们必须把自己知道的信息传达给类型检查器。知晓这一点之后，让我们再次定义 <code>Shape</code>。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Circle &#123;
  kind: &quot;circle&quot;;
  radius: number;
&#125;
 
interface Square &#123;
  kind: &quot;square&quot;;
  sideLength: number;
&#125;
 
type Shape &#x3D; Circle | Square;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我们将 <code>Shape</code> 适当地划分为两个类型，它们有不同的 <code>kind</code> 属性值，但 <code>radius</code> 和 <code>sideLength</code> 在对应的类型中成为了必需属性。</p><p>我们来看下试图访问 <code>Shape</code> 的 <code>radius</code> 会发生什么事：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;
  return Math.PI * shape.radius ** 2;
                         ^^^^^^
&#x2F;&#x2F; Property &#39;radius&#39; does not exist on type &#39;Shape&#39;.
  &#x2F;&#x2F; Property &#39;radius&#39; does not exist on type &#39;Square&#39;.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就像之前第一次定义 <code>Shape</code> 的时候一样，仍然抛出了一个错误。之前，当 <code>radius</code> 是可选属性的时候，我们看到了一个报错（仅在启用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictNullChecks">strictNullChecks</a> 的情况下），因为 TypeScript 无从得知这个属性是否真的存在。而现在 <code>Shape</code> 已经是一个联合类型了，TypeScript 告诉我们 <code>shape</code> 可能是 <code>Square</code>，而 <code>Square</code> 是没有定义 <code>radius</code> 属性的！两种解释都是合理的，但只有后者会在禁用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictNullChecks">strictNullChecks</a> 的情况下仍然抛出一个错误。</p><p>那么，如果这时候我们再次检查 <code>kind</code> 属性会怎么样呢？</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;
  if (shape.kind &#x3D;&#x3D;&#x3D; &quot;circle&quot;) &#123;
    return Math.PI * shape.radius ** 2;
                     ^^^^^  
                   &#x2F;&#x2F; (parameter) shape: Circle
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码不再报错了！当联合类型中的每个类型都包含一个字面量类型的公共属性的时候，TypeScript 会将其视为一个可辨识的联合类型，并通过收缩确认类型为联合类型的某个成员。</p><p>在本例中，<code>kind</code> 就是那个公共属性（也就是 <code>Shape</code> 的一个可辨识属性）。通过检查 <code>kind</code> 属性是否为 <code>&quot;circle&quot;</code>，我们可以排除掉 <code>Shape</code> 中所有 <code>kind</code> 属性值不为 <code>&quot;circle&quot;</code> 的类型。也就是说，可以将 <code>shape</code> 类型收缩为 <code>Circle</code> 类型。</p><p>同理，这种检查也可以用于 <code>switch</code> 语句中。现在我们可以编写一个完整的 <code>getArea</code> 函数了，而且它没有任何麻烦的 <code>!</code> 非空值断言符号。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getArea(shape: Shape) &#123;
  switch (shape.kind) &#123;
    case &quot;circle&quot;:
      return Math.PI * shape.radius ** 2;
                       ^^^^^ 
                      &#x2F;&#x2F; (parameter) shape: Circle
    case &quot;square&quot;:
      return shape.sideLength ** 2;
             ^^^^^ 
            &#x2F;&#x2F; (parameter) shape: Square
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子的重点在于 <code>Shape</code> 的编码。将重要的信息传达给 TypeScript 非常重要，我们得告诉它，<code>Circle</code> 和 <code>Square</code> 是两种不同的类型，有各自的 <code>kind</code> 属性值。这样我们就可以编写类型安全的 TypeScript 代码，它看起来与我们编写的 JavaScript 没有什么不同。知道了这一点之后，类型系统也可以做“正确的”处理，在 <code>switch</code> 的每个分支中弄清具体的类型。</p><blockquote><p>顺便一提，你可以尝试编写上面的示例并删除一些返回关键字。你将看到，在 switch 语句中意外遇到不同子句时，类型检查可以有效避免 bug 的出现</p></blockquote><p>可辨识联合类型的用处非常大，不仅仅是用在本例的圆形和正方形中。它们还适用于表示 JavaScript 中任意类型的消息传递方案，比如在网络上发送消息（客户端/服务端通信）或在状态管理框架中的 mutation 进行编码等。</p><h3 id="never-类型"><a class="markdownIt-Anchor" href="#never-类型"></a> <code>never</code> 类型</h3><p>在收缩类型的时候，你可以将联合类型减少到一个仅存的类型，这时候，你基本上已经排除了所有的可能性，并且没有剩余的类型可选了。此时，TypeScript 会使用 <code>never</code> 类型去表示一个不应该存在的状态。</p><h3 id="穷举检查"><a class="markdownIt-Anchor" href="#穷举检查"></a> 穷举检查</h3><p><code>never</code> 类型可以赋值给任意一个类型，但是，除了 <code>never</code> 本身，没有任意一个类型可以赋值给 <code>never</code>。这意味着你可以使用类型收缩和 <code>never</code> 在一个 <code>swicth</code> 语句块中进行穷举检查。</p><p>举个例子，在 <code>getArea</code> 函数的 <code>default</code> 分支中，我们可以把 <code>shape</code> 赋值给 <code>never</code> 类型的值。这样，当任意一个可能的情况没有在前面的分支得到处理的时候，在这个分支中就必然会抛出错误。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Shape &#x3D; Circle | Square;
 
function getArea(shape: Shape) &#123;
  switch (shape.kind) &#123;
    case &quot;circle&quot;:
      return Math.PI * shape.radius ** 2;
    case &quot;square&quot;:
      return shape.sideLength ** 2;
    default:
      const _exhaustiveCheck: never &#x3D; shape;
      return _exhaustiveCheck;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给 <code>Shape</code> 联合类型添加一个新成员，将会导致 TypeScript 抛出一个错误：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Triangle &#123;
  kind: &quot;triangle&quot;;
  sideLength: number;
&#125;
 
type Shape &#x3D; Circle | Square | Triangle;
 
function getArea(shape: Shape) &#123;
  switch (shape.kind) &#123;
    case &quot;circle&quot;:
      return Math.PI * shape.radius ** 2;
    case &quot;square&quot;:
      return shape.sideLength ** 2;
    default:
      const _exhaustiveCheck: never &#x3D; shape;
		   ^^^^^^^^^^^^^^^^	
          &#x2F;&#x2F;Type &#39;Triangle&#39; is not assignable to type &#39;never&#39;.
      return _exhaustiveCheck;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="post-nav"><div class="post-nav-prev"><a href="/2021/11/20/F-TypeScript%20%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92%E3%80%90%E5%9B%9B%E3%80%91%EF%BC%9A%E5%87%BD%E6%95%B0/" rel="prev" title="TypeScript 官方手册翻译计划【四】：函数"><i class="fa fa-angle-double-left"></i>&nbspTypeScript 官方手册翻译计划【四】：函数</a></div><div class="post-nav-next"><a href="/2021/11/18/F-TypeScript%20%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92%E3%80%90%E4%BA%8C%E3%80%91%EF%BC%9A%E6%99%AE%E9%80%9A%E7%B1%BB%E5%9E%8B/" rel="next" title="TypeScript 官方手册翻译计划【二】：普通类型">TypeScript 官方手册翻译计划【二】：普通类型&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%BC%A9"><span class="toc-text">类型收缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof-%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-text">typeof 类型保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%80%BC%E6%94%B6%E7%BC%A9"><span class="toc-text">真值收缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E6%80%A7%E6%94%B6%E7%BC%A9"><span class="toc-text">相等性收缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in-%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%94%B6%E7%BC%A9"><span class="toc-text">in 操作符收缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-%E6%94%B6%E7%BC%A9"><span class="toc-text">instanceof 收缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-text">控制流分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D"><span class="toc-text">使用类型谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%A8%E8%AF%86%E7%9A%84%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">可辨识的联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never-%E7%B1%BB%E5%9E%8B"><span class="toc-text">never 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%B7%E4%B8%BE%E6%A3%80%E6%9F%A5"><span class="toc-text">穷举检查</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>function send_valine_Server(){var e="desp=",t=document.title,n=t.indexOf("|"),a=(t.substring(0,n),document.URL),s=new Date,l=document.getElementsByClassName("vnick vinput")[0].value||"Anonymous",i=(document.getElementsByClassName("vmail vinput")[0].value,document.getElementsByClassName("vlink vinput")[0].value,document.getElementsByClassName("veditor vinput")[0].value),o=e+"文章："+a+"\n\n昵称："+l+"\n\n留言："+i+"\n\n时间："+s.toLocaleString(),v=new XMLHttpRequest;v.open("POST","https://sc.ftqq.com/"+SCKEY_Server+".send",!0),v.setRequestHeader("Content-type","application/x-www-form-urlencoded"),v.send(title1+"&"+o)}new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0});var title1="text=你的博客有新的评论",SCKEY_Server="SCT99005TwWJDrDKdBwQGK0YmcPRAsr4B",ValineButton=document.getElementsByClassName("vsubmit vbtn")[0];ValineButton.onclick=send_valine_Server</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/prism.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:150,height:300,vOffset:-120,hOffset:-5},mobile:{show:!1},react:{opacityDefault:1e3,opacityOnHover:1e3},log:!1})</script></body></html><!-- rebuild by neat -->