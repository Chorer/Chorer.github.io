<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>inline-blcok和float</title>
      <link href="/2019/03/27/F-inline-block%E5%92%8Cfloat/"/>
      <url>/2019/03/27/F-inline-block%E5%92%8Cfloat/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><h3 id="1-比对："><a href="#1-比对：" class="headerlink" title="1.比对："></a>1.比对：</h3><p>简单比对一下div+css布局中的inline-block和float的特点，同时附上使用inline-block之后元素之间产生空隙的解决方法。<br><a id="more"></a><br>虽然设置浮动跟设置inline-block有些特征类似，但两者的区别还是非常明显的:</p><ul><li><p>文档流（Document flow）:<br>浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。</p></li><li><p>水平位置（Horizontal position）：<br>很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。</p></li><li><p>垂直对齐（Vertical alignment）：<br>在两个div的高度不同时，两种方式的对齐效果也不相同：<br><img src="" alt=""><br>图一：<code>display:inlne-block</code>属性修饰的元素没有脱离文档流，当然会与在正常的文档流中的元素一样采取的底端对齐方式。<br>图二： <code>float</code>属性修饰的元素在一定程度上脱离了普通文档流的限制，只用考虑向某个方向浮动，所以会产生如图的效果。<br>区别来了！！！如果是使用<code>display:inlne-block</code>，则我们可以通过<code>vertical-align</code>来控制两个元素的对齐方式：<br>我们为两个div分别添加一个属性：<code>vertical-align:middle</code></p><pre class="line-numbers language-css"><code class="language-css">&lt;div class=<span class="token string">"myContainer"</span>>   &lt;div class=<span class="token string">"div1"</span> style=<span class="token string">"display: inline-block;vertical-align: middle"</span>>   &lt;/div>   &lt;div class=<span class="token string">"div2"</span> style=<span class="token string">"display: inline-block;vertical-align: middle"</span>>   &lt;/div>&lt;/div><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看一下运行效果：<br><img src="" alt=""></p></li></ul><p>如图，div1出现在了div2的居中位置。假如使用的是float，我们是没办法使div1位于div2的中间位置的。</p><ul><li>空隙（Whitespace）：<br>inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空隙。而浮动元素会忽略空白节点，互相紧贴。</li></ul><h3 id="2-总结："><a href="#2-总结：" class="headerlink" title="2.总结："></a>2.总结：</h3><p>什么时候使用inline-block、什么时候使用float，这取决于你的设计稿跟解决方法。通常来说，当你需要控制元素的垂直对齐跟水平排列时，使用inline-block；当你需要让元素环绕某一个元素时，或者需要支持旧版本ie，或者不想处理inline-block带来的空隙问题时，使用浮动。</p><h3 id="3-如何消除inline-block带来的空隙"><a href="#3-如何消除inline-block带来的空隙" class="headerlink" title="3.如何消除inline-block带来的空隙;"></a>3.如何消除inline-block带来的空隙;</h3><h4 id="3-1-思路一："><a href="#3-1-思路一：" class="headerlink" title="3.1 思路一："></a>3.1 思路一：</h4><p>元素间的间隙出现的原因是元素标签之间的空格，把空格去掉间隙自然就会消失。来看以下几种写法：</p><ul><li>写法一/不建议使用：<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>写法二：<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>写法三：<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--  --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--  --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--  --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-思路二："><a href="#3-2-思路二：" class="headerlink" title="3.2 思路二："></a>3.2 思路二：</h4></li></ul><p>取消span的结束标签，这样间隙就没有了。为了兼容IE6/IE7，最后一个标签需要闭合。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>.demo span{     background:#ddd;     display: inline-block;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-思路三："><a href="#3-3-思路三：" class="headerlink" title="3.3 思路三："></a>3.3 思路三：</h4><p>不管是思路一还是思路二，都只适用于写静态页面的时候，一旦HTML是后台生成，就不生效了。<br>这时还有一个办法：在父容器上使用font-size:0。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>.demo {font-size: 0;}.demo span{        background:#ddd;        display: inline-block;        font-size: 14px; /*要设置相应的字号*/}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原理：<br>换行和回车会给各个span之间带来空格，而空格会被当成字符处理，因此通过给父元素设置字体大小为0，则空格字符大小也为0，相当于消除了其大小。需要注意的是，一定要额外设置span中的字体大小，否则会继承父元素的0大小字体。</p><h4 id="3-4-思路四："><a href="#3-4-思路四：" class="headerlink" title="3.4 思路四："></a>3.4 思路四：</h4><p>上面的思路其实已经很完美，但可惜不兼容Safari，以下给出终极方案,即<code>font-size:0</code>配合<code>letter-space:-N px</code>。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.finally-solve</span> </span><span class="token punctuation">{</span><span class="token property">letter-spacing</span><span class="token punctuation">:</span> -<span class="token number">4</span>px<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*根据不同字体字号或许需要做一定的调整*/</span><span class="token property">word-spacing</span><span class="token punctuation">:</span> -<span class="token number">4</span>px<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.finally-solve</span> li </span><span class="token punctuation">{</span><span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">16</span>px<span class="token punctuation">;</span><span class="token property">letter-spacing</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span><span class="token property">word-spacing</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span>inline-block<span class="token punctuation">;</span>*<span class="token property">display</span><span class="token punctuation">:</span> inline<span class="token punctuation">;</span><span class="token property">zoom</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>折腾博客系列之发布自己的主题：PureBlue</title>
      <link href="/2019/03/24/T-%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue/"/>
      <url>/2019/03/24/T-%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>博客内容固然是最重要的，但是抛开内容不讲，博客本身也应该带有自己的Tag，而不是光会用别人的轮子。<br><a id="more"></a><br>最早接触的博客平台是CSDN和博客园，在上面学习到了很多网友的经验，于是萌发了想要创建自己博客的念头，在写了几篇文章后又觉得：为何不自己搭建一个博客平台呢？因此在今年一月份的寒假捣鼓了hexo和github pages，包括下载各种漂亮的主题、添加各种有意思的插件，一时乐在其中。平静下来之后，我开始进行知识迁移的工作，把以前存放在印象笔记中的东西重新修改并整合，转移到个人博客里，于是内容慢慢充实起来。</p><p>直到十几天前，我用的还是Next主题，这的确是一个相当成熟和漂亮的主题，我特别喜欢它的简洁。直到某天看到一句话：</p><blockquote><p>当你看到你用的主题出现在两个以上的博客时，那你就要考虑自己写一个了。</p></blockquote><p>别说两个了，Next主题的用户数应该是目前所有主题中最多的，而博客外观的雷同很显然是一件非常尴尬的事情。正好在那时我也陷入了一个纠结，就是我一直处于知识输入的状态却鲜有项目上的输出，简单地说就是学的多、做的少—-这是很要命的事，毕竟“纸上得来终觉浅”。也就是说我面临两个问题：</p><ul><li>缺少项目实践</li><li>博客主题缺少个性化</li></ul><p>这两个问题恰巧有共同的答案，那就是自己制作一个主题。当时想的是这学期能做出来都算好的了，于是立了一个flag：</p><center><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1.jpg" width="450" height="120"></center><p>不过很欣慰的是，我赶在月底之前把它完成了，前后大约花了14天。（大概是这个flag给我的动力）</p><center><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/2.jpg" width="400" height="340"></center><p>这是<a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">项目地址</a>。</p><p>虽然是一个小项目，而且代码也写得比较乱，但是收获颇丰——接触到了两个新的技术，一是模板引擎ejs，二个是css预处理器stylus，还有就是对hexo的原理有了更为深入的理解，至少知道了我写的markdown文件是怎么在网页上渲染出来的，而不是光会用却不知道原理。</p><p>万事开头难，前期准备工作的时候真的是一头雾水。首先是Hexo的官方文档，写得很不友好，所以读起来云里雾里；其次是不同主题使用的模板引擎和css预编译都不同，主题文件的结构也不同，这大大提高了阅读源码的难度和花在上面的时间成本。虽然经过“搜刮”，我找到了几篇教程，但是大部分还是讲的不够浅显易懂，越看越晕。这时候我意识到两个重要的问题：</p><ul><li>这些东西不是给纯新手准备的，我需要先了解基础的概念</li><li>善用搜索引擎，不要将视野局限在国内平台</li></ul><p>所以我开始去youtube上寻找相关的视频，幸运的是我的确找到了<a href="https://www.youtube.com/watch?v=vJsxE6-JXDs&amp;index=16&amp;list=PLLAZ4kZ9dFpOMJR6D25ishrSedvsguVSm" target="_blank" rel="noopener">纯新手向的主题制作教程</a>。每集只有几分钟，但是对于理解一些基础概念来说已经足够。不用担心听不懂，因为自带字幕，再配合up主的操作演示，还是很好理解的。</p><p>之后我又谷歌了相关的文章，成功找到了这个<a href="http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-1-Index/" target="_blank" rel="noopener">系列教程</a>，这是目前找到的最详细的教程，真真正正的从零开始教你怎么做一个主题，所以说实话真的很感谢这位老外。为了加深对主题制作的理解以及方便其他有需求的人，我将这个系列翻译了过来，可以在我的博客里找到，当然也可以去<a href="https://segmentfault.com/a/1190000018575126" target="_blank" rel="noopener">Segment Fault</a>。目前我只翻译了两篇，第三篇会另外找个时间搞定。</p><p>教程看下来，发现难点主要集中在两个地方：一是理清项目结构，进行合理的组织，二个是设计样式并具体实现。<br>准备工作差不多之后，就可以开始动工了，不需要太着急，每天完成一部分就行。<br>印象比较深的难点就是垂直时间轴的制作，也就是下面这个东西：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/3.png" alt=""></p><p>一个是要做出样式，主要涉及伪元素的使用，以及考虑怎么让垂直轴随着页面高度增加而延长；二个是逻辑，遍历所有文章并根据年份进行划分，这里需要使用ejs的语法，对Hexo的内置变量也要熟悉。</p><p>当然，做这个主题的时候也踩了很多坑，这里做一下踩坑记录：</p><ul><li><p>路径问题。为了使代码更容易管理，通常制作主题都是采用模块化的方式，因此存在着大量的文件引用。而A文件引用B文件时，不一定是使用B相对于A的路径，而要看最终A文件被谁引用。</p></li><li><p>某篇文章中出现了一行很长的代码，因为没有对它进行换行和溢出处理，导致图片尺寸无法正常设置，同时所有的文本内容都被挤出div。</p></li><li><p>在本地测试的时候某些文章无法显示全文内容，并且底部div消失。这个问题比较奇葩，而且至今无解。猜想应该是渲染出错还是什么= =。</p></li><li><p>写stylus文件时混用了空格和tab，git报错。（这个是真的坑，开了sublime的提示才看出来的）</p></li><li><p>第三方插件失效。返回顶部按钮是用的第三方jq插件，坑的地方就在于，作者引用jq库时是用的http链接，被浏览器阻止了，导致插件失效。一开始以为是缓存问题导致的样式无法修改，在反复修改和刷新了一个半小时后才想到去控制台看报错信息：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20190322212018.png" alt=""><br>所以，为了保险一点还是在项目中放jq文件比较好，当然更好的做法应该是直接用原生js来写。</p></li><li><p>改动不生效的问题。比较常见的状况，在本地预览一切正常，通过域名访问的时候改动却迟迟没有生效，而且通常的清除浏览器缓存或者<code>hexo clean</code>还不一定有效。只能说改动的同步还是需要时间的= =</p></li><li><p>page页面共用。这个严格来说不算坑，而是应该留意的一个地方。Hexo中并没有专门的展示所有标签或者所有类别的页面，拿我用的ejs来说，layout文件夹下的tag.ejs实际指的是单一标签下的所有文章，同理categories.ejs指的是单一类别下的所有文章。而我们需要的展示页面实际上是统一放在page.ejs中，再根据条件判断生成对应页面。不过我实际操作的时候发现分类页走的是归档页的布局。<del>所以目前这个主题的分类页无法正常工作，也许之后会找到原因吧</del>问题已解决，目前分类页可以正常工作。</p></li></ul><p>主题基本的东西都做好了，剩下的就是上传到github，并且向Hexo官方站点发起pull request—-这些对于我这个菜鸟来说还很陌生，所以不得不去b站找了github和git使用的相关教程。本来应该一切顺利了，但是本地这边一直无法推送到远程仓库，查了很久才发现是两边文件不一致的问题 = = 。</p><p>当然，git和github是每个技术人的必备技能，所以之后我会另外找个时间系统学习一下这两者的使用。</p><p>最后当然就是编写说明文档了，很神奇的是在编写的时候不由得想起以前做汉化时写的使用说明。这两者还是有共同之处的，因为你是要写给别人看，所以你必须确保描述清晰和完整——想象自己是一个用户，如果阅读这份文档后没有使用上的疑惑，我觉得就可以了。</p><p>感触比较深的两点：一个是注意阅读源码。如果实在没有思路，可以先参考别人是怎么写的，一开始制作主题的时候很难理清项目结构，所以我选择了先看看别人是怎么写的；二个是英语的重要性——1/5的答案在百度，4/5的答案在谷歌，学会英语就意味着你找到了解决问题的另一条途径，而且无疑是更加宽广的途径。比如Hexo主题的制作，国内是没有人真的会去为这个而做系列视频的，但是国外有；同样地，提问题时也可以考虑选择国外平台，如果你注意了提问礼仪，很大几率问题会得到秒回。</p><p>到这里差不多就告一段落了，之后的时间我会慢慢完善和更新这个主题。目前来说用户只有我自己，所以也算是为我自己而去努力地塑造它吧。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> PureBlue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;译&gt;创建一个Hexo主题-Part2:其他页面</title>
      <link href="/2019/03/22/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2/"/>
      <url>/2019/03/22/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>前言：<br>本系列文章翻译自全栈工程师Jonathan Klughertz的<a href="http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-2-Other-Pages/" target="_blank" rel="noopener">博客文章</a>，将会用三个part详细讲解如何制作一个Hexo主题。我自己从这几篇文章中受益良多，所以心想干脆翻译一下，于是有了这篇译文。<br>我不是学翻译出身，若有翻译错误或是不到位之处，请指正。</p><a id="more"></a><hr><p>在这个系列教程中，你将学习怎么从零开始制作一个Hexo主题。<br>在part1中，我们已经着手动工并创建了首页。在这篇文章中，我们将运用所学完成剩余的页面。</p><h2 id="文章详情页"><a href="#文章详情页" class="headerlink" title="文章详情页"></a>文章详情页</h2><p>让我们继续完成part1中的剩余工作并创建文章详情页。<br>正如我们看到的，为了生成详情页，Hexo将会在<code>/layout/</code>文件夹中寻找一个<code>post.ejs</code>文件。<br>这是我的post.ejs文件：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/post.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-full'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> page<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了让代码更加有序，我们会将实际代码放在<code>_partial/article-full.ejs</code>中。现在先来创建这个文件：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-full.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Title <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h2 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-title"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- item.path %>"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>title <span class="token operator">||</span> item<span class="token punctuation">.</span>link<span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Date and Author <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-meta"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> item<span class="token punctuation">.</span>date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>date_format<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>author<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            by <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>author <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Content <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>content <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>hr <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Tags and Categories links <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'article-tags'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'article-categories'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个模板几乎和<code></code>_partial/article-excerpt.ejs`一样，除了：</p><ul><li>我们使用<code>&lt;%- item.content %&gt;</code>展示全文内容而不是摘要</li><li>在底部新增两个部分，分别是标签部分和分类部分。接下来分别创建它们。</li></ul><h3 id="文章标签"><a href="#文章标签" class="headerlink" title="文章标签"></a>文章标签</h3><p>文章标签部分将生成一篇文章对应的所有标签：<code>layout/_partial/article-tags.ejs</code><br>我们想要创建的是一系列的标签和链接，每个链接都将导向对应的标签页面，而标签页面会显示该标签的所有文章。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-tags.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>tags <span class="token operator">&amp;&amp;</span> item<span class="token punctuation">.</span>tags<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span>    <span class="token keyword">var</span> tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    item<span class="token punctuation">.</span>tags<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">{</span>        tags<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'&lt;a href="'</span> <span class="token operator">+</span> config<span class="token punctuation">.</span>root <span class="token operator">+</span> tag<span class="token punctuation">.</span>path <span class="token operator">+</span> <span class="token string">'">#'</span> <span class="token operator">+</span> tag<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'&lt;/a>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-tags-container"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>span <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"glyphicon glyphicon-tags"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> tags<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很简单，我们通过<code>post.tags</code>遍历文章的所有标签并让这些标签一个接一个地显示。我在每个标签前面加了一个#号，并且在列表前面额外加了一个图标。</p><h3 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h3><p><code>layout/_partial/article-categories.ejs</code>的内容和上面很相似</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-categories.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>categories <span class="token operator">&amp;&amp;</span> item<span class="token punctuation">.</span>categories<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span>    <span class="token keyword">var</span> categories <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    item<span class="token punctuation">.</span>categories<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">{</span>        categories<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'&lt;a href="'</span> <span class="token operator">+</span> config<span class="token punctuation">.</span>root <span class="token operator">+</span> category<span class="token punctuation">.</span>path <span class="token operator">+</span> <span class="token string">'">'</span> <span class="token operator">+</span> category<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'&lt;/a>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-categories-container"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>span <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"glyphicon glyphicon-folder-open"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> categories<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' / '</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里不再赘述。</p><h3 id="文章样式"><a href="#文章样式" class="headerlink" title="文章样式"></a>文章样式</h3><p>可能有人注意到了，我们分别给了标签部分和分类部分一个类名，这是为了方便给它们设置样式。这是相关代码，将它们添加进<code>blog.css</code>中：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// source/css/blog.css</span><span class="token punctuation">.</span>blog<span class="token operator">-</span>tags<span class="token operator">-</span>container<span class="token punctuation">,</span> <span class="token punctuation">.</span>blog<span class="token operator">-</span>categories<span class="token operator">-</span>container <span class="token punctuation">{</span>    margin<span class="token operator">-</span>top<span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>    font<span class="token operator">-</span>size<span class="token punctuation">:</span> 20px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span>blog<span class="token operator">-</span>tags<span class="token operator">-</span>container span<span class="token punctuation">.</span>glyphicon<span class="token punctuation">,</span> <span class="token punctuation">.</span>blog<span class="token operator">-</span>categories<span class="token operator">-</span>container span<span class="token punctuation">.</span>glyphicon <span class="token punctuation">{</span>    margin<span class="token operator">-</span>right<span class="token punctuation">:</span> 20px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="页面类型模板的详情页"><a href="#页面类型模板的详情页" class="headerlink" title="页面类型模板的详情页"></a>页面类型模板的详情页</h2><p>这个很简单。“页面类型模板”和“文章类型模板”相差无几。就当做练习自定义一下就好，这是我的设置：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/page.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-full'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> page<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="归档页"><a href="#归档页" class="headerlink" title="归档页"></a>归档页</h2><p>归档页和首页一样会显示文章列表，只是它要更加简略—尽管基础结构和首页是差不多的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/archive.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> page<span class="token punctuation">.</span>posts<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-archive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/pagination'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文章归档页部分"><a href="#文章归档页部分" class="headerlink" title="文章归档页部分"></a>文章归档页部分</h3><p>和前面一样，实际的工作是由<code>article-archive.ejs</code>完成的。我使用<code>article-excerpt</code>作为基础结构，做了适当删减，只保留标题、日期和作者。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-archive.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Title <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h2 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-title-archive"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- item.path %>"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>title <span class="token operator">||</span> item<span class="token punctuation">.</span>link<span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Date and Author <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-meta"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> item<span class="token punctuation">.</span>date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>date_format<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>author<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            by <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>author <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的人可能注意到，我为标题创建了一个新的类名（它们太大了，我不喜欢）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// source/css/blog.css</span><span class="token punctuation">.</span>blog<span class="token operator">-</span>post<span class="token operator">-</span>title<span class="token operator">-</span>archive <span class="token punctuation">{</span>    margin<span class="token operator">-</span>bottom<span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>    font<span class="token operator">-</span>size<span class="token punctuation">:</span> 25px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="标签页和分类页"><a href="#标签页和分类页" class="headerlink" title="标签页和分类页"></a>标签页和分类页</h2><p>最后我们还需要创建两个页面。标签页将包括某个标签对应的全部文章，分类页同理。如果你还记得的话：<br>| 模板 | 备用模板 | 页面描述 |<br>|—–|—–|—-|<br>| archive | index | 这是归档页。它将显示我们博客中所有文章的标题和详情页链接|<br>| category | archive | 这是分类页。与归档页类似，但是会根据类别进行筛选|<br>| tag | archive | 这是标签页。与分类页类似，但是会根据标签进行筛选|</p><p><code>tag.ejs</code>和’category.ejs’的回退页是<code>archive.ejs</code>。我认为这三个页面并无太大区别，我们仅仅是在使用<code>archive.ejs</code>的回退页而已。好处就是代码量减少、提高代码可复用性和可维护性。</p><p>不过为了区分这三个页面，我们还是给归档页加上标题吧：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/archive.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span>    <span class="token keyword">var</span> title <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>category<span class="token punctuation">)</span> title <span class="token operator">=</span> page<span class="token punctuation">.</span>category<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> title <span class="token operator">=</span> page<span class="token punctuation">.</span>tag<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>archive<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>year<span class="token punctuation">)</span> title <span class="token operator">=</span> page<span class="token punctuation">.</span>year <span class="token operator">+</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>month <span class="token operator">?</span> <span class="token string">'/'</span> <span class="token operator">+</span> page<span class="token punctuation">.</span>month <span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> title <span class="token operator">=</span> <span class="token string">"Archives"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>   <span class="token operator">&lt;</span>h2 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-archive-title"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> title <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> page<span class="token punctuation">.</span>posts<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-archive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/pagination'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们有了一个漂亮的标题用以描述了归档页的类型。<br>这是对应的CSS样式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// source/css/blog.css</span><span class="token punctuation">.</span>blog<span class="token operator">-</span>archive<span class="token operator">-</span>title <span class="token punctuation">{</span>    margin<span class="token operator">-</span>bottom<span class="token punctuation">:</span> 50px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>本教程的第二篇文章非常简单，你只需要清楚<a href="https://segmentfault.com/a/1190000018575126" target="_blank" rel="noopener">第一篇文章</a>中提及的概念即可。我强烈推荐你根据自己的口味尝试修改主题。</p><p>在第三篇文章中，我们将添加评论部分、统计部分、装饰部件并做一些改进。期待与你再次相见！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;译&gt;创建一个Hexo主题-Part1:首页</title>
      <link href="/2019/03/18/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1/"/>
      <url>/2019/03/18/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>前言：<br>本系列文章翻译自全栈工程师Jonathan Klughertz的<a href="http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-1-Index/" target="_blank" rel="noopener">博客文章</a>，将会用三个part详细讲解如何制作一个Hexo主题。我自己从这几篇文章中受益良多，所以心想干脆翻译一下，于是有了这篇译文。<br>我不是学翻译出身，若有翻译错误或是不到位之处，请指正。</p><a id="more"></a><hr><p>在这个系列教程中，你将学习怎么从零开始制作一个Hexo主题。我很喜欢Hexo，并且每天都在使用，不幸的是，直到今天关于主题制作的文档还是相当稀缺。所以我打算弥补这个空缺。</p><h2 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h2><ul><li>Hexo博客的基础使用。如果你是第一次接触，请<a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">前往官网阅读教程</a></li><li>了解Bootstrap</li><li>了解Javascript模板引擎（我们将使用EJS）</li></ul><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>这个项目旨在制作一个Hexo主题并详细了解Hexo引擎的工作方式。<br>我不想在HTML和CSS上花费太多时间，所以我们将重置下面这个Hexo主题：<a href="https://getbootstrap.com/docs/3.4/examples/blog/" target="_blank" rel="noopener">https://getbootstrap.com/docs/3.4/examples/blog/</a> 。它是Bootstrap文档中的一个标准初始模板样例。<br>我们将一步步地重用CSS、复制粘贴HTML，直到最后实现想要的效果。<br>如果你感到困惑或者只对它的代码感兴趣，请<a href="https://github.com/klugjo/bootstrap-blog-hexo" target="_blank" rel="noopener">前往github</a>。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="创建一个新的hexo博客"><a href="#创建一个新的hexo博客" class="headerlink" title="创建一个新的hexo博客"></a>创建一个新的hexo博客</h3><p>让我们从搭建一个全新的hexo博客开始吧</p><pre><code># Create a new foldermkdir hexo-theme-creation cd hexo-theme-creation# Initialise Hexohexo init</code></pre><h3 id="创建主题文件夹"><a href="#创建主题文件夹" class="headerlink" title="创建主题文件夹"></a>创建主题文件夹</h3><pre><code># Enter the theme foldercd themes# bootstrap-blog-hexo is also going to be the name of our thememkdir bootstrap-blog-hexo</code></pre><p>注意：如果你想在git中保存主题的话（你也应该这么做），请在<code>/themes/bootstrap-blog-hexo/</code>中初始化git。</p><h3 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h3><p>这是我们开始工作所需要的文件和文件夹：</p><pre><code>|-- layout // .ejs templates |-- source // source files (CSS, scripts)|-- _config.yml</code></pre><p>创建以下两个文件夹和_config.yml文件。</p><ul><li>/layout/ 将包含<a href="https://hexo.io/docs/themes.html#layout" target="_blank" rel="noopener">我们所有的EJS模板</a></li><li>/source/ 将包含<a href="https://hexo.io/docs/themes.html#source" target="_blank" rel="noopener">我们所有的资源</a>（CSS文件、外部脚本和库）</li><li>_config.yml 包含<a href="https://hexo.io/docs/themes.html#config-yml" target="_blank" rel="noopener">我们的主题配置</a>。现在暂且不写入任何内容。</li></ul><h3 id="复制bootstrap-blog资源"><a href="#复制bootstrap-blog资源" class="headerlink" title="复制bootstrap blog资源"></a>复制bootstrap blog资源</h3><p>从<a href="https://getbootstrap.com/docs/3.4/examples/blog/" target="_blank" rel="noopener">bootstrap blog template</a>复制所有我们需要的资源并放在source文件夹里。你可以选择通过浏览器查看资源并复制下来，或者是下载该<a href="https://s3.amazonaws.com/klugjo.github.io/source-hex-blog-creation.zip" target="_blank" rel="noopener">压缩包</a>，之后解压到source文件夹里。</p><pre><code>|-- layout |-- source     |-- bootstrap // Copy the boostrap library files here     |-- css // Copy the blog&#39;s css file here    |-- favicon        |-- favicon.ico // Your choice of favicon    |-- js // Copy the blog&#39;s js file here|-- _config.yml</code></pre><h3 id="Hexo的基本要素"><a href="#Hexo的基本要素" class="headerlink" title="Hexo的基本要素"></a>Hexo的基本要素</h3><p>在我们开始写第一个模板文件之前，先来看看Hexo博客生成过程的基本要素。</p><h4 id="页面类型"><a href="#页面类型" class="headerlink" title="页面类型"></a>页面类型</h4><p>我们能够在主题中定义<a href="https://hexo.io/docs/templates.html" target="_blank" rel="noopener">6种页面类型</a>，与之相对应地，在public文件夹生成的每一个单独的HTML页面都属于下面模板中的其中一个：</p><table><thead><tr><th>模板</th><th>回退</th><th>页面描述</th></tr></thead><tbody><tr><td>index</td><td>无</td><td>这是博客的首页，也是网站的主要入口。本教程中我们将让其显示文章摘要列表</td></tr><tr><td>post</td><td>index</td><td>这是文章的详情页。我们将展示一篇完整的文章以及一个评论区</td></tr><tr><td>page</td><td>index</td><td>这是页面的详情页，与post一样，但是是page类型的post</td></tr><tr><td>archive</td><td>index</td><td>这是归档页。它将显示我们博客中所有文章的标题和详情页链接</td></tr><tr><td>category</td><td>archive</td><td>这是分类页。与归档页类似，但是会根据类别进行筛选</td></tr><tr><td>tag</td><td>archive</td><td>这是标签页。与分类页类似，但是会根据标签进行筛选</td></tr></tbody></table><p>在本篇教程中我们将创建index模板。</p><p>在页面生成过程中，Hexo将会搜索名字为index.ejs,post.ejs,page.ejs等的文件，这些模板之后用于创建静态HTML页面。</p><h4 id="公共布局"><a href="#公共布局" class="headerlink" title="公共布局"></a>公共布局</h4><p>Hexo支持使用<a href="https://hexo.io/docs/templates.html#Layouts" target="_blank" rel="noopener">公共的布局文件</a>，上面的模板都将使用到该文件。<br>该文件命名为layout.ejs。不同页面类型的模板会创建一些内容，而这个文件就好比这些内容的“外壳”。<br>在我们的主题中，公共布局将包括：<code>&lt;html&gt;</code>标签、<code>&lt;head&gt;</code>标签、头部、菜单、底部和侧边栏。基本上是所有类型的页面都具备的元素。<br>不同的页面模板将只负责创建实际内容，这些内容将放在我们的主体部位。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在所有的模板中，我们都可以使用<a href="https://hexo.io/docs/variables.html" target="_blank" rel="noopener">hexo引擎提供的内置变量</a>。以下是部分变量：</p><ul><li>Site：<code>site</code>包含了网站的信息。例如，我们可以通过<code>site.posts</code>访问博客中的所有文章。当我们想要显示统计数据的时候，这将派上用场。</li><li>Page：<code>page</code>是主要变量，包含了许多与当前页面相关的信息，包括所有的文章标题、日期、内容等。</li><li>Config：<code>config</code>是一个指向站点<code>_config.yml</code>文件的JavaScript对象</li><li>Theme：<code>theme</code>是一个指向主题<code>_config.yml</code>文件的JavaScript对象</li></ul><h3 id="主题的布局创建"><a href="#主题的布局创建" class="headerlink" title="主题的布局创建"></a>主题的布局创建</h3><p>上面提及了<code>/layout/layout.ejs</code>文件，现在我们开始来创建它。</p><h4 id="顶部标签"><a href="#顶部标签" class="headerlink" title="顶部标签"></a>顶部标签</h4><p>首先创建layout.ejs文件并插入<code>&lt;html&gt;&lt;/html&gt;</code>标签</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//layout/layout.ejs</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Head tag <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/head'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们将所有<code>&lt;head&gt;</code>标签里的代码提取出来并放在局部视图中，这有助于实现关注点分离和代码重用。<br>语法是<code>partial(&#39;path&#39; [, arguments])</code><br>在创建<code>layout/_partial/head.ejs</code>文件后，从bootstrap源码中复制head标签里的代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/head.ejs</span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"X-UA-Compatible"</span> content<span class="token operator">=</span><span class="token string">"IE=edge"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"description"</span> content<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"author"</span> content<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span>    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">"icon"</span> href<span class="token operator">=</span><span class="token string">"favicon/favicon.ico"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>Blog Template <span class="token keyword">for</span> Bootstrap<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Bootstrap core CSS <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'bootstrap/css/bootstrap.min.css'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> IE10 viewport hack <span class="token keyword">for</span> Surface<span class="token operator">/</span>desktop Windows <span class="token number">8</span> bug <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'css/ie10-viewport-bug-workaround.css'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Custom styles <span class="token keyword">for</span> <span class="token keyword">this</span> template <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'css/blog.css'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> HTML5 shim and Respond<span class="token punctuation">.</span>js <span class="token keyword">for</span> IE8 support <span class="token keyword">of</span> HTML5 elements and media queries <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token punctuation">[</span><span class="token keyword">if</span> lt IE <span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">></span>        <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>        <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://oss.maxcdn.com/respond/1.4.2/respond.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token punctuation">[</span>endif<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这很简单，我们只需使用<a href="https://hexo.io/docs/helpers.html#css" target="_blank" rel="noopener">CSS helper</a>插入样式表。<br>source文件夹中的文件将会被复制到站点根目录下，所以不要在路径中包含<code>source/</code><br>我们将让<code>&lt;title&gt;</code>和<code>&lt;meta&gt;</code>标签保持动态，不过现在先暂且不管它们。</p><h4 id="底部标签"><a href="#底部标签" class="headerlink" title="底部标签"></a>底部标签</h4><p>底部标签位于<code>&lt;/body&gt;</code>之前。我们将在这个局部视图中包含所有脚本。<br>先修改一下布局：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/layout.ejs</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Head tag <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/head'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> After footer scripts <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/after-footer'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建<code>layout/_partial/after-footer.ejs</code>的内容：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/after-footer.ejs</span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">js</span><span class="token punctuation">(</span><span class="token string">'bootstrap/js/bootstrap.min.js'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> IE10 viewport hack <span class="token keyword">for</span> Surface<span class="token operator">/</span>desktop Windows <span class="token number">8</span> bug <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">js</span><span class="token punctuation">(</span><span class="token string">'js/ie10-viewport-bug-workaround.js'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意<a href="https://hexo.io/docs/helpers.html#js" target="_blank" rel="noopener">JS helper function</a>的使用，它将引用本地js文件。</p><h4 id="顶部菜单"><a href="#顶部菜单" class="headerlink" title="顶部菜单"></a>顶部菜单</h4><p>类似地，在<code>&lt;body&gt;</code>标签后创建顶部菜单。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/layout.ejs</span><span class="token comment" spellcheck="true">// [...]</span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Menu <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/menu'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token comment" spellcheck="true">// [...]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>layout/_partial/menu.ejs</code>的内容：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/menu.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-masthead"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>nav <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-nav"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> theme<span class="token punctuation">.</span>menu<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>                <span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-nav-item"</span> href<span class="token operator">=</span><span class="token string">"&lt;%- url_for(theme.menu[i]) %>"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> i <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>nav<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意<code>theme</code>全局变量的使用,它指向的是主题的<code>_config.yml</code>文件。为了可以在主题配置中配置菜单，我们需要在<code>_config.yml</code>文件中添加配置：</p><pre><code>_config.yml# Headermenu:  Home: /  Archives: /archives</code></pre><p>在<code>menu.ejs</code>中我们遍历了配置文件中所有的菜单项目并创建对应的链接。</p><h4 id="顶部"><a href="#顶部" class="headerlink" title="顶部"></a>顶部</h4><p>顶部将位于顶部菜单下面，它包含了博客标题和子标题：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/header.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-header"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h1 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-title"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> config<span class="token punctuation">.</span>title <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"lead blog-description"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>subtitle<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> config<span class="token punctuation">.</span>subtitle <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们使用了指向站点<code>_config.yml</code>文件的<code>config</code>变量，它包含了可供配置的标题和子标题属性。<br>注意在布局的<code>&lt;div class=&quot;container&quot;&gt;&lt;div&gt;</code>中嵌套顶部：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/layout.ejs</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Head tag <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/head'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Menu <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/menu'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Blog Header<span class="token punctuation">:</span> title and subtitle <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/header'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token comment" spellcheck="true">// [...]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="底部"><a href="#底部" class="headerlink" title="底部"></a>底部</h4><p>底部现在是完全静态的，内容如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/footer.ejs</span><span class="token operator">&lt;</span>footer <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-footer"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>Blog template built <span class="token keyword">for</span> <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://getbootstrap.com"</span><span class="token operator">></span>Bootstrap<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span> by <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"https://twitter.com/mdo"</span><span class="token operator">></span>@mdo<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>Adapted to Hexo by <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://www.codeblocq.com/"</span><span class="token operator">></span>klugjo<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>Back to top<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>footer<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="主要内容和侧边栏"><a href="#主要内容和侧边栏" class="headerlink" title="主要内容和侧边栏"></a>主要内容和侧边栏</h4><p>此时，我们再加上主要内容和侧边栏，基本就差不多了。<br>下面是最终的<code>layout.ejs</code>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/layout.ejs</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Head tag <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/head'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Menu <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/menu'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Blog Header<span class="token punctuation">:</span> title and subtitle <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/header'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"row"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Main Content <span class="token operator">--</span><span class="token operator">></span>            <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"col-sm-8 blog-main"</span><span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> body <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Sidebar <span class="token operator">--</span><span class="token operator">></span>            <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"col-sm-3 col-sm-offset-1 blog-sidebar"</span><span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/sidebar'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Footer <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/footer'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> After footer scripts <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/after-footer'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>body</code>变量对应了不同页面类型模板创建的内容（参见上面）。<br>至于侧边栏，我们现在暂且使用来自bootstrap模板的硬编码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/sidebar.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sidebar-module sidebar-module-inset"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h4<span class="token operator">></span>About<span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>Etiam porta <span class="token operator">&lt;</span>em<span class="token operator">></span>sem malesuada magna<span class="token operator">&lt;</span><span class="token operator">/</span>em<span class="token operator">></span> mollis euismod<span class="token punctuation">.</span> Cras mattis consectetur purus sit amet fermentum<span class="token punctuation">.</span> Aenean lacinia bibendum nulla sed consectetur<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sidebar-module"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h4<span class="token operator">></span>Archives<span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span>    <span class="token operator">&lt;</span>ol <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list-unstyled"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>March <span class="token number">2014</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>February <span class="token number">2014</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>January <span class="token number">2014</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>December <span class="token number">2013</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>November <span class="token number">2013</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>ol<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sidebar-module"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h4<span class="token operator">></span>Elsewhere<span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span>    <span class="token operator">&lt;</span>ol <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list-unstyled"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>GitHub<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>Twitter<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>Facebook<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>ol<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="首页文件"><a href="#首页文件" class="headerlink" title="首页文件"></a>首页文件</h3><p>布局到位后，我们就可以开始创建第一个页面类型模板inde.ejs了。<br>这是比较简陋的第一个版本：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/index.ejs</span><span class="token operator">&lt;</span>span<span class="token operator">></span>Content<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>别小瞧它，我们可以用这个在浏览器中测试主题：</p><pre><code># Verify that everything is alrighthexo generate# Start hexo serverhexo server</code></pre><p>访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 。哇！<br>注意：不要忘记在站点的config文件中更新主题：</p><pre><code>_config.yml# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: bootstrap-blog-hexo</code></pre><h4 id="遍历博客文章"><a href="#遍历博客文章" class="headerlink" title="遍历博客文章"></a>遍历博客文章</h4><p>我们想要在首页显示各篇文章的摘要。<br>首先，在我们的index.ejs文件中遍历文章：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout.index.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> page<span class="token punctuation">.</span>posts<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-excerpt'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过<code>page.posts</code>获取该页面的所有文章</li><li>通过<code>&lt;%- partial(&#39;name&#39;, args) %&gt;</code>给partial传参</li></ul><h4 id="文章布局"><a href="#文章布局" class="headerlink" title="文章布局"></a>文章布局</h4><p>创建<code>article-excerpt.ejs</code>文件，添加适合主题的代码。这是我的布局：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-excerpt.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Title <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h2 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-title"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- item.path %>"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>title <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Date and Author <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-meta"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> item<span class="token punctuation">.</span>date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>date_format<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>author<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            by <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>author <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Content <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>excerpt <span class="token operator">||</span> item<span class="token punctuation">.</span>content <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Only display the Read More link <span class="token keyword">if</span> we are displaying an excerpt <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>excerpt<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>            <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- item.path %>"</span><span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> theme<span class="token punctuation">.</span>excerpt_link <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="全文链接"><a href="#全文链接" class="headerlink" title="全文链接"></a>全文链接</h5><p>全文链接是由<code>config.root</code>（配置选项，相当于<code>/</code>）和<code>item.path</code>(相对路径或者绝对路径，指向全文)连接组成的。</p><h5 id="文章作者"><a href="#文章作者" class="headerlink" title="文章作者"></a>文章作者</h5><p>默认情况下，Hexo没有关于作者属性的的文章变量。不过我们可以在<a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="noopener">front matter</a>中添加任意自己想要的变量。<br>如果你想要在文章中显示作者名字，那么文章的front matter应该类似如下进行设置：</p><pre><code>title: Hello Worldauthor: Klughertz Jonathan---</code></pre><h6 id="Item-excerpt-和-Item-content"><a href="#Item-excerpt-和-Item-content" class="headerlink" title="Item excerpt 和 Item content"></a>Item excerpt 和 Item content</h6><p>当用Hexo编辑文章时，你可以用<code>&lt;!-- more --&gt;</code>标签从文章内容中截取摘要。在本教程中，因为我们展示的是文章列表，所以选择显示摘要。之后用户可以通过点击文章标题或者“阅读更多”的链接浏览全文。</p><h6 id="“阅读更多”文本"><a href="#“阅读更多”文本" class="headerlink" title="“阅读更多”文本"></a>“阅读更多”文本</h6><p>别忘了，你需要像我这样在主题的配置文件中添加一个新的属性：</p><pre><code>_config.yml# Read More textexcerpt_link: Read More</code></pre><p>希望接下来的代码容易理解。现在，我建议你写一些除了默认的Hello World之外的文章并享受这个结果。</p><h3 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h3><p>在本篇文章中，我们最后需要处理的是首页的分页器。<br>在<code>index.ejs</code>文件中增加一个分页器的partial：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/index.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> page<span class="token punctuation">.</span>posts<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-excerpt'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/pagination'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后开始创建分页器的内容，<code>layout/_partial/pagination.ejs</code>:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/pagination.ejs</span><span class="token operator">&lt;</span>nav<span class="token operator">></span>    <span class="token operator">&lt;</span>ul <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"pager"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- page.prev_link %>"</span><span class="token operator">></span>Previous<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- page.next_link %>"</span><span class="token operator">></span>Next<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>nav<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>page.prev</code>：上一页的页码。如果当前页是第一页，则为0</li><li><code>page.next</code>：下一页的页码。如果当前页是最后一页，则为0</li><li><code>page.next_link</code>和<code>page.prev_link</code>是什么就不用多说了。</li></ul><p>如果你没有足够的文章用来查看分页器的工作效果，可以在主配置文件中（<code>per_page</code>属性）调整每一页的文章数。</p><p>这就是今天的内容，在下一篇教程中，我们将完成博客剩下的所有页面。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伪类和伪元素</title>
      <link href="/2019/03/10/F-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
      <url>/2019/03/10/F-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><h3 id="1-伪类和伪元素的引入"><a href="#1-伪类和伪元素的引入" class="headerlink" title="1.伪类和伪元素的引入"></a>1.伪类和伪元素的引入</h3><blockquote><p>CSS introduces the concepts of pseudo-elements and pseudo-classes to permit formatting based on information that lies outside the document tree.</p></blockquote><p>CSS 引入伪类和伪元素的概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。<br><a id="more"></a></p><h3 id="2-伪类和伪元素的概念"><a href="#2-伪类和伪元素的概念" class="headerlink" title="2.伪类和伪元素的概念"></a>2.伪类和伪元素的概念</h3><h4 id="2-1-伪类："><a href="#2-1-伪类：" class="headerlink" title="2.1 伪类："></a>2.1 伪类：</h4><blockquote><p>伪类用于当已有元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。</p></blockquote><p>例如，当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态。虽然它和普通的 CSS 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p><h4 id="2-2-伪元素"><a href="#2-2-伪元素" class="headerlink" title="2.2 伪元素"></a>2.2 伪元素</h4><blockquote><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。</p></blockquote><p>例如，我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><h3 id="3-伪类列举"><a href="#3-伪类列举" class="headerlink" title="3.伪类列举"></a>3.伪类列举</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/chor1.png" alt=""></p><h4 id="3-1-状态伪类"><a href="#3-1-状态伪类" class="headerlink" title="3.1 状态伪类"></a>3.1 状态伪类</h4><p>状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式就会失去。状态伪类的顺序很重要，顺序错误可能会导致没有效果。通常的建议是<span style="background-color:#fffa7d">LVFHA</span>，即—–link，visited，focus，hover，active。</p><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:link</td><td>a:link</td><td>选择所有未访问的链接</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有访问过的链接</td></tr><tr><td>:hover</td><td>a:hover</td><td>选择鼠标悬空的链接</td></tr><tr><td>:active</td><td>a:active</td><td>选择正在活动的链接</td></tr><tr><td>:focus</td><td>input:focus</td><td>选择获得焦点的输入框</td></tr></tbody></table><h4 id="3-2-结构化伪类"><a href="#3-2-结构化伪类" class="headerlink" title="3.2 结构化伪类"></a>3.2 结构化伪类</h4><p>结构化伪类是 CSS3 新增选择器，利用 DOM 树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少 class 和 id 属性的定义，使文档结构更简洁。</p><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:first-child</td><td>p:first-child</td><td>选择符合的p元素，该p元素必须是其父元素的第一个子元素</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择符合的p元素，该p元素必须是其父元素的第一个p子元素</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>选择符合的p元素，该p元素必须是其父元素的最后一个子元素</td></tr><tr><td>:last-of-type</td><td>p:last-of-type</td><td>选择符合的p元素，该p元素必须是其父元素的最后一个p子元素</td></tr><tr><td>:not(selector)</td><td>:not(p)</td><td>选择所有p以外的元素</td></tr><tr><td>:nth-child(n)</td><td>p:nth-child(2)</td><td>选择符合的p元素，该p元素必须是其父元素的第2个子元素</td></tr><tr><td>:nth-last-child(n)</td><td>p:nth-last-child(2)</td><td>选择符合的p元素，该p元素必须是其父元素的倒数第2个子元素</td></tr><tr><td>:nth-last-of-type(n)</td><td>p:nth-last-of-type(2)</td><td>选择符合的p元素，该p元素必须是其父元素的倒数第2个p子元素</td></tr><tr><td>:nth-of-type(n)</td><td>p:nth-of-type(2)</td><td>选择符合的p元素，该p元素必须是其父元素的第2个p子元素</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择符合的p元素，该p元素的父元素可以有多个子元素，但是类型为p的子元素只有一个</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择符合的p元素，该p元素的父元素只有一个子元素，就是该p元素</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动#news元素(点击URL包含锚的名字)</td></tr></tbody></table><h4 id="3-3-表单相关"><a href="#3-3-表单相关" class="headerlink" title="3.3 表单相关"></a>3.3 表单相关</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:disabled</td><td>input:disabled</td><td>选择所有禁用的表单元素</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择没有设置disabled属性的表单元素</td></tr><tr><td>:in-range</td><td>input:in-range</td><td>选择在指定区域内的表单元素</td></tr><tr><td>:out-of-range</td><td>input:out-of-range</td><td>选择不在指定区域内的表单元素</td></tr><tr><td>:valid</td><td>input:valid</td><td>选择条件验证正确的表单元素</td></tr><tr><td>:invalid</td><td>input:invalid</td><td>选择条件验证错误的表单元素</td></tr><tr><td>:required</td><td>input:required</td><td>选择设置required属性的表单元素</td></tr><tr><td>:optional</td><td>input:optional</td><td>选择没有required属性，即设置 optional属性的表单元素</td></tr><tr><td>:read-only</td><td>input:read-only</td><td>选择设置只读属性的表单元素</td></tr><tr><td>:read-write</td><td>input:read-write</td><td>选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态</td></tr><tr><td>:checked</td><td>input:checked</td><td>匹配勾选的input元素，input元素包括 radio 和 checkbox</td></tr><tr><td>:empty</td><td>p:empty</td><td>匹配所有没有子元素的 p 元素</td></tr><tr><td>:default</td><td></td><td>匹配默认选中的元素(提交按钮总是表单的默认按钮)</td></tr><tr><td>:indeterminate</td><td></td><td>当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。</td></tr><tr><td>:scope</td><td></td><td>匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。(试验阶段)</td></tr></tbody></table><h4 id="3-4-语言相关"><a href="#3-4-语言相关" class="headerlink" title="3.4 语言相关"></a>3.4 语言相关</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:lang(language)</td><td>匹配设置了特定语言的元素</td><td>设置特定语言可以是：HTML元素设置lang=” “属性，meta元素设置charset=” “属性，或者是在 http头部上设置语言属性。实际上，lang=” “ 属性不只可以在 html 标签上设置，也可以在其他的元素上设置。</td></tr><tr><td>:dir</td><td>匹配指定阅读方向的元素。</td><td>当 HTML 元素中设置了 dir 属性时该伪类才能生效。现时支持的阅读方向有两种：ltr（从左往右）和 rtl（从右往左）。目前，只有火狐浏览器支持 :dir 伪类，并在火狐浏览器中使用时需要添加前缀( -moz-dir() )(试验阶段)。</td></tr></tbody></table><h4 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:root</td><td>匹配文档的根元素</td><td>一般的 html 文件的根元素是 html 元素。</td></tr><tr><td>:fullscreen</td><td>匹配处于全屏模式下的元素</td><td>全屏模式不是通过按 F11 来打开的全屏模式，而是通过 Javascript 的 Fullscreen API 来打开的，不同的浏览器有不同的 Fullscreen API。目前，:fullscreen 需要添加前缀才能使用。</td></tr></tbody></table><p><strong>！！注意，伪类的名称不区分大小写。</strong></p><h3 id="4-伪元素列举"><a href="#4-伪元素列举" class="headerlink" title="4 伪元素列举"></a>4 伪元素列举</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/chor2.png" alt=""></p><h4 id="4-1-单双冒号"><a href="#4-1-单双冒号" class="headerlink" title="4.1 单双冒号"></a>4.1 单双冒号</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>::before/:before</td><td>在被选元素前插入内容</td><td>需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。</td></tr><tr><td>::after/:after</td><td>在被选元素后插入内容</td><td>用法同上</td></tr><tr><td>::first-letter/:first-letter</td><td>匹配元素中文本的首字母</td><td>被修饰的字母不在首字母中</td></tr><tr><td>::first-line/:first-line</td><td>匹配元素中第一行的文本</td><td>这个伪元素只能用在块元素中，不能用在内联元素中</td></tr></tbody></table><h4 id="4-1-仅双冒号"><a href="#4-1-仅双冒号" class="headerlink" title="4.1 仅双冒号"></a>4.1 仅双冒号</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>::selection</td><td>匹配被用户选中或者处于高亮状态的部分</td><td>在FF浏览器使用时需要添加 -moz 前缀</td></tr><tr><td>::placeholder</td><td>匹配占位符的文本</td><td>只有元素设置placeholder 属性时，该伪元素才能生效。该伪元素不是 CSS 的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（IE10 和 Firefox18 及其以下版本）会使用单冒号的形式</td></tr><tr><td>::backdrop</td><td>用于改变全屏模式下的背景颜色</td><td>全屏模式的默认颜色为黑色。(试验阶段)</td></tr></tbody></table><h3 id="5-first-child和-first-of-type的区别"><a href="#5-first-child和-first-of-type的区别" class="headerlink" title="5. :first-child和:first-of-type的区别"></a>5. :first-child和:first-of-type的区别</h3><p>:first-child选择器是css2中定义的选择器，从字面意思上来看也很好理解，就是第一个子元素。比如有段代码：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/chor3.png" alt=""></p><p><span style="color:red">p:first-child:</span> 匹配到的是p元素,因为p元素是div的第一个子元素；<br><span style="color:red">h1:first-child:</span> 匹配不到任何元素，因为在这里h1是div的第二个子元素，而不是第一个；<br><span style="color:red">span:first-child:</span> 匹配不到任何元素，因为在这里两个span元素都不是div的第一个子元素；<br><span style="color:red">:first-child:</span> 匹配到的是p元素,因为在这里div的第一个子元素就是p。</p><p>然后，在css3中又定义了:first-of-type这个选择器，这个跟:first-child有什么区别呢？还是看那段代码：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/chor4.png" alt=""></p><p><span style="color:red">p:first-of-type:</span> 匹配到的是p元素,因为p是div的所有为p的子元素中的第一个，事实上这里也只有一个为p的子元素；<br><span style="color:red">h1:first-of-type:</span> 匹配到的是h1元素，因为h1是div的所有为h1的子元素中的第一个，事实上这里也只有一个为h1的子元素；<br><span style="color:red">span:first-of-type:</span> 匹配到的是第三个子元素span。这里div有两个为span的子元素，匹配到的是第一个。<br><span style="color:red">:first-of-type:</span> 匹配到的是p元素</p><p>所以，通过以上两个例子可以得出结论：</p><blockquote><p>:first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。<br>:first-of-type 匹配的是该类型的第一个，类型是指什么呢，就是冒号前面匹配到的东西，比如 p:first-of-type，就是指所有p元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了，当然这些元素的范围都是属于同一级的，也就是同辈的。</p></blockquote><p>同样类型的选择器 :last-child 和 :last-of-type、:nth-child(n) 和 :nth-of-type(n) 也可以这样去理解。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text3插件简易使用教程</title>
      <link href="/2019/03/06/To-Sublime%20Text3%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/03/06/To-Sublime%20Text3%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/%E4%B8%8B%E8%BD%BD.png" alt=""><br><a id="more"></a></p><p>作为一款轻便的编辑器，Sublime Text3的下载和安装都比较简单，这里一并略过，只说安装插件的事情。Sublime Text3支持各种强大的插件，可以在一定程度上提高打码速度。</p><h2 id="1-安装Package-Control"><a href="#1-安装Package-Control" class="headerlink" title="1.安装Package Control"></a>1.安装Package Control</h2><p>安装插件有两种方式，一种是直接下载插件的安装包，解压缩到编辑器的Packages目录中，比较麻烦，不推荐；我们通常用另一种方法，即通过Package Control组件来安装插件。所以第一步，先安装Package Control组件。</p><p>打开编辑器，按control + ` 打开控制台，粘贴如下代码到命令行并回车；</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">,</span>os<span class="token punctuation">;</span>pf <span class="token operator">=</span> <span class="token string">'Package Control.sublime-package'</span><span class="token punctuation">;</span>ipp <span class="token operator">=</span> sublime<span class="token punctuation">.</span><span class="token function">installed_packages_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">install_opener</span><span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">build_opener</span><span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">ProxyHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">open</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>ipp<span class="token punctuation">,</span> pf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">urlopen</span><span class="token punctuation">(</span><span class="token string">'http://sublime.wbond.net/'</span> <span class="token operator">+</span> pf<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">'%20'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重启编辑器，在Perferences-&gt;Package Settings 中看到 Package Control，则表示安装成功。</p><p>当然，你有很大的概率会安装失败，遇到下面的报错弹窗：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/qaz1.png" alt=""></p><p>原因不便多说（你懂的），网上有比较多的解决方法，这里提供一种最有效也是最简单的方法。依次点击编辑器的Preferences–&gt;package settings–&gt;package control–&gt;settings user,进入用户自定义配置文件，修改channels的值为<code>&quot;http://www.miaoqiyuan.cn/products/proxy.php/https://packagecontrol.io/channel_v3.json&quot;</code>。如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/qaz2.png" alt=""></p><p>这样我们就可以成功安装package controls了。</p><h2 id="2-安装想要的插件"><a href="#2-安装想要的插件" class="headerlink" title="2.安装想要的插件"></a>2.安装想要的插件</h2><p>点击Preferences–&gt;package control，点选install package选项，输入自己想要安装的插件的名称，即可进行安装。当然，由于**原因，安装插件的过程一般比较慢，等一会就行了。一般来说，安装成功后会弹出新标签页。</p><h2 id="3-推荐的插件"><a href="#3-推荐的插件" class="headerlink" title="3.推荐的插件"></a>3.推荐的插件</h2><h3 id="3-1-汉化插件"><a href="#3-1-汉化插件" class="headerlink" title="3.1 汉化插件"></a>3.1 汉化插件</h3><p>如果你看不惯英文的话，可以下一个汉化插件。点选install package选项后，搜索“ChineseLocalization”进行安装。安装完后重启编辑器即可；</p><h3 id="3-2-解决中文乱码问题的插件"><a href="#3-2-解决中文乱码问题的插件" class="headerlink" title="3.2 解决中文乱码问题的插件"></a>3.2 解决中文乱码问题的插件</h3><p>Sublime Text3 不支持GB2312和GBK编码，会出现中文乱码的情况，所以推荐安装“ConvertToUTF8”插件，安装方法同上；</p><h3 id="3-3-解决输入法输入框不跟随问题的插件"><a href="#3-3-解决输入法输入框不跟随问题的插件" class="headerlink" title="3.3 解决输入法输入框不跟随问题的插件"></a>3.3 解决输入法输入框不跟随问题的插件</h3><p>中文状态下，我们会发现输入法的输入框无法跟随鼠标，看着非常难受，所以这里可以用IMESupport插件解决这个问题。这个方法绝大多数情况下是有效的，然而，如果你是win10用户，并且用的是系统自带输入法，那么你得采取另一种方法。原文链接在此 <a href="https://blog.csdn.net/qq_24345801/article/details/79077902" target="_blank" rel="noopener">https://blog.csdn.net/qq_24345801/article/details/79077902</a> ，这里粘贴一下主要内容。</p><blockquote><p>其实还是要用到插件IMESupport，只不过这个插件是国人大神自己修改的，下载地址是：<a href="https://github.com/zcodes/IMESupport" target="_blank" rel="noopener">https://github.com/zcodes/IMESupport</a><br>由于是修改过的源码，不能通过package control来在线安装，而是需要自己手动安装（安装前请先卸载原来的插件），安装过程如下：</p><ol><li>从上面的网址下载插件，解压</li><li>Preferences-&gt;Browse Packages打开插件安装的目录</li><li>将解压后的文件夹复制到上一步打开的目录中</li><li>重启sublime text 3即可</li></ol></blockquote><h3 id="3-4-自动补全代码的插件"><a href="#3-4-自动补全代码的插件" class="headerlink" title="3.4 自动补全代码的插件"></a>3.4 自动补全代码的插件</h3><p>使用“Emmet”插件，可以迅速编写HTML/CSS代码，例如，只需要用<code>html:5</code>配合tab键即可迅速生成html的基础结构，还可以用诸如<code>nav&gt;ul&gt;li</code>的快捷方式迅速生成嵌套结构，具体其他用法可以百度“Emmet语法”。</p><h3 id="3-5-语法检查插件"><a href="#3-5-语法检查插件" class="headerlink" title="3.5 语法检查插件"></a>3.5 语法检查插件</h3><p>也即SublimeLinter插件。但其实我们并不是直接用它进行代码检测——实际上它是一个包含了多种检测插件（sublimelinter-htmlhint，sublimelinter-csslint，sublimelinter-jshint）的“容器”。<br>本步骤的安装会比其他插件麻烦得多，下面介绍一下具体安装过程。</p><h4 id="3-5-1-安装node-js"><a href="#3-5-1-安装node-js" class="headerlink" title="3.5.1 安装node.js"></a>3.5.1 安装node.js</h4><p>安装SublimeLinter前必须先安装node.js这一重要前置。这是因为sublimelinter-htmlhint，sublimelinter-csslint，sublimelinter-jshint实际上分别调用的是node.js的htmlhint，csslint和jshint。安装node.js比较简单，这里略过。</p><h4 id="3-5-2-安装SublimeLinter"><a href="#3-5-2-安装SublimeLinter" class="headerlink" title="3.5.2 安装SublimeLinter"></a>3.5.2 安装SublimeLinter</h4><ul><li>打开Sublime，按下 Ctrl+Shift+p 进入 Command Palette;</li><li>输入install进入 Package Control: Install Package;</li><li>输入SublimeLinter，选择SublimeLinter进行安装。</li></ul><h4 id="3-5-3-安装sublimeLinter-contrib-htmlhint和xg-htmlhint"><a href="#3-5-3-安装sublimeLinter-contrib-htmlhint和xg-htmlhint" class="headerlink" title="3.5.3 安装sublimeLinter-contrib-htmlhint和xg-htmlhint"></a>3.5.3 安装sublimeLinter-contrib-htmlhint和xg-htmlhint</h4><p>SublimeLinter的插件之一，用来调用node.js的xg-htmlhint进行语法检查。</p><ul><li>前往Releases下载最新版本的压缩包，解压并重命名为“SublimeLinter-contrib-htmlhint”，并放入Sublime的Package目录(菜单-&gt;Preferences-&gt;BrowsePackages)</li><li>开始菜单—&gt;node.js—&gt;node.js command prompt，输入以下命令 ：<br><code>npm install -g xg-htmlhint</code><br>等待出现一堆数字版本号即为成功安装。</li></ul><h4 id="3-5-4-安装sublimeLinter-csslint和csslint，sublimeLinter-jshint和jshint"><a href="#3-5-4-安装sublimeLinter-csslint和csslint，sublimeLinter-jshint和jshint" class="headerlink" title="3.5.4 安装sublimeLinter-csslint和csslint，sublimeLinter-jshint和jshint"></a>3.5.4 安装sublimeLinter-csslint和csslint，sublimeLinter-jshint和jshint</h4><ul><li><p>打开Sublime Text3,按住Ctrl+Shift+P安装<br>SublimeLinter-csslint<br>SublimeLinter-jshint</p></li><li><p>开始菜单—&gt;node.js—&gt;node.js command prompt，输入以下命令：<br><code>npm install -g jshint</code><br><code>npm install -g csslint</code></p></li></ul><p>之后重启编辑器，大功告成。这个插件虽然不是万能的，但是可以鉴别很多错误，尤其是中文标点符号错误，有时候不靠插件纠错还真看不出来。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;译&gt;如何用原生JS打造一款简易谷歌插件</title>
      <link href="/2019/03/05/Trs-%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/03/05/Trs-%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>之前就想翻译文章来着，所以这回拿了Medium上的一篇博文下手。确实没有想象中的那么容易，因为你不得不仔细斟酌每个字词。我不是学翻译的，如有不对，欢迎指正。</p><p>原文: <a href="https://medium.com/javascript-in-plain-english/https-medium-com-javascript-in-plain-english-how-to-build-a-simple-chrome-extension-in-vanilla-javascript-e52b2994aeeb" target="_blank" rel="noopener">How to Build a Simple Chrome Extension in Vanilla JavaScript</a><br><a id="more"></a></p><p>今天，我打算向你们展示如何用原生JS做一款谷歌插件—-不依靠任何诸如React、Angular或者Vue框架的原生JS。</p><p>做一款谷歌插件并没有那么困难——在学习编程的第一年，我发布了两个插件，并且都是用HTML、CSS和原生JS做的。在这篇文章中，我会用几分钟的时间教你们怎么完成这件事。</p><p>我将向你们展示如何从零开始打造一款简易的谷歌插件主控面板。如果你对插件有自己的想法、只是想知道应该向已有项目文件中添加什么，从而让其运行在谷歌浏览器中的话，你可以跳到自定义mainfest.json文件和图标的部分。</p><h3 id="关于谷歌插件"><a href="#关于谷歌插件" class="headerlink" title="关于谷歌插件"></a>关于谷歌插件</h3><p>从本质上来说，一款谷歌插件只是一些用来定制浏览体验的文件。有许多不同类型的插件，有些插件仅在某种特定条件下才会激活，比如当你在商店的结账页面的时候；有些插件仅在你点击图标后才会弹出；有些则在你每次打开新标签页的时候才会出现。我今年发布的两款插件都是“新标签页式”插件，第一款是<a href="http://bit.ly/complimentdash" target="_blank" rel="noopener">Compliment Dash</a>,一个可以显示to-do list并问候用户的主控面板；第二款是<a href="http://liturgical.li/" target="_blank" rel="noopener">Liturgical.li</a>,为牧师量身打造的工具。如果你知道如何建设一个基本的网站，那么你就可以很轻松地做出这种插件。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>我们打算一切从简，所以本教程只会使用HTML、CSS和基本的JS，以及下面会讲到的自定义mainfest.json文件。谷歌插件的复杂度各不相同，因此做一款插件可能很简单，也可能很难，这取决于你打算让它实现什么功能。在学习了本篇文章的基础知识后，你将可以活用技能做出更为复杂的东西。</p><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>本教材中，我们将制作一款可以问候用户的简易主控面板，名字就叫Simple Greeting Dashboard好了。<br>首先需要创建三个文件：index.html,main.css和main.js。将这些文件放在各自的文件夹中。接下来，在html文件中书写必要的声明，并引入css文件和js文件：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- =================================Simple Greeting Dashboard================================= //--></span><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Simple Greeting Dashboard<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!-- My code will go here --></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定制你的mainfest-json文件"><a href="#定制你的mainfest-json文件" class="headerlink" title="定制你的mainfest.json文件"></a>定制你的mainfest.json文件</h3><p>仅有这些文件还不能够让你的插件项目正常运行。我们还需要一个mainfest.json文件以定制插件的基本信息。可以在<a href="https://developer.chrome.com/extensions/getstarted" target="_blank" rel="noopener">Google’s developer portal</a>下载该文件，或者复制粘贴如下代码到一个新文件中，另存为manifest.json文件。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Getting Started Example"</span><span class="token punctuation">,</span>  <span class="token string">"version"</span><span class="token punctuation">:</span> <span class="token string">"1.0"</span><span class="token punctuation">,</span>  <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"Build an Extension!"</span><span class="token punctuation">,</span>  <span class="token string">"manifest_version"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们修改上面文件中关于插件信息的内容。只需改变代码中的前三个值：<code>name</code>,<code>version</code>和<code>description</code>。填入插件名称以及相关描述，由于这是第一个版本，所以version项就不需要改了。<code>manifest_version</code>也不需要改动。<br>接着，添加代码行以告诉谷歌浏览器如何操作这个插件。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Simple Greeting Dashboard"</span><span class="token punctuation">,</span>  <span class="token string">"version"</span><span class="token punctuation">:</span> <span class="token string">"1.0"</span><span class="token punctuation">,</span>  <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"This Chrome extension greets the user each time they open a new tab"</span><span class="token punctuation">,</span>  <span class="token string">"manifest_version"</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token string">"incognito"</span><span class="token punctuation">:</span> <span class="token string">"split"</span><span class="token punctuation">,</span>  <span class="token string">"chrome_url_overrides"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"newtab"</span><span class="token punctuation">:</span> <span class="token string">"index.html"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"permissions"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>     <span class="token string">"activeTab"</span>   <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"icons"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"128"</span><span class="token punctuation">:</span> <span class="token string">"icon.png"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码<code>incognito&quot;: &quot;split</code>告诉谷歌浏览器当它处于匿名模式的时候应该如何操作该插件。“split”将允许插件运行在自己的进程中。其他选项请查阅<a href="https://www.baidu.com/#ie=UTF-8&amp;wd=developer%20documentation." target="_blank" rel="noopener">developer documentation</a></p><p>正如你所看到的，”chrome_url_overrides”指定浏览器打开新标签页的时候打开index.html。将值设定为“permissions”后，将弹出窗口，提示用户安装该插件将会覆盖新标签页。</p><p>最后，设定我们的图标：一个名为icon的png文件，尺寸为128x128像素。</p><h3 id="创建图标"><a href="#创建图标" class="headerlink" title="创建图标"></a>创建图标</h3><p>现在我们还没有Simple Greeting Dash的图标文件，所以来创建一个。你可以用下面我做的图标。如果你想自己做一个的话，用PS或者<a href="http://canva.com/" target="_blank" rel="noopener">Canva</a>都可以。切记图标尺寸为128x128像素，然后另存为名称icon的png文件，与HTML文件、CSS文件、JS文件和Json文件放在同一个文件夹里。</p><center><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/qq2.png"></center><h3 id="上传你的文件（如果你正在编写自己的页面）"><a href="#上传你的文件（如果你正在编写自己的页面）" class="headerlink" title="上传你的文件（如果你正在编写自己的页面）"></a>上传你的文件（如果你正在编写自己的页面）</h3><p>要创建你的“新标签页式”谷歌插件，只需明悉以上全部信息即可。在你定制了mainfest.json文件后，你可以用HTML、CSS和JS设计任何自己想要的新标签页，之后按照下图所示将其上传。不过，如果你想知道我怎么创建这个简易面板的话，请跳至“创建一个设置菜单”部分。</p><p>一旦你设计好了新标签页，你的谷歌插件就创建完成了，随时可以上传至谷歌浏览器。手动上传，请在浏览器的地址栏输入<code>chrome://extensions/</code>，进入页面后在右上角启用开发者模式。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/qq3.png" alt=""></p><p>刷新页面，点击“加载已解压的拓展程序”。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/qq4.png" alt=""></p><p>接着，选择存放HTML、CSS、JS、mainfest.json文件和icon.png的文件夹，上传。之后每次打开新标签页的时候该插件都会运行！</p><p>在创建了自己的插件并且通过测试之后，你便可以申请一个开发者账号并将该应用发布到谷歌拓展程序商店。这篇<a href="https://developer.chrome.com/webstore/publish" target="_blank" rel="noopener">教程</a>将指导你如何发布你的插件。</p><p>如果你现在不急着创建插件，只是想看看谷歌插件能够做什么的话，下面将教你如何创建一个非常简易的问候面板。</p><p>创建一个设置菜单</p><p>就这个插件来说，我首先要做的第一件事就是创建一个可供用户添加自己名字的输入框。因为我不打算让它一直显示，所以我将其放在一个名为<code>settings</code>的div下，该div只在用户点击settings按钮的时候才会显示。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>settings-button<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Settings<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>settings<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>settings<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-form<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-form<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-input<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>        <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-input<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Type your name here...<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-button<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Add<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的页面设置看起来大概是这样的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/qq5.png" alt=""></p><p>…因此很有必要通过CSS给它们添加一些样式。我将给settings按钮和输入框添加内边距和轮廓，之后让settings按钮和输入框之间留有一点空隙。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.settings</span> </span><span class="token punctuation">{</span>   <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>   <span class="token property">flex-direction</span><span class="token punctuation">:</span> row<span class="token punctuation">;</span>   <span class="token property">align-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">input </span><span class="token punctuation">{</span>   <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span>   <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>   <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">150</span>px<span class="token punctuation">;</span>   <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">button </span><span class="token punctuation">{</span>   <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">30</span>px<span class="token punctuation">;</span>   <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">70</span>px<span class="token punctuation">;</span>   <span class="token property">background</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* This removes the default background */</span>   <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#313131</span><span class="token punctuation">;</span>   <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid <span class="token hexcode">#313131</span><span class="token punctuation">;</span>   <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* This gives our button rounded edges */</span>   <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>   <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">form </span><span class="token punctuation">{</span>   <span class="token property">padding-top</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在看起来好多了：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/qq6.png" alt=""></p><p>不过，我们必须设置一下：用户未点击settings按钮的时候输入框不显示。我将通过给settings类添加下面的代码来完成这个设置，之后输入框将从屏幕上消失：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateX</span><span class="token punctuation">(</span>-<span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">transition</span><span class="token punctuation">:</span> transform <span class="token number">1</span>s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在创建一个名为settings-open的类，在用户点击settings按钮的时候该类名将动态添加或去除。当添加settings-open类给已经有settings类的div时，div将不会隐藏，而是在正常位置显示。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.settings-open.settings</span> </span><span class="token punctuation">{</span>   <span class="token property">transform</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着用JS实现类名的改变。定义一个名为openSettings的函数，它的功能是实现settings-open类名的添加或去除。具体做法是通过div的ID获取到该div元素，之后调用clssLIst.toggle方法添加settings-open类名。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">openSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"settings"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">toggle</span><span class="token punctuation">(</span><span class="token string">"settings-open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在添加一个事件监听器，它将会在settings按钮被点击的时候调用函数</p><pre class="line-numbers language-js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"settings-button"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> openSettings<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在你点击settings按钮后，输入框将显示或隐藏。</p><h3 id="创建一个个性化的问候语"><a href="#创建一个个性化的问候语" class="headerlink" title="创建一个个性化的问候语"></a>创建一个个性化的问候语</h3><p>接下来，我们来创建问候信息。首先在HTML中放入一个空的h2标签，之后用JS中的innerHTML方法来给它增加内容。为方便稍后获取h2元素，我们将给它一个ID，并将其放入一个名为greeting-container的div中。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>greeting-container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>greeting<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>greeting<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，我将在JS中结合用户名创建一个基本的问候信息。首先声明一个空的变量用以稍后存放用户名。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> userName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果就这样把useName变量放在HTML的问候语句中，即使为userName变量赋了值，谷歌浏览器也是不会使用相同的名字的。为了确保浏览器记住用户，我们必须进行本地存储的工作。因此，定义一个名为saveName的函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">saveName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'receivedName'</span><span class="token punctuation">,</span> userName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数<code>localStorage.setItem()</code>接受两个参数：第一个是用于稍后获取信息的关键词，第二个是它需要记住的信息，也即是<code>useName</code>。我将通过<code>localStorage.setItem</code>获取储存的信息，并用该信息来更新useName变量的值。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> userName <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'receivedName'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在将这条语句添加进表单的事件监听器之前，我想要让浏览器默认指定一个用户名，以应对我没有告诉它名字的情况。我将用if语句来完成这件事。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>userName <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   userName <span class="token operator">=</span> <span class="token string">"friend"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，将userName变量与表单连接起来。我们将该操作写进函数里，这样每次名字更新的时候都可以调用该函数。我们给这个函数取名changeName。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">changeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   userName <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"name-input"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>   <span class="token function">saveName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我想要让该函数在用户每次用表单提交名字的时候都被调用。这里用事件监听器，它可以调用changeName函数并防止在表单提交的时候页面默认刷新。</p><pre class="line-numbers language-js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"name-form"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'submit'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token function">changeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后，我们来创建问候语。我将把该语句也放进一个函数中，这样，在页面刷新或者<code>changeName()</code>调用后，我都可以调用该函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"greeting"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML  <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>userName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">. Enjoy your day!`</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">getGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最后，自定义你的页面"><a href="#最后，自定义你的页面" class="headerlink" title="最后，自定义你的页面"></a>最后，自定义你的页面</h3><p>现在是时候收尾了。我将用flexbox使标题居中，让它变得更大。同时在CSS中给body添加一个渐变背景。为了在渐变背景中突出按钮和h2，我会把它们设置成白色的。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.greeting-container</span> </span><span class="token punctuation">{</span>   <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>   <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>   <span class="token property">align-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.greeting</span> </span><span class="token punctuation">{</span>   <span class="token property">font-family</span><span class="token punctuation">:</span> sans-serif<span class="token punctuation">;</span>   <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span>   <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">body </span><span class="token punctuation">{</span>   <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#c670ca</span><span class="token punctuation">;</span>   <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span><span class="token number">45</span>deg, <span class="token hexcode">#c670ca</span> <span class="token number">0%</span>, <span class="token hexcode">#25a5c8</span> <span class="token number">52%</span>, <span class="token hexcode">#20e275</span> <span class="token number">90%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">html </span><span class="token punctuation">{</span>   <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就这样！你的页面大概会是下面这样子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/qqqqq.png" alt=""><br>虽然内容不多，但这是你创建和定义自己的谷歌插件的基础。如果有任何疑问，请告诉我，并随时在推特上@saralaughed 联系我。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事件循环</title>
      <link href="/2019/03/05/F-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2019/03/05/F-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/event-loop.png" alt=""><br><a id="more"></a></p><p>本篇博客讲的东西偏底层，较难理解。虽然有的地方不够精准和全面，但是我觉得对于理解js中的异步来说已经够了，所以没有再深究一些概念（比如浏览器在这个过程中充当的角色）。</p><h2 id="1-单线程"><a href="#1-单线程" class="headerlink" title="1.单线程"></a>1.单线程</h2><p>所谓的单线程，可以简单理解为做事情讲究先来后到，要做后面的事情，你得等前面的事情做完—–不管它需要多久。<br>既然如此，js引擎为何还要采取这种单线程的机制呢？<br>js主要是与用户互动，这个过程涉及到对DOM节点的操作，如果js是多线程的，一个在节点上添加内容，一个要对这个dom节点进行删除，到底是以哪个为准？所以这就是为什么js从一出现就秉承着单线程的运行机制。<br>另外还要注意：</p><blockquote><p>“为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质”</p></blockquote><h2 id="2-同步任务和异步任务"><a href="#2-同步任务和异步任务" class="headerlink" title="2.同步任务和异步任务"></a>2.同步任务和异步任务</h2><p>很显然，单线程会带来一个问题：就是代码执行的阻塞。比如：排在前面的任务如果耗时长，则后面的任务不得不一直等待它。 如果说耗时长是因为计算量大、cpu一直忙着计算的话倒也还好，可事实是——大部分时间浪费在了IO上（ajax从网络上获取数据），还有其他的如鼠标点击、setTimeout等等。因此这里提出了同步任务和异步任务的概念。</p><p>在js中，可以将同步和异步简单理解为执行顺序的问题。</p><h3 id="2-1同步（sync）："><a href="#2-1同步（sync）：" class="headerlink" title="2.1同步（sync）："></a>2.1同步（sync）：</h3><p>即上面所说的后面等待前面。同步对应了同步任务（synchronous），即可以按照正常顺序执行的任务，比如加载页面骨架等。</p><h3 id="2-2异步（async）："><a href="#2-2异步（async）：" class="headerlink" title="2.2异步（async）："></a>2.2异步（async）：</h3><p>即把耗时长的任务挂起，先执行耗时短的，再回过头执行耗时长的。<br>异步对应了异步任务（asynchronous），即不适合按照正常顺序执行的任务，主要包括：</p><ul><li>onclick等事件绑定—&gt; 当事件触发时，回调函数会被添加到任务队列中；</li><li>setTimeout / setInterval 等计时器—&gt; (时间延迟)当浏览器完成计时，回调函数会被添加到任务队列中；</li><li>AJAX请求—&gt;当网络请求完成返回时，回调函数会被添加到任务队列中</li></ul><h2 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3.事件循环"></a>3.事件循环</h2><ul><li>事件循环又叫event loop，需要注意的是，事件循环<strong>不是</strong>单线程的js引擎提供的机制，而是来自于js引擎的运行环境（多线程的浏览器或node.js）。</li><li>事件循环是实现异步的一种机制。一个线程中只有一个事件循环，我们将这个循环的每一次循环执行过程称之为tick。 具体每一次循环是怎么执行的，后文会讲。</li></ul><h2 id="4-执行栈和任务队列"><a href="#4-执行栈和任务队列" class="headerlink" title="4.执行栈和任务队列"></a>4.执行栈和任务队列</h2><p>事件循环机制离不开执行栈和任务队列的相互配合。js中将<span style="background-color:#fffa7d">同步任务放到主线程上执行，形成“执行栈”；异步任务则放到任务队列中</span>。</p><h4 id="4-1-任务队列的分类标准之一："><a href="#4-1-任务队列的分类标准之一：" class="headerlink" title="4.1 任务队列的分类标准之一："></a>4.1 任务队列的分类标准之一：</h4><p>一个线程可以拥有多个任务队列。每一个任务队列都对应某一任务源，并包含了一堆来自该任务源的任务。任务源是什么？像setTimeout/Promise/DOM事件/AJAX等都是任务源，来自同类任务源的任务我们称它们是同源的，比如setTimeout与setInterval就是同源的。</p><h4 id="4-2-任务队列的分类标准之二："><a href="#4-2-任务队列的分类标准之二：" class="headerlink" title="4.2 任务队列的分类标准之二："></a>4.2 任务队列的分类标准之二：</h4><p>在ES6中，我们用另一种方式对任务队列进行分类。<br><span style="background-color:#fffa7d">宏任务</span>: 即macro-task，包括整体代码script，setTimeout，setInterval、AJAX、用户I\O 等。宏任务会对应地进入宏任务队列中；<br><span style="background-color:#fffa7d">微任务</span>: 即micro-task,包括Promise，process.nextTick(callback)(可以理解为node.js版的setTimeOut)。微任务会对应地进入微任务队列中。</p><h2 id="5-事件循环的具体实现过程？"><a href="#5-事件循环的具体实现过程？" class="headerlink" title="5.事件循环的具体实现过程？"></a>5.事件循环的具体实现过程？</h2><p>总的来说，事件循环的顺序，决定了js代码执行的顺序。</p><ul><li>首先进入<code>&lt;script&gt;</code>包裹的整体代码(这是第一个宏任务)，标志着第一次循环开始。在整体代码的执行过程中，同步任务照旧执行，异步任务分发到对应的任务队列中；</li><li>整体代码执行完，执行栈清空，开始读取任务队列；</li><li>读取所有微观任务队列 -&gt; 执行 -&gt;<br>第一次循环结束，开始第二次循环<br>读取一个宏观任务队列 -&gt; 执行 -&gt;<br>读取所有微观任务队列 -&gt; 执行 -&gt;<br>第二次循环结束，开始第三次循环<br>读取一个宏观任务队列……………..<br>………<br>………<br>队列清空，执行栈清空，事件循环正式结束。</li></ul><p>PS：读取任务时，会执行这些任务指定的回调函数,并且要注意：若回调函数中又有宏任务，则该宏任务会被安排到下一轮循环中。</p><h2 id="6-事件循环的例子"><a href="#6-事件循环的例子" class="headerlink" title="6.事件循环的例子"></a>6.事件循环的例子</h2><p>下面通过三个由易到难的例子来理解上面所说的过程。</p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：<br>跑一下代码，会发现控制台执行task()需要的时间远远超过3秒，这就说明我们有的人理解的”setTimeout的第二个参数指定了多长时间后执行回调函数”的说法是错误的。<br>让我们来分析一下这个过程：</p><ul><li><code>&lt;script&gt;</code>中的整段代码作为第一个宏任务，进入主线程。即开启第一次事件循环；</li><li>首先遇到了setTimeout，将其回调函数task()进入Event Table并注册,同时浏览器开始计时；</li><li>继续，遇到了sleep函数，这是同步任务，所以直接执行。但是速度很慢，非常慢，而浏览器计时仍在继续；</li><li>好了，3秒终于到了，计时事件setTimeout总算完成，可以把task()放入任务队列了;</li><li>但是主线程上的sleep太慢了，还没执行完，于是我们只好等着；</li><li>sleep终于执行完了，执行栈清空,第一次循环的宏任务结束；</li><li>读取微任务队列….不对，没有任何任务被分发到这个队列，于是第一次循环只好这样结束了；</li><li>第二次循环开始，读取宏任务队列，刚好，里面有一个setTimeout对应的task()回调函数，压栈、令其进入主线程执行；</li><li>执行栈清空了，任务队列也清空了，事件循环正式结束。</li></ul><p>现在，我们知道setTimeout的回调函数是一开始就注册进event table的，但是那时并未进入任务队列—-要经过一定的时间，而这个时间由第二个参数来指定。也就是说，第二个参数指定的是“多长时间后将回调函数放入到任务队列中”。<br>另外，即使回调函数已经进入队列，也得先等主线程的执行栈清空后才有可能轮到自己。<br>我们还经常遇到<code>setTimeout(fn,0)</code>(或者干脆没有指定第二个参数)这样的代码，这是不是意味着可以立即执行呢？<br>不是。setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是注册进event table的同时就将任务放入队列中，只要主线程执行栈内的同步任务全部执行完成，且此时没有微任务队列，那么该任务就会马上压栈并执行。</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'console'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><ul><li><code>&lt;script&gt;</code>中的整段代码作为第一个宏任务，进入主线程。即开启第一次事件循环；</li><li>遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中（第二个参数不设定时，默认延迟为0）；</li><li>接下来遇到new Promise、Promise，立即执行，输出: promise 。将then函数分发到微任务队列中；</li><li>遇到console.log，立即执行，输出: console</li><li>整体代码作为第一个宏任务执行结束，此时去微任务队列中查看有哪些微任务，结果发现了then函数，然后将它推入主线程并执行，输出: then</li><li>第一轮事件循环结束，第二轮事件循环开始；</li><li>先从宏任务开始，去宏任务队列中查看有哪些宏任务，结果发现了setTimeout对应的回调函数，将它推入主线程并执行，输出：setTimeout</li><li>然后去微任务队列中查看是否有事件，结果没有；</li><li>此时第二轮事件循环结束；</li><li>执行栈清空了，任务队列也清空了，事件循环正式结束。</li></ul><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><h4 id="第一轮事件循环"><a href="#第一轮事件循环" class="headerlink" title="第一轮事件循环"></a>第一轮事件循环</h4><pre class="line-numbers language-html"><code class="language-html">a) 整段`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span>`代码作为第一个宏任务进入主线程，即开启第一轮事件循环b) 遇到console.log，立即执行。输出：1c) 遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中。我们将其标记为setTimeout1d) 遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务队列中。记为process1e) 遇到new Promise、Promise，立即执行；then回调函数放入Event table中注册，然后被分发到微任务队列中。记为then1。输出: 7f) 遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中。我们将其标记为setTimeout2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时第一轮事件循环宏任务结束，下表是第一轮事件循环宏任务结束时各任务队列的情况</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/e1.png" alt=""></p><p>可以看到第一轮事件循环宏任务结束后微任务事件队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行</p><pre class="line-numbers language-html"><code class="language-html">g)、执行process1。输出：6h)、执行then1。输出：8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一轮事件循环正式结束！</p><h4 id="第二轮事件循环"><a href="#第二轮事件循环" class="headerlink" title="第二轮事件循环"></a>第二轮事件循环</h4><pre class="line-numbers language-html"><code class="language-html">a）、第二轮事件循环从宏任务setTimeout1开始。遇到console.log，立即执行。输出: 2b）、遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务队列中。记为process2c）、遇到new Promise，立即执行；then回调函数放入Event table中注册，然后被分发到微任务队列中。记为then2。输出: 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时第二轮事件循环宏任务结束，下表是第二轮事件循环宏任务结束时各任务队列的情况</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/e2.png" alt=""></p><p>可以看到第二轮事件循环宏任务结束后微任务事件队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行</p><pre class="line-numbers language-html"><code class="language-html">d)、执行process2。输出：3e)、执行then2。输出：5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二轮事件循环正式结束！</p><h4 id="第三轮事件循环"><a href="#第三轮事件循环" class="headerlink" title="第三轮事件循环"></a>第三轮事件循环</h4><pre class="line-numbers language-html"><code class="language-html">a)、第三轮事件循环从宏任务setTimeout2开始。遇到console.log，立即执行。输出: 9d)、遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务队列中。记为process3c)、遇到new Promise，立即执行；then回调函数放入Event table中注册，然后被分发到微任务队列中。记为then3。输出: 11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时第三轮事件循环宏任务结束，下表是第三轮事件循环宏任务结束时各任务队列的情况</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/e3.png" alt=""></p><p>可以看到第二轮事件循环宏任务结束后微任务队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行</p><pre class="line-numbers language-html"><code class="language-html">d)、执行process3。输出：10e)、执行then3。输出：12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二轮事件循环正式结束！<br>执行栈清空，任务队列清空，事件循环正式结束！</p><p>参考：<br><a href="https://segmentfault.com/a/1190000017970432" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017970432</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生JavaScript获取DOM节点的方法汇总</title>
      <link href="/2019/03/04/F-HTML%20Collection%E5%92%8CNodelist/"/>
      <url>/2019/03/04/F-HTML%20Collection%E5%92%8CNodelist/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>感觉有时候还是会忘记，而且都是原生操作DOM的时候常用的东西，老是查阅文档不太方便，因此在这里做个记录。</p><h3 id="1-获取DOM节点的方法"><a href="#1-获取DOM节点的方法" class="headerlink" title="1.获取DOM节点的方法"></a>1.获取DOM节点的方法</h3><h4 id="1-1-通过顶层document节点获取："><a href="#1-1-通过顶层document节点获取：" class="headerlink" title="1.1 通过顶层document节点获取："></a>1.1 通过顶层document节点获取：</h4><ul><li><code>document.getElementById(&quot;ID&quot;)</code></li><li><code>document.getElementsByName(&quot;Name&quot;)</code></li><li><code>document.getElementsByClassName(&quot;className&quot;)</code></li><li><code>document.getElementsByTagName(&quot;tagName&quot;)</code><a id="more"></a> 注意，前两个都是document节点的专有方法，其他节点不能使用，尤其不能在ID下获取ID，这是非常愚蠢的做法。</li></ul><h4 id="1-2-通过父节点获取："><a href="#1-2-通过父节点获取：" class="headerlink" title="1.2 通过父节点获取："></a>1.2 通过父节点获取：</h4><ul><li><p><code>parentObj.firstChild</code>：获取父节点下的第一个子节点（会将空格和换行计入），这个属性是可以递归使用的，即支持<code>parentObj.firstChild.firstChild...</code>的形式，如此就可以获得更深层次的节点。</p></li><li><p><code>parentObj.firstElementChild</code>：获取父节点下的第一个子元素节点</p></li><li><p><code>parentObj.lastChild</code>：获取父节点下的最后一个子节点（会将空格和换行计入）。与<code>firstChild</code>一样，它也可以递归使用。</p></li><li><p><code>parentObj.lastElementChild</code>：获取父节点下的最后一个子元素节点</p></li><li><p><code>parentObj.childNodes</code>：获取父节点下的所有直接子节点（会将空格和换行计入）</p></li><li><p><code>parentObj.children</code>：获取父节点下的直接子元素节点。</p></li><li><p><code>parentObj.getElementsByTagName(&quot;tagName&quot;)</code></p></li><li><p><code>parentObj.getElementsByClassName(&quot;className&quot;)</code></p></li></ul><h4 id="1-3-通过子节点获取："><a href="#1-3-通过子节点获取：" class="headerlink" title="1.3 通过子节点获取："></a>1.3 通过子节点获取：</h4><ul><li><p><code>childObj.parentNode</code> : 获取子节点的直接父节点。w3c标准</p></li><li><p><code>childObj.parentElement</code> : 获取子节点的直接父节点。IE标准</p></li></ul><h4 id="1-4-通过兄弟节点获取："><a href="#1-4-通过兄弟节点获取：" class="headerlink" title="1.4 通过兄弟节点获取："></a>1.4 通过兄弟节点获取：</h4><ul><li><p><code>neighbourObj.parentNode.children[..]</code> :通过父节点间接获取已知节点的兄弟节点</p></li><li><p><code>neighbourObj.previousSibling</code>：获取已知节点的上一个兄弟节点（会将空格和换行计入）</p></li><li><p><code>neighbourObj.previousElementSibling</code>: 获取已知节点的上一个兄弟元素节点</p></li><li><p><code>neighbourObj.nextSibling</code>：获取已知节点的下一个兄弟节点（会将空格和换行计入）</p></li><li><p><code>neighbourObj.nextElementSibling</code>: 获取已知节点的下一个兄弟元素节点</p></li></ul><h4 id="1-5-通过CSS选择器获取："><a href="#1-5-通过CSS选择器获取：" class="headerlink" title="1.5 通过CSS选择器获取："></a>1.5 通过CSS选择器获取：</h4><p>采用CSS选择器的语法，即<code>#abc</code>，<code>div.abc</code>,<code>#abc .abc</code>等。</p><ul><li><p><code>document.querySelector(&quot;...&quot;)</code>: 返回匹配的第一个节点</p></li><li><p><code>document.querySelectorAll(&quot;...&quot;)</code>: 返回匹配的所有节点</p></li></ul><h3 id="2-HTMLCollection-和-NodeList"><a href="#2-HTMLCollection-和-NodeList" class="headerlink" title="2.HTMLCollection 和 NodeList"></a>2.HTMLCollection 和 NodeList</h3><p>我们都知道，当获得所有节点（如：<code>getElementsByTagName</code>）或者获得所有子元素（如：<code>element.childNodes</code>）时，实际上返回的是包含一些DOM节点的集合，这个集合要么是 <code>HTMLCollection</code>，要么是 <code>NodeList</code>，两者其实都是类数组的对象。</p><h4 id="2-1-HTMLCollection和NodeList的共同点："><a href="#2-1-HTMLCollection和NodeList的共同点：" class="headerlink" title="2.1 HTMLCollection和NodeList的共同点："></a>2.1 <code>HTMLCollection</code>和<code>NodeList</code>的共同点：</h4><ul><li>都是类数组对象，都有length属性;</li><li>都有共同的方法：<code>item</code>，可以通过<code>item(index)</code>或者<code>item(id)</code>来访问返回结果中的元素;</li><li>一般都是实时变动的（live），document上的更改会反映到相关对象上（！！注意：<code>document.querySelectorAll</code>返回的<code>NodeList</code>不是实时的）;</li></ul><h4 id="2-2-HTMLCollection和NodeList的不同点："><a href="#2-2-HTMLCollection和NodeList的不同点：" class="headerlink" title="2.2 HTMLCollection和NodeList的不同点："></a>2.2 <code>HTMLCollection</code>和<code>NodeList</code>的不同点：</h4><ul><li><code>NodeList</code>可以包含任何节点类型，<code>HTMLCollection</code>只包含元素节点（elementNode）。</li><li><code>HTMLCollection</code>比<code>NodeList</code>多一项方法：<code>NamedItem</code>，可以通过传递id或name属性来获取节点信息</li></ul><h4 id="2-3-规定返回结果："><a href="#2-3-规定返回结果：" class="headerlink" title="2.3 规定返回结果："></a>2.3 规定返回结果：</h4><ol><li><code>node.childNodes</code> 结果返回类型是 <code>NodeList</code>，即所有子节点；</li><li><code>node.children</code> 结果返回类型是 <code>HTMLCollection</code> ，即所有子元素节点；</li><li><code>getElementsByXXX</code> 结果返回类型是<code>HTMLCollection</code></li><li>旧版本浏览器(尤其是IE)中，<code>node.children</code> 结果返回类型是 <code>NodeList</code></li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闭包和计数器</title>
      <link href="/2019/03/04/F-%E9%97%AD%E5%8C%85%E5%92%8C%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>/2019/03/04/F-%E9%97%AD%E5%8C%85%E5%92%8C%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>之前想不通的一道题—–主要是不知道思路怎么来的，为何会想到用闭包。本来打算就将原博客转载过来，但是刚刚重新审视这道题的时候，好像看到了以前没有发现的东西，有种恍然大悟的感觉，所以决定用自己的话来解释这道题的思路。<br><a id="more"></a></p><p>假如我们想制作一个计数器，每点击一次就加一，代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把计数器counter设置成全局变量</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> counter<span class="token operator">+</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//此时counter=3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;&gt;</code>固然可以实现功能，但问题就在于其他语句也有可能会改动到counter，这样的计数器是不安全的。</p><p>如果把counter改为外部访问不到的局部变量呢？</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> counter<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>counter<span class="token operator">+</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;&gt;</code>固然保证了counter不会被其他语句影响到，但问题就在于每次调用函数都会重置counter，无法实现计数功能。</p><p>所以我们需要的counter应该满足：1.不会被重置；2.在函数内部</p><p>第2点容易满足，但是由上面的例子我们知道，如果单纯把counter写在一个函数里，则每次调用都会重置，所以我们定义这样一个嵌套函数：将counter放在父函数里，子函数作为操作counter的函数，每次我们只调用子函数。<br>但是，全局作用域是无法访问嵌套函数中的子函数的，所以我们必须将子函数作为闭包返回出来，使其暴露在全局作用域下。依照这个想法，代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> add <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//counter为1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//counter为1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//counter为1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;&gt;</code>意思是把add函数（父函数）执行后返回的函数（子函数）执行一次（注意这里是两次执行）。但这样的问题在于：每次调用add()()时依然执行了一次父函数，结果就是依然重置了counter。</p><p>那么有没有办法让父函数只执行一次，仅在那一次初始化counter，之后每次都只通过执行子函数来操作counter呢？<br>可以用自执行函数来解决这个问题—–也就是通过自执行函数（而不是通过add()）来调用父函数，在这一次调用初始化counter，之后将返回的子函数赋给add，通过调用add()来操作counter。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里add已经是父函数的执行结果了，即add已经是返回的那个子函数了</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来就是闭包的知识了：<br>在每次调用闭包add——-即<code>function(){return(++counter)</code>时，由于add中存在自由变量counter，所以它必须到定义该函数时所在的那个作用域中去寻找该变量，也就是到父函数中去寻找。恰好父函数中有一个为0的counter可以被引用，所以这时候完成加一操作，counter变成1。注意，接下来我们尝试调用了console.log(counter)，但是输出的是undefined，这说明了即使add函数执行后返回了值为1的counter，但是该返回值并不是返回到全局作用域中（不然不会输出undefined），而是覆盖了父函数中原来定义的counter，使counter变为1；第二次调用add函数依然同上，只是此时引用counter时，引用的是为1的counter，加1后变为2；同理第三次，引用的是为2的counter，加1后变为3。<br><br><br>基于这道题，我们不难看出使用闭包函数的好处：</p><p>1、<span style="background-color:#fffa7d">缓存</span>：<br>最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量作为相对于闭包函数的自由变量，在闭包函数里直接使用它。因此该自由变量只初始化一次，但却可以通过多次调用闭包函数来使用。这比起我们直接在闭包函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是上面例子中的—–实现计数功能。</p><p>2、<span style="background-color:#fffa7d">实现封装</span>：<br>自由变量只能被闭包函数本身或者其子函数访问，而不能被闭包函数之外的函数访问。这就实现了面向对象的封装性，更安全更可靠。</p><p>参考：<br><a href="http://www.cnblogs.com/haidaojiege/p/7070560.html" target="_blank" rel="noopener">http://www.cnblogs.com/haidaojiege/p/7070560.html</a><br><a href="https://www.cnblogs.com/leoin2012/p/3978979.html" target="_blank" rel="noopener">https://www.cnblogs.com/leoin2012/p/3978979.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Stack Overflow规范提问</title>
      <link href="/2019/03/03/T-Stack%20Overflow%E6%8F%90%E9%97%AE%E6%8C%87%E5%8D%97%E5%92%8C%E5%BF%85%E5%A4%87%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB/"/>
      <url>/2019/03/03/T-Stack%20Overflow%E6%8F%90%E9%97%AE%E6%8C%87%E5%8D%97%E5%92%8C%E5%BF%85%E5%A4%87%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/So.jpg" alt=""><br><a id="more"></a></p><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>最近学习js的时候看到了一段代码，思考再三之后仍然不是很理解，于是决定到尽可能多的平台进行提问，目的有二：1.最主要的，解决问题；2.借这个机会测试哪些平台可以在短时间内给予提问者反馈和援助，从而作为下次提问的首选之地。最后问题是解决了，但是关于提问这件事再次有了不一样的感想。</p><p>首先从我自身出发—-在中文环境下我能够做到比较规范的提问（我认为的规范），即</p><ul><li>表诉清晰</li><li>必要的答谢</li></ul><p>但是在英文环境下就显得吃力得多，暴露的缺点如下：</p><ul><li>表达不够地道清晰，误导了回答者，导致问题被认为是duplicate而被关闭</li><li>编辑问题后未进行必要的核查，导致了后期的修改</li><li>无法完全理解对方想要表达的意思</li></ul><p>其次从平台出发进行分析，不得不说国内的平台反馈速度和热情的确比不上国外的。知乎因为有邀请机制，所以问题还是有机会得到高手的点拨；SegmentFault本身定位就是中国的Stack Overflow，所以得到专业回答的可能性也比较大。<br>但是类似贴吧和QQ群这些交流平台，得到有效回答的机率却实在太低。本来QQ群是实时互动的，反馈更应该迅速点，但是很多时候问题会被忽略。是什么原因我就不说了，不好直接下定论，但这无疑提示了我：如果急着解决问题，就应该避免在这些地方浪费时间—-一来速度没保障，二来质量参差不齐。</p><p>理想的提问平台应该是SegmentFault或者Stack Overflow。关于如何在Stack Overflow规范提问，这里转载一篇不错的博客：</p><h1 id="规范提问指南"><a href="#规范提问指南" class="headerlink" title="规范提问指南"></a>规范提问指南</h1><hr><h2 id="可以问什么样的主题"><a href="#可以问什么样的主题" class="headerlink" title="可以问什么样的主题"></a>可以问什么样的主题</h2><p>大家都知道 Stack Overflow是编程类的问答社区， 但还真有人把它当成通用的问答社区了， 问些完全无关的问题。 其实， Stack Overflow 是有一系列兄弟网站的（目前已经有100+)， 统称 Stack Exchange， 涵盖很多主题， 比如数学、物理、化学等科学类， 服务器管理、Latex、数据库等计算机类， 中文、俄文、日文等语言类， 详细的列表看这里， 不要让好问题问错地方哦。</p><p>允许的主题包括： 具体的编程问题、软件算法相关、通常只有程序员用的软件工具相关等。</p><p>有些主题是比较容易弄错的， 比如一般的电脑操作问题， 应该去Super User(热门的 Linux/Unix, 和Ubuntu还有独立的站点）， 专业的服务器问题， 应该去Server Fault。这些都不属于编程类的问题， 尽管不少程序员的日常工作也有涉及（想一想“怎么修电脑？”属于编程问题么）。 再举个例子， 同样是编辑器， Vim/Emacs/Atom相关的问题是可以的，因为基本只有程序员会用这些工具， 而 Word/记事本相关的一般就不可以。</p><h2 id="什么样的问题应该避免问"><a href="#什么样的问题应该避免问" class="headerlink" title="什么样的问题应该避免问"></a>什么样的问题应该避免问</h2><p>编程相关还不够， Stack Overflow 要求问题必须是 <strong>「practical, answerable questions based on actual problems that you face」</strong>。</p><p>这是什么意思呢？ 首先， 开放式的问题是不允许的，比如“你为什么喜欢PHP?”， 隔壁Quora会是更合适的对象。 其次， 问题应该不需要很长的篇幅来回答， 如果一个问题期待的回答足够写一本书， 那很可能会被关闭的。 各种寻求资源的问题应该避免，如 “要完成某某工作， 有什么Python的库可以用”， 或者“学习C++应该选择哪本书？”等， 因为答案会主观， 也容易吸引广告。 最后， 问题不要基于凭空的假设，要基于实际的难题。</p><p>需要注意的是，你很可能见过一些违反上面规定的问题还在，而且浏览量很大， 尤其是一些寻求资源的问题， 和非编程相关的计算机问题等。 这是什么原因呢？ 原来，早期的Stack Overflow的规则还比较松，也没有Super User之类的站点。 这些问题往往是08/09年问的，大多数现在已经被关闭了。</p><p>上面的规则如果遵守， 你的问题应该问对地方了。 下面继续说说内容上具体需要注意的。</p><h2 id="直入主题"><a href="#直入主题" class="headerlink" title="直入主题"></a>直入主题</h2><p>Stack Overflow不是论坛， 它的目标是希望成为编程类问答的一个超级数据库， 所以每个问题都不止是为了帮助提问者本人， 更重要的是希望将来能够帮助到每一个遇到同样问题的人。</p><p>所以， 和问题无关的内容都被认为是一种噪音， 包括： 打招呼（比如 Hi, Hello， Good afternoon， Dear Coders等)， 表示感谢（比如 Thanks, Any help would be appreciated等)， 没必要的背景（比如 I’m a newbie in C#等)， 你的签名 等。<br>可能有人会不理解为什么这样规定， 尤其是不要表示感谢这点。 Stack Overflow社区的理由是， 对愿意阅读并尝试解答你问题的人来说， 最好的表达感谢的方式是upvote有帮助的回答， 以及选择其中一个作为答案。 每一句和问题无关的内容都增加了额外的阅读时间， 而一个问题可能会被大量的人阅读。 更多的相关讨论可以参见这里和这里。</p><p>同样道理， 当有人回答你的问题之后， 也不要去添加无用的评论， 比如单纯的表达感谢的话， “+1”， 或者闲聊等。 评论的唯一用处是用来澄清疑问。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>作为一个英语社区， 不论提问、回答还是在评论中和别人互动， 都是要用英语的。</p><p>除非英语水平真的很糟糕， 语法其实并不是最需要担心的，因为并不需要做到完美。Stack Overflow是允许自由的编辑其他人的问题/回答的（编辑者如果rep不到2K，需要经过评审才会生效）。 有很多人会热情的对问题进行编辑的， 包括修复可能的语法错误。 我想说的一点是， 要尽可能的保证单词拼写是正确的。 即使对英语不够好的人来说， 这也只需要多花一点时间检查就可以做到， 但它代表着对阅读你问题的人的尊重。 甚至很多英语母语的人在拼写上也不注意， 会把I’m 写成im, 把 want to写成 wanna之类的非正式英语， 这些都会降低问题被回答的概率。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>在发问题之前， 问自己几个问题：</p><ul><li>你做过足够的研究么？ 有的人连入门指南都没读上10分钟就去提问， 问的问题能有多少价值呢？</li><li>你尝试过搜索么？ 至少要试过Google和站内搜索， 很可能相同的问题已经有答案了</li><li>你试过debug么？ 把你的想法或调试过程写在问题里，否则很可能会看到几条评论“Have you tried anything?”或“We don’t do your homework”之后问题就被downvote得惨不忍睹了。 因为大多数人是拒绝回答没有努力尝试的提问者的。</li></ul><p><strong>标签</strong>： 一个问题可以加1~5个标签， 大多数问题是和某种具体的编程语言相关的， 这个语言的标签通常是必须的， 否则相关语言的关注者们很可能根本见不到问题。</p><p><strong>起一个好标题</strong>： 一般来说， 标题应该尽量用简介的语言描述具体的问题。 比如 C# number confusion就是个反例， 如果改成 Why does using float instead of int give me different results when all of my inputs are integers? 就要具体多了。</p><h2 id="提供代码"><a href="#提供代码" class="headerlink" title="提供代码"></a>提供代码</h2><p>对于编程类问题，的确有问题不需要代码也能表达清楚的， 但大多数问题都需要代码才能清晰的表达。“我声明了一个变量， 调用了几个函数， 然后它的值就变了， 为什么呢？” 这样的问题， 鬼才知道答案。</p><p>提供代码要注意： 不要贴截图， 难道你要回答者去照着截图敲键盘复现你的问题？ 也不要只贴站外的链接， 如果站外链接能够提供一些额外的方便功能， 也要在贴代码的基础上附上该链接。</p><p>对于提供什么样的代码， Stack Overflow给出了一个可参考的标准： MCVE， 即Minimal, Complete, and Verifiable example</p><ul><li>Minimal: 最小的， 也就是尽可能的去掉和问题无关的部分。 如果你贴了一个几百行的代码， 很少有人愿意花时间去仔细看。 构造最小化例子的过程本身也是debug的过程。</li><li>Complete: 完整的， 一个简单的判断是：别人看到问题， 可以通过复制你提供的代码复现出问题吗？</li><li>Verifiable: 可验证， 描述问题尽可能具体， “the code doesn’t work”这样的描述就很不好。 如果编译不过， 要加上编译错误信息； 如果运行报错， 也同样要加上具体的错误信息； 如果结果和你的预期不一致， 要说清楚你的预期结果是什么， 为什么会这样想。</li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>Stack Overflow的编辑器是Markdown格式的， 如果你还不熟悉， 建议去学一下， 因为Markdown真的是一个只要10分钟就可以学会的语言。</p><p>大多数的格式问题都是出在贴代码的地方， 如果你发现你的代码是普通文本， 而没有语法高亮等功能， 那你很可能是格式搞错了。 最方便的方法就是选择所有代码， 然后按键盘Ctrl + K 即可。</p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>有可能你的问题几分钟内就会有人回答， 也有可能有人对问题有疑问， 在评论中要求你解释。 可以评论@他们解释， 如果问题确实不够清晰， 编辑你的问题吧。 最后， 如果你自己发现了解答方法， 而还没人给出， 那就自己回答自己的问题吧。 自问自答是被鼓励的行为。</p><hr><h1 id="术语词汇"><a href="#术语词汇" class="headerlink" title="术语词汇"></a>术语词汇</h1><p>另外，我认为规范提问建立在规范词汇的基础上，诚如上面所说的，这是一种对回答者应有的尊重。如何积累规范的词汇？我的计划是每周阅读1到2篇MDN上的文档，首先阅读英文并做出自己的理解，之后借助本地化团队的译文加深/修正自己的理解，这个过程既锻炼了阅读技术文档的能力，也可以顺带积累术语词汇，值得尝试。<br>本篇博客会将积累的词汇持续更新在下面：</p><table><thead><tr><th>English</th><th>中文</th><th>English</th><th>中文</th></tr></thead><tbody><tr><td>arity</td><td>参数个数</td><td>argument</td><td>实参</td></tr><tr><td>assignment</td><td>赋值</td><td>array of arrays</td><td>多维数组</td></tr><tr><td>block scope</td><td>块级作用域</td><td>build-in</td><td>内置的</td></tr><tr><td>currying</td><td>柯里化</td><td>class-based</td><td>基于类的</td></tr><tr><td>classical inheritance</td><td>类式继承</td><td>closure</td><td>闭包</td></tr><tr><td>coexist</td><td>共存</td><td>declarative</td><td>声明式</td></tr><tr><td>dynamic</td><td>动态的</td><td>duplicate</td><td>重复；副本</td></tr><tr><td>execution context</td><td>执行上下文</td><td>event handler</td><td>事件处理器</td></tr><tr><td>event driven</td><td>事件驱动的</td><td>function signature</td><td>函数声明</td></tr><tr><td>free variable</td><td>自由变量</td><td>getter-only</td><td>只读</td></tr><tr><td>global scope</td><td>全局作用域</td><td>global variable</td><td>全局变量</td></tr><tr><td>hoist</td><td>提升</td><td>invoke</td><td>调用</td></tr><tr><td>identifier</td><td>标识符</td><td>iterate</td><td>遍历</td></tr><tr><td>iterator</td><td>迭代器</td><td>non-extensible</td><td>不可拓展</td></tr><tr><td>Object-oriented</td><td>面向对象的</td><td>prototypal inheritance</td><td>原型式继承</td></tr><tr><td>private property</td><td>私有属性</td><td>prototype chain</td><td>原型链</td></tr><tr><td>parameter</td><td>形参</td><td>scope chain</td><td>作用域链</td></tr><tr><td>strict mode</td><td>严格模式</td><td>semantics</td><td>语义</td></tr><tr><td>statement</td><td>语句</td><td>silentl failure</td><td>静默失败</td></tr><tr><td>syntactical sugar</td><td>语法糖</td><td>throw an exception</td><td>抛出异常</td></tr><tr><td>library</td><td>库</td><td>framework</td><td>框架</td></tr><tr><td>LexicalEnvironment</td><td>词法环境</td><td>programming patterns and paradigms</td><td>编程范式</td></tr><tr><td>heap</td><td>堆</td><td>stack</td><td>栈</td></tr><tr><td>sync</td><td>同步</td><td>async</td><td>异步</td></tr><tr><td>instance</td><td>实例</td><td>encapsulation</td><td>封装</td></tr><tr><td>implicit</td><td>隐式</td><td>explicit</td><td>显式</td></tr><tr><td>call by value</td><td>按值调用</td><td>call by reference</td><td>按引用调用</td></tr><tr><td>override</td><td>覆盖</td><td>binding</td><td>绑定</td></tr><tr><td>Immediately Invoked Function Expression</td><td>立即执行函数表达式</td><td>Named Function Expression</td><td>具名函数表达式</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经典面试题解析</title>
      <link href="/2019/03/02/F-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/03/02/F-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>本篇博客专门用于收集各类经典面试题，并给出相关的解题思路和原理。</p><h3 id="1-考点：块级作用域和闭包"><a href="#1-考点：块级作用域和闭包" class="headerlink" title="1.考点：块级作用域和闭包"></a>1.考点：块级作用域和闭包</h3><p>先看一道很经典的面试题</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>                     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>如果你认为输出的是6，那么恭喜你答错了。正确答案是10。首先分析一下这段代码的具体执行过程。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 用var声明的变量要么在函数作用域中，要么在全局作用域中，很明显这里是在全局作用域中，因此认为i是全局变量，直接放在全局变量中。*/</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 关键！！这里之所以i为i而不是0；是因为我们只是定义了该函数，并未调用它，所以没有进入该函数执行环境，i当然不会沿着作用域链向上搜索找到自由变量i的值。*/</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 由于不具备块级作用域，所以该函数暴露在全局作用域中。</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//第二次循环，这时var i=1;覆盖了前面的var i=0；即现在全局变量i为1;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//解释同a[0]函数。</span><span class="token punctuation">}</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 第三次循环，这时var i=2;覆盖了前面的var i=1；即现在全局变量i为2;</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token operator">...</span>第四次循环 此时i<span class="token operator">=</span><span class="token number">3</span>  这个以及下面的i不断的覆盖前面的i，因为都在全局作用域中<span class="token operator">...</span><span class="token operator">...</span>第五次循环 此时i<span class="token operator">=</span><span class="token number">4</span><span class="token operator">...</span><span class="token operator">...</span>第六次循环 此时i<span class="token operator">=</span><span class="token number">5</span><span class="token operator">...</span><span class="token operator">...</span>第七次循环 此时i<span class="token operator">=</span><span class="token number">6</span><span class="token operator">...</span><span class="token operator">...</span>第八次循环 此时i<span class="token operator">=</span><span class="token number">7</span><span class="token operator">...</span><span class="token operator">...</span>第九次循环 此时i<span class="token operator">=</span><span class="token number">8</span>   <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这时i为10，因为不满足循环条件，所以停止循环。</span>紧接着在全局环境中继续向下执行。a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 这时调用a[6]函数，所以随即进入a[6]函数的执行上下文环境中，即function(){console.log(i)}中，此时执行函数中的代码console.log(i)，因为在当前的函数执行上下文中不存在变量i，所以i为自由变量，此时会沿着作用域链向上寻找，进而进入了全局作用域中寻找变量i,而全局作用域中的i在循环跑完后已经变成了10，所以a[6]的值就是10了。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么，如果我们想要输出6，应该怎么修改代码呢？两种方法。<br>1.使用let形成块级作用域，配合闭包使用</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//进入第一次循环</span>    <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*注意：因为使用let使得for循环为块级作用域，此次let i=0    在这个块级作用域中，而不是在全局作用域中。*/</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 注意：由于是用let声明的i,所以使整个块成为块级作用域，又由于a[0]这个函数引用到了上一级作用域中的自由变量，所以a[0]就成了一个闭包。*/</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*声明:这里用｛｝表达并不符合语法，只是希望通过它来说明let存在时，这个for循环块是块级作用域，而不是全局作用域。*/</span>    讲道理，上面这是一个块级作用域，就像函数作用域一样，执行完毕，其中的变量会被销毁，但是因为这个块级作用域中存在一个闭包，且该闭包维持着对自由变量i的引用，所以在闭包被调用之前也就是后续为了测试而console<span class="token punctuation">.</span>log出a<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>之前，此次循环的自由变量i即<span class="token number">0</span>不会被销毁<span class="token punctuation">.</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//进入第二次循环</span>     <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*注意：进入第二次循环即进入第二个代码块，此时处于激活状态的是let i=1。     它位于与let i=0不同的块级作用域中，所以两者不会相互影响。*/</span>     a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同样，这个a[i]也是一个闭包</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token operator">...</span>进入第三次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第四次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第五次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第六次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第七次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第八次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第九次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//进入第十次循环</span>    <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//同样，这个a[i]也是一个闭包</span><span class="token punctuation">}</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*不符合条件，不再向下执行，导致此次的块级作用域中不存在闭包，导致let i=10    未像前面的i一样等待被闭包引用，故此次的i没有必要继续存在，随即被销毁。*/</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*调用a[6]()函数，这时执行环境随即进入下面这个代码块中的执行环境：funcion(){console.log(i)};*/</span>即进入：<span class="token punctuation">{</span>      <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>      a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同样，这个a[i]也是一个闭包</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span>函数（闭包）这个执行环境中，它会首先寻找该执行环境中是否存在 i，没有找到，就沿着作用域链继续向上到了函数所在的块级作用域，找到了自由变量i<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>于是输出了<span class="token number">6</span>，即a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的结果为<span class="token number">6</span>。闭包既已被调用，所以整个代码块中的变量i和函数a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>被销毁。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.利用自执行函数<br>说来惭愧，本来如果明白这道题的原理，应该自然想到可以利用自执行函数达到相同的目的，但是最后还是在群里朋友的点拨下才明白的。<br>实际很简单，前面我们说过一句很关键的话：</p><blockquote><p>这里之所以i为i而不是0；是因为我们只是定义了该函数，并未调用它，所以没有进入该函数执行环境，i当然不会沿着作用域链向上搜索找到自由变量i的值</p></blockquote><p>那么反过来想一想，假如我们在定义了函数之后即刻对其进行了调用，是否此时将会在环境中寻找i的值并马上替换掉console.log(i)中的i呢？是的。至于怎么即刻对其调用，我们用自执行函数就可以，代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>                     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拿第一次循环举例，此时，a[0]函数的内容已经确定了，不再是随着循环的进行而动态变化了。</p><h3 id="2-考点：连等、解析和引用类型"><a href="#2-考点：连等、解析和引用类型" class="headerlink" title="2.考点：连等、解析和引用类型"></a>2.考点：连等、解析和引用类型</h3><p>这是某大厂一道知名的面试题，表面简单但是坑很多。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>a<span class="token punctuation">.</span>x <span class="token operator">=</span> a <span class="token operator">=</span><span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// {n:2}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来分析一下这段代码到底是怎么执行的，就会明白为什么结果与我们预想的完全不同，甚至可以说很怪异。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先，这两句令a和b同时引用了{n:2}对象，接着的<code>a.x = a = {n：2}</code>是关键。尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的<code>{n:1}</code>对象新增了一个属性x，即此时对象将变为<code>{n:1;x:undefined}</code>。之后按正常情况，从右到左进行赋值，此时执行<code>a ={n:2}</code>的时候，a重定向，指向了新对象<code>{n：2}</code>,而b依然指向的是旧对象，这点是不变的。接着的关键来了：执行<code>a.x = {n：2}</code>的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为<code>{n：2}</code>，旧对象为 <code>{n:1;x:{n：2}}</code>，它被b引用着。<br>后面输出a.x的时候，又要解析a了，此时的a当然是重定向后的指向新对象的a，而这个新对象是没有x属性的，故得到undefined；而输出b.x的时候，将输出旧对象的x属性的值，即<code>{n:2}</code>。</p><h3 id="3-考点：异步、作用域、闭包"><a href="#3-考点：异步、作用域、闭包" class="headerlink" title="3.考点：异步、作用域、闭包"></a>3.考点：异步、作用域、闭包</h3><p>如果无法深入到内部，从原理层面上理解代码的运行机制，那么知识只是浮在表面、浅尝辄止。“同步优先，异步靠边，回调垫底”的口诀可以帮助我们迅速判断，但是我希望用自己刚学习的事件循环机制来解释这道题。<br>实际上这也是比较普遍的一道面试题：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 代码最后输出什么？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不熟悉异步，很可能直截了当地回答是：<code>0 0 1 1 2 2</code> 。<br>正确答案应该是 <code>0 1 2 3 3 3</code><br>根据事件循环的机制，跑循环和输出i的值都是主线程上的同步任务，既然是同步任务，当然是按照顺序执行，所以<code>0 1 2</code>是容易理解的。那么setTimeout怎么办呢？setTimeout是异步任务，并不在主线程上，而是在宏任务队列里，它必须等待主线程的执行栈清空，才有自己的“一席之地”，才能去执行，所以这里我们直接忽略setTimeout，将前三次循环的setTimeout都挂在任务队列里。之后，循环跑完了，主线程的同步任务结束。此时i变成了3。<br>轮到任务队列了——&gt; 我们回过头调用setTimeout里的回调函数，进行i的输出。当然，由于i只有一个，即全局变量，所以此时输出的都是3，三次setTimeout即三次3。</p><p>如果我们要输出 <code>0 1 2 0 1 2</code> 呢？<br>其实这里就和第一个考点很像了。这里有两种方法，</p><p>一是将var改为let，从而形成多个独立的块级作用域，这样，每个setTimeout里的回调函数的i都将对应每一次循环的i（因为是块级作用域）。接着，由于输出和循环依然是同步任务，所以输出 <code>0 1 2</code>；之后轮到任务队列，也是输出<code>0 1 2</code>。</p><p>二是利用自执行函数，令函数在定义之后就即刻执行，那么函数中的i将会指向当前循环的i，这个i的值为多少在那时就已经确定了，而不再是随着跑循环而动态变化。这里又有两种自执行的方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个是将回调函数作为自执行函数，一个是将setTimeout函数作为自执行函数，效果是一样的。</p><h3 id="4-考点：作用域、NFE的函数名只读性"><a href="#4-考点：作用域、NFE的函数名只读性" class="headerlink" title="4.考点：作用域、NFE的函数名只读性"></a>4.考点：作用域、NFE的函数名只读性</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    b<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 代码最后输出什么？</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有认识到NFE函数的函数名只读性，这道题就会做错。正确答案应该是：</p><pre class="line-numbers language-js"><code class="language-js">f <span class="token punctuation">{</span>    b<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要理解这道题，先来看另一段代码</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> c<span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// b is no defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，这是一个具名函数表达式，即NFE。而NFE的函数名只能在函数内部访问，所以我们将该函数的引用赋给变量c之后，就只能通过c()调用该函数，而不能通过b()调用，更不能访问b。并且还要注意，函数名在函数内部类似于一个const常量，只能访问而不能对它进行修改。</p><p>理解这一点之后再来看最开始的代码，这是一段IIFE—–立即执行函数表达式（因为括号是操作符，所以认为括号里的是表达式而不是声明），它同样也是具名函数表达式，自然也有上面的性质。函数自调用，遇到<code>b=20</code>语句时开始在函数作用域中查找b是在哪里声明的，结果发现就是函数b，然后试图对函数名进行修改，因为这种修改相当于是修改一个常量，所以是无效的（非严格模式下静默失败，严格模式下抛出Type错误）。忽略了这段语句后，等于是只输出b，也就是输出函数本身。之后，我们在全局下输出b，根据上面的说法，我们无法在NFE函数外部访问NFE的函数名，所以这里的b代表的不是函数，而是用let声明的那个变量b。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> b<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，如果在函数内部用var或者let重新声明一个同名变量b并赋值，则是允许的，此时的b变量与函数b没有任何关系，仅仅是同名而已。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原型式继承和类式继承</title>
      <link href="/2019/03/02/F-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF%E5%92%8C%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/03/02/F-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF%E5%92%8C%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>java和JavaScript都是面向对象的语言，但二者的继承方式截然不同。前者采用类式继承（classical inheritence），也是大多数面向对象语言的继承方式。而后者采用原型式继承（prototype ineritence），因此称JavaScript为基于对象更加合适。<br><a id="more"></a></p><h2 id="1-JavaScript的继承"><a href="#1-JavaScript的继承" class="headerlink" title="1.JavaScript的继承"></a>1.JavaScript的继承</h2><p>就JavaScript的继承来说，又可以分为es5的继承和es6的继承。参考阮一峰老师在《ES6标准入门》一书中所说的：</p><blockquote><p>在ES6之前，class是保留字，ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p></blockquote><p>虽然在es6中引入了类的概念，但它其实只是简化了原来需要我们自己编写的原型链代码的语法糖，从而让js更趋向于传统的面向对象语言而已。要理解这个过程，首先要明白es6中的class做了什么。</p><h4 id="1-1-class到底做了什么："><a href="#1-1-class到底做了什么：" class="headerlink" title="1.1 class到底做了什么："></a>1.1 class到底做了什么：</h4><ul><li><p>首先看看class是什么东西</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token keyword">typeof</span> Person   <span class="token comment" spellcheck="true">//  function </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里的class与java中的class不同，它并不是一个全新的数据类型，而是相当于原型继承中的构造函数。</p></li><li><p>接着看看es5和es6在实现继承上的区别：</p></li></ul><p>es5：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//父类</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">SubPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 子类</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 子类继承父类的属性 需要将this指向父类中的name</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// job是子类的新增属性</span><span class="token punctuation">}</span>SubPerson<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 让子类继承父类的方法</span><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token string">'zcl'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//实例化子类对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// zcl（父类属性）</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// zcl（父类方法）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>es6：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">// 父类</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubPerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//子类</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 用super来调用父类的构造函数</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// job是子类的新增属性</span>    <span class="token punctuation">}</span>    <span class="token function">showJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>job<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token string">'zcl'</span><span class="token punctuation">,</span><span class="token string">'前端开发'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例化子类对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// zcl（父类属性）</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// zcl（父类方法）</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前端开发（子类属性）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，es6中采用class后，大大简化了组合继承的步骤。</p><ul><li>class做了什么：</li></ul><p>1.定义父类时</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    constructor<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*constructor*/</span> <span class="token punctuation">}</span>    method<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*method*/</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等价于</span><span class="token keyword">function</span> Person<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*constructor*/</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>method<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*method*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.子类继承父类时：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">SubPerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    onstructor<span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">/*constructor*/</span>       <span class="token comment" spellcheck="true">//子类新增属性</span>         <span class="token punctuation">}</span>    method<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*method*/</span> <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//子类新增方法</span><span class="token punctuation">}</span><span class="token keyword">var</span> subperson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 等价于</span><span class="token keyword">function</span> SubPerson<span class="token punctuation">{</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/*constructor*/</span>          <span class="token comment" spellcheck="true">//子类新增属性</span><span class="token punctuation">}</span>SubPerson<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>SubPerson<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>method<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*method*/</span>               <span class="token comment" spellcheck="true">//子类新增方法</span><span class="token punctuation">}</span><span class="token keyword">var</span> subperson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于es6继承而言，访问实例化的子类对象的属性或者方法时，依然是沿着原型链进行追溯，并且子类实例创建后，class SubPerson中的this依然会指向该子类，可以看出，这与es5的原型继承的一模一样的。</p><h4 id="1-2-关于this："><a href="#1-2-关于this：" class="headerlink" title="1.2 关于this："></a>1.2 关于this：</h4><p>es5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.call(this)）；es6的继承机制完全不同，实质是先通过调用super方法（super指向父类的构造函数）创造父类的实例对象this，然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加。</p><h2 id="2-Java的继承"><a href="#2-Java的继承" class="headerlink" title="2.Java的继承"></a>2.Java的继承</h2><p>首先了解java中创建对象的方式。java中，类一般包含field(变量)，constructor(构造方法)，method(其他方法)。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 创建父类</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//  field</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// method</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// constructor</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着实现继承</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SubPerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 创建子类</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// field</span>    <span class="token keyword">public</span> String <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// method</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SubPerson</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// constructor</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 通过super调用父类构造方法</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//重写父类方法，发生覆盖</span>        <span class="token keyword">return</span> <span class="token string">"I am not "</span><span class="token operator">+</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" but I am "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建测试类</p><pre class="line-numbers language-java"><code class="language-java">Public <span class="token keyword">class</span> <span class="token class-name">Testclass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Person person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"father"</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//通过new一个构造方法创建父类实例</span>        SubPerson subperson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token string">"son"</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 创建子类实例</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subperson1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//->I am not father but I am son.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-JavaScript的原型式继承与Java的类式继承"><a href="#3-JavaScript的原型式继承与Java的类式继承" class="headerlink" title="3.JavaScript的原型式继承与Java的类式继承"></a>3.JavaScript的原型式继承与Java的类式继承</h2><p>由上面分析可见，es6中的类继承实际只是披着语法糖外衣的原型继承。在此，我们可以将es5的原型继承和es6的类继承统一归类为原型继承，那么这种原型继承与java中真正的类继承相比，有什么区别呢？</p><ul><li>首先，类继承的方法都会存在父对象之中，每一次实例，都会将funciton保存在内存中，这样的做法毫无以为会带来性能上的问题。</li><li>其次，类继承是不可变的。在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法；相反，原型继承是可以通过改变原型链进而对子类进行修改的。</li><li>另外，类继承不支持多重继承（一个儿子一个父亲），而对于原型继承来说，你只需要写好extend对对象进行扩展即可。</li></ul><h2 id="4-补充：子类如何调用父类被覆盖的同名方法"><a href="#4-补充：子类如何调用父类被覆盖的同名方法" class="headerlink" title="4.补充：子类如何调用父类被覆盖的同名方法"></a>4.补充：子类如何调用父类被覆盖的同名方法</h2><p>首先这是一个比较奇怪的需求，因为既然子类重写了父类方法，就说明父类方法无法实现我们的要求，反过来，假设父类方法可以实现要求，则没必要重写该方法。但是让我们设想一下，假定现在一定要通过子类调用父类被覆盖的那个方法，应该怎么做呢？</p><p>通过上面的例子可以看到，在java中，我们只能在子类的构造方法中通过super关键字调用父类方法，而无法直接用子类的实例调用那个方法，像“子类实例.super.父类方法”，这是无效的；但是在js中，我们是可以做到的。基本思路就是：将父类实例以属性的方式进行保存，且该属性是子类构造函数的原型对象的属性。</p><p>这其实和原型链有关。我们设想有父类A、子类B以及同名方法say，并且设定子类B的原型对象的superClass属性指向父类实例b。那么，子类实例a直接调用say方法，必然是调用重写之后的方法；当它想要调用被覆盖的方法时，我们只需要用<code>a.superClass.say()</code>即可—–对于实例a，我们知道它本身并不具备superClass属性，因此它将沿着自己的原型对象也即子类B的原型对象进行查找，刚好B的原型对象有一个指向b的superClass属性，所以我们拿来用，而b有被覆盖的say方法，所以这里顺利完成了被覆盖方法的调用。<br><a href="https://blog.csdn.net/zhy416011189/article/details/50980016?utm_source=blogxgwz0" target="_blank" rel="noopener">附上CSDN的参考链接</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解闭包</title>
      <link href="/2019/02/27/F-%E9%97%AD%E5%8C%85/"/>
      <url>/2019/02/27/F-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E4%B8%8B%E8%BD%BD.png" alt=""><br><a id="more"></a></p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本篇博客不是原创，而是转载自@王福朋 王老师的系列文章。系列文章共计18篇，主要涉及js中的两座“大山”—-原型和闭包，由于原型部分我在另外一篇博客有介绍，所以这里只集合了他关于闭包的几篇讲解，包括了作用域、执行上下文等。我很喜欢他的讲解方式：图文并茂+循序渐进。</p><p>原作者：王福朋<br>来源：<a href="http://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">深入理解JavaScript原型和闭包</a><br>转载授权:<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/pro.png" alt=""></p><h2 id="1-简述执行上下文（上）："><a href="#1-简述执行上下文（上）：" class="headerlink" title="1.简述执行上下文（上）："></a>1.简述执行上下文（上）：</h2><p>什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q1.png" alt=""></p><p>第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。</p><p>在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q2.png" alt=""></p><p>这是第一种情况。</p><p>下面还有。先来个简单的。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q3.png" alt=""></p><p>有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。</p><p>与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。</p><p>下面还有。。。第三种情况。</p><p>在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q4.png" alt=""></p><p>看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。<br>没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。</p><p>好了，“准备工作”介绍完毕。</p><p>我们总结一下，在“准备工作”中完成了哪些工作：</p><ul><li><span style="background-color:#fffa7d">变量、函数表达式——变量声明，默认赋值为undefined；</span></li><li><span style="background-color:#fffa7d">this——赋值；</span></li><li><span style="background-color:#fffa7d">函数声明——赋值；</span></li></ul><p><span style="background-color:#fffa7d">这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。</span></p><p style="font-size:14px;font-family:楷体">这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——<span style="background-color:#fffa7d">任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的。</span></p><p>细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。<br>其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。<span style="background-color:#fffa7d">这个“代码段”其实分三种情况——全局代码，函数体，eval代码。</span><br><br></p><p>这里解释一下为什么代码段分为这三种。<br>所谓“代码段”就是一段文本形式的代码。<br>首先，全局代码是一种，这个应该没有非议，本来就是手写文本到<code>&lt;script&gt;</code>标签里面的。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q5.png" alt=""></p><p>其次，eval代码接收的也是一段文本形式的代码。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q6.png" alt=""></p><p>最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q7.png" alt=""></p><p>这样解释应该能理解了。</p><p>最后，eval不常用，也不推荐大家用。</p><h2 id="2-简述执行上下文（下）："><a href="#2-简述执行上下文（下）：" class="headerlink" title="2.简述执行上下文（下）："></a>2.简述执行上下文（下）：</h2><p>继续上面的内容。<br>上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：</p><ul><li>变量、函数表达式——变量声明，默认赋值为undefined；</li><li>this——赋值；</li><li>函数声明——赋值；</li></ul><p>如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q8.png" alt=""></p><p>以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，<span style="background-color:#fffa7d">函数每被调用一次，都会产生一个新的执行上下文环境。</span>因为不同的调用可能就会有不同的参数。</p><p>另外一点不同在于，<span style="background-color:#fffa7d">函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。</span>至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q9.png" alt=""></p><p>好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。</p><p>全局代码的上下文环境数据内容为：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q10.png" alt=""></p><p>如果代码段是函数体，那么在此基础上需要附加：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q11.png" alt=""></p><p>给执行上下文环境下一个通俗的定义——<span style="background-color:#fffa7d">在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。</span></p><p><span style="font-size:14px;font-family:楷体">了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！</span></p><p>讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。</p><h2 id="3-执行上下文栈"><a href="#3-执行上下文栈" class="headerlink" title="3.执行上下文栈"></a>3.执行上下文栈</h2><p>继续上文的内容。</p><p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。<span style="background-color:#fffa7d">处于活动状态的执行上下文环境只有一个。</span></p><p><span style="background-color:#fffa7d">其实这是一个压栈出栈的过程——执行上下文栈</span>。 如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q12.png" alt=""></p><p>可根据以下代码来详细介绍上下文栈的压栈、出栈过程。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q13.png" alt=""><br>如上代码。</p><p>在执行代码之前，首先将创建全局上下文环境。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q14.png" alt=""></p><p>然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q15.png" alt=""></p><p>执行到第13行，调用bar函数。<br>跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q16.png" alt=""></p><p>并将这个执行上下文环境压栈，设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q17.png" alt=""></p><p>执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q18.png" alt=""></p><p>待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q19.png" alt=""></p><p>同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q20.png" alt=""></p><p>好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。</p><p>讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。</p><p>要说闭包，咱们还得先从自由变量和作用域说起。</p><h2 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4.作用域"></a>4.作用域</h2><p>提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q21.png" alt=""></p><p>再比如for语句：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q22.png" alt=""></p><p>所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q23.png" alt=""></p><p>其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——<span style="background-color:#fffa7d;font-weight:700">javascript除了全局作用域之外，只有函数可以创建的作用域。</span></p><p>所以，<span style="background-color:#fffa7d">我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。</span></p><p>jQuery就是一个很好的示例：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q24.png" alt=""></p><p>下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q25.png" alt=""></p><p>如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，<span style="background-color:#fffa7d">作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。</span>例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。<br><br><br><br></p><p><span style="background-color:#fffa7d">作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</span>例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。<br>说到这里，咱们又可以拿出jquery源码来讲讲了。<br>jQuery源码的最外层是一个自动执行的匿名函数：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q26.png" alt=""></p><p>为什么要这样做呢？</p><p>原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。</p><p>全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。</p><p>作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。<br>下一节将把作用域和执行上下文环境结合起来说一说。<br>可见，要理解闭包，不是一两句话能说清楚的。</p><h2 id="5-作用域和上下文环境"><a href="#5-作用域和上下文环境" class="headerlink" title="5.作用域和上下文环境"></a>5.作用域和上下文环境</h2><p>上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q27.png" alt=""></p><p>如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，<span style="background-color:#fffa7d">作用域在函数定义时就已经确定了。而不是在函数调用时确定</span>。</p><p>下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。另外，对上下文环境不了解的朋友，可以回过头看看前面。</p><p>第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q28.png" alt=""></p><p>第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q29.png" alt=""></p><p>第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q30.png" alt=""></p><p>第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q31.png" alt=""></p><p>第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q32.png" alt=""></p><p>第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q33.png" alt=""></p><p>结束了 ！</p><p>最后我们可以把以上这几个图片连接起来看看。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q34.png" alt=""></p><p>连接起来看，还是挺有意思的。<span style="background-color:#fffa7d">作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值</span>。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，<span style="background-color:#fffa7d">作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了</span>。</p><p>所以，<span style="background-color:#fffa7d">如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值</span>。</p><p>虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。</p><p>以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。</p><h2 id="6-从自由变量到作用域链"><a href="#6-从自由变量到作用域链" class="headerlink" title="6.从自由变量到作用域链"></a>6.从自由变量到作用域链</h2><p>先解释一下什么是“自由变量”。</p><p>在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q35.png" alt=""></p><p>如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？<br>有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q36.png" alt=""></p><p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——<span style="background:#fffa7d">要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记</span>——其实这就是所谓的“静态作用域”。</p><p>对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。</p><p>上面描述的只是跨一步作用域去寻找。</p><p>如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。<br>这个一步一步“跨”的路线，我们称之为——<span style="background:#fffa7d">作用域链</span>。<br>我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）</p><ul><li>第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</li><li>第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</li><li>第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</li><li>第四步，跳转到第一步。</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q37.png" alt=""></p><p>以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。</p><p>这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。</p><p>接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。</p><h2 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.闭包</h2><p>前面提到的上下文环境和作用域的知识，一方面是必须了解的知识，一方面也是理解闭包的基础。<br>至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。<br><span style="background-color:#fffa7d">但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递</span>。<br>闭包的作用，简而言之一句话：<span style="background-color:#fffa7d">可以在其他的执行上下文中，访问到函数的内部变量</span>。</p><p><strong>第一，函数作为返回值</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q38.png" alt=""></p><p>如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。</p><p><strong>第二，函数作为参数被传递</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q39.png" alt=""></p><p>如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p><p>上一节讲到自由变量跨作用域取值时，曾经强调过：<span style="background-color:#fffa7d">要去创建这个函数的作用域取值，而不是“父作用域”</span>。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。</p><p>另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。</p><p>在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。<br>但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。<span style="background-color:#fffa7d">这就是需要理解闭包的核心内容</span>。</p><p>咱们可以拿本文的第一段代码（稍作修改）来分析一下。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q40.png" alt=""></p><p>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q41.png" alt=""></p><p>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q42.png" alt=""></p><p>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。<span style="background-color:#fffa7d">注意，重点来了</span>：因为执行fn()时，<span style="background-color:#fffa7d">返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域</span>.。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</p><p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。</p><p>——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q43.png" alt=""></p><p>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q44.png" alt=""></p><p>执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p><p>这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</p><p><span style="background-color:#fffa7d">使用闭包会增加内容开销，现在很明显了吧</span>！</p><p>第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。</p><p>正如我们所看到的，闭包和作用域、上下文环境有着密不可分的关系。</p><p>另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，<span style="background-color:#fffa7d">像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么</span>，因为这些BUG可能完全在你的知识范围之外。</p><p>到现在闭包就简单介绍完了。</p><h2 id="8-补充：上下文环境和作用域的关系"><a href="#8-补充：上下文环境和作用域的关系" class="headerlink" title="8.补充：上下文环境和作用域的关系"></a>8.补充：上下文环境和作用域的关系</h2><p>本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。</p><p>在说明之前，咱们先用简单的语言来概括一下这两个的区别。</p><h4 id="8-1-上下文环境："><a href="#8-1-上下文环境：" class="headerlink" title="8.1. 上下文环境："></a>8.1. 上下文环境：</h4><p>可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？</p><p>另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？</p><h4 id="8-2-作用域："><a href="#8-2-作用域：" class="headerlink" title="8.2. 作用域："></a>8.2. 作用域：</h4><p>首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。</p><h4 id="8-3-两者："><a href="#8-3-两者：" class="headerlink" title="8.3. 两者："></a>8.3. 两者：</h4><p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。<br><br><br><br><br>上面的文字不理解没关系，且看下面的例子。</p><p>第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q45.png" alt=""></p><p>第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q46.png" alt=""></p><p>第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q47.png" alt=""></p><p>第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q48.png" alt=""></p><p>第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。<span style="background-color:#fffa7d">但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境</span>。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/q49.png" alt=""></p><p>讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。</p><p>目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 执行上下文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一下的一些计划</title>
      <link href="/2019/02/24/T-%E5%A4%A7%E4%B8%80%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92/"/>
      <url>/2019/02/24/T-%E5%A4%A7%E4%B8%80%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>1.关于英语<br>准备四级考试，重点是听力和写作；</p><p>2.前端</p><p>2.1. 旧东西的收尾，具体来说包括：</p><ul><li><del>培训视频（进阶系列）</del></li><li>SegmentFault上js进阶的相关文章。由于是js中的难点，并且在面试中出现比较多，所以慢慢来。打算是每周攻克一个或两个<br>【进阶1期】 调用堆栈<br>【进阶2期】 作用域闭包<br>【进阶3期】 this全面解析<br>【进阶4期】 深浅拷贝原理<br><del>【进阶5期】 原型Prototype</del><br>【进阶6期】 高阶函数<br>【进阶7期】 事件机制<br>【进阶8期】 Event Loop原理<br>【进阶9期】 Promise原理<br>【进阶10期】Async/Await原理<br>【进阶11期】防抖/节流原理<br>【进阶12期】模块化详解<br>【进阶13期】ES6重难点<br>【进阶14期】计算机网络概述<br>【进阶15期】浏览器渲染原理<a id="more"></a></li></ul><p>2.2. 《js高程》的阅读。<br>之所以单独拎出这一点，因为这学期基本不可能读完这么厚的书。所以打算是在学习h5的时候同步阅读本书。</p><p>2.3. 找一个小项目做。<br><del>初步决定是面向对象的小游戏，也有可能是hexo的一个主题</del><br>主题已完成，接下来可能会探索一下小程序</p><p>2.4. 新东西的开始<br>html5+css3，了解新特性，重点放在css动画。如果有时间，就学习ajax和jq。jq不作为重点。</p><p>4.关于阅读<br>看两本历史相关的书，大概是以下其中两本：<br>中东问题：《奥斯曼帝国六百年》《穿越百年中东》《中东生死门》<br>以色列/犹太人：《我为何放弃做犹太人》《耶路撒冷异乡人》《我的一生》《我的应许之地》《以色列123》《爱与黑暗的故事》《犹太国》《犹太复国主义史》<br>巴勒斯坦：《最后的天空之后》<br>伊拉克：《搅动世界的伊拉克》<br>阿拉伯：《阿拉伯的劳伦斯》<br>战争回忆录：《南瓜花》</p><p>5.游戏<br><del>可能会把巫师3+dlc打通关，当然，前提是有时间。</del><br>已通关，一句话评价：满分神作</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解line-height</title>
      <link href="/2019/02/20/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/"/>
      <url>/2019/02/20/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><h2 id="1-相关概念普及："><a href="#1-相关概念普及：" class="headerlink" title="1.相关概念普及："></a>1.相关概念普及：</h2><p>1.1 <span style="background-color:#fffa7d">顶线，中线，基线和底线</span> ：<br>直接见下图。inline-block和inline都可以有这四种线。其中，我们重点研究基线，即base line。基线并不是汉字文字的下端沿，而是英文字母“x”的下端沿。<br>1.2 <span style="background-color:#fffa7d">行高</span>：<br>即line-height，是指同一个元素中，两个文本行基线间的垂直距离。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span><span class="token number">170</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">16</span>px<span class="token punctuation">;</span><span class="token property">line-height</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     I'm the first line     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">16</span>px<span class="token punctuation">;</span> <span class="token property">line-height</span><span class="token punctuation">:</span><span class="token number">40</span>px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     I'm the second line     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line1.png" alt=""><br>比如上图或者下图中两条红线之间的距离。<br>1.3 <span style="background-color:#fffa7d">行距</span>：上行的底线和下一行的顶线之间的距离就是行距，行距的一半称为半行距<br>1.4 <span style="background-color:#fffa7d">字体大小</span>：即font-size，是指同一行的顶线和底线之间的距离</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line2.png" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line3.png" alt=""><br>从上图我们就可以看出，行距、font-size与行高之间的关系满足</p><blockquote><p>行距 = （行高 - font-size）</p></blockquote><p>当font-size等于行高时，行距 = 0，如下图<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line4.png" alt=""><br>而当font-size大于行高时，行距为负值，则两行重叠，如下图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line4%20%5B2%5D.png" alt=""></p><p>1.5 <span style="background-color:#fffa7d">CSS boxes的四种类型（containing boxes、inline boxes、line boxes、content area)</span></p><p>1.5.1 content area （内容区）：<br>内容区是包围着文字的一种box，无法显示出来。<br>在没有其他因素 (比如padding) 的影响时，内容区的高度即为font-size。</p><p>1.5.2 inline box (行内框) ：<br>每个行内元素会生成一个行内框，行内框是一个浏览器渲染模型中的一个概念，无法显示出来。<br>在没有其他因素 (比如padding) 的影响时，行内框的高度即为内容区的高度；<br>设定line-height后，实际改变的是行距，行内框的高度将由 内容区 变为 内容区＋行距。因此，此时会有行内框高度=行高。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line5.png" alt=""></p><p>1.5.3 3.line box（行框） ：<br>行框是指本行的一个虚拟的矩形框，由该行中一个个行内框组成。行框也是浏览器渲染模式中的一个概念，无法显示出来。<br>行框高度等于本行中所有行内框高度的最大值。当有多行内容时，每一行都有自己的行框。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line6.png" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line7.png" alt=""></p><p>1.5.4 containing box（包含框）：<br>包裹着上述三种box的box<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line8.png" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line9.png" alt=""></p><h2 id="2-line-height的取值方法与继承"><a href="#2-line-height的取值方法与继承" class="headerlink" title="2. line-height的取值方法与继承"></a>2. line-height的取值方法与继承</h2><p>一般而言，line-height只影响行内元素( 包括行内替换元素和行内非替换元素，如img和span )，并不能直接应用于块级元素。但是line-height 具有可继承性，块级元素的子元素会继承该特性，并且在行内元素上生效。</p><p>一般情况下，浏览器默认的line-height为1.2。可以自定义 line-height 覆盖这个初始值，那么该怎样设置line-height呢？有以下5种方式：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line10.png" alt=""></p><p>line-height是个<span style="background-color:#fffa7d">可继承</span>属性，它的继承规则比较复杂。需要提前说明的是：line-height的大小与font-size息息相关，除了指定line-height为多少px，剩下的设置方式都是<span style="background-color:#fffa7d">基于font-size</span>算出来的。 下面一一解释。</p><ul><li>inherit ：继承父元素line-height的值，所以父元素的是多少就是多少。 如果其后代元素不设置line-height 的话，也会是这个值。</li><li>数字＋px： 假设设置 line-height 为20px，那么该行的行高就是20px，与 font-size 无关，不会随着 font-size 做相应比例的缩放。 这个长度值（20px）会被后代元素继承，所有的后代元素会使用这个相同的、继承的 line-height (20px)，除非后代元素设定 line-height 。</li><li>数字＋％ ：假设自身的 font-size 为16px，line-height 设为120%。那么其行高为：16 * 120% = 19.2px。即 line-height 是根据自身的 font-size 计算出来的。 子元素会继承父元素的line-height，它继承的不是百分比而是父元素line-height计算后的最终值。</li><li>normal ：假设设置line-height 为 normal ，则会根据浏览器的解析情况给元素分配一个倍数，一般是1.2，即line-height为字体的1.2倍。与上一个不同的是，其子元素不再继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line11.png" alt=""><br>可见，子元素随着自身 font-size 的大小而做相应比例的缩放。</li><li>纯数字/缩放因子 ：如果既想要 normal 的灵活，又想设置一个自定义的值，那就要用 纯数字 。纯数字方式与 normal 唯一的不同，在于数值的大小不一定是1.2，而是完全由你自己决定。同样地，其子元素不是继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line12.png" alt=""></p><p>总结如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/line13.png" alt=""></p><p>那么，哪一种是最好的方式呢？ 一般来数，设置行高的值为<span style="background-color:#fffa7d">纯数字</span>是最推荐的方式，因为其会随着对应的 font-size 而缩放。</p><h2 id="3-line-height实现垂直居中的原理"><a href="#3-line-height实现垂直居中的原理" class="headerlink" title="3 line-height实现垂直居中的原理"></a>3 line-height实现垂直居中的原理</h2><p>通常情况下，div中的a标签包含文本，文本将默认出现在div的顶端，如果想要垂直居中，可以设置div的高度等于行高，由于行高不直接作用于块状元素且行高可以继承，所以实际上等效于设置a的行高等于div的高度。</p><p>a的行高即a的行内框高度，即 内容区＋行距。行高默认是浏览器分配的1.2，由于此时重新设置了行高☞☞所以行距跟着改变☞☞所以内容区上下往外延伸☞☞即行内框整体延伸。但是，文字始终在行内框里垂直居中，行内框延伸的终点是div的高度，也就是延伸至行内框高度等于div高度。此时，文本自然会在div中垂直居中。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧</title>
      <link href="/2019/02/18/T-%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/"/>
      <url>/2019/02/18/T-%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/11111111111111111111111111111.jpg" alt=""></p><a id="more"></a><p>提问领域的“圣经”，虽然很难严格按照里面的标准规范自己的行为，但是可以作为一个提醒的方式。译文应该是很长时间没维护了，因为bug被直接翻译为“臭虫”的情况屡见不鲜，但是总体上还是可以把英文原文要表达的意思说明白的。之所以放在博客，一是阅读体验，因为博客的TOC自动生成目录会使得阅读本文更加轻松；二是迁移，这类长文我认为不适合放在笔记里。主要是个人需要，所以悄悄地copy下来了，没有去要授权。</p><p>原文：<br><a href="http://doc.zengrong.net/smart-questions/cn.html?from=singlemessage" target="_blank" rel="noopener">http://doc.zengrong.net/smart-questions/cn.html?from=singlemessage</a></p><p>下面是正文</p><h2 id="提问前"><a href="#提问前" class="headerlink" title="提问前"></a>提问前</h2><p>在通过电邮、新闻组或论坛提技术问题以前，做以下事情：</p><p>1.尝试在你准备提问论坛的历史文档中搜索答案</p><p>2.尝试搜索互联网以找到答案</p><p>3.尝试阅读手册以找到答案</p><p>4.尝试阅读“常见问题文档”（FAQ）以找到答案</p><p>5.尝试自己检查或试验以找到答案</p><p>6.尝试请教懂行的朋友以找到答案</p><p>如果你是程序员，尝试阅读源代码以找到答案</p><p>提问时，请先表明你已做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中 学到的东西 ，我们喜欢回答那些表现出能从答案中学习的人。</p><p>运用某些策略，比如用谷歌（Google）搜索你遇到的各种错误提示（既搜索 谷歌论坛，也搜索网页）， 这样很可能直接就找到了解决问题的文档或邮件列表线索。 即使没有结果，在邮件列表或新闻组寻求帮助时提一句“我在谷歌中搜过下列句子但没有找到什么有用的东西” 也是件好事，至少它表明了搜索引擎不能提供哪些帮助。将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。</p><p>别着急，不要指望几秒钟的谷歌搜索就能解决一个复杂的问题。读一下常见问题文档。在向专家提问之前，先向后靠靠放松一下，再思考一下问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑抛出，只因你的第一次搜索没有结果（或者结果太多）。</p><p>认真地思考，准备好你的问题。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。</p><p>注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想 “愚蠢的问题……”，一边按将错就错的答案回复你，并且希望这种只是得到你自己“问的问题”而非真正所需的解答，给你一个教训。</p><p>永远不要假设你 有资格 得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社区贡献经验，而不仅仅是消极地要求从别人那获取知识的问题，你将“挣到”答案。</p><p>另一方面，表明你有能力也乐意参与问题的解决是个很好的开端。“有没有人能指个方向？”，我这还差点什么？”，“我应该查哪个网站？”，通常要比 “请给出我可以用的完整步骤”更容易得到回复，因为你表明了只要有人能指个方向，你就很乐意完成剩下的过程。</p><h2 id="提问时"><a href="#提问时" class="headerlink" title="提问时"></a>提问时</h2><h4 id="仔细挑选论坛"><a href="#仔细挑选论坛" class="headerlink" title="仔细挑选论坛"></a>仔细挑选论坛</h4><p>要对在哪提问留心，如果你做了下述事情，多半会被一笔勾销或被看成“失败者”：</p><ul><li>张贴与论坛主题无关的问题</li><li>在面向高级技术问题的论坛上张贴肤浅的问题，或者反之。</li><li>在太多不同的新闻组同时张贴</li><li>给既非熟人也没有义务解决你问题的人发送你私人的电邮</li></ul><p>为保护通信的渠道不被无关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想让这种事落到自己头上的。</p><p>因此，第一步是找对论坛。谷歌和其它搜索引擎还是你的朋友，可以用它们搜索你遇到困难的软硬件问题最相关的项目网站。那里通常都有项目的常见问题（FAQ）、邮件列表及文档的链接。如果你的努力（包括 阅读 FAQ）都没有结果，这些邮件列表就是最后能取得帮助的地方。项目的网站也许还有报告bug的流程或链接，如果是这样，去看看。</p><p>向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个内容丰富的网页的作者想充当你的免费顾问，不要对你的问题是否会受到欢迎做太乐观的估计──如果你不确定，向别处发或者压根别发。</p><p>在选择论坛、新闻组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以明确你的问题是否切题。发贴前先翻翻已有的帖子，这样可以让你感受一下那里行事的方式。事实上，张贴前在新闻组或邮件列表的历史文档中搜索与你问题相关的关键词是个极好的主意，也许就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别象机关枪似的一次性“扫射”所有的帮助渠道，这就象大喊大叫一样会令人不快，温柔地一个一个来。</p><p>弄懂主题！最典型的错误之一是在某种致立于跨平台可移植的语言、库或工具的论坛中提关于 Unix 或 Windows 操作系统程序接口的问题。如果你不明白为什么这是大错，最好在搞清楚概念前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回答。有几个道理支持这点，一是看潜在的回复者有多少，二是看论坛的参与者有多少，黑客更愿回答能启发多数人的问题。</p><p>可以理解，老练的黑客和一些流行软件的作者正在承受过多的不当消息。就象那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端──已经好几次了，一些流行软件的作者退出了对自己软件的支持，因为伴随而来的涌入其私人邮箱的垃圾邮件变得无法忍受。</p><h4 id="面向新手的论坛和互联网中继聊天（IRC）通常响应最快"><a href="#面向新手的论坛和互联网中继聊天（IRC）通常响应最快" class="headerlink" title="面向新手的论坛和互联网中继聊天（IRC）通常响应最快"></a>面向新手的论坛和互联网中继聊天（IRC）通常响应最快</h4><p>本地的用户组织或者你所用的 Linux 发行版也许正在宣传新手取得帮助的论坛或 IRC 通道（在一些非英语国家，新手论坛很可能还是邮件列表），这些地方是开始提问的好去处，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 通道是公开邀请提问的地方，通常可以得到实时的回复。</p><p>事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的项目论坛或邮件列表，（否则）该项目的黑客可能仅仅回复“用 我们的 代码”。</p><p>在任何论坛发贴以前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 通道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发者保留。所以先在论坛或 IRC 中寻求与该项目相关的帮助。</p><h4 id="第二步，使用项目的邮件列表"><a href="#第二步，使用项目的邮件列表" class="headerlink" title="第二步，使用项目的邮件列表"></a>第二步，使用项目的邮件列表</h4><p>当某个项目存在开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文档和主页，找到项目的邮件列表并使用它。采用这种办法有几个很好的理由：</p><p>向个别开发者提的问题（如果）足够好，也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为骚扰个别开发者的理由。</p><p>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导）也许太忙以至于没法回答你的问题。</p><p>大多数邮件列表都要存档，那些存档将被搜索引擎索引，如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</p><p>如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</p><p>如果一个项目既有 “用户” 也有“开发者”（或 “黑客”）邮件列表或论坛，而你又不摆弄那些代码，向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会遭受你的噪音干扰。</p><p>然而，如果你 确信 你的问题不一般，而且在“用户” 列表或论坛中几天都没有回复，可以试试“开发者”列表或论坛。建议你在张贴前最好先暗暗地观察几天,至少看看最近几天保存的帖子,以了解那的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h4 id="使用有意义且明确的主题"><a href="#使用有意义且明确的主题" class="headerlink" title="使用有意义且明确的主题"></a>使用有意义且明确的主题</h4><p>在邮件列表、新闻组或论坛中，主题是你在五十个或更少的字以内吸引有资格专家注意的黄金机会，不要用诸如 “请帮我” （更别提大写的 “请帮我！！！！”，这种主题的消息会被条件反射式地删掉）之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题描述。</p><p>使用主题的好惯例是“对象──偏差”（式的描述），许多技术支持组织就是这样做的。在“对象”部分指明是哪一个或哪一组东西有问题，在“偏差”部分则描述与期望的行为不一致的地方。</p><p>愚蠢：<br>救命啊！我的笔记本视频工作不正常！</p><p>明智：<br>X.org 6.8.1 扭曲鼠标光标，MV1005 型号的某显卡芯片组</p><p>更明智：<br>使用 MV1005 型号的某显卡芯片组在 X.org 6.8.1 的鼠标光标被扭曲</p><p>编写 “对象──偏差”式描述的过程有助于你组织对问题的细致思考。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在 X.org 中出现？或只是在其 6.8.1 版中？是针对某显卡芯片组？或者只是其中的 MV1005 型号？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。</p><p>更一般地，想象一下在一个只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接就找到答案的线索，而不用再次发贴提问。</p><p>如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象 “Re: 测试” 或者 “Re: 新bug”的消息不太可能引起足够的注意。同时，将回复中与新主题不甚相关的引用内容尽量删除。</p><p>对于列表消息，不要直接点击回复（按钮）来开始一个全新的线索，这将限制你的观众。有些邮件阅读程序，比如 mutt，允许用户按线索排序并通过折叠线索来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变主题还不够。mutt 和其它一些邮件阅读程序还要检查邮件头主题以外的其它信息，以便为其指定线索，所以宁可发一个全新的邮件。</p><p>在论坛，因为消息与特定的线索紧密结合，并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧。不是所有论坛都允许在回复中出现分离的主题，而且这样做了基本上没有人会去看。不过，通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该线索的人读到。所以，除非你 只想 在该线索当前活跃的人群中提问，还是另起炉灶比较好。</p><h4 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h4><p>以“请向……回复”来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，换个好点的；如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是敏感的（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如“留意本线索”、“有回复发送邮件”等功能。</p><h4 id="用清晰、语法、拼写正确的语句书写"><a href="#用清晰、语法、拼写正确的语句书写" class="headerlink" title="用清晰、语法、拼写正确的语句书写"></a>用清晰、语法、拼写正确的语句书写</h4><p>经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程（我敢打赌）。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将时间花在其它地方。</p><p>清楚、良好地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意（你的问题）麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它 必须 很准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将“its”混淆为“it’s”，“loose”搞成“lose”或者将“discrete”弄成 “discreet”。不要全部用大写，这会被视为无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox [注：著名黑客，Linux 内核的重要参与者] 也许可以这样做，但你不行。）</p><p>一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。也不要使用即时通讯中的简写，如将“you”简化为“u”会使你看起来象一个为了节约二次击键的半文盲式的傻子。更糟的是，如果象个小孩似地鬼画桃符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在非母语论坛提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍（是的，我们通常看得出其中的差别）。同时，除非你知道回复者使用的语言，请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被阅读就被直接删除的可能性降到最低。</p><p>如果你用英语书写但它是你的第二语言，最好提醒潜在的回复者语言上可能的困难以便绕过这个问题，比如：</p><ul><li>英语不是我的母语，请谅解拼写错误。</li><li>如果您使用某某语言，请电邮/私聊我，也许我需要您的协助翻译我的问题。</li><li>对于这个技术术语本身我很熟悉，但对于它的一些俚语或习惯表达方式就不太明白了。</li><li>我已经同时用某某语及英语提问，如果您使用两者之一回复，我很乐意翻译。</li></ul><h4 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h4><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文本而不是 HTML（超文本标注语言）（ 关闭HTML 并不难）</li><li>使用 MIME（多用途互联网邮件扩展）附件通常没有问题，前提是真正有内容（譬如附带的源文件或补丁），而不仅仅是邮件客户端程序生成的模板（譬如只是消息内容的拷贝）。</li><li>不要发送整段只是单行句子但多次折回的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的文本终端阅读邮件，设置你的行折回点小于 80 列。</li><li>但是，也 <em>不要</em> 用任何固定列折回数据（譬如日志文件拷贝或会话记录）。数据应该原样包含，使回复者确信他们看到的是与你看到的一样的东西。</li><li>在英语论坛中，不要使用’Quoted-Printable’ MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持。当它们分断时，那些文本中四处散布的 “=20”符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>永远 <em>不要</em> 指望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就象有人将还在冒热气的猪粪倒在你门口时你的反应一样。即使他们能够处理，也很厌恶这么做。</li><li>如果你从使用视窗的电脑发送电子邮件，关闭问题颇多的微软“聪明引用”功能（在“工具” -&gt; “自动纠正选项”的“输入时自动格式化”下去掉聪明引用的选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用“表情符号”和“HTML”功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。</li></ul><p>如果你使用图形用户界面的邮件客户端程序(如网景公司的 Messenger、微软公司的 Outlook 或者其它类似的)，注意它们的缺省配置不一定满足这些要求。大多数这类程序有基于菜单的“查看源码”命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。</p><h4 id="描述问题应准确且有内容"><a href="#描述问题应准确且有内容" class="headerlink" title="描述问题应准确且有内容"></a>描述问题应准确且有内容</h4><ul><li>仔细、清楚地描述问题的症状</li><li>描述问题发生的环境(主机、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：“Fedora Core 7”、“Slackware 9.1”等）</li><li>描述提问前做过的研究及其理解。</li><li>描述提问前为确定问题而采取的诊断步骤。</li><li>描述最近对计算机或软件配置的任何相关改变。</li><li>如果可能，提供在可控环境下重现问题的方法。</li><li>尽最大努力预测黑客会提到的问题，并提前备好答案。</li></ul><p>如果你认为是代码有问题，向黑客提供在可控环境下重现问题的方法尤其重要。当你这么做时，得到有用且及时回复的可能性将大大增加。</p><p>西蒙.泰瑟姆（Simon Tatham）写过一篇 如何有效报告bug的文章，我强烈推荐各位阅读。</p><h4 id="量不在多，精炼则灵"><a href="#量不在多，精炼则灵" class="headerlink" title="量不在多，精炼则灵"></a>量不在多，精炼则灵</h4><p>你应该（写得）精炼且有内容，简单地将一大堆代码或数据罗列在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝试将其裁剪得越小越好。</p><p>至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到 <em>有用的</em> 回复。第三，在提纯bug报告的过程中，你可能自己就找到了解决办法或权宜之计。</p><p>别急于宣称找到bug<br>当你在一个软件中遇到问题，除非你 <em>非常、非常</em> 的有根据，不要动辄声称找到了bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你（声称）发现了文档的“bug”，你应该能提供相应位置的替代文本。</p><p>记住，还有许多其它用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时就应该发现了（你在报怨前已经做了这些，是吧 ？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了bug，也就置疑了他们的能力，即使你是对的，也有可能会使其中的部分人感到不快。（此外，）在主题中嚷嚷“bug”也是特别不老练的。</p><p>提问时，即使你私下非常确信已经发现一个真正的bug，最好写得像是你做错了什么。如果真的有bug，你会在回复中看到这点。这样做的话，如果真的有bug，维护者就会向你道歉，这总比你弄砸了然后欠别人一个道歉要强。</p><h4 id="低声下气代替不了做自己的家庭作业"><a href="#低声下气代替不了做自己的家庭作业" class="headerlink" title="低声下气代替不了做自己的家庭作业"></a>低声下气代替不了做自己的家庭作业</h4><p>有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端：“我知道我只是个可怜的新丁，一个失败者，但……”。这既使人困扰，也没有用，当伴随着对实际问题含糊的描述时还特别令人反感。</p><p>别用低级灵长类动物的办法浪费你我的时间，相反，尽可能清楚地描述背景情况和你的问题，这比低声下气更好地摆正了你的位置。</p><p>有时，论坛设有单独的初学者提问版面，如果你真的认为遇到了肤浅的问题，到那去就是了，但一样别低声下气。</p><h4 id="描述问题症状而不是猜测"><a href="#描述问题症状而不是猜测" class="headerlink" title="描述问题症状而不是猜测"></a>描述问题症状而不是猜测</h4><p>告诉黑客是什么导致了问题是没用的（如果你的诊断理论是了不起的东西，你还会向别人咨询求助吗？）。所以，确保只是告诉他们问题的原始症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述自己的猜测很重要，应清楚地说明这只是你的猜测并描述为什么它们不起作用。</p><p>愚蠢：<br>我在编译内核时接连遇到 SIG11 错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？</p><p>明智：<br>我组装的电脑（K6/233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机 20 分钟左右、做内核编译时频繁地报 SIG11 错，但在头 20 分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问题，相关的典型编译会话日志附后。</p><p>由于以上这点许多人似乎难以掌握，这里有句话可以提醒你：“所有的诊断专家都来自密苏里州”。美国国务院的官方座右铭则是“让我看看”（出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：“我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。”）针对诊断者而言，这并不是怀疑，而只是一种真实而有用的需求，以便让他们看到与你看到的原始证据尽可能一致的东西，而不是你的猜测与总结。（所以，）让我们看看。</p><h4 id="按时间先后罗列问题症状"><a href="#按时间先后罗列问题症状" class="headerlink" title="按时间先后罗列问题症状"></a>按时间先后罗列问题症状</h4><p>刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你、电脑和软件在崩溃前都做了什么。在命令行处理的情况下，有会话日志（如运行脚本工具生成的）并引用相关的若干（如20）行记录会非常有帮助。</p><p>如果崩溃的程序有诊断选项（如-v详述开关），试着选择这些能在记录中增加排错信息的选项。记住，“多”不等于“好”。试着选取适当的排错级别以便提供有用的信息而不是将阅读者淹没在垃圾中。</p><p>如果你的记录很长（如超过四段），在开头简述问题随后按时间先后罗列详细过程也许更有用。这样，黑客在读你的记录时就知道该注意哪些内容了。</p><h4 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h4><p>如果你想弄清楚如何做某事（而不是报告一个bug），在开头就描述你的目标，然后才陈述遇到问题的特定步骤。</p><p>经常出现这种情况，寻求技术帮助的人在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身有问题，结果要费很大的劲才能通过。</p><p>愚蠢：<br>我怎样才能让某图形程序的颜色拾取器取得十六进制的 RGB 值？</p><p>明智：<br>我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的 RGB 值。</p><p>第二种提法是明智的，它使得建议采用更合适的工具以完成任务的回复成为可能。</p><h4 id="别要求私下回复电邮"><a href="#别要求私下回复电邮" class="headerlink" title="别要求私下回复电邮"></a>别要求私下回复电邮</h4><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为回复者也因为能力和学识被其它同行看到而得到某种回报。</p><p>当你要求私下回复时，此过程和回报都被中止。别这样做，让 回复者 来决定是否私下回答──如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人毫无意义。</p><p>对这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么“向我发电邮，我将为论坛归纳这些回复”将是神奇的句子。试着将邮件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你必须信守诺言。</p><h4 id="提问应明确"><a href="#提问应明确" class="headerlink" title="提问应明确"></a>提问应明确</h4><p>漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人（假如只是因为他们承担了太多工作的话），这些人对于没有止境的时间无底洞极其敏感，所以他们也倾向于讨厌那些漫无边际的问题。</p><p>如果你明确了想让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力并间接地设定了他们为帮助你需要花费的时间和精力上限，这很好。</p><p>要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很忙的专家那里得到解答。</p><p>所以限定你的问题以使专家回答时需要付出的时间最少──这通常与简化问题还不太一样。举个例，“请问可否指点一下哪有好一点的 X 解释？”通常要比“请解释一下 X”明智。如果你的代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。</p><h4 id="关于代码的问题"><a href="#关于代码的问题" class="headerlink" title="关于代码的问题"></a>关于代码的问题</h4><p>别要求他人给你出问题的代码排错而不提及应该从何入手。张贴几百行的代码，然后说一声“它不能运行”会让你得不到理睬。只贴几十行代码，然后说一句“在第七行以后，本应该显示<x>，但实际出现的是<y>”非常有可能让你得到回复。</y></x></p><p>最精确描述代码问题的方法是提供一个能展示问题的最小测试样例。什么是最小测试样例？它是对问题的展现，只需要刚好能够重现非预期行为的代码即可。如何生成一个最小测试样例？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样例（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源码并去除那些与问题无关的代码段。你能提供的最小测试样例越小越好（参见 量不在多，精炼则灵 ）。</p><p>生成一个非常小的最小测试样例并不总是可能，但尽力去做是很好的锻练，这有可能帮助你找到需要自己解决的问题。即使你找不到，黑客们喜欢看到你努力过，这将使他们更合作。</p><p>如果你只是想让别人帮忙审一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h4 id="别张贴家庭作业式问题"><a href="#别张贴家庭作业式问题" class="headerlink" title="别张贴家庭作业式问题"></a>别张贴家庭作业式问题</h4><p>黑客们善于发现“家庭作业”式的问题。我们中的大多数人已经做了自己的家庭作业，那是该 你 做的，以便从中学到东西。问一下提示没有关系，但不是要求完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户组、论坛或（作为最后一招）在项目的“用户”邮件列表或论坛中提问。尽管黑客们 会 看出来，一些老用户也许仍会给你提示。</p><h4 id="删除无意义的要求"><a href="#删除无意义的要求" class="headerlink" title="删除无意义的要求"></a>删除无意义的要求</h4><p>抵制这种诱惑，即在求助消息末尾加上诸如“有人能帮我吗？”或“有没有答案？”之类在语义上毫无意义的东西。第一，如果问题描述还不完整，这些附加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如“是的，你可以得到帮助”和“不，没有给你的帮助”。</p><p>一般来说，避免提“是或否”类型的问题，除非你想得到 “是或否”类型的回答。</p><h4 id="不要把问题标记为“紧急”，-即使对你而言的确如此"><a href="#不要把问题标记为“紧急”，-即使对你而言的确如此" class="headerlink" title="不要把问题标记为“紧急”， 即使对你而言的确如此"></a>不要把问题标记为“紧急”， 即使对你而言的确如此</h4><p>这是你的问题，不要我们的。宣称“紧急”极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关照。而且“紧急”或其它有类似含义的主题有可能触发垃圾过滤规则，潜在的回复者可能永远看不到你的问题！</p><p>有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌地提到这点，人们也许会有足够的兴趣快一点回答。</p><p>当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原因这样做几乎肯定不行。事实上，张贴诸如“紧急：帮我救救这个毛绒绒的小海豹！”肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄懂了再发贴也不迟。</p><h4 id="礼貌总是有益的"><a href="#礼貌总是有益的" class="headerlink" title="礼貌总是有益的"></a>礼貌总是有益的</h4><p>礼貌一点，使用“请”和“谢谢你的关注”或者“谢谢你的关照”，让别人明白你感谢他们无偿花时间帮助你。</p><p>坦率地讲，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要（同时也不能替代它们）。黑客们一般宁可读有点唐突但技术鲜明的bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价它的）</p><p>然而，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。</p><p>（我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的“提前谢了”，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的建议是要么先说 “提前谢了”，事后 再 对回复者表示感谢，要么换种方式表达，譬如用“谢谢你的关注”或“谢谢你的关照”）。</p><h4 id="问题解决后追加一条简要说明"><a href="#问题解决后追加一条简要说明" class="headerlink" title="问题解决后追加一条简要说明"></a>问题解决后追加一条简要说明</h4><p>问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比较恰当。</p><p>最理想的方式是向最初提问的线索回复此消息，并在主题中包含“已解决”、“已搞定”或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见线索 “问题 X”和“问题 X-已解决”的潜在回复者就明白不用再浪费时间了（除非他个人觉得“问题 X”有趣），因此可以利用此时间去解决其它问题。</p><p>追加的消息用不着太长或太复杂，一句简单的“你好──是网线坏了！谢谢大家──比尔”就比什么都没有要强。事实上，除非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。</p><p>对于有深度的问题，张贴排错历史的摘要是恰当的。描述问题的最终状态，说明是什么解决了问题，在此之后 才指明可以避免的弯路。应避免的弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。</p><p>除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。</p><p>最后，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题叙述到最后不知所终总是令人沮丧的，黑客们痒痒地渴望它们被解决。“挠痒痒”为你挣到的信誉将对你下次再次张贴提问非常非常的有帮助。</p><p>考虑一下怎样才能避免他人将来也遇到类似的问题，问问自己编一份文档或 FAQ 补丁会不会有帮助，如果是的话就将补丁发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。</p><h2 id="如何解读回答"><a href="#如何解读回答" class="headerlink" title="如何解读回答"></a>如何解读回答</h2><h4 id="“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸"><a href="#“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸" class="headerlink" title="“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸"></a>“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸</h4><p>有一个古老而神圣的传统：如果你收到“读读该死的手册”（RTFM） 的回复，发信人认为你应该去“读读该死的手册”。他或她多半是对的，去读一下吧。</p><p>“读读该死的手册”（RTFM）有个年轻一点的亲戚，如果你收到“搜搜该死的网络”（STFW）的回复，发信人认为你应该“搜搜该死的网络”。那人多半也是对的，去搜一下吧。(更温和一点的说法是“谷歌是你的朋友！”)</p><p>在论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种关照，提问前应该先搜索一下文档。</p><p>通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息很容易找到。第二，自已找要比别人喂到嘴里能学得更多。</p><p>你不应该觉得这样就被冒犯了，按黑客的标准，回复者没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。</p><h4 id="如果还不明白……"><a href="#如果还不明白……" class="headerlink" title="如果还不明白……"></a>如果还不明白……</h4><p>如果你看不懂回答，不要马上回复一个要求说明的消息，先试试那些最初提问时用过的相同工具（如手册、FAQ、网页、懂行的朋友等）试着搞懂回答。如果还是需要说明，展现你已经明白的。</p><p>譬如，假如我告诉你：“看起来象是某输入项有问题，你需要清除它”，接着是个 不好 的回帖：“什么是某输入项？”。而这是一个 很好 的跟帖：“是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？”</p><h4 id="对待无礼"><a href="#对待无礼" class="headerlink" title="对待无礼"></a>对待无礼</h4><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱的人是很自然的。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了过格的事，邮件列表、新闻组或论坛中的前辈多半会招呼他。如果这 没有 发生而你却光火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而 你 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外来者，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，缺少用于润滑人类社会“正常”交往所需的脑电路。这既可能是真也可能是假。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们 喜欢 现在这个样子，并且一般都对病号标记有站得住脚的怀疑。）</p><p>在下一节，我们会谈到另一个问题，当 你 行为不当时会受到的“冒犯”。</p><h2 id="别像失败者那样反应"><a href="#别像失败者那样反应" class="headerlink" title="别像失败者那样反应"></a>别像失败者那样反应</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸──以本文描述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反，你该这样去做：</p><p>熬过去，这很正常。事实上，它是有益健康与恰当的。</p><p>社区的标准不会自己维持，它们是通过参与者积极而 公开 地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称“如果你不想帮助用户就闭嘴”。有思路的参与者纷纷离开的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。</p><p>是夸张的“友谊”（以上述方式）还是有用？挑一个。</p><p>记着：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要容易得多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是别人想象你搞砸了）， 有些人也会无缘无故地攻击你本人。在这种情况下，报怨倒是 真的 会把问题搞砸。</p><p>这些找茬者要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些找茬者在给自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，大多数口水战最好不要理睬──当然，是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其中之后（这也是可能的）。</p><h2 id="提问禁忌"><a href="#提问禁忌" class="headerlink" title="提问禁忌"></a>提问禁忌</h2><p>下面是些典型的愚蠢问题和黑客不回答它们时的想法。</p><p>问：我到哪可以找到某程序或 X 资源？<br>问：我怎样用 X 做 Y？<br>问：如何配置我的 shell 提示？<br>问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？<br>问：我的{程序、配置、SQL 语句}不运行了<br>问：我的视窗电脑出问题了，你能帮忙吗？<br>问：我的程序不运行了，我认为系统工具X有问题<br>问：我安装 Linux 或 X 遇到困难，你能帮忙吗？<br>问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？<br>问：<br>我到哪可以找到某程序或 X 资源？</p><p>答：<br>在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 谷歌 吗？</p><p>问：<br>我怎样用 X 做 Y？</p><p>答：<br>如果你想解决的是 Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对要解决的 Y 问题糊涂，还被特定形势禁锢了思维。等他们把问题弄好再说。</p><p>问：<br>如何配置我的 shell 提示？</p><p>答：<br>如果你有足够的智慧提这个问题，你也该有足够的智慧去 “读读该死的手册”（RTFM），然后自己去找出来。</p><p>问：<br>我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？</p><p>答：<br>试试就知道了。如果你试过，你既知道了答案，又不用浪费我的时间了。</p><p>问：<br>我的{程序、配置、SQL 语句}不运行了</p><p>答：<br>这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下：</p><p>你还有什么补充吗？</p><p>噢，太糟了，希望你能搞定。</p><p>这跟我究竟有什么关系？</p><p>问：<br>我的视窗电脑出问题了，你能帮忙吗？</p><p>答：<br>是的，把视窗垃圾删了，装个象 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方的视窗版或者与视窗有交互(如 Samba)，你 可以 问与视窗相关的问题，只是别对问题是由视窗操作系统而不是程序本身造成的回复感到惊讶，因为视窗一般来说太差，这种说法一般都成立。</p><p>问：<br>我的程序不运行了，我认为系统工具 X 有问题</p><p>答：<br>你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文档作后盾。</p><p>问：<br>我安装 Linux 或 X 遇到困难，你能帮忙吗？</p><p>答：<br>不行，我需要亲手操作你的电脑才能帮你排错，去向当地的 Linux 用户组寻求方便的帮助（你可以在 这里 找到用户组列表）</p><p>注意：如果安装问题与某 Linux 发行版有关，在针对 它 的邮件列表、论坛或本地用户组织中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 “linux”和 所有 被怀疑的硬件 [作关键词] 仔细搜索。</p><p>问：<br>我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？</p><p>答：<br>想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。</p><h2 id="好问题与坏问题"><a href="#好问题与坏问题" class="headerlink" title="好问题与坏问题"></a>好问题与坏问题</h2><p>最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。</p><p>愚蠢：我在哪能找到关于 Foonly Flurbamatic 设备的东西？<br>这个问题在乞求得到 “搜搜该死的网络”（STFW） 式的回复。</p><p>明智： 我用谷歌搜索过“Foonly Flurbamatic 2600”，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？<br>这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。</p><p>愚蠢： 我不能编译某项目的源代码，它为什么这么破？<br>提问者假设是别人搞砸了，太自大了。</p><p>明智： 某项目的源代码不能在某 Linux 6.2 版下编译。我读了常见问题文档，但其中没有与某 Linux 相关的内容。这是编译时的记录，我做错了什么吗？<br>提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，这家伙值得注意。</p><p>愚蠢： 我的主板有问题，谁能帮我？<br>某黑客对此的反应可能是：“是的，还需要帮你拍背和换尿布吗？”，然后是敲下删除键。</p><p>明智： 我在 S2464 主板上试过 X、Y 和 Z，当它们都失败后，又试了 A、B 和 C。注意我试 C 时的奇怪症状，显然某某东西正在做某某事情，这不是期望的行为。通常在 Athlon MP 主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？<br>相反地，这个人看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。</p><p>在最后那个问题中，注意“给我一个回答”与“请帮我看看我还能再做点什么测试以得到启发”之间细微但重要的差别。</p><p>事实上，最后那个问题基本上源于 2001 年 8 月 Linux 内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。</p><p>通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。</p><p>事后，当我感谢大家并评论这次良好的经历时，一个 Linux 内核邮件列表的成员谈到，他认为我得到答案并不是因为我的名字挂在列表上，而只是因为我正确的提问方式。</p><p>黑客们在某种方面是非常不留情面的精英分子。我想在这事上他是对的，如果我 表现得 象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果得不到回答，请不要认为我们不想帮你，有时只是因为被问到的小组成员的确不知道答案。没有回复不等于不被理睬，当然必须承认从外面很难看出两者的差别。</p><p>一般而言，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。</p><p>有许多在线与本地的用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。</p><p>还有众多大小商业公司提供签约支持服务，别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。</p><p>象 Linux 这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。</p><h2 id="如何更好地回答"><a href="#如何更好地回答" class="headerlink" title="如何更好地回答"></a>如何更好地回答</h2><p>态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p>对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 FAQ 都不知道。</p><p>如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p>如果帮不了忙，别妨碍。 不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。</p><p>探索性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫报怨一声“读读该死的手册”（RTFM）是正当的，指出文档的位置（即使只是建议做个谷歌关键词搜索）会更好</p><p>如果你决意回答，给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。</p><p>请回答真正的问题！如果提问者已经做了自己该做的研究，并且说明尝试过X，Y，Z，A，B与C都没有得到想要的結果，那么回复“试试A或B” 或者给出一个内容为 “试一下X，Y，Z，A，B或C”的链接将极其无益！</p><p>帮助你的社区从中学习。当回复一个好问题时，问问自己 “如何修改相关文件或 FAQ 文档以免再次解答同样的问题？”，接着再向文档维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟“授人以鱼，不如授人以渔”。</p><h2 id="补充-XY-Problem-："><a href="#补充-XY-Problem-：" class="headerlink" title="补充(XY Problem)："></a>补充(XY Problem)：</h2><h4 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it?"></a>What is it?</h4><blockquote><p>The XY problem is asking about your attempted solution rather than your actual problem. This leads to enormous amounts of wasted time and energy, both on the part of people asking for help, and on the part of those providing help.</p></blockquote><ul><li>User wants to do X.</li><li>User doesn’t know how to do X, but thinks they can fumble their way to a solution if they can just manage to do Y.</li><li>User doesn’t know how to do Y either.</li><li>User asks for help with Y.</li><li>Others try to help user with Y, but are confused because Y seems like a strange problem to want to solve.</li><li>After much interaction and wasted time, it finally becomes clear that the user really wants help with X, and that Y wasn’t even a suitable solution for X.</li></ul><p>The problem occurs when people get stuck on what they believe is the solution and are unable step back and explain the issue in full.</p><h4 id="What-to-do-about-it"><a href="#What-to-do-about-it" class="headerlink" title="What to do about it?"></a>What to do about it?</h4><ol><li>Always include information about a broader picture along with any attempted solution.</li><li>If someone asks for more information, do provide details.</li><li>If there are other solutions you’ve already ruled out, share why you’ve ruled them out. This gives more information about your requirements.</li></ol><p>Remember that if your diagnostic theories were accurate, you wouldn’t be asking for help right?</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏往事</title>
      <link href="/2019/02/18/G-%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/"/>
      <url>/2019/02/18/G-%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>之前就说过这个博客不会纯记录自己的学习心得，而是会适当地聊聊自己的一些感想，其中当然也包括游戏。游戏被称为“第九艺术”，艺术自然不止是带给人娱乐感。</p><h4 id="gt-gt-2012年：《刺客信条II》"><a href="#gt-gt-2012年：《刺客信条II》" class="headerlink" title="&gt;&gt;2012年：《刺客信条II》"></a>&gt;&gt;2012年：《刺客信条II》</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/1.jpeg" alt=""><br><a id="more"></a><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/2.jpeg" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/3.jpeg" alt=""></p><p>译：</p><blockquote><p>当我年少轻狂时，我曾拥有自由，但我并不明白它的意义。<br>我曾拥有时间，但我没有意识到它的珍贵。<br>我曾拥有爱，但我从未用心去体会。<br>数十年的时间考验后，我终于理解了三者的真谛。<br>现在，我已风烛残年，这种理解已经逐渐变成一种满足。<br>爱，自由和时间，曾一度被我挥霍，而今成为了我前进的动力。<br>而我将最特别的爱，献给最亲爱的你和我们的孩子们，以及刺客联盟的兄弟姐妹们，<br>并献给赋予我们生命的那壮美奇妙，让人产生无限遐想的世界。<br>此爱永恒，Mia Sofia<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ——艾吉奥·奥迪托雷</p></blockquote><p>最早接触的游戏之一，有七年之久了。年代久远，写不下太多感慨性的文字，但是—-游戏里的场景还是记忆犹新：耶路撒冷、佛罗伦萨、罗马、君士坦丁堡……更重要的是Ezio这个人物给我留下了深刻的印象。我现在还觉得，能够在游戏中体验一个角色完整的一生是实属难得的事情。</p><h4 id="gt-gt-2013年：《刺客信条IV》"><a href="#gt-gt-2013年：《刺客信条IV》" class="headerlink" title="&gt;&gt;2013年：《刺客信条IV》"></a>&gt;&gt;2013年：《刺客信条IV》</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/ac1.jpg" alt=""><br><!--more--><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/ac2.jpg" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/ac3.jpg" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/ac4.jpg" alt=""></p><p>荡气回肠的加勒比海之旅以如此平静的方式结束。爱德华在最后摘下一朵红花送给女儿，这一幕在今天看来仍然美妙而浪漫，它带给我的视觉冲击力难以言说。</p><blockquote><p>“如果没有黄金，我们早就是英雄了”</p></blockquote><p>黑胡子的这句话也许是对那个航海时代最好的概括。爱德华最后得到了黄金、跻身上流贵族之列，然而代价之深重恐怕只有他自己清楚。</p><p>大概人总会有一种错觉，以为离去的人其实还活着。在安妮最后弹唱这首《The parting glass》的时候，爱德华恍惚之间仿佛看到昔日的朋友们正在与自己举杯共饮，片刻后才回过神，他们早就不在了。</p><p>“晚安，愿快乐与你们相伴”</p><blockquote><p>Of all the money that ere I had, I’ve spent it in good company,<br>过去我所有的积蓄，我都已和伙伴们一同分享<br>And of all the harm that ere I’ve done, alas was done to none but me.<br>而我做过的所有伤人之事，唉，受伤的只是我自己<br>And all I’ve done for want of wit, to memory now I cannot recall.<br>我为寻求智慧所做的一切，已成了不可追的回忆<br>So fill me the parting glass, goodnight and joy be with you all.<br>就为我添满这杯离别酒吧，晚安，愿快乐与你们常伴<br>Of all the comrades that ere I had, they’re sorry for my going away,<br>我所有的战友们，都不舍我即将离去<br>And of all the sweethearts that ere I’ve had , they wish me one more day to stay,<br>而我所有的情人们，都希望我多留一日<br>But since it falls unto my lot that I should rise and you should not,<br>但因为我深感起身之时已至 诸君安坐<br>I’ll gently rise and I’ll softly call, Goodnight and joy be with you all.<br>我会轻轻站起并柔声祝道，晚安，愿快乐与你们常伴<br>A man may drink and not be drunk,<br>一位男子大可畅饮但不该喝醉<br>A man may fight and may not be slain<br>一位男子大可战斗但不该嗜杀<br>A man may court a pretty girl<br>一位男子大可追求可爱的女孩<br>and perhaps be welcome back again.<br>而且或许还能欣然再相见<br>But since it has so ordered been by a time to rise<br>可是人生注定如此 有时起<br>And a time to fall<br>又有时落<br>Come fill to me the Parting glass, goodnight and joy be with<br>you all.<br>为我添满这杯离别酒，晚安，愿快乐与你们常伴<br>Come fill to me the Parting glass, goodnight and joy be with you all.<br>为我添满这杯离别酒，晚安，愿快乐与你们常伴</p></blockquote><h4 id="gt-gt-2019年：《巫师III》"><a href="#gt-gt-2019年：《巫师III》" class="headerlink" title="&gt;&gt;2019年：《巫师III》"></a>&gt;&gt;2019年：《巫师III》</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/q3.png" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/q4.png" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/q2.png" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BF%BB%E8%AF%91/q1.png" alt=""></p><p>玩下来的一个感觉就是：满分佳作——-我是一个对游戏很挑剔的人，即使是玩了有5年之久的游戏，我也不会对其缺点避而不谈。但巫师这款游戏意外地推翻了我之前对于RPG游戏的固有认知，让我明白了这个世界上真的有一款RPG游戏近乎完美，从任何方面来看都无可挑剔。<br>比起传统的美式RPG游戏，在游玩过程中深有体会的一点就是：波兰人真的很会讲故事。他们为玩家呈现的不是大量中世纪传说的意象（比如烂大街的骑士和恶龙），而是真真正正底蕴丰厚的故事。或者愤慨，或者无奈，或者悲恸，玩家的情感爆发点仿佛尽在这群鬼才开发者的掌握之中，只等剧情走向的推动去点燃那小小的火苗。用一个老外很喜欢的词来形容再适合不过了—immersive，入味，而且是余韵不绝的那种。<br>游戏里的大部分对话选项都会影响剧情的走向和人物的最终结局，这是我非常喜欢的一点。我个人觉得，开放世界游戏的所谓“开放”，绝不仅仅局限于地图的规模和场景的互动性，更体现在剧情的丰富化。丰富多样的剧情比起单一的剧情，最大的优势就在于大幅度提高了游戏的可探索性，玩家不得不去考虑：如果我做另外一个选择，结果会是怎么样？不同的选择带来不同的后果，这种极具冒险性的尝试恰好像极了我们的现实生活。<br>人们向来喜欢拿《巫师》和《上古卷轴5：天际》进行对比，虽然在情感上我更偏向于后者（因为它对我而言不只是一款游戏），但不得不承认的是，《巫师》的战斗系统尤其值得后者借鉴：针对不同的敌人需要采用不同的打法、角色的技能提高需要玩家做出适当的取舍以找出效果最好的组合方案、魔法和药水需要紧密结合，你几乎不可能靠着单一的技能或者装备撑过整场战斗……总的来说系统设计非常流畅和舒服，而且值得玩家花时间去钻研，这在一定程度上也提高了可玩度。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Gaming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于js对象和jq对象的疑问</title>
      <link href="/2019/02/15/F-jq%E5%AF%B9%E8%B1%A1%E5%92%8Cjs%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/02/15/F-jq%E5%AF%B9%E8%B1%A1%E5%92%8Cjs%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>问题：想要使所有div下的p标签的类名+1.因此采用下列办法：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">var</span> allp<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>allp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span><span class="token string">"i+2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><a id="more"></a><p>结果控制台报错：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/j1.png" alt=""></p><p>提示<code>allp[i].attr</code>不是一个方法，而attr是jq对象的方法，这个报错等于说allp[i]不是一个jq对象。<br>参考<a href="https://stackoverflow.com/questions/33023806/typeerror-1-attr-is-not-a-function" target="_blank" rel="noopener">stackoverflow</a> ，可知<code>$()[i]</code>返回的的确不是jq对象，而是原生dom对象，无法使用jq方法<code>attr()</code> 。</p><p>关于如何判断是jq对象还是dom对象，可以用常用的instanceof方法判断，也可以用只有jq对象才有的jquery属性结合if语句判断。</p><p>那么，如何用jq实现上诉功能？</p><p><strong>1）转化为jq对象</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>allp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span>allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>allp[i] 放在$( )中则为jq对象<br><strong>2).eq(i)</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> 。            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为jq collection 对象的eq( )方法将返回以参数值为索引值的单个元素.<br><strong>3).each遍历</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，因为each()本身可以传参，因此可以写成</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，i表示index，n表示当前元素（可用this操作）<br><strong>4).或者更简单的，配合回调函数使用</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span>，<span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>        n<span class="token operator">=</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是个错误的例子。</p><ul><li><p>jq本身可以隐式迭代，所以这里的for循环完全是多余的，加了for循环反而是错的。</p><blockquote><p>隐式迭代：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用</p></blockquote></li><li><p>在attr中将回调函数作为参数时，回调函数本身接受两个参数。具体到例子中，i为index，n为当前元素的当前值，也就是类名，这里的类名虽然为1到5，但是是string而不是number，所以需要用number( )进行类型转换才可以运算。</p></li><li>n最后必须return。<br>综上，正确代码为<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> allp<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      allp<span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token function">Number</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>each( )遍历，控制台打印<pre class="line-numbers language-js"><code class="language-js">allp<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/j2.png" alt=""></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>折腾博客系列之编辑工具的选择</title>
      <link href="/2019/02/15/To-%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/"/>
      <url>/2019/02/15/To-%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>Hexo是静态博客网站，必须先在本地编辑好md文件再推送到网站上去—md文件也就是所谓的用markdown语法编写内容的文件。“工欲善其事，必先利其器”，因此我们需要一个合适的markdown编辑工具，它必须具备以下特点：<br>1.可导出md文件到本地，并随时进行修改<br>2.可提供分屏预览，支持同步滚动和定位<br>3.启动时响应速度快，编辑时渲染速度快</p><p>以下是一些工具在markdown编写方面的优劣比较，可酌情进行选择。<br>（平台：windows）<br><a id="more"></a></p><h4 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h4><p>印象笔记自带markdown编辑器,如下图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%B7%A5%E5%85%B71.png" alt=""></p><p>优点：提供分屏预览，无需直接编写md代码，只需点击按钮即可，操作方便<br>缺点：无法导出md文件到本地，这是它的致命缺点。</p><h4 id="sublime-text3"><a href="#sublime-text3" class="headerlink" title="sublime text3"></a>sublime text3</h4><p>优点：安装插件后可以提供分屏预览<br>缺点：预览效果极差，超出的文本内容无法自动换行显示，而是直接隐藏。如下图红框部分<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%B7%A5%E5%85%B72.png" alt=""></p><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><p>优点：简洁美观<br>缺点：不提供分屏预览，md代码编辑完成后回车即自动渲染出文本来。（虽然它认为这是优点，很多人习惯的却是分屏）</p><h4 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h4><p>优点：提供分屏预览，有较多可拓展插件<br>缺点：响应速度极慢，编辑时明显感觉卡顿；软件过大，大概100多m；安装插件极其困难，失败率较高</p><h4 id="HexoEditor"><a href="#HexoEditor" class="headerlink" title="HexoEditor"></a>HexoEditor</h4><p>优点：简洁美观，提供分屏预览，图片插入方便<br>缺点：需要用npm指令下载安装，和Atom插件安装如出一辙，很容易卡死</p><h4 id="Hexo-admin"><a href="#Hexo-admin" class="headerlink" title="Hexo-admin"></a>Hexo-admin</h4><p>非工具。Hexo自带的博客后台管理，可以在web ui界面下进行编辑<br>优点：提供分屏预览<br>缺点：界面过于简陋，自定义程度较低，本地服务器必须一直开着才能使用</p><h4 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h4><p>这是这么多工具中我觉得体验最好的，本篇博客也是用vscode编写。<br>优点：提供分屏预览、同步滚动等；较多markdown插件和主题；启动速度快，使用流畅不卡顿，渲染速度很快<br>缺点：需要自己写md代码，不过鉴于md语法并不复杂，我觉得这个缺点完全可以忽略不计。<br><br><br><br><br><span style="background:#fffa7d">最后是博客编写方面的一点小tip：</span><br>原生markdown语法并不支持定义字体颜色和大小等样式，但是由于在hexo中，我们编写的md文件最后会生成对应的html文件，所以完全可以在编写的时候使用html语法，浏览器会自动解析并渲染文件中包含的标签等。比如，上面就可以通过将句子放在span标签中，再加上内联样式达到荧光高亮的效果。不止是样式，我们还可以用<code>&lt;br&gt;</code>标签实现换行,让每一段不至于太紧凑。（md中空格是会被合并的，这点和html一样）</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>折腾博客系列之博客搭建：Hexo+Github pages</title>
      <link href="/2019/02/15/T-hexo+github%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3/"/>
      <url>/2019/02/15/T-hexo+github%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>初衷：之前我习惯用印象笔记进行知识的收集和整理，虽然很好用，但终归只适合输入而不适合输出。我需要的是一个更加开放的平台，在这上面可以输出： 1.<strong>学习的收获 ；2.生活的感想 ；3.有价值的分享</strong>，因此有了这个博客网站。</p><p>用hexo+github pages 可以很方便地搭建一个个人博客网站，不需要购买域名和服务器，只需要按部就班操作即可。我自己大概是花了两三个小时搞定，主要是因为对git bash的使用不够熟悉，因此走了一些弯路。实际上动作快的话半个小时就可以搞定。下面是对部署过程的大概介绍，以及<strong>必须注意的事项</strong>（划重点，也就是所谓的“坑”）。由于本文参考了大量博客，所以在文末我会列出原文链接。</p><a id="more"></a><h2 id="一-Github，Github-pages-，Hexo"><a href="#一-Github，Github-pages-，Hexo" class="headerlink" title="一.Github，Github pages ，Hexo"></a>一.Github，Github pages ，Hexo</h2><p>首先介绍一下这三个东西，有大概的了解、知道是什么东西就可以。GitHub是一个面向开源及私有软件项目的托管平台，而GIthub Pages则是github的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，现在大多用来开发和制作个人博客网站。它的好处在于域名和服务器都是免费提供的，并且没有网站数量的限制。而Hexo 是一个快速、简洁且高效的博客框架，它使用Markdown解析文章，在几秒内，就可以利用靓丽的主题生成静态网页。（关于Hexo的详细介绍，请看官方文档 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a> ，这里就不展开了）。因此，可以说github和hexo是绝配。接下来，开始我们的工作。</p><h2 id="二-环境和必要准备"><a href="#二-环境和必要准备" class="headerlink" title="二. 环境和必要准备"></a>二. 环境和必要准备</h2><p>我个人的环境：win10，64bit<br>必要准备：你需要<br><strong>（1）github账号</strong> ：前往<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> 官网注册就好<br><strong>（2）git</strong> ： 最新版本的git（本文发表的时候是2.20.1版本），前往<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 官网下载并安装。安装完后前往git文件夹下打开git bash，运行以下命令：</p><pre><code>git config --global user.name &quot;username&quot;git config --global user.email &quot;your mail&quot;</code></pre><p>注：将username替换为自己的github账号名，将your mail替换为自己注册github时绑定的邮箱。这一步非常重要，当时部署的时候我因为遗漏了这一步，导致后面报错.</p><p><strong>（3）node.js</strong> ： 前往 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载并安装。<br>这两个的安装比较简单，一路next就好，不过我推荐还是修改一下路径，尽量放在自己可以找到的位置。<br><strong>（4）hexo</strong> ：打开git文件夹下的git bash，运行 以下命令安装hexo<br><code>npm install -g hexo-cli</code></p><p>依次运行以下命令进行hexo的初始化</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><p>注：请将上面代码的<code>&lt;folder&gt;</code>替换成你自己想要的文件夹名字，以我为例，我想要在git文件夹下新建一个Myblog文件夹以存放站点文件，那么我这里的代码就应该是</p><pre><code>$ hexo init Myblog$ cd  Myblog$ npm install</code></pre><p>成功之后，我们会在git文件夹下看到新建的Myblog文件夹，这个就是我们的站点文件夹，网站相关文件都存放在这里。<br>这里顺便介绍一下<code>cd Myblog</code>的作用，可以理解为“进入Myblog运行git bash”，你也可以在Myblog中右键运行git bash（如下图），效果是一样的。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA1.png" alt="在这里插入图片描述"></p><p><strong>在之后介绍的操作中，凡是需要输入命令的，请确保你已经cd进自己的站点文件夹。</strong></p><p>接着上面的代码，我们继续运行：</p><pre><code>hexo server</code></pre><p>这将在本地打开我们的网站，当提示”xxx is running at xxx“的时候，我们可以通过<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 这个网址预览我们的网站，想要切断连接，只需要在命令行窗口按下ctrl+c。至此，hexo博客已经在本地搭建好了。接下来，我们要将hexo和github进行对接。</p><h2 id="三-hexo与github-实现对接"><a href="#三-hexo与github-实现对接" class="headerlink" title="三. hexo与github 实现对接"></a>三. hexo与github 实现对接</h2><p><strong>1.建立仓库</strong></p><p>还记得我们之前注册的github账号吗？现在，请进入github网站，并点击头像选择your repository，我们现在需要创建一个仓库（也就是repository）用于存放相关站点文件。按照下图顺序进行设置：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA2.png" alt="在这里插入图片描述"><br>其中，Repository name也即是我们的仓库名字，必须是 Github账号名称.github.io的格式。比如你的github名字是ccc，那么仓库名字必须是ccc.github.io 。</p><p><strong>2.对接github</strong><br>在git bash中运行以下命令，安装 hexo-deployer-git 插件。</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>运行以下命令，创建SSH key。（注：和上面一样，请将your mail替换成github邮箱地址）</p><pre><code>$ ssh-keygen -t rsa -C &quot;your mail&quot;</code></pre><p>前往 C:\Users\Administrator.ssh\id_rsa.pub （注意，这只是大概位置。不同系统路径可能不同，但是大同小异）打开id_rsa.pub文件（可以用记事本打开，但是推荐用sublime text）。复制文件中的全部内容，前往 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a> ，将刚才复制的内容粘贴在New SSH key 的文本框中。</p><p>前往站点目录下（例如：git/ Myblog），打开_config.yml 文件，对文件末尾进行如下修改：</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:username/username.github.io.git  branch: master</code></pre><p>在这里要注意，1）所有的冒号距离右边的内容之间都有一个空格，如果没有空格，则修改是无效的。2）和前面一样，将usename替换成我们自己的github用户名 。 3）repo后面的地址，在旧版本的hexo中是http地址，但在新版本的hexo用的是ssh地址，<strong>我们统一用如上所示的ssh地址</strong>。有些博客由于没有进行更新，在说明这个问题的时候依然用的是http地址，造成了一定程度上的误导。</p><p>运行以下命令，对接并推送内容到github。</p><pre><code>$ hexo g$ hexo d</code></pre><p>等待片刻，打开 https://&lt;Github账号名称&gt;.github.io （例如 <a href="https://ccc.github.io" target="_blank" rel="noopener">https://ccc.github.io</a> ) 即可进入你搭建好的个人博客网站了。当然，网站默认用的是landscape主题，比较难看，关于主题的美化和后期一些插件的添加，可以参考文章末尾贴出的链接。</p><p><strong>PS：</strong></p><p>这里顺便介绍一下常用的 hexo 命令：<br><code>hexo clean</code> ————————&gt;清除缓存文件和已生成的静态文件<br><code>hexo g</code> 或者 <code>hexo generate</code> ————————&gt;生成静态文件<br><code>hexo d</code> 或者<code>hexo deploy</code> ————————&gt;生成静态文件并部署到仓库<br><code>hexo s</code> 或者 <code>hexo server</code> —————————&gt;在本地打开网站</p><p>一般来说，在对网站进行修改后，我们可以先用hexo g和hexo s 在本地预览效果，如果效果符合预期的话再用hexo d 推送到 github。当然，可能会遇到本地打开和域名打开的效果不一致，这种情况下通常是因为 1. 没有用hexo clean 清除缓存 2. 没有清除浏览器缓存（ctrl+f5 ） 3.忘记用hexo d 将本地文件推送到github 4. 本地和线上的同步本身需要时间，所以上述方法如果无效，可以尝试等几分钟，再打开网站就正常显示了。</p><p>参考自：<br><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a><br><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM Core 与 HTML-DOM</title>
      <link href="/2019/02/14/F-DOM%20Core%20%E5%92%8CHTML%20DOM/"/>
      <url>/2019/02/14/F-DOM%20Core%20%E5%92%8CHTML%20DOM/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><h4 id="1-DOM"><a href="#1-DOM" class="headerlink" title="1.DOM"></a>1.DOM</h4><p>DOM（文档对象模型）是由W3C制定的一套访问和操作XML（eXtensible Markup Language）文档的标准，即API。比如DOM告诉JavaScript引擎如何在浏览器窗口中显示和操作XML创建的标记（Tag）。</p><p>DOM与特定的平台、浏览器、语言无关，很多种语言都实现了DOM，比如因为JavaScript和PHP都实现了DOM，所以 JavaScript中有getElementsByTagName()方法，PHP中也有 getElementsByTagName()，getElementsByTagName()方法是DOM规定的访问XML文档的接口。<br><a id="more"></a></p><h4 id="2-XML、XHTML、HTML"><a href="#2-XML、XHTML、HTML" class="headerlink" title="2.XML、XHTML、HTML"></a>2.XML、XHTML、HTML</h4><p>XML与HTML相似，但两者是有区别。XML和HTML都来自于SGML，它们都含有标记，有着相似的语法，HTML和XML的最大区别在 于：HTML是一个定型的标记语言，用固定的标记来描述和显示数据，比如<code>&lt;h1&gt;</code>表示首行标题，有固定的尺寸；而XML没有固定的标记，只能通过自定义的标记来描述数据的形式和结构，而不能显示。HTML是将数据 和显示混在一起，而XML则是将数据和显示分开来。那为什么能使用DOM访问和操作HTML文档（即网页）呢？Web语义化的一个发展方向是将HTML逐 渐演变为更有语义、能将数据内容与现实分离的XML，但HTML不可能立即演变为XML，目前推荐使用的是一个过渡产物——XHTML。HTML与 XHTML网页形成的节点树（统称为HTML节点树）在结构上与XML节点树一样，可以看做是一个符合DOM的XML文档，因此可以使用实现了DOM的程序语言（如JavaScript、PHP等）来访问和操作HTML文档，即访问和操作那些节点。</p><h4 id="3-DOM-Core和HTML-DOM"><a href="#3-DOM-Core和HTML-DOM" class="headerlink" title="3.DOM Core和HTML-DOM"></a>3.DOM Core和HTML-DOM</h4><p>由于HTML与XML的相似性及差异，JavaScript不仅实现了标准的DOM方法和属性（即由W3C制定的），而且还实现了HTML特有的 DOM方法和属性，前者称为DOM Core，并不专属于JavaScript，后者称为HTML-DOM。不管是DOM Core还是HTML-DOM，我们在使用JavaScript的时候要注意浏览器之间的兼容性，因为不同的浏览器对这两类方法和属性的支持可能不一样。</p><p><span style="background:#fffa7d;font-weight:700">常见的DOM Core方法如下：</span></p><blockquote><p>1、创建节点<br>createElement()<br>createTextNode()<br>2、复制节点<br>cloneNode()<br>3、插入节点<br>appendChild()<br>insertBefore()<br>4、删除节点<br>removeChild()<br>5、替换节点<br>replaceChild()<br>6、查找和设置节点属性<br>setAttribute()<br>getAttribute()<br>7、查找节点<br>getElementById()<br>getElementsByTagName()<br>hasChildNode()</p></blockquote><p><span style="background:#fffa7d;font-weight:700">常见的DOM Core属性如下：</span></p><blockquote><p>node.childNodes<br>node.firstChild<br>node.lastChild<br>node.nextSibling<br>node.previousSibling<br>node.parentNode</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件相关概念详解</title>
      <link href="/2019/02/13/F-%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/13/F-%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><blockquote><p><strong>事件</strong>：事件是用户或浏览器自身执行的某种动作，如click,load和mouseover都是事件的名字。响应某个事件的函数叫做事件处理函数 / 事件处理程序 / 事件句柄。如果想要绑定多个函数，则需要用到事件监听器。</p></blockquote><h2 id="1-事件绑定的几种方式"><a href="#1-事件绑定的几种方式" class="headerlink" title="1. 事件绑定的几种方式"></a>1. 事件绑定的几种方式</h2><p>javascript给DOM绑定事件处理函数总的来说有2种方式：在html文档中绑定、在js代码中绑定。下面的方式1、方式2属于在html中绑定事件，方式3、方式4和方式5属于在js代码中绑定事件，其中，方式4和5属于事件监听，而方式5是最推荐的做法。</p><a id="more"></a><h4 id="1）在html文档中绑定"><a href="#1）在html文档中绑定" class="headerlink" title="1）在html文档中绑定"></a>1）在html文档中绑定</h4><p><strong>方式1：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>函数名( )<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>方式2：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>直接写函数内容<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2）在js代码中绑定"><a href="#2）在js代码中绑定" class="headerlink" title="2）在js代码中绑定　　　　"></a>2）在js代码中绑定</h4><p><strong>方式3：</strong></p><pre class="line-numbers language-js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：方式3也称为“DOM0级事件处理程序”。它无法绑定多个事件，当绑定多个事件的时候，只有最后一个会生效，其他皆被覆盖）</p><p><strong>方式4：</strong><br>[object].attachEvent(“事件类型”,”处理函数”)</p><p>说明：<br>①方式4也称为“IE事件处理程序”。这种方法不属于w3c标准，并且仅IE8及以下支持该方法；<br>②事件类型要加on；<br>③如下图，b中声明a函数时分配了一块内存地址 ，两个<code>dom.attachEvent(&#39;onclick&#39;,a)</code>中的a都指向的是下面定义的a；c中只是两个函数体一样的匿名函数，分别有各自的内存地址，故认为是两个不同的函数对象</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E4%BA%8B%E4%BB%B61.png" alt=""></p><p><strong>方式5：</strong>[object].addEventListener(“事件类型”,”处理函数”,”冒泡事件或捕获事件”);</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E4%BA%8B%E4%BB%B62.png" alt=""></p><p>说明：<br>①方式5也称为“DOM2级事件处理程序”。w3c正统标准，IE9及以上、Chrome、Firefox等支持该方法；<br>②事件类型不加on；<br>③第三个参数不设置的时候，默认为false即冒泡；<br>④ 同一个事件处理函数可以绑定2次,一次用于事件捕获，一次用于事件冒泡；如果绑定的是同一个事件处理函数，并且都是事件冒泡类型或者事件捕获类型，那么只能绑定一次；<br>⑤ 不同的事件处理函数可以重复绑定，这点与上面attachEvent是一样的</p><h2 id="2-事件处理函数的执行顺序"><a href="#2-事件处理函数的执行顺序" class="headerlink" title="2. 事件处理函数的执行顺序"></a>2. 事件处理函数的执行顺序</h2><p>方式123都不能实现事件的重复绑定，所以自然也就不存在执行顺序的问题。方式4和方式5可以重复绑定特性，所以需要了解下执行顺序的问题。<br>结论：<br>对于addEventListener，如果给目标的同一个事件绑定多个处理函数，先绑定的先执行。 attachEvent则刚好相反，后绑定的先执行，这是因为采用attachEvent的是IE8-，而IE8-是不支持dom事件流模型的。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">var</span> outA<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"outA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"outA"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当点击outA的时候，会依次打印出1、2、3、4。这里特别需要注意：我们是同时给outA这个元素绑定了多个onclick事件处理函数，没有涉及父子元素，所以也不涉及事件冒泡和事件捕获的问题，即addEventListener的第三个参数在这种场景下，没有什么用处，直接忽略之。如果是通过事件冒泡或者是事件捕获触发outA的click事件，那么函数的执行顺序会有变化。</p><h2 id="3-事件捕获和事件冒泡"><a href="#3-事件捕获和事件冒泡" class="headerlink" title="3. 事件捕获和事件冒泡"></a>3. 事件捕获和事件冒泡</h2><p>我们知道HTML中的元素是可以嵌套的，形成类似于树的层次关系。比如下面的代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>outA<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>outB<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>outC<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果点击了最内侧的outC，那么外侧的outB和outC算不算被点击了呢？很显然算，不然就没有必要区分事件冒泡和事件捕获了，这一点各个浏览器厂家也没有什么疑义。假如outA、outB、outC都注册了click类型事件处理函数，当点击outC的时候，触发顺序是A–&gt;B–&gt;C，还是C–&gt;B–&gt;A呢？如果浏览器采用的是事件冒泡，那么触发顺序是C–&gt;B–&gt;A，由内而外，像气泡一样，从水底浮向水面；如果采用的是事件捕获，那么触发顺序是A–&gt;B–&gt;C，从上到下，像石头一样，从水面落入水底。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E4%BA%8B%E4%BB%B63.png" alt=""></p><p>一般来说事件冒泡机制用的更多一些，所以在IE8以及之前，IE只支持事件冒泡。IE9+/FF/Chrome这2种模型都支持，可以通过addEventListener的第三个参数来设定，false代表事件冒泡，true代表事件捕获。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> outA <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"outA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">var</span> outB <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"outB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">var</span> outC <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"outC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 使用事件冒泡</span>        outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outB<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outC<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"outA"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"outB"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"outC"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的是事件冒泡，当点击outC的时候，打印顺序是3–&gt;2–&gt;1。如果将false改成true使用事件捕获，打印顺序是1–&gt;2–&gt;3。</p><h2 id="4-DOM事件流"><a href="#4-DOM事件流" class="headerlink" title="4. DOM事件流"></a>4. DOM事件流</h2><h4 id="4-1-事件流定义："><a href="#4-1-事件流定义：" class="headerlink" title="4.1  事件流定义："></a>4.1 事件流定义：</h4><p>事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点与根节点之间按照特定的顺序如流水一样传播，路径所经过的所有节点都会收到该事件，这个传播过程即事件流。</p><h4 id="4-2-事件流模型："><a href="#4-2-事件流模型：" class="headerlink" title="4.2 事件流模型："></a>4.2 事件流模型：</h4><p>事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。</p><blockquote><p><strong>冒泡型事件流</strong>：事件的传播是从最特定的事件目标到最不特定的事件目标。即<strong>由内到外</strong><br><strong>捕获型事件流</strong>：事件的传播是从最不特定的事件目标到最特定的事件目标。即<strong>由外到内</strong></p></blockquote><h4 id="4-3-DOM事件流："><a href="#4-3-DOM事件流：" class="headerlink" title="4.3 DOM事件流："></a>4.3 DOM事件流：</h4><h5 id="4-3-1-dom事件流定义："><a href="#4-3-1-dom事件流定义：" class="headerlink" title="4.3.1 dom事件流定义："></a>4.3.1 dom事件流定义：</h5><p>DOM标准采用捕获+冒泡的DOM事件流。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E4%BA%8B%E4%BB%B64.png" alt=""></p><h5 id="4-3-2-dom事件流包括："><a href="#4-3-2-dom事件流包括：" class="headerlink" title="4.3.2  dom事件流包括："></a>4.3.2 dom事件流包括：</h5><p>DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。<br><em>事件捕获阶段：<strong>实际目标</strong><code>(&lt;div&gt;)</code>在捕获阶段<strong>不会接收事件</strong>。也就是在捕获阶段，事件从document到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>就停止了。上图中为1~3.</em><br><em>处于目标阶段：事件在<code>&lt;div&gt;</code>上发生并处理。但是<strong>事件处理会被看成是冒泡阶段的一部分</strong>。</em><br><em>冒泡阶段：事件又传播回文档。</em></p><h5 id="4-3-3-dom事件流与冒泡、捕获"><a href="#4-3-3-dom事件流与冒泡、捕获" class="headerlink" title="4.3.3 dom事件流与冒泡、捕获"></a>4.3.3 dom事件流与冒泡、捕获</h5><p>将DOM事件流看作整个过程，那么其实 useCapture=false意味着：<span style="color:red;font-weight:700">将该事件处理函数加入到冒泡阶段</span>，在冒泡阶段会被调用；useCapture=true意味着：<span style="color:red;font-weight:700">将该事件处理函数加入到捕获阶段</span>，在捕获阶段会被调用。从DOM事件流模型可以看出，捕获阶段的事件处理函数，一定比冒泡阶段的事件处理函数先执行。</p><h5 id="4-3-4-dom事件流的相关概念"><a href="#4-3-4-dom事件流的相关概念" class="headerlink" title="4.3.4   dom事件流的相关概念"></a>4.3.4 dom事件流的相关概念</h5><p>1） target:<br>触发事件的某个具体对象，固定不变的。<br>2） currentTarget:<br>绑定事件的对象，恒等于this，可能出现在事件流的任意一个阶段中。动态变化的。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E4%BA%8B%E4%BB%B65.png" alt=""></p><p>控制台：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E4%BA%8B%E4%BB%B66.png" alt=""></p><p>点击最里面的son3后，可以看到target一直不变，而由于冒泡，导致currentTarget动态变化。</p><p>3） 两者的应用场合<br>通常情况下target和currentTarget是一致的，我们只要使用terget即可，但有一种情况必须区分这三者的关系，那就是在父子嵌套的关系中，父元素绑定了事件，单击了子元素（根据事件流，在不阻止事件流的前提下他会传递至父元素，导致父元素的事件处理函数执行），这时候currentTarget指向的是父元素，因为他是绑定事件的对象，而target指向了子元素，因为他是触发事件的那个具体对象</p><p><strong>PS</strong>：<br>注意！！！并非所有的事件都会经过冒泡阶段 。所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。</p><h2 id="5-DOM事件流中的“事件处理函数的执行顺序”"><a href="#5-DOM事件流中的“事件处理函数的执行顺序”" class="headerlink" title="5. DOM事件流中的“事件处理函数的执行顺序”"></a>5. DOM事件流中的“事件处理函数的执行顺序”</h2><p>我们回头再来说事件处理函数的执行顺序。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E4%BA%8B%E4%BB%B67.png" alt=""></p><p>点击outC的时候，打印顺序是 :<br>capture1–&gt;capture2–&gt;target2–&gt;target1–&gt;bubble2–&gt;bubble1。<br>由于outC是我们触发事件的目标对象，在outC上注册的几个事件处理函数都属于DOM事件流中的目标阶段。对同一个绑定对象（这里是outC）而言，同处于目标阶段的多个函数的执行顺序：先注册的先执行，后注册的后执行。这就是上面我们说的，在目标对象（outC）上绑定的函数是采用捕获，还是采用冒泡，都没有什么关系，因为冒泡和捕获只是对父元素上的函数执行顺序有影响，对自己没有什么影响。<br>至此我们可以给出事件函数执行顺序的结论了：</p><blockquote><p><strong>捕获阶段的处理函数最先执行，其次是目标阶段的处理函数，最后是冒泡阶段的处理函数。目标阶段的处理函数如果有多个，则先注册的先执行，后注册的后执行。</strong></p></blockquote><h2 id="6-阻止事件冒泡和捕获"><a href="#6-阻止事件冒泡和捕获" class="headerlink" title="6. 阻止事件冒泡和捕获"></a>6. 阻止事件冒泡和捕获</h2><p>默认情况下，多个事件处理函数会按照DOM事件流模型中的顺序执行。如果子元素上发生某个事件，不需要执行父元素上注册的事件处理函数，那么我们可以停止捕获和冒泡，避免没有意义的函数调用。前面提到的5种事件绑定方式，都可以实现阻止事件的传播。由于第5种方式，是最推荐的做法。所以我们基于第5种方式，看看如何阻止事件的传播行为。<br>注意：<br>IE8以及IE8之前可以通过 window.event.cancelBubble=true阻止事件的继续传播；IE9+/FF/Chrome通过event.stopPropagation()阻止事件的继续传播。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E4%BA%8B%E4%BB%B68.png" alt=""></p><p>当点击outC的时候，打印出capture–&gt;target，不会打印出bubble。<br>因为当事件传播到outC上的处理函数时，通过stopPropagation阻止了事件的继续传播，所以不会继续传播到冒泡阶段。想要在哪个节点阻止传播，就在哪个节点的事件处理函数中添加stopPropagation，记得要传参。</p><h2 id="7-事件代理-事件委托"><a href="#7-事件代理-事件委托" class="headerlink" title="7. 事件代理/事件委托"></a>7. 事件代理/事件委托</h2><h4 id="7-1-概述："><a href="#7-1-概述：" class="headerlink" title="7.1 概述："></a>7.1 概述：</h4><p>事件委托又叫事件代理。JavaScript高级程序设计上讲:事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。我们可以用取快递的例子来理解这个东西。</p><p>假设：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台也会在收到寄给新员工的快递后核实并代为签收。</p><p>这里其实还有2层意思的：<br>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；<br>第二，新员工也是可以被前台代为签收的，即程序中新添加的dom节点也是有事件的。</p><h4 id="7-2-为什么要使用事件委托："><a href="#7-2-为什么要使用事件委托：" class="headerlink" title="7.2 为什么要使用事件委托："></a>7.2 为什么要使用事件委托：</h4><blockquote><p>简单来说，就是为了减少不必要的dom操作，优化性能。</p></blockquote><p>一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？</p><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p><p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了。比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢？如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，自然性能就会更好。</p><h4 id="7-3-事件委托的原理："><a href="#7-3-事件委托的原理：" class="headerlink" title="7.3 事件委托的原理："></a>7.3 事件委托的原理：</h4><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><h4 id="7-4-事件委托如何实现："><a href="#7-4-事件委托如何实现：" class="headerlink" title="7.4 事件委托如何实现："></a>7.4 事件委托如何实现：</h4><p>终于到了本文的核心部分了。在介绍事件委托的方法之前，我们先来看例一：<br>需求：不管点击哪个li，都能弹出123：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ul1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>333<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>444<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>aLi<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作:首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；<br>那么我们用事件委托的方式做又会怎么样呢？</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oUl<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们让父级ul监听点击事件，则不管是哪个li被点击————由于冒泡原理，事件最终都会冒泡到ul上，触发ul上的点击事件，弹出123。当然，这里当点击ul的时候，也是会触发的。</p><p>那么问题就来了，如果我想让<strong>事件代理的效果</strong>跟<strong>直接给某个指定的节点的事件效果</strong>一样怎么办？比如说只有点击li才会触发，不怕，我们有绝招：</p><blockquote><p>事件本身是一个对象，即Event对象，事件发生时该对象作为参数传给回调函数。而Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称之为事件源.</p></blockquote><p>也就是说，target可以表示为当前的事件直接操作的那个dom。当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>　　<span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　oUl<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">{</span>　　　　<span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>　　　　<span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>　　　　<span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>　 　　　　　　 <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　　　　  <span class="token function">alert</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　<span class="token punctuation">}</span>　　<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！<br>上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？请看例二：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>添加<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>remove<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>删除<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>move<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>移动<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>select<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>选择<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> Add <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> Remove <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"remove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> Move <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"move"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> Select <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"select"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Add<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'添加'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Remove<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'删除'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Move<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'移动'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Select<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'选择'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面实现的效果很简单，4个按钮对应4个不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oBox <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oBox<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span><span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLocaleLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'input'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token string">'add'</span> <span class="token punctuation">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'添加'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token string">'remove'</span> <span class="token punctuation">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'删除'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token string">'move'</span> <span class="token punctuation">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'移动'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token string">'select'</span> <span class="token punctuation">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'选择'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的</p><p>现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？</p><p>请看例三：<br>我们的需求是是：<br>①移入li，li变红，移出li，li变白<br>②对于点击按钮后新增的li节点，仍然具有该效果。</p><p>以下是正常的方法：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>添加<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ul1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>333<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>444<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//鼠标移入变红，移出变白</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>aLi<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onmouseover <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onmouseout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'#fff'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//添加新节点</span>oBtn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">var</span> oLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oLi<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去——这是因为li遍历这一动作发生在新增li这一动作之前，在那个时候已经确定了li的个数是4，因此只绑定了4个li。这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环封装在一个函数里，命名为mHover，如下：</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">function</span> mHover <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//鼠标移入变红，移出变白</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>aLi<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onmouseover <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onmouseout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'#fff'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>mHover <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加新节点</span>oBtn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">var</span> oLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oLi<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span><span class="token punctuation">;</span>mHover <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与上面方法不同的是，这个方法没有在新增li之前就为原有li绑定事件，而是在新增li后遍历所有的li（包括新增li），并一起绑定事件。虽然功能实现了，看着还挺好，但实际上无疑又增加了一个dom操作，在优化性能方面是不可取的，那么用事件委托的方式，能做到优化吗？</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//事件委托，添加的子元素也有事件</span>oUl<span class="token punctuation">.</span>onmouseover <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span><span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">"red"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>oUl<span class="token punctuation">.</span>onmouseout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span><span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">"#fff"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加新节点</span>oBtn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">var</span> oLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oLi<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，新添加的节点是带有事件效果的。根据事件冒泡原理，不管是原有li还是新增li，只要鼠标一移入li中就等同于鼠标移入ul中，自然会触发ul的鼠标移入事件，之后我们只要在ul的事件函数中定义相关行为就可以了。<br>我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了。这样可以大大的减少dom操作，这才是事件委托的精髓所在。</p><h4 id="7-5-总结："><a href="#7-5-总结：" class="headerlink" title="7.5 总结："></a>7.5 总结：</h4><p>那什么样的事件可以用事件委托，什么样的事件不可以用呢？<br>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。<br>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。<br>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，至于focus，blur之类的就更不用说了，本身就没有冒泡的特性，自然就不能用事件委托了。</p><h2 id="8-事件对象"><a href="#8-事件对象" class="headerlink" title="8 事件对象"></a>8 事件对象</h2><h4 id="8-1-认识事件对象"><a href="#8-1-认识事件对象" class="headerlink" title="8.1 认识事件对象"></a>8.1 认识事件对象</h4><p>事件在浏览器中是以对象的形式存在的，即event对象。触发一个事件，就会产生一个event对象，该对象包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。<br>例如：鼠标操作产生的event中会包含鼠标位置的信息；键盘操作产生的event中会包含与按下的键有关的信息。<br>所有浏览器都支持event对象，但支持方式不同，在DOM中event对象必须作为唯一的参数传给事件处理函数，在IE中event是window对象的一个属性。</p><h4 id="8-2-html事件处理程序中的事件对象"><a href="#8-2-html事件处理程序中的事件对象" class="headerlink" title="8.2 html事件处理程序中的事件对象"></a>8.2 html事件处理程序中的事件对象</h4><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>click<span class="token punctuation">"</span></span><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span> console.log(<span class="token punctuation">'</span>html事件处理程序<span class="token punctuation">'</span>+event.type)<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样会创建一个包含局部变量event的函数。可通过event直接访问事件对象。</p><h4 id="8-3-DOM中的事件对象"><a href="#8-3-DOM中的事件对象" class="headerlink" title="8.3 DOM中的事件对象"></a>8.3 DOM中的事件对象</h4><p>DOM0级和DOM2级事件处理程序都会把event作为参数传入。<br>参数命名：随便。习惯上用e，或者ev或者event。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"btn"</span> type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"click"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">var</span> btn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    btn<span class="token punctuation">.</span>onclick<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"DOM0 &amp; click"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//click    }</span>    btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"DOM2 &amp; click"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//click    },false);</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DOM中事件对象的重要属性和方法。<br><strong>属性：</strong></p><ul><li>type属性，用于获取事件类型</li><li>target属性，用于获取事件直接作用的目标（更具体target.nodeName）</li><li>currentTarget属性，用于获取事件实际绑定的目标</li></ul><p><strong>方法：</strong></p><ul><li>stopPropagation()方法,用于阻止事件冒泡</li><li>preventDefault()方法,阻止事件的默认行为 移动端用的多</li></ul><h4 id="8-4-IE中的事件对象"><a href="#8-4-IE中的事件对象" class="headerlink" title="8.4 IE中的事件对象"></a>8.4 IE中的事件对象</h4><p>第一种情况： 通过DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"btn"</span> type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"click"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">var</span> btn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token punctuation">.</span>onclick<span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> event<span class="token operator">=</span>window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//click</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种情况：通过attachEvent()添加的事件处理程序，event对象作为参数传入。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"btn"</span> type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"click"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">var</span> btn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">"onclick"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//click</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="font-weight:bolder">IE中事件对象的重要属性和方法:</span><br>属性：</p><ul><li>type属性，用于获取事件类型(一样)</li><li>srcElement属性，用于获取事件直接作用的目标（更具体srcElement.nodeName）</li><li>cancelBubble属性，用于阻止事件冒泡。IE中cancelBubble为属性而不是方法，true表示阻止冒泡。</li><li>returnValue属性，阻止事件的默认行为。false表示阻止事件的默认行为</li></ul><p>PS：targrt和srcElement的兼容性处理如下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//兼容性处理</span><span class="token keyword">function</span> <span class="token function">showMsg</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>event<span class="token operator">=</span>event<span class="token operator">||</span>window<span class="token punctuation">.</span>event<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//IE8以前必须通过window获取event，DOM中就是个简单的传参</span><span class="token keyword">var</span> ele<span class="token operator">=</span>event<span class="token punctuation">.</span>target <span class="token operator">||</span> event<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取目标元素，DOM中用target,IE中用srcElement</span><span class="token function">alert</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考链接</strong>：<br><a href="https://blog.csdn.net/aitangyong/article/details/43231111" target="_blank" rel="noopener">https://blog.csdn.net/aitangyong/article/details/43231111</a><br><a href="http://www.cnblogs.com/starof/p/4066381.html" target="_blank" rel="noopener">http://www.cnblogs.com/starof/p/4066381.html</a><br><a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/5616484.html</a><br><a href="http://www.cnblogs.com/starof/p/4077532.html" target="_blank" rel="noopener">http://www.cnblogs.com/starof/p/4077532.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件 </tag>
            
            <tag> dom事件流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量的两种命名方式</title>
      <link href="/2019/02/12/F-%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%91%BD%E5%90%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2019/02/12/F-%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%91%BD%E5%90%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><h2 id="一、驼峰命名法："><a href="#一、驼峰命名法：" class="headerlink" title="一、驼峰命名法："></a>一、驼峰命名法：</h2><p><br><strong>①全部小写</strong>：变量名中的每一个逻辑断点/每个单词都用下划线隔开。比如：print_employee_paychecks()；<br><strong>②大小写混合</strong>：<br>1）<em>小驼峰法</em>：<br>变量一般用小驼峰法标识。第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstName、myLastName<br>2）<em>大驼峰法/帕斯卡命名法（Upper Camel Case/pascal）</em>：<br>常用于类名，函数名，属性，命名空间。相比小驼峰法，大驼峰法把第一个单词的首字母也大写了。例如：DataBaseUser</p><h2 id="二、匈牙利命名法："><a href="#二、匈牙利命名法：" class="headerlink" title="二、匈牙利命名法："></a>二、匈牙利命名法：</h2><p><a id="more"></a></p><p>基本原则是：变量名=类型+对象描述。</p><p>匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。</p><p>匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等。这些符号可以多个同时使用，顺序是先m_（成员变量），再指针，再简单数据类型，再其他。</p><p>例如：m_lpszStr, 表示指向一个以0字符结尾的字符串的长指针成员变量。</p><p>匈牙利命名法中常用的小写字母的前缀：</p><p>前缀 类型<br>a – – — – – —— —————– 数组 (array)<br>b ———————————- 布尔值 (boolean)<br>by———————————- 字节 (byte)<br>c ———————————- 有符号字符 (char)<br>cb ————————– 无符号字符 (char Byte，没有多少人用)<br>cr ———————————- 颜色参考值 (colorRef)<br>fn ———————————- 函数 （function）<br>fl ———————————- 浮点（float）<br>h ———————————- 句柄（handle）<br>i ———————————- 整型 （int）<br>l ———————————- 长整型 (long Int)<br>lp———————————- 长指针（long Pointer）<br>m ———————————- 类的成员 （member）<br>n———————————- 短整型 (short Int)<br>np ———————————- 近指针（near Pointer）<br>o ———————————- 对象（object）<br>p ———————————- 指针（pointer）<br>re ——————————— 正则（regular expression）<br>s ———————————- 字符串型 （string）<br>sz ————————— 以null做结尾的字符串型 (String with Zero End)</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>null和undefined</title>
      <link href="/2019/02/12/F-null%E5%92%8Cundefined/"/>
      <url>/2019/02/12/F-null%E5%92%8Cundefined/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><h2 id="一-undefined在变量声明中的体现："><a href="#一-undefined在变量声明中的体现：" class="headerlink" title="一. undefined在变量声明中的体现："></a>一. undefined在变量声明中的体现：</h2><p>1）声明了、但是没有初始化的变量：</p><pre><code>var aa;alert(aa);</code></pre><p>浏览器会弹出窗口显示 <code>undefined</code>。因为对于使用了 <code>var</code> 声明但没有进行初始化定义的变量, 其值默认为 <code>undefined</code>.<br>2） 未声明的变量(1)：</p><pre><code>alert(aa);</code></pre><p>浏览器不会弹出任何东西. 因为 aa 是没有声明的变量。打开 chrome 浏览器的控制台会看到报错如下：<br><a id="more"></a><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/null%E5%92%8Cundefined%201.png" alt="在这里插入图片描述"></p><p>3）未声明的变量(2)：</p><pre><code>alert(typeof aa);</code></pre><p>浏览器会弹出窗口显示 undefined。对于没有声明的变量, 只能执行一种操作，即使用 typeof 操作符检验它的类型.。它的类型和声明了但没有进行初始化的变量的类型一样, 都是 undefined.</p><h2 id="二-null和undefined："><a href="#二-null和undefined：" class="headerlink" title="二. null和undefined："></a>二. null和undefined：</h2><pre><code>alert(undefined == null); // 返回 true</code></pre><p>对于undefined 和null 的相等性测试，返回 true,如上图。这是因为，undefined是由null派生而来的。但是，这两者差别很大，之所以要设置两个值，让我们从历史原因说起吧<br>1）历史原因：<br>1995年js诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象；其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。<br>因此，Brendan Eich又额外设计了一个undefined。</p><p>2）最初设计：<br>JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p><pre><code>Number(undefined)// NaN5 + undefined// NaN</code></pre><p>3）目前的用法：<br>但是，上面这样的区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。</p><p><strong>①null</strong></p><p>null是基本数据类型之一，值仅有一个，即为null。表示”空对象”(因此类型检测返回对象)，即如果有对象，就会是一个具体的对象，如果没对象，就是null。典型用法是：<br>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。</p><pre><code>Object.getPrototypeOf(Object.prototype) // nulltypeof null     // object</code></pre><p>如果定义的变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。<br>只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子：</p><pre><code>if(abc != null){//对abc执行某些操作}</code></pre><p><strong>②undefined</strong></p><p>undefined是基本数据类型之一，值仅有一个，即为undefined。表示”缺少值”(因此类型检测返回undefined)，即此处应该有一个值，但是还没有定义。典型用法是：<br>（1）变量被声明了，但没有赋值时，就等于undefined。<br>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>（3）对象没有赋值的属性，该属性的值为undefined。<br>（4）函数没有返回值时，默认返回undefined。</p><pre><code>var i;i // undefinedfunction f(x){console.log(x)}f() // undefinedvar o = new Object();o.p // undefinedvar x = f();var exp = undefined;8x // undefined</code></pre><p><strong>③如何检测某个变量是undefined：</strong></p><p>错误的用法：<br><code>if(abc==undefined)</code> // 正如上面所说，js规定用<code>==</code> 判断时，null和undefined是等同的</p><p>正确的用法：</p><pre><code>if (typeof(abc) `==` &quot;undefined&quot;)   </code></pre><p>或者最简单的办法：</p><pre><code>if(abc===undefined)</code></pre><p>注意！！！ type的用法有运算符形式和函数形式，即if (typeof(abc) <code>==</code> “undefined”) 和 if (typeof abc <code>==</code> “undefined”) 效果是一样的。另外，由于typeof会返回诸如”number”的字符串形式的结果，因此==的右操作数应注意加双引号表示字符串。</p><p><strong>④如何检测某个变量是null：</strong></p><p>错误的用法：</p><p>1、<code>if(abc == null)</code><br>// 解释同上。不过：要判断abc是 null 或者 undefined 时可使用本法。<br>2、<code>if ( !abc)</code><br>// 这个的原理是：abc为假值，则 ! abc为真值，条件成立。然而，假值也可能是undefined，0 或 false。不过：要判断 abc是null、undefined、0 或者false 时可使用本法。</p><p>3、<code>if(typeof abc == &quot;null&quot;)</code><br>// 为了向下兼容，abc 为 null 时，typeof null 总返回 object，所以不能这样判断。</p><p>4、 <code>if ( isNull (abc) )</code><br>// VBScript 中有 IsNull 这个函数，但 JavaScript 中没有。</p><p>=============================================================================</p><p>正确的方法：<br>1、 <code>if (! abc &amp;&amp; typeof abc != &quot;undefined&quot; &amp;&amp; abc != 0)</code></p><p>// 这个的原理是：如果！abc 成立，则 abc 为假值，则 abc 要么是undefined，0，false或者null 。typeof abc!= “undefined” 排除了 undefined；exp != 0 排除了0 和 false （0= =false，0= =0）。所以，abc一定是剩下的null。</p><p>2、最简单的方法：</p><pre><code> if (abc=== null)</code></pre><p>尽管如此，我们在 DOM 应用中，一般只需要用 (! abc) 来判断就可以了，因为 DOM 应用中，可能返回 null，可能返回 undefined，如果具体判断 null 还是 undefined 会使程序过于复杂。</p><h2 id="三-测试对象是否存在："><a href="#三-测试对象是否存在：" class="headerlink" title="三. 测试对象是否存在："></a>三. 测试对象是否存在：</h2><p>在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法。<br>对象只有被定义才有可能为 null，否则为 undefined。因此，如果我们想测试对象是否存在，必须先检测对象是否已定义。<br>因此，这是错误的：<br>if (abc !== null &amp;&amp; typeof abc !== “undefined”)<br>这是正确的：</p><pre><code>if (typeof  abc !== &quot;undefined&quot; &amp;&amp; abc!== null)</code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型和继承</title>
      <link href="/2019/02/12/F-%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/02/12/F-%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/inheritance.png" alt=""><br><a id="more"></a><br>这几天在掘金上阅读到了一篇关于原型的文章，角度较之前看到的几篇博客都不一样，顿时感觉我对于原型的知识点还没有完全吃透。鉴于本篇文章很可能会进行不定期的修订和拓展，故在此附上更新日志，以简单记录我在学习上的认知更新。</p><p>2019.2.24</p><ul><li>js继承的几种实现方式</li></ul><p>2019.2.19</p><ul><li>完善关于constructor属性的介绍</li><li>比对new和Object.create()的本质区别</li><li>纠正隐式原型的错误写法（之前没看仔细，一直写错，今天报错才发现）</li></ul><h2 id="1-创建对象的方法"><a href="#1-创建对象的方法" class="headerlink" title="1.创建对象的方法"></a>1.创建对象的方法</h2><p>在了解原型链之前，首先先了解一下创建对象的几种方式，为后面做个铺垫。介绍以下三种。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B1.png" alt="在这里插入图片描述"></p><p>代码：</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">// 第一种方式：字面量</span>    <span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'o1'</span><span class="token punctuation">}</span>    <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'o2'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 第二种方式：构造函数</span>    <span class="token keyword">var</span> M <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">var</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token string">'o3'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 第三种方式：Object.create</span>    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'p'</span><span class="token punctuation">}</span>    <span class="token keyword">var</span> o4 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o3<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o4<span class="token punctuation">)</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B2.png" alt="在这里插入图片描述"></p><h2 id="2-构造函数、实例、原型、原型链"><a href="#2-构造函数、实例、原型、原型链" class="headerlink" title="2.构造函数、实例、原型、原型链"></a>2.构造函数、实例、原型、原型链</h2><p>先来一张图简单了解一下<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B3.png" alt="在这里插入图片描述"></p><h3 id="2-1-什么是原型？实例？构造函数？"><a href="#2-1-什么是原型？实例？构造函数？" class="headerlink" title="2.1  什么是原型？实例？构造函数？"></a>2.1 什么是原型？实例？构造函数？</h3><p>首先是代码</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token keyword">var</span> M <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">var</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token string">'o3'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>实例就是通过new一个构造函数生成的对象。在本例中o3就是实例，M就是构造函数。</li><li>每个函数都有prorotype属性，每个对象都有<strong>proto</strong> 属性（隐式原型,读作dunder prototype）</li><li>从上图中可以知道，实例的<strong>protpo</strong>指向原型对象。</li><li>从上图中可以知道，实例的构造函数的prototype也是指向原型对象。</li><li><p>原型对象的construor指向构造函数。</p><p>再来通过下面这个图来理解一下<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B4.png" alt="在这里插入图片描述"></p></li></ul><h3 id="2-2-什么是原型链？"><a href="#2-2-什么是原型链？" class="headerlink" title="2.2 什么是原型链？"></a>2.2 什么是原型链？</h3><p>简单理解就是原型组成的链，实例的<strong>proto</strong>就是原型，而原型也是一个对象，也有<strong>proto</strong>属性，它会指向另一个原型…………就这样可以一直通过<strong>proto</strong>向上找，这就是原型链，当向上找找到Object这个构造函数的原型（即null）时，这条原型链就算到头了。也就是说，原型链的尽头是null 。</p><h3 id="2-3-原型作用何在？"><a href="#2-3-原型作用何在？" class="headerlink" title="2.3 原型作用何在？"></a>2.3 原型作用何在？</h3><p>原型的存在是为了帮助实现继承。我们先来思考一个问题：假如现在通过一个构造函数创建了多个实例，想要给它们添加同一个方法，该怎么做呢？</p><p>1.给每个实例去添加。太过麻烦，并不是一个明智的选择；<br>2.在构造函数的内部添加方法。这样做的话在每次用构造函数创建实例时都会大量产生方法的副本，这些方法副本功能一样，实际却是不同的。这会影响性能，且不利于代码复用；<br>3 .这时，就该用上原型了。只要给构造函数的原型添加一个方法，那么构造函数的所有实例便都有了这个方法。接着上面的例子继续演示：</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token keyword">function</span> <span class="token function">M</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">var</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token string">'o3'</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> o5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token string">'o5'</span><span class="token punctuation">)</span>    M<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say<span class="token operator">=</span><span class="token function">furnction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>     o3<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     o5<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o3<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>o5<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//  true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B5.1.png" alt="在这里插入图片描述"><br>按照JS引擎的分析方式，在访问一个实例的方法时，首先在实例本身中找，如果找到了就说明其构造函数先前是有定义这个方法的(this)；如果没找到就去实例的原型中找，还没找到就再沿着原型链往上找，直到找到。当然，不止方法，属性也是可以继承自原型的。</p><p>那么怎么判断属性是实例本身具有的还是继承的？对实例用 hasOwnProperty( )方法即可。那么实例为何有这个方法？同样是继承来的。 由于所有的对象的原型链都会找到追溯到Object.prototype，因此所有的对象都会有Object.prototype的方法，其中就包括 hasOwnProperty( )方法 。</p><h3 id="2-4-访问原型"><a href="#2-4-访问原型" class="headerlink" title="2.4  访问原型"></a>2.4 访问原型</h3><p>可以用<code>obj.prototype</code>，<code>obj.__proto__</code>，或者<code>obj.getPrototypeOf()</code>。这里重点说后面两个。<br><code>__proto__</code>属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，更不推荐通过这种方式修改实例的原型，除了标准化的原因之外还有性能问题。<br>为了更好的支持，推荐使用 Object.getPrototypeOf()。</p><h3 id="2-5-原型、构造函数、实例、Function、Object的关系"><a href="#2-5-原型、构造函数、实例、Function、Object的关系" class="headerlink" title="2.5  原型、构造函数、实例、Function、Object的关系"></a>2.5 原型、构造函数、实例、Function、Object的关系</h3><p>前面我们给出了一幅图简单梳理了一下关系，但想追本溯源，光靠那张图是不够的。下面我们给出另一张更详细的图。请先记住，Function和Object 是特殊的构造函数。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B5.2.png" alt="在这里插入图片描述"></p><p>首先从构造函数Foo（或任意一个普通构造函数）出发，它创建了实例f1和f2等，而实例的<code>__proto__</code>指向了Foo.prototype这个原型，该原型的<code>__proto__</code>向上再次指向其他构造函数的原型，一直向上，最终指向Object这个构造函数的原型，即Object.prototype。而Object.prototype的 <code>__proto__</code>指向了null，这时我们说到达了原型链的终点null。回过头看，该原型又被Object构造函数的实例的<code>__proto__</code>指向，而函数的实例就是我们通常通过字面量创建的那些对象，也即是图中的o1，o2。那么，普通构造函数（这里指Foo）和特殊构造函数Object又来自于哪里？答案是，来自于另一个特殊构造函数Function。</p><p>实际上，所有的函数都是由Function函数创建的实例，而构造函数当然也是函数，所以也来自于Function。从图中可以看到，实例Foo的<code>__proto__</code>和实例Object的<code>__proto__</code> 都指向了 Function的prototype，即Function.prototype 。</p><p>既然所有的函数都是由Function函数创建的实例，那么Function又是怎么来的？答案是，Function自己创造了自己。它既作为创造其他实例函数的构造函数而存在，也作为实例函数而存在，所以可以在图上看到<span style="background-color:#fffa7d">作为实例的Function</span>的<code>__proto__</code> 指向了<span style="background-color:#fffa7d">作为构造函数的Function</span>的prototype,</p><p>即<code>Function.__proto__ ===Function.prototype</code></p><p>正如我们前面所说的，Function.prototype的<code>__proto__</code>也像其他构造函数.prototype的<code>__proto__</code>一样，最终指向Object.porototype，而Object.porototype的<code>__proto__</code>最终指向null，原型链结束。</p><p>可以发现，经过简单梳理，这几者的关系没有我们想象的那么复杂。一句话，看懂这幅图就够了。</p><h2 id="3-instanceof的原理"><a href="#3-instanceof的原理" class="headerlink" title="3.instanceof的原理"></a>3.instanceof的原理</h2><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B6.png" alt="在这里插入图片描述"><br>instanceof 沿着 <span style="background:#fffa7d">实例—&gt; <strong>proto</strong> —&gt; ……..</span> 这条线来找，同时沿着<span style="background:#fffa7d"> 实例的构造函数的prototype—&gt;<strong>proto</strong> —&gt; ……..</span> 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。如下图，很显然 f1 instanceof Object 成立<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B7.png" alt="在这里插入图片描述"></p><p>注意：正因为 instanceof 的原理如上所述，因此实例的instanceof在比较的时候，与原型链上向上找的的构造函数相比都是true。</p><p>继续上面的代码<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B8.png" alt="在这里插入图片描述"></p><p>那怎么判断实例是由哪个构造函数生成的呢？这时候就要用到constructor了。<br>实例的原型的构造函数， obj.<strong>proto</strong>.constructor<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B9.png" alt="在这里插入图片描述"></p><h2 id="4-constructor属性"><a href="#4-constructor属性" class="headerlink" title="4.constructor属性"></a>4.constructor属性</h2><h3 id="4-1-定义："><a href="#4-1-定义：" class="headerlink" title="4.1 定义："></a>4.1 定义：</h3><p>构造函数的prototype属性指向它的原型对象，在原型对象中有一个constructor属性，指向该构造函数。值类型（除了null和undefined，这两者不具有这个属性）的constructor是只读的，不可修改，引用类型的constructor是可修改的，例如5.2提到的修复指向。</p><h3 id="4-2-修复constructor的指向："><a href="#4-2-修复constructor的指向：" class="headerlink" title="4.2 修复constructor的指向："></a>4.2 修复constructor的指向：</h3><p>为了实现从父类到子类方法的继承，一般会重写构造函数的原型，如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span>Student<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这将使得实例student具有构造函数Person的方法，但同时也会导致constructor的指向出现问题，造成继承链的紊乱，因此为了修复这个错误指向，需要显式指定<code>obj.prototype.constructor = obj</code> 。拿下面例子说明：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B11.png" alt="在这里插入图片描述">未重写原型对象之前，实例化了一个dog；第6行重写了原型对象，使其指向另一个实例（等式右边是字面量，因此可以看作是由Object构造函数实例化出来的一个对象），之后实例化了一个cat。</p><p>查看dog和cat的constructor：</p><pre class="line-numbers language-js"><code class="language-js">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//function Animal()</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//function Object()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">    dog<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//wan</span>    cat<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//miao</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先，构造函数没有constructor属性，这导致了它构造的实例也没有constructor属性，所以，实例将沿着原型链(注意，构造函数不算在原型链里)向上追溯对应的原型对象的constructor属性。dog.constructor可以指向原来的构造函数，说明原来的原型对象还存在；而cat.constructor 指向另一个构造函数，是因为Animal( )的原型被重写，并且作为Object( )构造函数的一个实例而存在，那么由cat实例出发，向上进行constructor属性追溯的时候，最终会找到Object( ) 构造函数。同样的，正因为原型重写前后创建的实例分别对应了初始原型和新的原型，所以我们可以对旧实例调用初始原型的方法、对新实例调用新的原型的方法，放在本例子中，就表现为dog依然可以调用say( )方法发出wan，而cat也可以调用say( )方法发出miao 。</p><p><strong>总结：</strong><br>重写原型对象之后，会切断构造函数与最初原型之间的连接，使新构造的实例对象的原型指向重写的原型，而先前构造的实例对象的原型还是指向最初原型。在这种情况下，先前的实例对象可以使用最初原型的方法，新的实例对象可以使用重写的原型的方法。</p><h2 id="5-new和Object-create-的区别："><a href="#5-new和Object-create-的区别：" class="headerlink" title="5. new和Object.create()  的区别："></a>5. new和Object.create() 的区别：</h2><p>这里，让我们回到文章开头提到的创建对象的三种方式。重点介绍后两种。</p><h3 id="5-1-new"><a href="#5-1-new" class="headerlink" title="5.1 new"></a>5.1 new</h3><p>new一个构造函数时，实际发生的过程是：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>o<span class="token punctuation">.</span>__proto__<span class="token operator">=</span>M<span class="token punctuation">.</span>prototypeM<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>第一步，创建一个空对象o；</li><li>第二步，令空对象的<strong>proto</strong>指向构造函数M的prototype；</li><li>第三步，令构造函数M中的this指针指向o，使得o具有M的属性或方法，因为M无返回值或返回的不是对象，所以最后会返回o 。</li></ul><p>在这里要注意下面这个坑：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> Base <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Base<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>构造函数就好比印钞机，而它创建的实例就好比钞票。构造函数中的this.xxxx都是为了实例而准备的属性和方法，这些this在构造函数内，但并不指向构造函数，而是在new构造函数执行的时候转而指向新实例。构造函数自身没有这些属性和方法，像上面那样调用Base的a属性是会报错的，Base根本没有a属性。</p><h4 id="5-1-1-手动实现new运算符"><a href="#5-1-1-手动实现new运算符" class="headerlink" title="5.1.1 手动实现new运算符"></a>5.1.1 手动实现new运算符</h4><p>下面根据new的工作原理通过代码手动实现一下new运算符</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token keyword">var</span> new2 <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> 　　 <span class="token comment" spellcheck="true">//创建对象</span>    <span class="token keyword">var</span> k <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　　　　　　<span class="token comment" spellcheck="true">//改变this指向，把结果付给k</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> k <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>　　　　　　　<span class="token comment" spellcheck="true">//判断k的类型是不是对象</span>    <span class="token keyword">return</span> k<span class="token punctuation">;</span>　　　　　　　　　　　　　　 <span class="token comment" spellcheck="true">//是，返回k</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> o<span class="token punctuation">;</span>　　　　　　　　　　　　　　 <span class="token comment" spellcheck="true">//不是，返回构造函数的执行结果</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/%E5%8E%9F%E5%9E%8B10.png" alt="在这里插入图片描述"></p><p>经过上图一系列折腾，不难看出，我们手动编写的new2和new运算符的作用是一样的。</p><h3 id="5-2-Object-create"><a href="#5-2-Object-create" class="headerlink" title="5.2 Object.create()"></a>5.2 Object.create()</h3><p>Object.create()方法创建一个新对象（实例），并使用现有的对象(参数)作为新创建的对象的<strong>proto</strong> 也就是说，这个方法可以起到指定原型的作用。</p><p>执行Object.create() 时，实际发生的过程是：</p><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>create <span class="token operator">=</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> F <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一步，创建空的构造函数；</li><li><p>第二步，令构造函数的prototype指向传入的对象；</p><blockquote><p>实际上也相当于 令新实例的<strong>proto</strong>指向传入的对象</p></blockquote></li><li><p>第三步，实例化一个对象并返回</p></li></ul><p>这里，如果Object.create()接受的参数是null，即<code>var obj = Object.create(null)</code>,则obj是真正意义上的空对象，不具有hasOwnProperty(),toString()等方法或属性。</p><h2 id="6-js实现父类到子类的继承的7种方式"><a href="#6-js实现父类到子类的继承的7种方式" class="headerlink" title="6 js实现父类到子类的继承的7种方式"></a>6 js实现父类到子类的继承的7种方式</h2><h3 id="6-1-原型链继承"><a href="#6-1-原型链继承" class="headerlink" title="6.1.原型链继承"></a>6.1.原型链继承</h3><ul><li>核心：重写子类原型，代之以父类的实例<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>Worker<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>缺点：<br>创建子类实例时，无法向父类构造函数传参；<br>对一个子类实例的引用类型属性的操作将会影响其他子类实例，即引用属性共享<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> worker1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> worker2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token function">alert</span><span class="token punctuation">(</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span class="token function">alert</span><span class="token punctuation">(</span>worker2<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="6-2-借用构造函数继承"><a href="#6-2-借用构造函数继承" class="headerlink" title="6.2.借用构造函数继承"></a>6.2.借用构造函数继承</h3><p>又称为冒充继承、经典继承、伪造对象继承</p><ul><li><p>核心：使用父类的构造函数来增强子类实例，等同于复制父类的实例属性给子类（不使用原型）</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Worker</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>  Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> worker1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> worker2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token function">alert</span><span class="token punctuation">(</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span class="token function">alert</span><span class="token punctuation">(</span>worker2<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//[6,12,24]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>缺点：虽然消除了原型链继承的缺点，但是不利于实现函数复用，每个子类都有父类实例函数的副本，影响性能。</p></li></ul><h3 id="6-3-组合继承"><a href="#6-3-组合继承" class="headerlink" title="6.3.组合继承"></a>6.3.组合继承</h3><ul><li>核心：原型链继承+借用构造函数继承。即使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shout<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Ahhhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">...</span>其余新增属性。。。<span class="token punctuation">}</span>Worker<span class="token punctuation">.</span>prototype<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Worker<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token operator">=</span>Worker  <span class="token comment" spellcheck="true">//别忘记修正constructor的指向</span><span class="token keyword">var</span> worker1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺点：很常用的继承方式，但也有缺点，就是代码第11、13行合计调用了两次父类函数，造成了不必要的消耗。</li></ul><h3 id="6-4-原型式继承"><a href="#6-4-原型式继承" class="headerlink" title="6.4.原型式继承"></a>6.4.原型式继承</h3><p>用到了object()，规范化之后即为Object.create()</p><ul><li>核心：利用Object.create()对传入其中的对象进行浅拷贝</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>    age<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">var</span> worker1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token keyword">var</span> worker2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺点：和原型链继承一样，存在引用属性共享的问题。</li></ul><pre class="line-numbers language-js"><code class="language-js">worker1<span class="token punctuation">.</span>age<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token function">alert</span><span class="token punctuation">(</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span class="token function">alert</span><span class="token punctuation">(</span>worker2<span class="token punctuation">.</span>age<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>原因很好解释，因为worker1无age属性，因此向它的原型查找，它的原型恰好就是Person对象。因此实际上是在改动Person的age属性。</p><h3 id="6-5-寄生继承"><a href="#6-5-寄生继承" class="headerlink" title="6.5.寄生继承"></a>6.5.寄生继承</h3><ul><li>核心：创建一个函数用于封装继承的过程，在函数内部增强对象，最后将其返回<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>  age<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> worker0 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">;</span>  worker0<span class="token punctuation">.</span>shout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Ahhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> worker0<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> worker1 <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span>worker1<span class="token punctuation">.</span><span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>缺点：和原型链继承一样，存在引用属性共享的问题;和经典继承一样，无法实现函数复用</li></ul><h3 id="6-6-寄生组合继承"><a href="#6-6-寄生组合继承" class="headerlink" title="6.6.寄生组合继承"></a>6.6.寄生组合继承</h3><ul><li>核心：结合寄生式继承和组合继承的优点，避免为了指定子类的原型而二次调用父类的构造函数</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//封装函数。功能：在避免二次调用父类函数的前提下令子类原型指向父类实例</span><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span>subType<span class="token punctuation">,</span> superType<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">var</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>      subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>    subType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//修正constructor的指向</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 父类初始化实例属性和原型属性</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Ahhhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><span class="token keyword">function</span> <span class="token function">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 调用函数，令子类原型指向父类实例</span><span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Worker<span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>优点：基本完美的继承方式，无任何缺点，也是目前库实现的方式。</li></ul><h3 id="6-7-extends类继承"><a href="#6-7-extends类继承" class="headerlink" title="6.7.extends类继承"></a>6.7.extends类继承</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 父类</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Ahhhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//子类继承父类</span><span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"I am working"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>解释：可以看作是ES6新增的语法糖，使得js中继承的写法更趋向于传统的面向对象语言。super是关键字，代表父类构造函数，只有在子类的构造函数中调用super()函数，才能让父类构造出this给子类去丰富。</li></ul><p>参考：<br><a href="http://www.cnblogs.com/wangfupeng1988/p/3978131.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangfupeng1988/p/3978131.html</a><br><a href="https://www.cnblogs.com/chengzp/p/prototype.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengzp/p/prototype.html</a><br><a href="https://juejin.im/post/5c6a9c10f265da2db87b98f3" target="_blank" rel="noopener">https://juejin.im/post/5c6a9c10f265da2db87b98f3</a><br><a href="https://www.cnblogs.com/94pm/p/9113434.html" target="_blank" rel="noopener">https://www.cnblogs.com/94pm/p/9113434.html</a><br><a href="https://segmentfault.com/a/1190000016891009" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016891009</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> 原型 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery AJAX load()方法中代码执行顺序的问题</title>
      <link href="/2019/02/12/F-jQuery%20AJAX%20load()%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/02/12/F-jQuery%20AJAX%20load()%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>问题来源于菜鸟教程介绍jq load() 方法时用的一个实例：<br><strong>js：</strong></p><pre><code>$(&quot;button&quot;).click(function(){  $(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){    if(statusTxt==&quot;success&quot;)      alert(&quot;外部内容加载成功!&quot;);    if(statusTxt==&quot;error&quot;)      alert(&quot;Error: &quot;+xhr.status+&quot;: &quot;+xhr.statusText);  });});</code></pre><p><strong>html：</strong></p><pre><code>&lt;div id=&quot;div1&quot;&gt;&lt;h2&gt;使用 jQuery AJAX 修改该文本&lt;/h2&gt;&lt;/div&gt;&lt;button&gt;获取外部内容&lt;/button&gt;</code></pre><p>这里作为load方法参数的函数是一个回调函数。什么是回调函数呢？我们先来看看回调的英文定义：</p><a id="more"></a><p>A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。字面上的理解，回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。那么根据这个解释，这段代码应该是先执行load(“demo_test.txt”) 加载外部内容，之后再执行回调函数弹出alert。但是实际运行后发现和预想的不一样：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/1.png" alt="在这里插入图片描述"><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/2.png" alt="在这里插入图片描述"><br>从结果来看，是先弹出alert再改变文本内容。那么，为什么会这样呢？难道上面的说法有误？为了进一步验证，修改代码如下：</p><pre><code> $(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){ alert(responseTxt); if(statusTxt==&quot;success&quot;){</code></pre><p>运行：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/3.png" alt="在这里插入图片描述"><br>很明显文本内容已经改变，说明前面关于回调函数最后执行的说法是没问题的。接着猜想，之所以先弹出alert再改变文本内容，可能是因为必须等回调函数执行完后才能把文本渲染到浏览器上。<br>为了进一步验证，修改代码如下：</p><pre><code>$(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){    if(statusTxt==&quot;success&quot;){          debugger；           console.log(&quot;1&quot;);      }</code></pre><p>运行：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/4.png" alt="在这里插入图片描述"><br>控制台中没有打印出1，且程序中断，说明此时回调函数还在执行当中，但是文本内容却已经改变了。这说明上面的猜想错误—–即文本渲染到浏览器上不需要等到回调函数执行结束。<br>但是，那只是一般情况！！问题就在于，<strong>alert是可以阻塞浏览器的渲染工作的！</strong></p><p>重新运行最初的代码，可以看到还是先弹出alert，文本没变，但是这时候点开控制台的elements，可以看到图中红框显示这时候文本的内容其实已经改变了。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/5.png" alt="在这里插入图片描述"><br>虽然文本内容看上去不变——但是实际情况是文本内容已经改变了，也就是load()方法已经生效了，只是alert阻塞了浏览器将它渲染出来。<br>在这里还要注意，alert可以阻塞浏览器的渲染，而debugger是没办法的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AJAX </tag>
            
            <tag> 浏览器渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英伦摇滚入门：20支英国摇滚乐队</title>
      <link href="/2019/02/11/M-%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/"/>
      <url>/2019/02/11/M-%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>之前看到的一篇关于英国摇滚乐队的总结。还挺好的，不全是英伦摇滚。排名不分先后，当然，我还是偏爱Oasis。</p><h4 id="1-The-Beatles（披头士乐队-甲壳虫乐队）"><a href="#1-The-Beatles（披头士乐队-甲壳虫乐队）" class="headerlink" title="1. The Beatles（披头士乐队/甲壳虫乐队）"></a>1. The Beatles（披头士乐队/甲壳虫乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_1.jpg" alt=""><br><a id="more"></a><br>这支才华横溢的英国乐队就不用多说了，几乎是英国摇滚的代名词，屹立半个世纪不倒，他们的作品现在还传颂世界。The Beatles（披头士乐队）虽然早已不复存在，但是他们却奠定了英式摇滚的基本基调，在国际音乐界享有盛誉。他们的贵族式的优雅反击直击摇滚的核心精神：为普通人发出声音和呐喊。爱和自由、反战是披头士永恒的创作主题。披头士有两位灵魂人物，一位是John Lennon（约翰·列侬），一位是James Paul McCartney（保罗·麦卡特尼）。喜欢这支乐队的朋友可以看看乐评《最爱那一世的疯狂——“披头士热”下的英伦风情》<br>经典专辑：《Sergeant Pepper’s Lonely Hearts Club Band》、《Abbey Road》、《Let It Be》、《Rubber Soul》、《Help!》</p><h4 id="2-The-Rolling-Stones（滚石乐队）"><a href="#2-The-Rolling-Stones（滚石乐队）" class="headerlink" title="2. The Rolling Stones（滚石乐队）"></a>2. The Rolling Stones（滚石乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_2.jpg" alt=""><br>The Rolling Stones（滚石乐队）是一支非常长寿的英国摇滚乐队，一直活跃在英国的摇滚乐坛，他们和披头士分庭抗礼，代表着两种不同的摇滚理念：披头士是温和的、优雅的，而滚石则是纯粹的、爆裂性的。滚石乐队成员的平均年龄已经超过了70岁，堪称英国摇滚界的活国宝，他们身先士卒证明了什么叫“老骥伏枥，志在千里”。几个“老头子”处处践行着不服老的摇滚心态，依然能够在舞台上大放光彩，不断推出新作，这才是真正的摇滚精神！绝对的硬摇滚，粗放豪气的摇滚范儿，祝福这支长寿的乐队！<br>经典专辑：《Let It Bleed》、《Beggars Banquet》、《Exile On Main Street》</p><h4 id="3-The-Who（谁人乐队）"><a href="#3-The-Who（谁人乐队）" class="headerlink" title="3. The Who（谁人乐队）"></a>3. The Who（谁人乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_3.jpg" alt=""><br>作为“布兰顿之声”的The Who（谁人乐队），他们代表着反叛与反主流的音乐风格，他们是MOD文化的代言人，四人个性放荡不羁，反叛而激进，为青年而歌，为底层人民而歌。正是The who发明了摇滚乐的砸琴砸摔鼓的表演风格，他们是纯粹硬摇乐队，是反叛的象征，他们的舞台表演风格为后世许多的摇滚乐队所模仿。The Who创造了许多的经典歌曲，至今无人能够超越。<br>经典专辑：《Who’s Next》、《Tommy》、《My Generation》</p><h4 id="4-The-Police（警察乐队）"><a href="#4-The-Police（警察乐队）" class="headerlink" title="4. The Police（警察乐队）"></a>4. The Police（警察乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_4.jpg" alt=""><br>想听慢摇风格的乐迷看过来，这支乐队非常具有传奇色彩，他们靠着借贷创作的第一张专辑就大卖一万多张。他们的乐队风格有一种华丽的英式抒情的感觉，感觉主唱的爆破音特别重，他们的歌曲特别有感染力，另外主唱Sting还会唱西班牙语，非常多才多艺。这支乐队只有三个人，但是曾经获得了六次格莱美奖，乐队在义演散场之后宣布告别，但是灵魂人物Sting现在还活跃在英国乐坛之上，还多次斩获格莱美。<br>经典专辑：《Regatta de Blanc》、《Zenyatta Mondatta》、《Wrapped Around Your Finger》</p><h4 id="5-Pink-Floyd（平克·弗洛伊德）"><a href="#5-Pink-Floyd（平克·弗洛伊德）" class="headerlink" title="5. Pink Floyd（平克·弗洛伊德）"></a>5. Pink Floyd（平克·弗洛伊德）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_5.jpg" alt=""><br>大PF是必须要说的，促使我去了解英国摇滚乐队的就是披头士和Pink Floyd（平克·弗洛伊德）了，PF不算是那种非常有盛誉的那种乐队，但是我就是喜欢。他们的音乐充满哲学的思辨气质和浪漫主义的想象力，专辑的艺术感极强，尤其是他们开创的太空迷幻摇滚，简直是致幻的LSD，令人沉醉其中不能自拔。他们在音乐技术上的突破和对迷幻摇滚新领域的开辟，都在音乐史上不可被磨灭，这支乐队有一支长达23分钟的神奇的单曲——《Echoes》，号称一曲走天下，他们的《月之暗面》（The Dark Side of The Moon）和《迷墙》（The Wall）两张专辑永垂不朽。某种程度上来说，我甚至觉得他们是一支被低估了的乐队。<br>经典专辑：《The Wall》、《The Dark Side of the Moon》、《Ummagumma》</p><h4 id="6-Sex-Pistols（性手枪乐队）"><a href="#6-Sex-Pistols（性手枪乐队）" class="headerlink" title="6. Sex Pistols（性手枪乐队）"></a>6. Sex Pistols（性手枪乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_6.jpg" alt=""><br>要说到英国的朋克摇滚，就必须要说到Sex Pistols，在1976年，性手枪参加了伦敦牛津The 100俱乐部举办的朋克音乐节，至今这个节日还被认为是朋克文化的发源地。这是一支真正的朋克乐队，有人甚至评价道：“性手枪之后再无朋克”，如果你去听了他们的音乐，就会发现这是真的。他们的音乐充满了黑色幽默和调侃，歇斯底里的反叛甚至是下流的感觉，但这就是真正的朋克精神——彻底的毁灭与自我毁灭。他们的歌曾经登上了BBC排行榜榜首，让全英国人民都为朋克摇旗呼喊，让朋克文化高涨兴盛。但是这支乐队好景不长，他们连换了三个唱片公司，但乐队成员相继离开，最终没落令人十分惋惜。<br>经典专辑：《Jubilee》、《Never Mind the Bollocks Here’s the Sex Pistols》</p><h4 id="7-The-Clash（碰撞乐队-冲击乐队-冲撞乐队）"><a href="#7-The-Clash（碰撞乐队-冲击乐队-冲撞乐队）" class="headerlink" title="7. The Clash（碰撞乐队/冲击乐队/冲撞乐队）"></a>7. The Clash（碰撞乐队/冲击乐队/冲撞乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_7.jpg" alt=""><br>与性手枪相比，The Clash并不算是真正的朋克乐队，因为他们后期逐渐商业化，但是The Clash前期对朋克摇滚做出了巨大的贡献。他们的首张同名专辑就一炮成名，被封为朋克圣典。但是后期的碰撞乐队逐渐吸收了许多的流行摇滚的元素，他们的MTV商业运作得很好。The Clash与Sex Pistols一起铸就了朋克乐队的高峰。碰撞关注社会底层人民的生活状况，他们的歌曲里面充满了对失业、种族歧视和黑帮犯罪势力的反抗和控诉，而且碰撞乐队在美国市场上还比较成功，让英国朋克摇滚名声在外。<br>经典专辑：《London Calling》、《The Clash》、《Black Market Clash》</p><h4 id="8-Iron-Maiden（铁娘子乐队）"><a href="#8-Iron-Maiden（铁娘子乐队）" class="headerlink" title="8. Iron Maiden（铁娘子乐队）"></a>8. Iron Maiden（铁娘子乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_8.jpg" alt=""><br>重金属恶魔的铁娘子乐队！生猛的铁娘子！牛逼的铁娘子！正是他们开启了英国的重金属浪潮。他们是一支霸气的重金属乐队，乐队几经分合，但是做了很多的音乐新领域的尝试，他们做了很多摇滚器乐实验，奠定了铁娘子在重金属领域中的地位。Iron Maiden的曲风非常硬朗，听得人情绪高涨，不自觉地High，主唱的声音简直是绝对的歇斯底里，他们的吉他行云流水，贝斯出神入化，想感受下重金属激情的迷妹一定要去听一下，没听过他们你都不好意思说你听过重金属。<br>经典专辑：《Killers》、《Piece Of Mind》、《Iron Maiden》、《Number of the Beast》</p><h4 id="9-Def-Leppard（威豹乐队）"><a href="#9-Def-Leppard（威豹乐队）" class="headerlink" title="9. Def Leppard（威豹乐队）"></a>9. Def Leppard（威豹乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_9.jpg" alt=""><br>威豹也是英国重金属新浪潮中一支非常重要的乐队，这支乐队70年代末期组建，80年代成名，他们在硬摇滚上造诣很高。80-90年代期间是他们商业最成功的阶段，在美国都具有广泛的影响力。威豹也不是那种纯粹的重金属乐队，他们的情歌非常的好听感人，主唱Joe Elliott的声音是略带沧桑的沙哑，这些摇滚汉子唱起情歌分分钟秒杀你的心灵。另外乐队的长发造型很酷炫，而且他们是双吉他演奏，节奏非常动人优美。这个乐队最令人感动的是鼓手，只有一条手臂还怀着一颗坚毅的心重返乐队，我很敬佩这样牛逼的音乐人。另外他们的合声也是相当美丽的，很少有摇滚乐队合声如此好听，默契到位又流畅自然，分分钟刷新你的重金属三观。<br>经典专辑；《Best of Def Leppard》、《Hysteria》、《Retro Active》</p><h4 id="10-Suede（山羊皮乐队）"><a href="#10-Suede（山羊皮乐队）" class="headerlink" title="10. Suede（山羊皮乐队）"></a>10. Suede（山羊皮乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_10.jpg" alt=""><br>Suede（山羊皮乐队）在90年代非常受欢迎，一开始这支乐队其实是倍受质疑的，后来才受到了大众的喜爱。他们的风格是另类摇滚和英式摇滚。这和当时的摇滚大环境有关，90年代，英国传统摇滚乐的巅峰已经接近末声，演化出了英式摇滚，Suede其实就是这些乐队之一。他们的风格比较邪魅狂绢，充满了一种癫狂和风情万种的艺术气质，主唱的声音听多了会怀孕的。山羊皮对华挺友好的，曾经来过中国演出。还有令无数歌迷沉醉的还有主唱的颜值——他年轻的时候简直帅呆了！<br>经典专辑：《The Drowners》、《Suede》、《Coming Up》、《Head Music》</p><h4 id="11-Oasis（绿洲乐队）"><a href="#11-Oasis（绿洲乐队）" class="headerlink" title="11. Oasis（绿洲乐队）"></a>11. Oasis（绿洲乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_11.jpg" alt=""><br>Oasis（绿洲乐队）组建于曼彻斯特，是一支个性狂放的乐队，这和乐队的两兄弟的性格有关系。这支乐队最好的地方在于结合了流行摇滚与传统摇滚，传承了传统摇滚的精髓，乐评家非常钟爱这支乐队，对他们给予很高的评价。一说到英式摇滚人们首先会想到就是绿洲，其次是Blur，他们的吉他简直是神了，奠定了英式摇滚的吉他抒情风格。但是他们也叛逆咆哮，这完全不同于像披头士那样的“乖小孩”，自带一种粗犷的摇滚天性。<br>经典专辑：《Definitely Maybe》、《Morning Glory》</p><h4 id="12-Radiohead（电台司令乐队）"><a href="#12-Radiohead（电台司令乐队）" class="headerlink" title="12. Radiohead（电台司令乐队）"></a>12. Radiohead（电台司令乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_12.jpg" alt=""><br>Radiohead（电台司令）是那种让人绝望抑郁至死的乐队，个人觉得偶尔听一下还是不错啦。这支乐队的评价还是蛮好的，他们的风格很沉郁，在歌词的创作上独具匠心。灵魂人物兼主唱Yorke性格敏感脆弱，他们的作品里充满了一种病态美学的美感，吟唱人性最卑微脆弱之处，像《Creep》这种就是他们风格的集大成之作，这种风格在摇滚乐队里是比较少见的。<br>经典专辑：《The Bends》、《OK Computer》、《 Kid A 》</p><h4 id="13-Muse（缪斯乐队）"><a href="#13-Muse（缪斯乐队）" class="headerlink" title="13. Muse（缪斯乐队）"></a>13. Muse（缪斯乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_13.jpg" alt=""><br>多元的音乐风格、对英式摇滚拿捏到刚刚好的新生代英国摇滚乐队。融合重金属、电子音乐、前卫音乐、太空摇滚等等元素。更难得的是，从缪斯的歌曲里你还能听出千丝万缕的英国古典音乐气息，就像灵魂一样穿插在乐曲之中，非常特别，这在英国这样一个复古气息非常浓厚的国家非常有代表性，所以我认为他们的英式摇滚的头衔是应得的。有人说缪斯主唱Bellamy的唱腔和Yorke很像，细听确实有一点，都有一种浅唱低吟的感觉，但是Bellamy更加积极魅惑一点，不似Yorke给人彻彻底底地绝望之感。<br>经典专辑：《Black Holes and Revelations》、《Absolution》、《The 2nd Law》</p><h4 id="14-Blur（模糊乐队-布勒乐队-污点乐队）"><a href="#14-Blur（模糊乐队-布勒乐队-污点乐队）" class="headerlink" title="14. Blur（模糊乐队/布勒乐队/污点乐队）"></a>14. Blur（模糊乐队/布勒乐队/污点乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_14.jpg" alt=""><br>这支乐队和绿洲一起是一个神奇的存在，最为乐迷津津乐道的就是Blur（模糊乐队）与绿洲的掐架了，因为他们的风格挺像的，都是英式摇滚路线。但是我觉得模糊乐队没有像绿洲那样的狂放个性，显得更加的温和内敛，所以这支乐队被认为具有披头士的神韵。很多人评价一支乐队经常说某某乐队是某某乐队的接班人，我其实并不喜欢这种评价，乐队和乐队之间是一种传承和学习的关系，但是每个乐队都是一个独立的个体，所以我觉得披头士是披头士，Blur是Blur。近几年Blur做了一些比较诡异的尝试，风格越来越让人摸不透了，不过有了自己的经典之作之后，他们想做一些新的突破也是非常勇敢的。<br>经典专辑：《The Best Of Blur》、《The Great Escape》、《Parklife》</p><h4 id="15-Travis（特拉维斯乐队）"><a href="#15-Travis（特拉维斯乐队）" class="headerlink" title="15. Travis（特拉维斯乐队）"></a>15. Travis（特拉维斯乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_15.jpg" alt=""><br>这是来自苏格兰的一支传统摇滚乐队，他们涉足英式摇滚、传统摇滚、Post-Grunge与另类摇滚多个领域。乐队成员都是70后，他们最开始只是一个小地方的乐团，发行第二张专辑之后难掩才华，一时间成为英国摇滚乐坛巨星。其实我觉得主唱的声线是比较忧郁的，唱歌的方式有点浅唱低吟的感觉。他们也尝试过软摇滚，总之是一支听起来比较舒服的乐队。<br>经典专辑：《The Man Who》、《Side》、《Pipe Dreams》</p><h4 id="16-Queen（皇后乐队）"><a href="#16-Queen（皇后乐队）" class="headerlink" title="16. Queen（皇后乐队）"></a>16. Queen（皇后乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_16.jpg" alt=""><br>一支华丽丽的硬摇乐队，作品具有浓厚的歌剧色彩，非常硬，乐队的歌曲都保留了那种老式硬摇滚的精髓，键盘和完美的吉他Solo是他们的特点。主唱Freddie Mercury的声音是摇滚乐坛少有的好嗓，非常高亢嘹亮，天生是摇滚主唱的料，这也给皇后乐队注入了一种恢弘而大气磅礴的音乐感染力，但Freddie Mercury不幸因染上艾滋病辞世，全球歌迷为之震惊心痛。在失去这位灵魂人物之后，皇后乐队还是人气高涨，不断出了好作品，最终被选入摇滚名人堂。<br>经典专辑：《A Night at The Opera》、《Innuendo》、《A Kind of Magic》</p><h4 id="17-Black-Sabbath（黑色安息日乐队）"><a href="#17-Black-Sabbath（黑色安息日乐队）" class="headerlink" title="17. Black Sabbath（黑色安息日乐队）"></a>17. Black Sabbath（黑色安息日乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_17.jpg" alt=""><br>一看名字就知道这是支重金属乐队，乐队组建于伯明翰。这支乐队音色纯正，音乐简单干净又粗暴，但是他们的歌曲具有深刻的现实意义。他们的歌曲关注当时的核战争和死亡，描写毒品、反叛、青年和灰暗的生活命运，反映了底层人的痛苦绝望的生活状态，深受当时年轻人的喜爱。这支乐队的辉煌时期在70年代，后来渐渐地没落。好像70年代的英国朋克乐队都很难长久，不知道这是个什么怪圈，我想这可能是因为朋克自身所带的那种毁灭性，使他们自己也无法长久吧。<br>经典专辑：《Paranoid》、《Vol. 4》、《Master Of Reality》、《Sabbath Bloody Sabbath》</p><h4 id="18-Snow-Patrol（雪地巡游者乐队）"><a href="#18-Snow-Patrol（雪地巡游者乐队）" class="headerlink" title="18. Snow Patrol（雪地巡游者乐队）"></a>18. Snow Patrol（雪地巡游者乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_18.jpg" alt=""><br>Snow Patrol（雪地巡游者乐队）是一支来自苏格兰的乐队，乐队风格清新哀婉，歌词非常的温暖感人，是当代比较成功的英国摇滚乐队。乐队风格是迷幻和另类路线，出了一些很不错的单曲，我个人比较喜欢他们的一些作品，可以拿来听听。听他们的歌曲非常的治愈，给人温暖、干净而清澈的感觉，近几年也是风生水起，至于未来还会怎样发展，还有很多的可能性。<br>经典专辑：《Final Straw》、《Up To Now》</p><h4 id="19-Led-Zeppelin（齐柏林飞船）"><a href="#19-Led-Zeppelin（齐柏林飞船）" class="headerlink" title="19. Led Zeppelin（齐柏林飞船）"></a>19. Led Zeppelin（齐柏林飞船）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_19.jpg" alt=""><br>被誉为重金属鼻祖的一支英国乐队，他们的重金属融合了朋克、中东音乐、蓝调、乡村、雷鬼音乐等等元素。他们的有的歌曲听起来很忧伤，令人神往遐思，代入感极强。有很多歌曲的歌词非常的有深度，甚至是对人性的拷问和追寻。他们的音乐前奏都非常漂亮，节奏感超强。虽然是重金属乐队，但是其并没有像后期的重金属乐队那样太多的嘶吼和器乐嘈杂，很是入耳。<br>经典专辑：《Led Zeppelin Ⅳ》、《Houses of the Holy》、《Physical Graffiti》</p><h4 id="20-The-Kinks（奇想乐队）"><a href="#20-The-Kinks（奇想乐队）" class="headerlink" title="20. The Kinks（奇想乐队）"></a>20. The Kinks（奇想乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/p106505_20.jpg" alt=""><br>奇想是一支老乐队了，他们主要活跃在60-70年代，在流行摇滚上造诣颇高，曲风也是蛮广的，迷幻、流行随手拈来。作为“不列颠入侵”的主要乐队之一，奇想与披头士、谁人和滚石并称为英国摇滚乐坛“Big Four”，当时的英国摇滚就是这四个乐队大放异彩、风靡全球。奇想也是摇滚名人堂的成员，但是96年这个乐队就解散了。他们的歌曲听着很舒服，充满怀旧伤感之情。可惜的是，这支本来很优秀的乐队在当时有点被披头士的巨大光芒掩盖了，现在去重新发现下也是不错的。<br>经典专辑：《Face to Face》、《Muswell Hillbillies》、《Arthur》</p><p>英国的摇滚乐队不胜枚举，大大小小的、成名的不成名的、大众的和小众的非常多，他们各有风格，但是真正能够在摇滚史上留下名字的乐队还是少数。总的来说，英国摇滚的特点是自成一派的英式摇滚，还有PF所创立的迷幻摇滚流派，加之上世纪70年代的朋克摇滚，这些都是英国土生土长的摇滚形式。除此外，英国摇滚还有其独有的思想性，从披头士的爱、和平、反战，到朋克对现实的抨击，及众多英式摇滚乐队的壮大复兴，都是英国摇滚乐的迷人之处。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Music </category>
          
          <category> Britpop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/2017/01/19/test/"/>
      <url>/2017/01/19/test/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Mar 30 2019 17:03:22 GMT+0800 (GMT+08:00) --><p>Just for a simple test</p><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
