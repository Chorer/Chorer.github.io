<!-- build time:Sat Jan 01 2022 19:26:59 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/prism.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">浅谈网络协议：Web 安全篇</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-04-07&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp5.4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp20 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/网络安全/">网络安全</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-5.png" alt=""></p><span id="more"></span><h3 id="跨域和跨站的区别"><a class="markdownIt-Anchor" href="#跨域和跨站的区别"></a> 跨域和跨站的区别</h3><p>涉及到 Web 安全，会有一个跨站的概念，跨站和跨域是不同的。</p><h4 id="跨域"><a class="markdownIt-Anchor" href="#跨域"></a> 跨域</h4><p>跨域即 cross-domain，它和同源（same-origin）相对，要求两个 URL 的协议、端口号、域名都一致才能称为同源。</p><h4 id="跨站"><a class="markdownIt-Anchor" href="#跨站"></a> 跨站</h4><p>跨站即 cross-site，它和同站（same-site）相对，对协议和端口号无要求，只要两个 URL 的 <code>eTLD + 1</code> 一致，就能称为同站。那么什么是 <code>eTLD</code> 呢？</p><p><code>eTLD</code> 即 effective top level domain，有效顶级域名，比如 <code>http://juejin.cn</code> 的 <code>eTLD</code> 是 <code>.cn</code>，<code>http://test.org</code> 的 <code>eTLD</code> 是 <code>.org</code>，而 <code>http://chorer.github.io</code> 则是 <code>github.io</code>（注意不是 <code>.io</code>）。而 <code>eTLD + 1</code> 指的是有效顶级域名 + 二级域名，比如对于 <code>http://juejin.cn</code> 来说就是 <code>juejin.cn</code>，对于 <code>http://test.org</code> 来说就是 <code>test.org</code>。</p><p>**PS：**不过需要注意的是，same-site 实际上也分为两种，一种是上面定义的协议松散型 same-site，即 scheme-less same-site，在判断是否同站时并不需要考虑协议；另一种则是协议严格型 same-site，即 schemeful same-site，要求协议必须一致才能认定为是同站。</p><h3 id="xss"><a class="markdownIt-Anchor" href="#xss"></a> XSS</h3><p>XSS 即 Cross-Site Scripting（跨站脚本攻击），指的是黑客将恶意代码注入页面中，只要打开页面，代码就会执行。XSS 攻击可能导致 Cookie 被窃取、个人信息泄露、劫持流量实现恶意跳转等。</p><h4 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h4><p>XSS 基本可以分为两类，一个是反射型 XSS（非持久型 XSS），一个是存储型 XSS（持久型 XSS）。</p><p><strong>反射型 XSS</strong></p><p>黑客诱导用户点击带有特殊参数的 URL，从而往页面中注入恶意代码。比如说，正常向服务器发起请求的 URL 是 <code>http://test.com?name=jack</code>，服务器拿到参数 <code>jack</code> 之后，不做处理，直接返回一个响应 <code>Hello jack</code>，HTML 是这样的：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>Hello jack<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样当然没问题，但如果用户点击了黑客的 URL 是 <code>http://test.com?name=&lt;script&gt;alert(1)&lt;/script&gt;</code>，那么服务器拿到了 <code>name</code> 参数，如果不做处理就返回响应，HTML 会是这样的：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么解析 HTML 的时候，实际上是会执行中间这段脚本的。<code>alert(1)</code> 只是一个示例 —— 这里可以是任何的脚本操作，包括通过 <code>document.cookie</code> 窃取用户 Cookie，通过 <code>window.location</code> 实现跳转等，会有很大的安全风险。</p><p><strong>存储型 XSS</strong></p><p>存储型 XSS 是持久的，而且风险会更大，因为恶意代码会存储到数据库中，无论哪个用户访问页面，都会被波及。比如说，黑客给某篇文章的评论区留言，写下 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，之后提交表单给服务器。服务器不做任何处理，只是把留言存储到数据库中。下次无论哪位用户访问这篇文章，服务器都会从数据库中获取留言并返回给浏览器，这当然也包括了 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> ，只要一执行就会产生弹窗，对于所有用户都是如此。同样，这里弹窗只是一个举例，它可以是任何危害到用户信息安全的脚本操作。</p><h4 id="防御措施"><a class="markdownIt-Anchor" href="#防御措施"></a> 防御措施</h4><p><strong>1）HTML 转义</strong></p><blockquote><p><code>&lt;</code> 用于定义标签的开始，如果我们希望浏览器确实显示 <code>&lt;</code> 这个字符本身，而不是把它当作一个标签去解析，那么就必须对字符进行转义（escape），编写字符实体而不是字符。</p></blockquote><p>同理，为了安全起见，我们不应该把 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 作为标签去解析，而只是希望它是一个单纯的字符串，所以可以考虑在服务端这边进行 HTML 转义：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token entity named-entity" title="&lt;">&amp;lt;</span>script<span class="token entity named-entity" title="&gt;">&amp;gt;</span>alert(1)<span class="token entity named-entity" title="&lt;">&amp;lt;</span>/script<span class="token entity named-entity" title="&gt;">&amp;gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个转义的结果最终返回给浏览器， <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 会作为字符串在页面上显示出来，而不再是可执行的脚本。</p><p><strong>2）用户输入验证</strong></p><p>转义指的是对 <code>&lt;</code>、<code>&gt;</code>等特殊字符进行转义，如果说注入的恶意脚本都是用 <code>&lt;script&gt;&lt;/script&gt;</code>包裹的，那么 HTML 转义确实可以避免 XSS 攻击 —— 但实际上，有其他的方式可以进行脚本注入。比如某社区网站允许用户在个人资料中填写自己博客的地址，并最终作为 <code>&lt;a href=&quot;xxx&quot;&gt;我的博客地址&lt;/a&gt;</code>展示出来，那么别有用心的黑客就可以填入 <code>javascript:alert(1);</code>，这是不会经过 HTML 转义的，因此最终黑客的博客地址是这样的：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>javascript:alert(1);<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是用户博客的地址<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只要有人点击查看他资料中的博客地址，就会发生弹窗。</p><p>同样的，如果网站还允许用户通过填写 URL 的方式设置头像图片，并最终作为 <code>&lt;img src=&quot;xxx&quot;&gt;</code> 展示出来，那么黑客可以填入 <code>xxx&quot; onerror=&quot;alert(1)</code>，这同样是不会经过 HTML 转义的，因此最终 <code>img</code> 标签是这样的：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onerror</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的 <code>src</code> 明显是不合法的，所以会触发 <code>error</code> 事件，发生弹窗。</p><p>因此，单纯的 HTML 转义并不能规避所有 XSS 攻击，我们还必须对用户输入的数据进行验证。</p><p><strong>3）CSP</strong></p><p>CSP 即 Content Security Policy（内容安全策略），开发者提供一个白名单，告诉浏览器只能加载特定来源的代码，从而禁止某些第三方脚本的运行。</p><p>CSP 有两种使用方式：</p><ul><li>服务端响应一个 <code>content-security-policy</code> 头部字段，约束浏览器的加载行为：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html">Content-Security-Policy: script-src 'self'; style-src cdn.example.org third-party.org; child-src https:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>HTML 中使用 <code>meta</code> 标签，约束浏览器的加载行为：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Content-Security-Policy<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>script-src <span class="token punctuation">'</span>self<span class="token punctuation">'</span>; style-src cdn.example.org third-party.org; child-src https:<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它们的形式不同，但作用都是一样的：</p><ul><li><code>script-src</code>：设置只允许加载哪些来源的脚本，设置为 <code>self</code> 代表只能加载本域名的脚本。注意它会禁止内联脚本的事件监听，比如前面例子的 <code>onerror</code>，使用的时候会报错提示违反了 CSP</li><li><code>style-src</code>：设置只允许加载哪些来源的样式文件，这里只能加载 <code>cdn.example.org</code> 和 <code>third-party.org</code>的</li><li><code>child-src</code>：设置为 <code>https</code> 表示必须使用 <code>https</code> 去加载 <code>iframe</code></li></ul><p><strong>4）HttpOnly</strong></p><p>前面说过，黑客可以注入脚本窃取用户的 Cookie，这本质上是因为可以通过 <code>document.cookie</code> 去访问 Cookie，因此服务端可以在给客户端响应的 <code>Set-Cookie</code> 头部字段，声明一个 <code>HttpOnly</code> 来禁止通过脚本获取 Cookie。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Set<span class="token operator">-</span>Cookie<span class="token operator">:</span> id<span class="token operator">=</span>a3fWa<span class="token punctuation">;</span> Expires<span class="token operator">=</span>Wed<span class="token punctuation">,</span> <span class="token number">21</span> Oct <span class="token number">2015</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span><span class="token punctuation">;</span> Secure<span class="token punctuation">;</span> HttpOnly<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="csrf"><a class="markdownIt-Anchor" href="#csrf"></a> CSRF</h3><h4 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h4><p>CSRF 即跨站请求伪造，黑客利用请求会携带 Cookie 的特点，冒充用户身份向正常网站发出请求，执行某些非法操作。它的作用过程大概是这样的：</p><ul><li>用户登录 <code>http://article.com</code>，服务器验证通过，返回 Cookie 给浏览器保存</li><li>假设 Cookie 没过期，这期间黑客诱导用户访问恶意网站 <code>http://evil.com</code>，这个网站中有这么一段代码：</li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://article/delete?id=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>那么恶意网站就会向 <code>http://article.com</code> 发起一个携带 Cookie 的请求，服务端这边验证没问题，就会把 id 为 1 的文章给删除了</li></ul><p>这里黑客之所以可以发起 CSRF 攻击，有下面几个原因：</p><ul><li>用户：登录了正常网站且没有登出（Cookie 有效），之后访问了恶意网站</li><li>黑客：知道执行请求的 URL 和所有的参数</li><li>服务端：只使用 Cookie 进行权限验证，没有任何针对 CSRF 的防御措施</li><li><code>img</code> 是支持跨域请求的。其实黑客也可以直接发送一个 AJAX 请求，不过由于同源策略和 CORS 的限制，<code>http://evil.com</code> 是无法向不同源的 <code>http://article.com</code> 发送请求的，所以黑客使用的是天然可以跨域的 <code>img</code> 标签</li></ul><h4 id="xss-csrf"><a class="markdownIt-Anchor" href="#xss-csrf"></a> XSS + CSRF</h4><p>上面的例子属于利用 Cookie 而不是窃取 Cookie，实际上，黑客可以先使用 XSS 拿到用户的 Cookie，接着再使用 CSRF 伪造发送请求。</p><h4 id="防御措施-2"><a class="markdownIt-Anchor" href="#防御措施-2"></a> 防御措施</h4><p>要制定防御措施，可以从 CSRF 产生的原因入手：</p><ul><li>CSRF 大多来自第三方网站，若服务端能知道请求是谁发出的，并相应进行限制，那么可以在一定程度上规避攻击。与此相关的有 <code>SameSite</code> 属性、<code>Origin</code> 头部字段、<code>Referer</code> 头部字段</li><li>CSRF 发生的关键在于第三方网站也能携带 Cookie 发送请求，导致服务端并不知道请求来自恶意网站还是正常用户。那么，我们可以让正常用户发送请求时携带一个恶意网站无法获取到的 token，服务端通过校验请求是否携带正确的 token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 攻击。与此相关的就是 <code>CSRF token</code>。</li></ul><p><strong>同站限制 —— SameSite</strong></p><blockquote><ul><li><mark>第一方 Cookie</mark>：在 <code>http://bank.com</code> 下对 <code>http://bank.com/xxx</code> 发起请求，那么携带的 Cookie 是第一方 Cookie（由第一方携带的）；</li><li><mark>第三方 Cookie</mark>：在 <code>http://evil.com</code> 下对 <code>http://bank.com/xxx</code> 发起请求，携带的则是第三方 Cookie（由第三方携带的）。</li></ul></blockquote><p>如果站点当初响应返回的 <code>Set-Cookie</code> 声明了 <code>SameSite</code> 属性，那么该 Cookie 就会成为一个同站 Cookie，这样的 Cookie 是不能作为第三方 Cookie 的 —— 换句话说，声明 <code>SameSite</code> 可以避免在 <code>http://evil.com</code> 下对 <code>http://bank.com/xxx</code> 发起请求时携带 Cookie 过去，因此可以规避 CSRF 攻击。</p><p>1）<code>Set-Cookie: SameSite = Strict</code>：</p><p>这是最严格的模式，声明之后 Cookie 将不会在任何跨站请求中携带，也即完全禁用了第三方 Cookie，因此可以完全阻止 CSRF 攻击。但缺点是用户体验比较差 —— 比如当前网页有一个跳转到目标网站的链接，点击进入后往往已经是登录状态了，这是因为当前网页向目标网站发起的请求中携带了目标网站的 Cookie，而现在如果彻底禁用第三方 Cookie，就无法维持这个登录状态了，进入目标网站后需要重新登录。</p><p>2）<code>Set-Cookie: SameSite = Lax</code>：</p><p>默认值。这种模式相对来说比较宽松，声明之后 Cookie 在大多数跨站请求的场景下还是不会携带的，因此保证了安全性；同时，<strong>导航到目标网站的 GET 请求</strong>是可以携带 Cookie 的，因此保证了可用性（比如说维持登录态）。具体情况如下：</p><table><thead><tr><th>请求类型</th><th>示例</th><th>正常情况</th><th>Lax</th></tr></thead><tbody><tr><td>链接</td><td><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>预加载</td><td><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>GET 表单</td><td><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>发送 Cookie</td></tr><tr><td>POST 表单</td><td><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>iframe</td><td><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>AJAX</td><td><code>$.get(&quot;...&quot;)</code></td><td>发送 Cookie</td><td>不发送</td></tr><tr><td>Image</td><td><code>&lt;img src=&quot;...&quot;&gt;</code></td><td>发送 Cookie</td><td>不发送</td></tr></tbody></table><p>表格的前三种都属于导航到目标网站的 GET 请求，这些请求虽然跨站但是可以携带 Cookie —— 尤其是第一种情况，允许我们通过外链到达目标网站后直接处于登录状态。</p><p>3）<code>Set-Cookie: SameSite = None; Secure</code></p><p>这种模式可以关闭 <code>SameSite</code> 属性，跨站请求中第三方 Cookie 的携带不受限制。但与此同时，必须声明 <code>Secure</code>，让 Cookie 只能在 HTTPS 请求中携带。</p><p>为什么要设置 <code>SameSite</code> 之后再将其关闭，而不是一开始直接就不设置 <code>SameSite</code> 呢？因为 Chrome 默认设置 <code>SameSite = Lax</code>，所以必须通过显式设置 <code>SameSite = None</code> 的方式将其关闭。</p><blockquote><p>PS：Chrome 将在 2022 年全面禁用第三方 Cookie</p></blockquote><p><strong>同源检测 —— <code>Origin</code> 和 <code>Referer</code></strong></p><p>通常可以从请求报文的 <code>Origin</code> 或者 <code>Referer</code> 头部字段知道请求源，区别在于前者只给出服务器地址，而后者还会给出具体路径：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Origin<span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>developer<span class="token punctuation">.</span>mozilla<span class="token punctuation">.</span>org

Referer<span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>developer<span class="token punctuation">.</span>mozilla<span class="token punctuation">.</span>org<span class="token operator">/</span>en<span class="token operator">-</span><span class="token constant">US</span><span class="token operator">/</span>docs<span class="token operator">/</span>Web<span class="token operator">/</span>JavaScript<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么应该用哪一个呢？<code>Origin</code> 在 IE11 的 CORS 请求中不会携带，在 302 重定向的请求中也不会携带，所以更保险的是使用 <code>Referer</code> —— 但即便如此也要知道，在 HTTPS 页面跳转到 HTTP 页面的时候，出于安全考虑，不会携带 <code>Referer</code> 。</p><p><strong>CSRF token</strong></p><p>恶意网站进行 CSRF 攻击的一个必要条件是知道请求格式和参数，那么，如果让请求必须携带一个只有正常用户才知道的 token 作为参数，恶意网站就无法构造完整的请求了，也就无法进行攻击。</p><blockquote><p>模式一：隐藏表单域 + session：</p></blockquote><ul><li><p>服务端生成一个随机 CSRF token，存储在服务器的 session 中，同时下发 token 到用户的前端页面中。这里有两种情况</p><p>一是将 token 注入到每个表单的隐藏的 <code>input</code> 域中：</p></li></ul><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>csrf-token<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>CIwNZNlR4XbisJF39I8yWnWX9wX4WFoz<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​ 二是将 token 注入到 <code>meta</code> 标签中：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>csrf-token<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>CIwNZNlR4XbisJF39I8yWnWX9wX4WFoz<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>前端若要发起 GET 请求，则通过 JS 获取 <code>meta</code> 中的 token，并作为请求 URL 的参数，形如 <code>http://test.com?csrftoken=CIwNZNlR4XbisJF39I8yWnWX9wX4WFoz</code> ；若要发起 POST 请求，则直接提交表单即可，之前注入到表单中的 token 会自动作为请求体的参数</li><li>服务端拿到 GET 或者 POST 请求的 token 参数，与保存在 session 中的 token 比较，若相同则认为此次请求来自合法用户，否则认为来自恶意网站（恶意网站是拿不到 token 的，无法构造完整的请求）</li></ul><blockquote><p>模式二：隐藏表单域 + cookie：</p></blockquote><ul><li>服务端生成一对互相关联的 CSRF token，一个 token 通过隐藏表单域下发到用户的前端页面中，另一个 token 注入到 <code>set-Cookie</code> 字段中</li><li>前端提交表单发起 POST 请求，隐藏表单域中的 token 自动成为请求体的参数，<code>set-Cookie</code> 中的 token 则被放到请求头部字段 Cookie 中</li><li>服务端对收到的两个 token 进行校验，校验通过则说明此次请求来自合法用户</li></ul><p>PS：这种模式不需要服务端通过 session 维护大量的 token。虽然恶意网站还是可以在请求中携带 Cookie（内含 token），但是由于它拿不到服务端返回给用户的隐藏表单域（内含 token） ，因此它的请求参数是缺失的，实际上无法通过服务端的校验。</p><p><strong>验证码</strong></p><p>像删除数据这类敏感操作，如果不进行任何验证就直接执行操作，会有很大的风险。因此可以考虑使用验证码，但验证码应该只用于关键的业务节点中，滥用将会影响用户体验 —— 从这个角度来说，验证码更适合作为一个防御 CSRF 攻击的辅助手段。</p><h3 id="clickjacking"><a class="markdownIt-Anchor" href="#clickjacking"></a> ClickJacking</h3><p>ClickJacking 即点击劫持，指的是劫持用户的点击行为进行某些操作。</p><p>比如说有一个恶意网站 <code>http://evil.com</code>，有一个正常网站 <code>http://funnyvideo.com</code>，恶意网站的网页下面是一个透明的、引用了正常网站的 <code>iframe</code>。黑客诱导用户进入恶意网站并在网页中进行点击，看起来用户只是在点击恶意网站的网页，但实际上是在点击正常网站的网页。</p><h4 id="防御措施-3"><a class="markdownIt-Anchor" href="#防御措施-3"></a> 防御措施</h4><p><strong><code>X-Frame-Options</code> 实现：</strong></p><p>上述点击劫持发生的本质原因是恶意网站可以通过 <code>iframe</code> 引用正常网站，如果我们设法禁止通过 <code>iframe</code> 去引用正常网站，或者限制只有某些信任网站可以通过 <code>iframe</code> 引用正常网站，那么就可以规避点击劫持。响应头部字段 <code>X-Frame-Options</code> 就是来做这个事的，它可以设置下面的值：</p><ul><li><code>deny</code>：禁止任何网站通过 <code>iframe</code> 引用正常网站</li><li><code>sameorigin</code>：只允许同源网站通过 <code>iframe</code> 引用正常网站</li><li><code>allow-from</code>：只允许特定网站通过 <code>iframe</code> 引用正常网站，比如 <code>allow-from http://test.com</code>，就表示 <code>http://test.com</code> 是受信任的，可以引用正常网站</li></ul><p><strong>JS 实现：</strong></p><p>对于某些不支持设置 <code>X-Frame-Options</code> 头部字段的旧浏览器，可以使用 js 作为一种 callback 的方案。</p><ul><li>当 A 网站通过 <code>iframe</code> 引用 B 网站的时候，B 网站可以通过 <code>self</code> 获取自身 <code>window</code> 对象，通过 <code>top</code> 获取 A 网站的 <code>window</code> 对象，因此 B 网站可以使用 <code>top == self</code> 判断自身是否被其它网站通过 <code>iframe</code> 引用。</li><li>同时，它还可以通过 <code>top.location.href</code> 获取引用自己的网站的 URL，据此可以通过模式匹配实现网站过滤，只允许信任的网站引用自己。</li></ul><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">!=</span> self<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> style <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'style'</span><span class="token punctuation">)</span>
    style<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'html&#123;display:none!important;&#125;'</span>
    document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>style<span class="token punctuation">)</span>
    top<span class="token punctuation">.</span>location <span class="token operator">=</span> self<span class="token punctuation">.</span>location
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码处理方式比较粗糙，如果 <code>top</code> 不等于 <code>self</code>，说明有其它网站引用了自己，那么就隐藏自身的所有内容，同时让第三方网站跳转到自身。当然，可以修改代码实现类似于 <code>X-Frame-Options</code> 各个参数的效果。</p><h3 id="中间人攻击"><a class="markdownIt-Anchor" href="#中间人攻击"></a> 中间人攻击</h3><p>中间人攻击（Man-in-middle Attack）指的是，攻击者充当一个中间人的角色，与通信的两端分别创建独立的联系，对传输的数据进行劫持和篡改。整个会话被中间人操控，但通信的两端都以为是在和对方通信。中间人攻击发生的原因在于通信双方没有采用数字签名、数字证书等手段验证对方身份。</p><p>以前面讲过的混合加密过程为例，如果发生中间人攻击，过程大概如下：</p><ul><li>客户端发送请求，请求获取服务端的公钥。中间人拦截请求，并将请求转发给服务端</li><li>服务端收到请求，生成一对公钥（服）和私钥（服），私钥（服）自己保管，公钥（服）发给中间人（服务端以为此时的中间人是客户端）</li><li>中间人拿到公钥（服）。同时生成自己的一对公钥（中）和私钥（中），冒充服务端将公钥（中）发给客户端</li><li>客户端收到公钥（中），生成会话密钥（客），用公钥（中）加密会话密钥（客），然后发给中间人（客户端以为此时的中间人是服务端）</li><li>中间人用私钥（中）解密，得到会话密钥（客）。同时生成自己的会话密钥（中），用公钥（服）加密之后发给服务端</li><li>服务端收到，用私钥（服）解密，拿到会话密钥（中），以为这是客户端发来的会话密钥（客），于是用这个会话密钥加密数据 XXX，发送给中间人</li><li>中间人收到，用会话密钥（中）进行解密，拿到数据 XXX 后进行篡改，得到数据 YYY。接着用会话密钥（客）对数据 YYY 进行加密，发送给客户端</li><li>客户端收到数据 YYY，用会话密钥（客）加密数据 ZZZ，发给中间人</li><li>中间人收到，用会话密钥（客）进行解密，拿到数据 ZZZ 后进行篡改，得到数据 WWW。接着用会话密钥（中）对数据 WWW 进行加密，发送给服务端</li><li>服务端收到，用会话密钥（中）解密，拿到数据 WWW</li><li>……</li></ul><p>可以看到，中间人在客户端面前表现为服务端，在服务端面前又表现为客户端，两边来回劫持和篡改数据。下面的图更加清晰地展示了整个过程：</p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/17.jpg" style="zoom:67%"><h3 id="dns-污染和劫持"><a class="markdownIt-Anchor" href="#dns-污染和劫持"></a> DNS 污染和劫持</h3><h4 id="dns-劫持"><a class="markdownIt-Anchor" href="#dns-劫持"></a> DNS 劫持</h4><p>DNS 劫持指的是劫持 DNS 服务器，获得对于某个域名的解析记录控制权，进而修改该域名的解析结果，返回一个错误的 IP 地址给客户端。DNS 劫持篡改的是 DNS 服务器上的数据，会导致用户无法访问某个网站，或者访问了一个假的克隆网站，从而导致个人信息泄露等。</p><p><strong>案例</strong>：访问谷歌但是打开的是百度</p><p><strong>解决方案</strong>：既然问题是出在 DNS 服务器，那么可以考虑手动更换 DNS 服务器为公共 DNS</p><h4 id="dns-污染"><a class="markdownIt-Anchor" href="#dns-污染"></a> DNS 污染</h4><p>DNS 污染属于 DNS 缓存投毒攻击，它把自己伪装成 DNS 服务器，将用户访问的域名指向不正确的 IP 地址然后返回。</p><p><strong>案例：</strong> GFW 导致无法访问国外网站</p><p>**解决方案：**VPN 等</p><h3 id="http-劫持"><a class="markdownIt-Anchor" href="#http-劫持"></a> HTTP 劫持</h3><p>发起 HTTP 劫持的可能是第三方运营商、局域网或者免费公共 Wi-Fi 等，发生的原因在于流量必须经过运营商、局域网、Wi-Fi 等，而 HTTP 本身又是明文传输的，这就给了它们对数据进行劫持和篡改的机会。</p><p>我们有时候在浏览某些网站的时候，经常会看到右下角有弹窗广告，实际上这不一定是网站本身投放的广告，往往是运营商进行 HTTP 劫持之后投放的。解决的方法也很简单，就是使用加密的 HTTPS。</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2021/04/07/CN-%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9ATCP%E7%AF%87/" rel="prev" title="浅谈网络协议：TCP 篇"><i class="fa fa-angle-double-left"></i>&nbsp浅谈网络协议：TCP 篇</a></div><div class="post-nav-next"><a href="/2021/04/07/CN-%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9ADNS%20%E7%AF%87/" rel="next" title="浅谈网络协议：DNS 篇">浅谈网络协议：DNS 篇&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E5%92%8C%E8%B7%A8%E7%AB%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">跨域和跨站的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E7%AB%99"><span class="toc-text">跨站</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xss"><span class="toc-text">XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-text">防御措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csrf"><span class="toc-text">CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xss-csrf"><span class="toc-text">XSS + CSRF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD-2"><span class="toc-text">防御措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clickjacking"><span class="toc-text">ClickJacking</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD-3"><span class="toc-text">防御措施</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="toc-text">中间人攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns-%E6%B1%A1%E6%9F%93%E5%92%8C%E5%8A%AB%E6%8C%81"><span class="toc-text">DNS 污染和劫持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dns-%E5%8A%AB%E6%8C%81"><span class="toc-text">DNS 劫持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dns-%E6%B1%A1%E6%9F%93"><span class="toc-text">DNS 污染</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E5%8A%AB%E6%8C%81"><span class="toc-text">HTTP 劫持</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>function send_valine_Server(){var e="desp=",t=document.title,n=t.indexOf("|"),a=(t.substring(0,n),document.URL),s=new Date,l=document.getElementsByClassName("vnick vinput")[0].value||"Anonymous",i=(document.getElementsByClassName("vmail vinput")[0].value,document.getElementsByClassName("vlink vinput")[0].value,document.getElementsByClassName("veditor vinput")[0].value),o=e+"文章："+a+"\n\n昵称："+l+"\n\n留言："+i+"\n\n时间："+s.toLocaleString(),v=new XMLHttpRequest;v.open("POST","https://sc.ftqq.com/"+SCKEY_Server+".send",!0),v.setRequestHeader("Content-type","application/x-www-form-urlencoded"),v.send(title1+"&"+o)}new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0});var title1="text=你的博客有新的评论",SCKEY_Server="SCT99005TwWJDrDKdBwQGK0YmcPRAsr4B",ValineButton=document.getElementsByClassName("vsubmit vbtn")[0];ValineButton.onclick=send_valine_Server</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2022</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/prism.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:150,height:300,vOffset:-120,hOffset:-5},mobile:{show:!1},react:{opacityDefault:1e3,opacityOnHover:1e3},log:!1})</script></body></html><!-- rebuild by neat -->