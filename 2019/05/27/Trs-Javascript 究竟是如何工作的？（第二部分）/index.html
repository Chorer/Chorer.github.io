<!-- build time:Fri May 01 2020 12:35:25 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">「译」JavaScript 究竟是如何工作的？（第二部分）</div></h1><div class="post-sub_title">内存管理、调用堆栈、线程和事件循环是怎么和 JavaScript 的 V8 引擎一起工作的？</div><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-05-27&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><blockquote><ul><li>原文地址：<a href="https://blog.bitsrc.io/how-does-javascript-work-part-2-40cc15360bc" target="_blank" rel="noopener">How Does JavaScript Really Work? (Part 2)</a></li><li>原文作者：<a href="https://blog.bitsrc.io/@priyeshp18" target="_blank" rel="noopener">Priyesh Patel</a></li><li>译文地址：<a href="https://juejin.im/post/5cef7e766fb9a07efd46f183" target="_blank" rel="noopener">[译] JavaScript 究竟是如何工作的？（第二部分）</a></li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89-1.jpg" alt=""><br><span style="font-size:14px;color:#999">照片来源于 <a href="https://unsplash.com/search/photos/storage?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a> 上的 <a href="https://unsplash.com/photos/JuFcQxgCXwA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Samuel Zeller</a></span><br><br><br>在<a href="https://chorer.github.io/2019/05/10/Trs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/">这篇文章的第一部分</a>，我简要概述了编程语言的一般工作机制，并深入探讨了 V8 引擎的管道。第二部分将介绍一些更重要的概念，这些概念是每一个 JavaScript 程序员都必须了解的，并且不仅仅和 V8 引擎有关。<br>对于任何一个程序员来说，最关注的两个问题无非就是：<strong>时间复杂度</strong>和<strong>空间复杂度</strong>。<a href="https://chorer.github.io/2019/05/10/Trs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/">第一部分</a>介绍了 V8 为改进 JavaScript 执行时间所做的速度提升和优化，第二部分则将着重介绍内存管理方面的知识。</p><h2 id="内存堆"><a href="#内存堆" class="headerlink" title="内存堆"></a>内存堆</h2><center><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89-2.jpg"></center><br><center style="font-size:14px;color:#999">Orinoco 的 logo：V8 的垃圾回收器</center><ul><li>每当你在 JavaScript 程序中定义了一个变量、常量或者对象时，你都需要一个地方来存储它。这个地方就是内存堆。</li><li>当遇到语句 <code>var a = 10</code> 的时候，内存会分配一个位置用于存储 <code>a</code> 的值</li><li>可用内存是有限的，而复杂的程序可能有很多变量和嵌套对象，因此合理地使用可用内存非常重要。</li><li>和诸如 C 这种需要显式分配和释放内存的语言不同，JavaScript 提供了自动垃圾回收机制。一旦对象/变量离开了上下文并且不再使用，它的内存就会被回收并返还到可用内存池中。</li><li>在 V8 中，垃圾回收器的名字叫做 Orinoco，它的处理过程非常高效。<a href="https://v8.dev/blog/trash-talk" target="_blank" rel="noopener">这篇文章</a>有相关解释。</li></ul><h2 id="标记与清除算法"><a href="#标记与清除算法" class="headerlink" title="标记与清除算法"></a>标记与清除算法</h2><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89-3.jpg" alt=""></p><center style="font-size:14px;color:#999">标记和清除算法</center><p>我们通常会使用这种简单有效的算法来判定可以从内存堆中安全清除的对象。算法的工作方式正如其名：将对象标记为可获得/不可获得，并将不可获得的对象清除。<br>垃圾回收器周期性地从根部或者全局对象开始，移向被它们引用的对象，接着再移向被这些对象引用的对象，以此类推。所有不可获得的对象会在之后被清除。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>虽然垃圾回收器很高效，但是开发者不应该就此将内存管理的问题束之高阁。管理内存是一个很复杂的过程，哪一块内存不再需要并不是单凭一个算法就能决定的。<br>内存泄漏指的是，程序之前需要用到部分内存，而这部分内存在用完之后并没有返回到内存池。<br>下面是一些会导致你的程序出现内存泄漏的常见错误：<br><strong>全局变量</strong>：如果你不断地创建全局变量，不管有没有用到它们，它们都将滞留在程序的整个执行过程中。如果这些变量是深层嵌套对象，将会浪费大量内存。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  c <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这是一个你没有意识到的全局变量</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你试图访问一个此前没有声明过的变量，那么将在全局作用域中创建一个变量。在上面的例子中，<code>c</code> 是没有使用 <code>var</code> 关键字显式创建的变量/对象。</p><p><strong>事件监听器</strong>：为了增强网站的交互性或者是制作一些浮华的动画，你可能会创建大量的事件监听器。而用户在你的单页面应用中移向其他页面时，你又忘记移除这些监听器，那么也可能会导致内存泄漏。当用户在这些页面来回移动的时候，这些监听器会不断增加。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> element  <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Intervals 和 Timeouts</strong>：当在这些闭包中引用对象时，除非闭包本身被清除，否则不会清除相关对象。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 引用对象</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 这时候忘记清除计时器</span>
<span class="token comment" spellcheck="true">// 那么将导致内存泄漏！</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>移除 DOM 元素</strong>：这个问题很常见，类似于全局变量导致的内存泄漏。DOM 元素存在于对象图内存和 DOM 树中。用例子来解释可能会更好：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> terminator <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'terminate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> badElem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'toDelete'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
terminator<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>memory
  badElem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在你通过 <code>id = ‘terminate’</code> 点击了按钮之后，<code>toDelete</code> 会从 DOM 中移除。不过，由于它仍然被监听器引用，为这个对象分配的内存并不会被释放。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> terminator <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'terminate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
terminator<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>
  <span class="token keyword">var</span> badElem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'toDelete'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  badElem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>badElem</code> 是局部变量，在移除操作完成之后，内存将会被垃圾回收器回收。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>栈是一种遵循 LIFO（先进后出）规则的数据结构，用于存储和获取数据。JavaScript 引擎通过栈来记住一个函数中最后执行的语句所在的位置。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">multiplyByTwo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">multiplyByTwo</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> hello <span class="token operator">=</span> <span class="token string">"some more code follows"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.引擎了解到我们的程序中有两个函数<br>2.运行 <code>calculate()</code> 函数<br>3.将 <code>calculate</code> 压栈并计算两数之和<br>4.运行 <code>multiplyByTwo()</code> 函数<br>5.将 <code>multiplyByTwo</code> 函数压栈并执行算术计算 x*2<br>6.在返回结果的同时，将 <code>multiplyByTwo()</code> 从栈中弹出，之后回到 <code>calculate()</code> 函数<br>7.在 <code>calculate()</code> 函数返回结果的同时，将 <code>calculate()</code> 从栈中弹出，继续执行后面的代码</p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><center><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89-4.jpg"></center><p>在不对栈执行弹出的情况下，可连续压栈的数目取决于栈的大小。如果超过了这个界限之后还不断地压栈，最终会导致栈溢出。chrome 浏览器将会抛出一个错误以及被称为<strong>栈帧</strong>的栈快照。</p><p><strong>递归</strong>：递归指的是函数调用自身。递归可以大幅度地减少执行算法所花费的时间（时间复杂度），不过它的理解和实施较为复杂。<br>下面的例子中，基本事件永远不会执行，<code>lonley</code> 函数在没有返回值的情况下不断地调用自身，最终会导致栈溢出。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lonely</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 基本事件</span>
 <span class="token punctuation">}</span>
 <span class="token function">lonely</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 递归调用</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="为什么-JavaScript-是单线程的？"><a href="#为什么-JavaScript-是单线程的？" class="headerlink" title="为什么 JavaScript 是单线程的？"></a>为什么 JavaScript 是单线程的？</h2><p>一个线程代表着在同一时间段内可以单独执行的程序部分的数目。要想查看一门语言是单线程的还是多线程的，最简单的方式就是了解它有多少个调用栈。JS 只有一个，所以它是单线程语言。<br>这样不是会阻碍程序运行吗？如果我运行多个耗时的阻塞操作，例如 HTTP 请求，那么程序必须得在每一个操作得到响应之后才能执行后面的代码。<br>为了解决这个问题，我们需要找到一种可以在单线程下异步完成任务的办法。事件循环就是用来发挥这个作用的。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>到现在为止，我们谈到的内容大多包含在 V8 里面，但是如果你去查看 V8 的代码库，你会发现它并不包含例如 setTimeout 或者 DOM 的实现。事实上，除了运行引擎之外，JS 还包括浏览器提供的 Web API，这些 API 用于拓展 JS。<br>关于事件循环的概念，菲利普·罗伯茨讲得比我更好，可以看下面这段视频。</p><iframe height="360" width="640" src="https://player.youku.com/embed/XNDIwMTM5NzI0MA==" frameborder="0" allowfullscreen></iframe><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>关于制作一门编程语言，其实还有很多内容，并且语言的实现在这些年也是不断变化的。我希望这两篇博客可以帮助你成为一名更好的 JS 程序员，并且接受 JS 中那些晦涩难懂的内容 。对于诸如“V8”，“事件循环”，“调用栈”这样的术语，你现在应该熟悉了。<br>大部分的学生（比如我）是从一个新的框架起步，之后再去学习原生 JS。现在他们应该熟悉代码背后发生的事情了，反过来，这将帮助他们写出更好的代码。</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/05/30/F-DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/" rel="prev" title="DOM 和 BOM 中的各种宽高属性"><i class="fa fa-angle-double-left"></i>&nbspDOM 和 BOM 中的各种宽高属性</a></div><div class="post-nav-next"><a href="/2019/05/25/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/" rel="next" title="CSS 基础系列：水平垂直居中方案">CSS 基础系列：水平垂直居中方案&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存堆"><span class="toc-text">内存堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标记与清除算法"><span class="toc-text">标记与清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存泄漏"><span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用栈"><span class="toc-text">调用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈溢出"><span class="toc-text">栈溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么-JavaScript-是单线程的？"><span class="toc-text">为什么 JavaScript 是单线程的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件循环"><span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2020</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->