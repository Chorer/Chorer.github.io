<!-- build time:Thu May 14 2020 09:53:02 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">数据类型判断</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-08-06&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp816&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp3 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/数据类型/">数据类型</a></div></div><div class="post-content"><a id="more"></a><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><code>typeof</code></h2><p><code>typeof</code> 操作符返回一个表示数据类型的字符串，它可以应付常规场景下的数据类型判断。对基本数据类型 <code>undefined</code>, <code>boolean</code>, <code>string</code>, <code>number</code> 和引用数据类型 <code>function</code> 都可以正确判断，但是对 null，数组，对象则统一返回 “object”。也就是说，<code>typeof</code> 不适合用来判断引用数据类型。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">typeof</span> a <span class="token comment" spellcheck="true">// "number"</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">typeof</span> b <span class="token comment" spellcheck="true">// "object"</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">typeof</span> c <span class="token comment" spellcheck="true">// "object"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p><code>instanceof</code> 解决了上述问题，它的原理就是判断右操作数（通常是构造函数）的原型对象是否出现在左操作数（通常是实例）的原型链上，如果在则返回 <code>true</code>。据此可以判断引用数据类型具体是哪种类型。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
b <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token comment" spellcheck="true">// true</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
c <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，<code>instanceof</code> 对于不是通过 new 创建的基本数据类型无法做出正确的判断：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">Number</span> <span class="token comment" spellcheck="true">// false</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是因为此时的 a 仅仅是一个基本类型的值，而不是实例对象，如果我们通过 new 创建 a，那么就能正确判断</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token keyword">instanceof</span> <span class="token class-name">Number</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结合 <code>instanceof</code> 的原理其实就很好理解其中原因了。</p><p><code>&gt;&gt;</code> 另外要注意，<code>instanceof</code> 这个方法并非百试百灵 —— 假定脚本中有多个全局环境，例如 html 中有多个子 iframe，那么对于每一个全局环境而言，它都有自己版本的构造函数，进而有自己版本的原型链。<code>instanceof</code> 左右两边的操作数来自于不同全局环境时，即使实例和构造函数对应，也只会返回 false。</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a><code>Object.getPrototypeOf()</code></h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">===</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用原型链。存在同上问题。</p><h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a><code>isPrototypeOf()</code></h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用原型链。存在同上问题。</p><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a><code>Object.prototype.toString.call()</code></h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token template-string"><span class="token string">`Object.prototype.toString.call(arr)`</span></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"[object Array]"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个方法基本很完善，原理就是：在任何值上调用 <strong>Object 原生的 toString() 方法</strong>，都会返回一个格式为 [object NativeconstructorName] 的字符串。据此可以准确判断任何值的数据类型。</p><p>这里注意几个点：</p><ol><li><p>arr 作为对象，也是 Object 的一个实例，为什么不直接使用 <code>arr.toString()</code>？这是因为它的这个方法被重写了，即 <code>Array.prototype.toString()</code>。在使用 <code>arr.toString()</code> 的时候，它优先在原型链上找到并调用了重写的方法，最后输出的是 <code>&quot;1,2&quot;</code>。</p></li><li><p>对象字面量调用 <code>toString()</code> 的时候则依然输出 <code>&quot;[object Object]&quot;</code>，这是因为它没有重写这个方法，所以找到的是 <code>Object.prototype</code> 的该方法。</p></li><li><p>同样的，函数对象的 <code>toString()</code> 方法也被重写了，即 <code>Function.prototype.toString()</code>。调用的时候返回一个表示当前函数源代码的字符串。当对内置函数对象调用该方法时，返回如下格式的字符串：</p></li></ol><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// "function Object() {</span>
<span class="token comment" spellcheck="true">//    [native code]</span>
<span class="token comment" spellcheck="true">// }"</span>

Array<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// "function Array() { </span>
<span class="token comment" spellcheck="true">//    [native code] </span>
<span class="token comment" spellcheck="true">// }"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，这里的 Object 是构造函数，既然是函数，就可以看作是 Function 构造函数实例化的对象，因此这里相当于函数对象调用了 <code>toString()</code> 方法，也就是调用的 <code>Function.prototype.toString()</code> 方法。</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/09/08/F-Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="prev" title="Vue 生命周期与钩子函数"><i class="fa fa-angle-double-left"></i>&nbspVue 生命周期与钩子函数</a></div><div class="post-nav-next"><a href="/2019/08/05/F-call,apply%E5%92%8Cbind/" rel="next" title="call() 和 apply() 的相关介绍和应用场景">call() 和 apply() 的相关介绍和应用场景&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof"><span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-getPrototypeOf"><span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isPrototypeOf-NaN"><span class="toc-text">isPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype-toString-call"><span class="toc-text">Object.prototype.toString.call()</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2020</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->