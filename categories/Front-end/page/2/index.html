<!-- build time:Sun Sep 05 2021 14:32:53 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><div class="category-page-container"><div class="category-page-title"><span class="category_title">Front-end</span></div><div class="category-page-cards"><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/25/F-你的手写new实现足够严谨吗？/">你的手写 new 实现足够严谨吗？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-25&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.5k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp5 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/25/F-你的手写new实现足够严谨吗？/"><span id="more"></span><p>在开始阅读这篇文章之前，你可以对比下面这两段代码的输出结果是否一致（假设 <code>myNew</code> 是你自己实现的 new 操作）：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">F</span>()<span class="op">&#123;&#125;</span>
<span class="va">F</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">null</span>
<span class="kw">const</span> obj1 <span class="op">=</span> <span class="kw">new</span> <span class="at">F</span>()
<span class="kw">const</span> obj2 <span class="op">=</span> <span class="at">myNew</span>(F)

<span class="va">console</span>.<span class="at">log</span>(<span class="va">Object</span>.<span class="at">getPrototypeOf</span>(obj1))
<span class="va">console</span>.<span class="at">log</span>(<span class="va">Object</span>.<span class="at">getPrototypeOf</span>(obj2))</code></pre></div><p>如果不一样，那么可能说明你的 <code>myNew</code> 方法和标准的 <code>new</code> 操作之间存在着些许出入，这篇文章也许能够让你的方法更加完善 / 严谨。</p><h4 id="从-object.create-说起">从 <code>Object.create</code> 说起</h4><p>最近在刷一些手写实现原生方法的面试题，偶然看到了有一个 <code>Object.create()</code> 方法的实现是这么写的：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">myCreate</span> <span class="op">=</span> <span class="kw">function</span> (proto<span class="op">,</span> propertyObject <span class="op">=</span> <span class="kw">undefined</span>) <span class="op">&#123;</span>
  <span class="cf">if</span> (propertyObject <span class="op">===</span> <span class="kw">null</span>) <span class="op">&#123;</span>
    <span class="co">// 这里没有判断propertyObject是否是原始包装对象</span>
    <span class="cf">throw</span> <span class="st">&#39;TypeError&#39;</span>
  <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
    <span class="kw">function</span> <span class="at">Fn</span> () <span class="op">&#123;&#125;</span>
    <span class="va">Fn</span>.<span class="at">prototype</span> <span class="op">=</span> proto
    <span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">Fn</span>()
    <span class="cf">if</span> (propertyObject <span class="op">!==</span> <span class="kw">undefined</span>) <span class="op">&#123;</span>
      <span class="va">Object</span>.<span class="at">defineProperties</span>(obj<span class="op">,</span> propertyObject)
    <span class="op">&#125;</span>
    <span class="cf">if</span> (proto <span class="op">===</span> <span class="kw">null</span>) <span class="op">&#123;</span>
      <span class="co">// 创建一个没有原型对象的对象，Object.create(null)</span>
      <span class="va">obj</span>.<span class="at">__proto__</span> <span class="op">=</span> <span class="kw">null</span>
    <span class="op">&#125;</span>
    <span class="cf">return</span> obj
  <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>而这个方法在<a target="_blank" rel="noopener" href="http://es5.github.io/#x15.2.3.5">规范</a>里的实现是这样的：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/2.jpg"></div><p>简单地说，它会接受两个参数，第一个参数作为调用后返回对象的 <code>__proto__</code>，第二个参数负责配置该对象的相关属性。而<strong>这里的第一个参数，可以是对象也可以是 <code>null</code></strong>。</p><p>基本上，上面代码的实现没有什么问题，但是我突然产生了一个疑问：当第一个参数是 <code>null</code> 的时候，<code>Fn.prototype = proto</code> 已经把构造函数的原型对象设置为 <code>null</code>了，为什么后面还要在判断第一个参数为 <code>null</code> 之后设置 <code>obj.__proto__ = null</code> 呢？这两个语句的作用难道不是一样的吗？毕竟 <code>Fn.prototype</code> 和 <code>obj.__proto__</code> 都是指向同一个原型对象呀！</p><p>于是我将代码中的 <code>if (proto === null)</code> 判断去掉，并分别测试了 <code>Object.create()</code> 方法和 <code>Object.myCreate()</code> 方法：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/3.jpg"></div><p>可以看到，第二个打印是符合预期的，返回对象的 <code>__proto__</code>确实指向传入的参数 <code>null</code>；但第一个打印却和预想的不一样，展开打印对象后会发现，它其实是 <code>Object.prototype</code>。这是怎么回事呢？难道说代码中执行 <code>Fn.prototype = proto</code> 的时候，实际上实例的 <code>__proto__</code> 并没有跟着改变？</p><p>于是继续测试：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/4.jpg"></div><p>这里可以看到：用 <code>null</code> 重写构造函数的原型后，通过 new 构造函数创建的实例的 <code>__proto__</code> 并没有跟着变成 <code>null</code>，而是指向了 <code>Object.prototype</code>。</p><h4 id="调用构造函数的时候做了什么">调用构造函数的时候做了什么？</h4><p>这时候，我们可能会想到，通过 new 调用构造函数的时候，内部可能做了一些处理，导致最终返回的实例对象的 <code>__proto__</code> 和我们预期的不一致。既然如此，我们通过<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-13.2.2">规范</a>看一下调用构造函数的时候，具体做了什么事：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/5.jpg"></div><p>这里我们只需要关注第六步和第七步。这两步会检查构造函数的原型对象的类型，如果是一个对象，则会将其作为实例的 <code>__proto__</code>；如果不是对象，则会将 <code>Object.prototype</code> 作为实例的 <code>__proto__</code>。这就能解释为什么用 <code>null</code> 重写构造函数的原型后，实例的 <code>__proto__</code> 没有跟着改变了，因为在调用构造函数的过程中，它链接上了 <code>Object.prototype</code>，可以说，这里实例的原型链并没有断开。</p><h4 id="实现一个更严谨的-new">实现一个更严谨的 <code>new</code></h4><p>在大部分的手写 <code>new</code> 实现中，通常都没有去检查构造函数的原型是否是一个对象。有的实现中甚至直接使用了 <code>Object.create()</code> 方法以快速地建立原型关系，就像这样：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myNew</span>(Fn<span class="op">,</span>...<span class="at">args</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> Fn <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(Fn <span class="op">+</span> <span class="st">&#39;is not a constructor&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">const</span> instance <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="va">Fn</span>.<span class="at">prototype</span>)    
    <span class="kw">const</span> returnValue <span class="op">=</span> <span class="va">Fn</span>.<span class="at">call</span>(instance<span class="op">,</span>...<span class="at">args</span>)
    <span class="cf">return</span> returnValue <span class="kw">instanceof</span> Object <span class="op">?</span> returnValue : instance
<span class="op">&#125;</span></code></pre></div><p>这里直接使用<code>Object.create()</code> 方法，是有问题的。</p><p>在前面阅读规范的时候我们已经知道了，即使传给 <code>Object.create</code> 的参数是 <code>null</code>，也会将其作为创建的对象的 <code>__proto__</code>，所以这里如果使用了 <code>Object.create</code>，并且构造函数的原型 <code>Fn.prototype</code> 还恰好就是 <code>null</code> 的话，就会导致实例的 <code>__proto__</code> 也是 <code>null</code>，这和 <code>new</code> 的实际实现是有出入的。</p><p>所以，如果想实现一个更加严谨的 <code>new</code>，那么就不应该在内部去调用 <code>Object.create</code> 方法，而应该选择手动创建一个对象并和构造函数建立原型关系，同时，我们还应该加入对构造函数原型的类型判断，看它到底是不是一个对象。</p><p>因此，上面的代码可以修改如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myNew</span>(Fn<span class="op">,</span>...<span class="at">args</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> Fn <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(Fn <span class="op">+</span> <span class="st">&#39;is not a constructor&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">const</span> instance <span class="op">=</span> <span class="op">&#123;&#125;</span>
    <span class="co">// 检测构造函数原型是不是对象</span>
    <span class="va">instance</span>.<span class="at">__proto__</span> <span class="op">=</span> <span class="va">Fn</span>.<span class="at">prototype</span> <span class="at">instanceof</span> <span class="at">Object</span> <span class="op">?</span> <span class="va">Fn</span>.<span class="at">prototype</span> : <span class="va">Object</span>.<span class="at">prototype</span> 
    <span class="kw">const</span> returnValue <span class="op">=</span> <span class="va">Fn</span>.<span class="at">call</span>(instance<span class="op">,</span>...<span class="at">args</span>)
    <span class="cf">return</span> returnValue <span class="kw">instanceof</span> Object <span class="op">?</span> returnValue : instance
<span class="op">&#125;</span></code></pre></div><p>现在，我们再用这个改进之后的 <code>new</code> 去测试文章开头的代码：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/6.jpg"></div><p>可以看到，加入了对构造函数原型可能为 <code>null</code> 的处理之后，返回的实例的 <code>__proto__</code> 明确指向了 <code>Object.prototype</code>。现在我们实现的 <code>new</code> 就更加严谨了，而且也更接近原生的 <code>new</code> 操作。</p><p>本文到这里就结束了。不过，从语言设计的角度来说，为什么不将实例的 <code>__proto__</code> 也跟着设置为 <code>null</code> 呢？这里不断开实例的原型链，而是将其链接到 <code>Object.prototype</code> 有什么好处？大家可以在评论区留言讨论一下。另外，不排除本文存在原理性的错误或者说法上的偏颇，如果你发现了，也欢迎在评论区指正。</p><h4 id="参考">参考</h4><p>https://262.ecma-international.org/5.1/#sec-13.2.2</p><p>http://es5.github.io/#x15.2.3.5</p><p>https://stackoverflow.com/questions/18198178/null-prototype-object-prototype-and-object-create</p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/21/F-JS原生方法原理探究（一）：如何实现call、apply 和 bind？/">JS 原生方法原理探究（一）：如何实现 call、apply 和 bind？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-21&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.9k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp11 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/21/F-JS原生方法原理探究（一）：如何实现call、apply 和 bind？/"><span id="more"></span><p>这是 JS 原生方法原理探究系列的第一篇文章。本文会介绍如何实现 call、apply 和 bind 方法。关于这几个方法的具体用法，MDN 已经描述得很清楚了，这里不再赘述。</p><h2 id="手写实现-call">手写实现 call</h2><h3 id="es3-版本">ES3 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myCall</span> <span class="op">=</span> <span class="kw">function</span>(thisArg)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;The caller must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">undefined</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">&#125;</span>   
    <span class="kw">var</span> args <span class="op">=</span> []
    <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>i <span class="op">&lt;</span> <span class="va">arguments</span>.<span class="at">length</span><span class="op">;</span>i <span class="op">++</span>)<span class="op">&#123;</span>
        <span class="va">args</span>.<span class="at">push</span>(<span class="st">&#39;arguments[&#39;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&#39;]&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">var</span> res <span class="op">=</span> <span class="at">eval</span>(<span class="st">&#39;thisArg.fn(&#39;</span> <span class="op">+</span> args <span class="op">+</span> <span class="st">&#39;)&#39;</span>)
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">&#125;</span></code></pre></div><h3 id="es6-版本">ES6 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myCall</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>...<span class="at">args</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;The caller must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">undefined</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">&#125;</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">const</span> res <span class="op">=</span> <span class="va">thisArg</span>.<span class="at">fn</span>(...<span class="at">args</span>)
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">&#125;</span></code></pre></div><p>通过 <code>call</code> 调用函数的时候，可以通过传给 <code>call</code> 的 thisArg 指定函数中的 this。而只要使得函数是通过 thisArg 调用的，就能实现这一点，这就是我们的主要目标。</p><h3 id="实现要点">实现要点</h3><ol style="list-style-type:decimal"><li>最终是通过函数去调用 <code>myCall</code> 的，所以 <code>myCall</code> 和 <code>call</code> 一样挂载在函数原型上。同时，也正因为是通过函数去调用 <code>myCall</code> 的，所以在 <code>myCall</code> 内部我们可以通过 this 拿到 <code>myCall</code>的调用者，也就是实际执行的那个函数。</li><li>按理说，<code>myCall</code> 是挂载在函数原型上，当我们通过一个非函数去调用 <code>myCall</code> 的时候，肯定会抛出错误，那么为什么还要在 <code>myCall</code> 中检查调用者的类型，并自定义一个错误呢？这是因为，当一个调用者 <code>obj = &#123;&#125;</code> 是一个对象，但是继承自 <code>Function</code> 的时候（<code>obj.__proto__ = Function.prototype</code>），它作为一个非函数实际上也是可以调用 <code>myCall</code> 方法的，这时候如果不进行类型检查以确保它是个函数，那么后面直接将它当作函数调用的时候，就会抛出错误了</li><li>传给 <code>call</code> 的 thisArg 如果是 null 或者 undefined，那么 thisArg 实际上会指向全局对象；如果 thisArg 是一个基本类型，那么可以使用 <code>Object()</code> 做一个装箱操作，将其转化为一个对象 —— 主要是为了确保后续可以以方法调用的方式去执行函数。那么可不可以写成 <code>thisArg = thisArg ? Object(thisArg) : globalThis</code> 呢？其实是不可以的，如果 thisArg 是布尔值 false，那么会导致 thisArg 最终等于 globalThis，但实际上它应该等于 <code>Boolean &#123;false&#125;</code>。</li><li>前面说过，可以在 <code>myCall</code> 里通过 this 拿到实际执行的那个函数，所以 <code>thisArg.fn = this</code> 相当于将这个函数作为 thisArg 的一个方法，后面我们就可以通过 thisArg 对象去调用这个函数了。</li><li><code>thisArg.fn = this</code> 相当于是给 thisArg 增加了一个 fn 属性，所以返回执行结果之前要 delete 这个属性。此外，为了避免覆盖 thisArg 上可能存在的同名属性 fn，这里也可以使用 <code>const fn = Symbol('fn')</code> 构造一个唯一属性，然后 <code>thisArg[fn] = this</code>。</li><li>ES3 版本和 ES6 版本主要的区别在于参数的传递以及函数的执行上：</li><li>ES6 因为引入了剩余参数，所以不管实际执行函数的时候传入了多少个参数，都可以通过 args 数组拿到这些参数，同时因为引入了展开运算符，所以可以展开 args 参数数组，把参数一个个传递给函数执行</li><li>但在 ES3 中没有剩余参数这个东西，所以在定义 <code>myCall</code> 的时候只接收一个 thisArg 参数，然后在函数体中通过 arguments 类数组拿到所有参数。我们需要的是 arguments 中除第一个元素（thisArg）之外的所有元素，怎么做呢？如果是 ES6，直接<code>[...arguments].slice(1)</code>就可以了，但这是 ES3，于是我们只能从索引 1 开始遍历 arguments，然后 push 到一个 args 数组中了。而且还要注意的是，这里 push 进去的是字符串形式的参数，这主要是为了方便后续通过 eval 执行函数的时候，将参数一个一个传递给函数。</li><li>为什么必须通过 eval 才能执行函数呢？因为我们不知道函数实际上要接收多少个参数，况且也用不了展开运算符，所以只能构造一个可执行的字符串表达式，显式地传入函数的所有参数。</li></ol><h2 id="手写实现-apply">手写实现 apply</h2><p>apply 的用法和 call 很类似，因此实现也很类似。需要注意的区别是，call 在接受一个 thisArg 参数之后还可以接收多个参数（即接受的是参数列表），而 apply 在接收一个 thisArg 参数之后，通常第二个参数是一个数组或者类数组对象：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">fn</span>.<span class="at">call</span>(thisArg<span class="op">,</span>arg1<span class="op">,</span>arg2<span class="op">,</span>...)
<span class="va">fn</span>.<span class="at">apply</span>(thisArg<span class="op">,</span>[arg1<span class="op">,</span>arg2<span class="op">,</span>...])        </code></pre></div><p>如果第二个参数传的是 null 或者 undefined，那么相当于是整体只传了 thisArg 参数。</p><h3 id="es3-版本-1">ES3 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myApply</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>args)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">&#125;</span> 
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(args <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> args <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
        args <span class="op">=</span> []
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="cf">if</span>(<span class="op">!</span><span class="va">Array</span>.<span class="at">isArray</span>(args))<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;CreateListFromArrayLike called on non-object&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">var</span> _args <span class="op">=</span> []
    <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>i <span class="op">&lt;</span> <span class="va">args</span>.<span class="at">length</span><span class="op">;</span>i <span class="op">++</span>)<span class="op">&#123;</span>
        <span class="va">_args</span>.<span class="at">push</span>(<span class="st">&#39;args[&#39;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&#39;]&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">var</span> res <span class="op">=</span> <span class="va">_args</span>.<span class="at">length</span> <span class="op">?</span> <span class="at">eval</span>(<span class="st">&#39;thisArg.fn(&#39;</span> <span class="op">+</span> _args <span class="op">+</span> <span class="st">&#39;)&#39;</span>):<span class="va">thisArg</span>.<span class="at">fn</span>()
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">&#125;</span></code></pre></div><h3 id="es6-版本-1">ES6 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myApply</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>args)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> thisArg <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">&#125;</span> 
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(args <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> args <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
        args <span class="op">=</span> []
    <span class="op">&#125;</span> 
    <span class="co">// 如果传入的不是数组，仿照 apply 抛出错误</span>
    <span class="cf">else</span> <span class="cf">if</span>(<span class="op">!</span><span class="va">Array</span>.<span class="at">isArray</span>(args))<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;CreateListFromArrayLike called on non-object&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">const</span> res <span class="op">=</span> <span class="va">thisArg</span>.<span class="at">fn</span>(...<span class="at">args</span>)
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">&#125;</span></code></pre></div><h3 id="实现要点-1">实现要点</h3><p>基本上和 call 的实现是差不多的，只是我们需要检查第二个参数的类型。</p><h2 id="手写实现-bind">手写实现 bind</h2><p><code>bind</code> 也可以像 <code>call</code> 和 <code>apply</code> 那样给函数绑定一个 this，但是有一些不同的要点需要注意：</p><ul><li><code>bind</code> 不是指定完 this 之后直接调用原函数，而是基于原函数返回一个内部完成了 this 绑定的新函数</li><li>原函数的参数可以分批次传递，第一批可以在调用 <code>bind</code> 的时候作为第二个参数传入，第二批可以在调用新函数的时候传入，这两批参数最终会合并在一起，一次传递给新函数去执行</li><li>新函数如果是通过 new 方式调用的，那么函数内部的 this 会指向实例，而不是当初调用 <code>bind</code> 的时候传入的 thisArg。换句话说，这种情况下的 <code>bind</code> 相当于是无效的</li></ul><h3 id="es3-版本-2">ES3 版本</h3><p>这个版本更接近 MDN 上的 polyfill 版本。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myBind</span> <span class="op">=</span> <span class="kw">function</span>(thisArg)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">var</span> fnToBind <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">var</span> args1 <span class="op">=</span> <span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">slice</span>.<span class="at">call</span>(arguments<span class="op">,</span><span class="dv">1</span>)
    <span class="kw">var</span> fnBound <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;</span>
        <span class="co">// 如果是通过 new 调用</span>
        <span class="cf">return</span> <span class="va">fnToBind</span>.<span class="at">apply</span>(<span class="kw">this</span> <span class="kw">instanceof</span> fnBound <span class="op">?</span> <span class="kw">this</span>:thisArg<span class="op">,</span><span class="va">args1</span>.<span class="at">concat</span>(args2))
    <span class="op">&#125;</span>
    <span class="co">// 实例继承</span>
    <span class="kw">var</span> Fn <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
    <span class="va">Fn</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">this</span>.<span class="at">prototype</span>
    <span class="va">fnBound</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">Fn</span>()
    <span class="cf">return</span> fnBound
<span class="op">&#125;</span></code></pre></div><h3 id="es6-版本-2">ES6 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myBind</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>...<span class="at">args1</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">const</span> fnToBind <span class="op">=</span> <span class="kw">this</span>
    <span class="cf">return</span> <span class="kw">function</span> <span class="at">fnBound</span>(...<span class="at">args2</span>)<span class="op">&#123;</span>
        <span class="co">// 如果是通过 new 调用的</span>
        <span class="cf">if</span>(<span class="kw">this</span> <span class="kw">instanceof</span> fnBound)<span class="op">&#123;</span>
            <span class="cf">return</span> <span class="kw">new</span> <span class="at">fnToBind</span>(...<span class="at">args1</span><span class="op">,</span>...<span class="at">args2</span>)
        <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
            <span class="cf">return</span> <span class="va">fnToBind</span>.<span class="at">apply</span>(thisArg<span class="op">,</span>[...<span class="at">args1</span><span class="op">,</span>...<span class="at">args2</span>])
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><h3 id="实现要点-2">实现要点</h3><ol style="list-style-type:decimal"><li><p><code>bind</code> 实现内部 this 绑定，需要借助于 <code>apply</code>，这里假设我们可以直接使用 <code>apply</code> 方法</p></li><li><p>先看比较简单的 ES6 版本:</p></li><li><strong>参数获取</strong>：因为 ES6 可以使用剩余参数，所以很容易就可以获取执行原函数所需要的参数，而且也可以用展开运算符轻松合并数组。</li><li><p><strong>调用方式</strong>：前面说过，如果返回的新函数 fnBound 是通过 new 调用的，那么其内部的 this 会是 fnBound 构造函数的实例，而不是当初我们指定的 thisArg，因此 <code>this instanceof fnBound</code>会返回 true，这种情况下，相当于我们指定的 thisArg 是无效的，new 返回的新函数等价于 new 原来的旧函数，即 new fnBound 等价于 new fnToBind，所以我们返回一个 new fnToBind 即可；反之，如果 fnBound 是普通调用，则通过 apply 完成 thisArg 的绑定，再返回最终结果。从这里可以看出，bind 的 this 绑定，本质上是通过 apply 完成的。</p></li><li><p>再来看比较麻烦一点的 ES3 版本：</p></li><li><p><strong>参数获取</strong>：现在我们用不了剩余参数了，所以只能在函数体内部通过 arguments 获取所有参数。对于 <code>myBind</code>，我们实际上需要的是除开第一个传入的 thisArg 参数之外的剩余所有参数构成的数组，所以这里可以通过 <code>Array.prototype.slice.call</code> 借用数组的 slice 方法（arguments 是类数组，无法直接调用 slice），这里的借用有两个目的：一是除去 arguments 中的第一个参数，二是将除去第一个参数之后的 arguments 转化为数组（slice 本身的返回值就是一个数组，这也是类数组转化为数组的一种常用方法）。同样地，返回的新函数 fnBound 后面调用的时候也可能传入参数，再次借用 slice 将 arguments 转化为数组</p></li><li><p><strong>调用方式</strong>：同样，这里也要判断 fnBound 是 new 调用还是普通调用。在 ES6 版本的实现中，如果是 new 调用 fnBound，那么直接返回 <code>new fnToBind()</code>，这实际上是最简单也最容易理解的方式，我们在访问实例属性的时候，天然就是按照 <code>实例 =&gt; 实例.__proto__ = fnToBind.prototype</code> 这样的原型链来寻找的，可以确保实例成功访问其构造函数 fnToBInd 的原型上面的属性；但在 ES3 的实现中（或者在网上部分 bind 方法的实现中），我们的做法是返回一个 <code>fnToBind.apply(this)</code>，实际上相当于返回一个 undefined 的函数执行结果，根据 new 的原理，我们没有在构造函数中自定义一个返回对象，因此 new 的结果就是返回实例本身，这点是不受影响的。这个返回语句的问题在于，它的作用仅仅只是确保 fnToBind 中的 this 指向 new fnBound 之后返回的实例，而并没有确保这个实例可以访问 fnToBind 的原型上面的属性。实际上，它确实不能访问，因为它的构造函数是 fnBound 而不是 fnToBind，所以我们要想办法在 fnBound 和 fnToBind 之间建立一个原型链关系。这里有几种我们可能会使用的方法：</p><p><code>js // 这里的 this 指的是 fnToBind fnBound.prototype = this.prototype</code></p><p>这样只是拷贝了原型引用，如果修改 <code>fnBound.prototype</code>，则会影响到 <code>fnToBind.prototype</code>，所以不能用这种方法</p><p><code>js // this 指的是 fnToBind fnBound.prototype = Object.create(this.prototype)</code></p><p>通过 <code>Object.create</code> 可以创建一个 <code>__proto__</code> 指向 <code>this.prototype</code> 的实例对象，之后再让 <code>fnBound.prototype</code> 指向这个对象，则可以在 fnToBind 和 fnBound 之间建立原型关系。但由于 <code>Object.create</code> 是 ES6 的方法，所以无法在我们的 ES3 代码中使用。</p><p><code>js // this 指的是 fnToBind const Fn = function()&#123;&#125; Fn.prototype = this.prototype fnBound.prototype = new Fn()</code></p><p>这是上面代码采用的方法：通过空构造函数 Fn 在 fnToBind 和 fnBound 之间建立了一个联系。如果要通过实例去访问 fnToBind 的原型上面的属性，可以沿着如下原型链查找：</p><p><code>实例 =&gt; 实例.__proto__ = fnBound.prototype = new Fn() =&gt; new Fn().__proto__ = Fn.prototype = fnToBind.prototype</code></p></li></ol><p>​</p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/07/29/F-Vue+Koa前后端分离项目线上部署/">Vue+Koa2 前后端分离项目线上部署</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-29&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4.1k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp16 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/07/29/F-Vue+Koa前后端分离项目线上部署/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%2BKoa%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2/d0.jpg"></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/07/27/F-concurrently实现前后端连载启动/">concurrently 实现前后端连载启动</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-27&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp393&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp1 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/07/27/F-concurrently实现前后端连载启动/"><span id="more"></span><p>在做一个 Vue + koa2 技术栈的前后端项目时，常常需要通过终端分别启动前端和后端服务，通过安装 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/concurrently">concurrently</a> 模块，可以做到前后端连载启动。</p><p>以我项目的目录结构为例：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">Project
<span class="op">|--</span> Front<span class="op">-</span>end
    <span class="op">|--</span> <span class="im">package</span><span class="op">,</span>json
<span class="op">|--</span> Back<span class="op">-</span>end
    <span class="op">|--</span> <span class="im">package</span>.<span class="at">json</span></code></pre></div><p>首先来到 <code>Back-end</code> 文件夹下，安装模块：</p><pre class="shell"><code>npm install concurrently</code></pre><p>配置前端项目的 <code>package.json</code>：</p><div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json">  <span class="er">&quot;scripts&quot;:</span> <span class="fu">&#123;</span>
    <span class="dt">&quot;dev&quot;</span><span class="fu">:</span> <span class="st">&quot;vue-cli-service serve&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;start&quot;</span><span class="fu">:</span> <span class="st">&quot;npm run dev&quot;</span>
  <span class="fu">&#125;</span><span class="er">,</span></code></pre></div><p>配置后端项目的 <code>package.json</code>：</p><div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json">  <span class="er">&quot;scripts&quot;:</span> <span class="fu">&#123;</span>
    <span class="dt">&quot;client&quot;</span><span class="fu">:</span> <span class="st">&quot;npm run start --prefix ../Admin-frontend&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;server&quot;</span><span class="fu">:</span> <span class="st">&quot;nodemon app.js&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;dev&quot;</span><span class="fu">:</span> <span class="st">&quot;concurrently </span><span class="ch">\&quot;</span><span class="st">npm run server</span><span class="ch">\&quot;</span><span class="st"> </span><span class="ch">\&quot;</span><span class="st">npm run client</span><span class="ch">\&quot;</span><span class="st">&quot;</span>
  <span class="fu">&#125;</span><span class="er">,</span></code></pre></div><p>这样基本就 ok 了，说几个注意事项：</p><ul><li>因为到时候是用 <code>npm run dev</code> 指令一键启动整个项目的，这个指令和前端项目的启动指令冲突了，所以前端项目再配置一个额外的指令 <code>start</code></li><li>执行 <code>npm run dev</code> ，本质上是执行 <code>npm run server</code> 和 <code>npm run client</code>，前者负责用 nodemon + 后端项目入口文件（<code>app.js</code>）启动后端项目，后者负责调用此前前端项目额外配置的启动指令。</li><li><code>client</code> 指令配置的时候需要跟上前端项目根目录的路径。这是一个相对路径，比方说我如果把整个前端项目丢进 <code>Back-end</code> 文件夹，和 <code>package.json</code> 同一个目录，那么我这时候路径就只需要写 <code>Front-end</code> 即可</li></ul><p>最后 <code>npm run dev</code>，看到这样的提示就说明成功了：</p><div class="figure"><img src="https://i.loli.net/2020/07/27/ToX8LmztbfEqrUI.png"></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/07/26/F-聊一聊：一道 Promise 链式调用的题目/">聊一聊：一道 Promise 链式调用的题目</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp13 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/07/26/F-聊一聊：一道 Promise 链式调用的题目/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/0.jpg"></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/07/19/F-微信小程序订阅消息推送/">微信小程序订阅消息推送</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-19&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp5 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/07/19/F-微信小程序订阅消息推送/"><span id="more"></span><p>这几天在使用小程序的模板消息推送接口的时候，出现了个报错信息 “the formId is no longer available in develop or trial version”，去文档查看了一下才发现，模板消息功能在今年1月份已经下架了，现在统一都是使用订阅消息：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/1.png"></div><p>那么这两个功能有什么区别呢？</p><p><strong>模板消息推送</strong></p><p>简单地说，用户每进行一次提交表单或是支付行为，都会产生一个 formId，开发者可以通过这个 formId 向用户推送消息。由于下发权限是在开发者这边，为了防止消息频繁推送对用户造成的骚扰，小程序做出了一个限制：一个 formId 只有 7 天有效期，每推送一次消息会消耗一个 formId，也就是说，正常情况下，开发者 7 天内可以推送的消息数量是有限的。这样当然对用户是友好的，但是对开发者来说，有些业务场景又确实推送多条消息：比如说 A 用户发布一个二手商品，B 用户点击了“感兴趣”，需要推送消息告知 A 用户，同理，C 用户也点击了“感兴趣”，同样需要推送消息告知 A 用户，这种情况下一个 formId 肯定是不够用的。于是在订阅消息出现以前，开发者就使用了一些黑科技来收集 formId：包括基于事件冒泡的多层嵌套表单，以及在小程序里埋藏大量的点击事件等，只要用户点击了就会触发表单提交，生成新的 formId，然后记录下有效期存放到数据库中，方便后续的使用。</p><p>不过有不少的黑科技已经被微信官方修复了，而且我们会发现，最终还是回到了起点，仍然没有解决用户受到消息骚扰的问题。微信大概也意识到了这一点，所以推出了订阅消息功能。</p><p><strong>订阅消息推送</strong></p><p>举个订阅消息的例子：当我们参与某个公众号的抽奖活动之后，会有弹窗提示我们是否接受抽奖结果的信息推送，这个弹窗就属于订阅消息功能的授权环节。</p><p>从使用体验来看，订阅消息推送最大的特征就在于，它对于用户和开发者都是友好的。首先，消息下发的权限交还给了用户，由用户自己来决定要不要接受消息推送，不再像之前那样被动接受了；其次，对于我们开发者来说，只需要调用接口询问用户是否接受消息推送即可，只要用户同意，那么我们就可以多次发送消息，不再需要像以前那样费力去收集 formId 了。</p><p><strong>使用</strong></p><p>首先登录微信公众平台，选择 订阅消息 —— 我的模板 —— 添加，然后根据自己的需求选择一个模板，配置关键字，提交之后即可获得模板对应的模板 Id，这个 Id 稍后调用 api 的时候会用到，当然，同样需要用到的还有关键字对应的参数：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/2.png"></div><p>小程序端代码：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> templateId <span class="op">=</span> <span class="st">&#39;Ite6-mnfTlONu6rd35AJ-SGQYKQgj1WMvjVj0O5h9kE&#39;</span>
<span class="va">wx</span>.<span class="at">requestSubscribeMessage</span>(<span class="op">&#123;</span>
    <span class="dt">tmplIds</span><span class="op">:</span> [templateId]<span class="op">,</span>
    <span class="dt">success</span><span class="op">:</span> (res)<span class="op">=&gt;</span> <span class="op">&#123;</span>
        <span class="co">// 如果用户点击允许</span>
        <span class="cf">if</span>(res[templateId] <span class="op">==</span> <span class="st">&#39;accept&#39;</span>)<span class="op">&#123;</span>
            <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;点击了允许&#39;</span>)
            <span class="va">wx</span>.<span class="va">cloud</span>.<span class="at">callFunction</span>(<span class="op">&#123;</span>
                <span class="dt">name</span><span class="op">:</span><span class="st">&#39;sendMessage&#39;</span><span class="op">,</span>
                <span class="dt">data</span><span class="op">:&#123;</span>
                    templateId<span class="op">,</span>
                    <span class="dt">content</span><span class="op">:</span> <span class="kw">this</span>.<span class="va">data</span>.<span class="at">textContent</span><span class="op">,</span>
                    <span class="dt">blogId</span><span class="op">:</span> <span class="kw">this</span>.<span class="va">properties</span>.<span class="at">blogid</span><span class="op">,</span>
                <span class="op">&#125;</span>
            <span class="op">&#125;</span>).<span class="at">then</span>(res <span class="op">=&gt;</span> <span class="op">&#123;</span>                      
                <span class="kw">this</span>.<span class="at">setData</span>(<span class="op">&#123;</span>
                    <span class="dt">textContent</span><span class="op">:</span><span class="st">&#39;&#39;</span>
                <span class="op">&#125;</span>)
            <span class="op">&#125;</span>)
        <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
            <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;点击了取消&#39;</span>)
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>
    <span class="dt">fail</span><span class="op">:</span>(res) <span class="op">=&gt;</span> <span class="op">&#123;&#125;</span>
<span class="op">&#125;</span>) </code></pre></div><p><code>wx.requestSubscribeMessage</code> 这个 api 主要用来调起弹窗询问用户是否接受消息推送，<code>tmplIds</code> 数组存放各类模板 Id，因为开发者可能不止使用了一个模板。</p><p>这里要注意两个地方，第一个是这个 api 只能在点击事件或者触发支付回调后使用，<code>bindsubmit</code> 表单提交事件是用不了的；第二个是，不管用户点击允许还是拒绝，都会来到 success 回调，fail 回调是在 api 本身调用失败后执行的。那么怎么判断用户是点击了允许还是拒绝（取消）呢？如果用户点击了允许，那么 res 中模板 Id 键对应的键值会是 “accept”（反之则是 “reject”），然后调用相应的云函数并传参，进行消息推送。</p><p>在云函数中调用相关 api 之前，要先去云函数文件夹下的 <code>config.JSON</code> 文件设置调用权限：</p><div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json"><span class="fu">&#123;</span>
  <span class="dt">&quot;permissions&quot;</span><span class="fu">:</span> <span class="fu">&#123;</span>
    <span class="dt">&quot;openapi&quot;</span><span class="fu">:</span> <span class="ot">[</span>
      <span class="st">&quot;subscribeMessage.send&quot;</span>
    <span class="ot">]</span>
  <span class="fu">&#125;</span>
<span class="fu">&#125;</span></code></pre></div><p>相关的云函数：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> cloud <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;wx-server-sdk&#39;</span>)
<span class="va">cloud</span>.<span class="at">init</span>()

<span class="va">exports</span>.<span class="at">main</span> <span class="op">=</span> <span class="at">async</span> (event<span class="op">,</span> context) <span class="op">=&gt;</span> <span class="op">&#123;</span>
  <span class="kw">const</span> <span class="op">&#123;</span>OPENID<span class="op">&#125;</span> <span class="op">=</span> <span class="va">cloud</span>.<span class="at">getWXContext</span>()

  <span class="cf">return</span> await <span class="va">cloud</span>.<span class="va">openapi</span>.<span class="va">subscribeMessage</span>.<span class="at">send</span>(<span class="op">&#123;</span>
    <span class="dt">touser</span><span class="op">:</span> OPENID<span class="op">,</span>
    <span class="dt">page</span><span class="op">:</span> <span class="vs">`/pages/blog-comments/blog-comments?blogId=</span><span class="sc">$&#123;</span><span class="va">event</span>.<span class="at">blogId</span><span class="sc">&#125;</span><span class="vs">`</span><span class="op">,</span>
    <span class="dt">data</span><span class="op">:&#123;</span>
      <span class="dt">thing4</span><span class="op">:&#123;</span>
        <span class="dt">value</span><span class="op">:</span><span class="st">&#39;评价完成&#39;</span>
      <span class="op">&#125;,</span>
      <span class="dt">thing1</span><span class="op">:&#123;</span>
        <span class="dt">value</span><span class="op">:</span> <span class="va">event</span>.<span class="at">content</span>
      <span class="op">&#125;</span>
    <span class="op">&#125;,</span>
    <span class="dt">templateId</span><span class="op">:</span> <span class="va">event</span>.<span class="at">templateId</span>
  <span class="op">&#125;</span>)
<span class="op">&#125;</span></code></pre></div><p>主要是用到了 <code>cloud.openapi.subscribeMessage.send()</code> 这个 api，相关的参数就根据自己的实际情况来：这里的 <code>OPENID</code> 是消息发送目标的 <code>openid</code>，<code>page</code> 则是用户点击消息后进入的页面（这里是评论详情页），<code>data</code> 就对应我们之前在微信公众平台设置的模板关键字，当然，这里要注意使用此前模板提供的键名（<code>thing4</code> 和 <code>thing1</code>），最后还有一个参数就是我们的模板 Id 啦。其实和之前模板消息的用法是差不多的，只不过我们不再需要传参 fromId 了。</p><p>最后，对用户来说，他也可以在弹窗的时候点击允许和记住选择，这样就是默认每次都接受消息推送了，对应的就是默认执行 <code>wx.requestSubscribeMessage</code> 中的 if 代码块。</p><p>其实，不谈技术，单从用户的角度来看，这个功能的调整其实是很人性化的，选择权确实本就应该掌握在用户手中，如果用户没有权限拒收不需要的消息，这样的产品还谈什么用户体验呢？在查阅相关资料的时候，也看到了一篇从产品角度分析的<a target="_blank" rel="noopener" href="http://www.woshipm.com/pd/3003619.html">文章</a>，感觉写得不错，感兴趣的可以看一看。</p><p>参考：</p><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html#method-cloud">小程序官方文档</a></p><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/小程序/">小程序</a></span></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/07/11/F-记一次小程序开发的踩坑之旅/">记一次小程序开发的踩坑之旅</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-11&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp8 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/07/11/F-记一次小程序开发的踩坑之旅/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/0.png"></div><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/小程序/">小程序</a></span></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/06/29/F-打开Devtools前后对象的打印有什么区别？/">打开DevTools前后，对象的打印有什么区别？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-06-29&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.2k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp4 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/06/29/F-打开Devtools前后对象的打印有什么区别？/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%89%93%E5%BC%80DevTools%E5%89%8D%E5%90%8E%EF%BC%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/0.png" alt="chrome-devtools"><p class="caption">chrome-devtools</p></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/05/13/F-记两道关于事件循环的题/">记两道关于事件循环的题</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-05-13&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp9 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/05/13/F-记两道关于事件循环的题/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-1.png"></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/04/29/F-如何在Vue项目中更优雅地使用svg/">如何在Vue项目中更优雅地使用svg</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-04-29&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp6 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/04/29/F-如何在Vue项目中更优雅地使用svg/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9B%B4%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8svg/%E5%A6%82%E4%BD%95%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9B%B4%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8svg-0.png"></div><div class="default">阅读全文......</div></a></div></article></section></div><nav class="pager-nav"><a class="extend prev" rel="prev" href="/categories/Front-end/">« Prev</a><a class="page-number" href="/categories/Front-end/">1</a><span class="page-number current">2</span><a class="page-number" href="/categories/Front-end/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/categories/Front-end/page/7/">7</a><a class="extend next" rel="next" href="/categories/Front-end/page/3/">Next »</a></nav></div></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->