<!-- build time:Sun Sep 05 2021 14:32:53 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><div class="category-page-container"><div class="category-page-title"><span class="category_title">Front-end</span></div><div class="category-page-cards"><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/09/05/F-万字梳理  Webpack 常用配置和优化方案/">万字梳理 Webpack 常用配置和优化方案</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-09-05&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp11.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp46 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/09/05/F-万字梳理  Webpack 常用配置和优化方案/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/webpack%E5%AD%A6%E4%B9%A0-0-1.png"></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/08/01/F-JS 原生方法原理探究（十）：如何手写实现 PromiseA+ 及相关方法？/">JS 原生方法原理探究（十）：如何手写实现 Promise/A+ 及相关方法？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-08-01&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp8.5k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp37 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/08/01/F-JS 原生方法原理探究（十）：如何手写实现 PromiseA+ 及相关方法？/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JS%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/5.jpeg"></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/07/09/F-JS原生方法原理探究（九）：如何实现浅拷贝和深拷贝？/">JS 原生方法原理探究（九）：如何手写实现浅拷贝和深拷贝？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-07-09&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.5k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp14 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/07/09/F-JS原生方法原理探究（九）：如何实现浅拷贝和深拷贝？/"><span id="more"></span><blockquote><p>这是JS 原生方法原理探究系列的第九篇文章。本文会介绍如何手写实现浅拷贝和深拷贝。</p></blockquote><h2 id="实现浅拷贝">实现浅拷贝</h2><h3 id="什么是浅拷贝">什么是浅拷贝？</h3><p>对原对象进行浅拷贝，会生成一个和它“一样”的新对象。但是这种拷贝只会拷贝原对象第一层的基本类型属性，引用类型属性仍然和原对象共享同一个。</p><p>用一个简单的例子来理解：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> obj1 <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="st">&#39;Jack&#39;</span><span class="op">,</span>
    <span class="dt">b</span><span class="op">:</span> <span class="op">&#123;</span>
        <span class="dt">c</span><span class="op">:</span> <span class="dv">1</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">let</span> obj2 <span class="op">=</span> <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">&#123;&#125;,</span>obj1)
<span class="va">obj1</span>.<span class="at">a</span> <span class="op">=</span> <span class="st">&#39;Tom&#39;</span>
<span class="va">obj1</span>.<span class="va">b</span>.<span class="at">c</span> <span class="op">=</span> <span class="dv">2</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">obj1</span>.<span class="at">a</span>)      <span class="co">// &#39;Tom&#39;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">obj2</span>.<span class="at">a</span>)      <span class="co">// &#39;Jack&#39;   </span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">obj1</span>.<span class="va">b</span>.<span class="at">c</span>)    <span class="co">// 2</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">obj2</span>.<span class="va">b</span>.<span class="at">c</span>)    <span class="co">// 2</span></code></pre></div><p>可以看到，因为新对象拷贝了原对象第一层的基本类型属性，所以修改 <code>obj1.a</code> 的值并不会影响 <code>obj2.a</code> 的值；同时，因为新对象和原对象共享同一个第一层的引用类型属性，所以修改 <code>obj1.b</code> 对象也会影响到 <code>obj2.b</code> 对象。</p><h3 id="如何实现浅拷贝">如何实现浅拷贝？</h3><p>JS 中常见的浅拷贝方法有 <code>Object.assign()</code>、<code>...</code> 展开运算符以及数组的 <code>slice</code> 方法。但是如果我们要自己实现一个浅拷贝，应该怎么做呢？</p><p>其实也很简单，因为浅拷贝只作用在第一层，所以只需要遍历原对象，将它的每一个成员添加到新对象上就行。这里说的原对象指的是对象字面量、数组、类数组对象、Set 以及 Map 这些可以遍历的对象。对于其它的不可遍历对象以及基本类型的值直接将其返回即可。</p><p>代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">getType</span>(obj)<span class="op">&#123;</span>
    <span class="cf">return</span> <span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toSrting</span>.<span class="at">call</span>(obj).<span class="at">slice</span>(<span class="dv">8</span><span class="op">,-</span><span class="dv">1</span>)
<span class="op">&#125;</span>
<span class="co">// 可以遍历的数据类型</span>
<span class="kw">let</span> iterableList <span class="op">=</span> [<span class="st">&#39;Object&#39;</span><span class="op">,</span><span class="st">&#39;Array&#39;</span><span class="op">,</span><span class="st">&#39;Arguments&#39;</span><span class="op">,</span><span class="st">&#39;Set&#39;</span><span class="op">,</span><span class="st">&#39;Map&#39;</span>]
<span class="co">// 浅拷贝</span>
<span class="kw">function</span> <span class="at">shallowCopy</span>(obj)<span class="op">&#123;</span>
    <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(obj)
    <span class="cf">if</span>(<span class="op">!</span><span class="va">iterableList</span>.<span class="at">includes</span>(type)) <span class="cf">return</span> obj
    <span class="kw">let</span> res <span class="op">=</span> <span class="kw">new</span> <span class="va">obj</span>.<span class="at">constructor</span>()
    <span class="co">// 如果是 Set 或者 Map</span>
    <span class="va">obj</span>.<span class="at">forEach</span>((value<span class="op">,</span>key) <span class="op">=&gt;</span> <span class="op">&#123;</span>
        type <span class="op">===</span> <span class="st">&#39;Set&#39;</span> <span class="op">?</span> <span class="va">res</span>.<span class="at">add</span>(value) : <span class="va">res</span>.<span class="at">set</span>(key<span class="op">,</span>value)
    <span class="op">&#125;</span>)        
    <span class="co">// 如果是对象字面量、类数组对象或者数组</span>
    <span class="va">Reflect</span>.<span class="at">ownKeys</span>(obj).<span class="at">forEach</span>(key <span class="op">=&gt;</span> <span class="op">&#123;</span>
        res[key] <span class="op">=</span> obj[key]
    <span class="op">&#125;</span>)        
    <span class="cf">return</span> res
<span class="op">&#125;</span></code></pre></div><p>一些要点：</p><ul><li>初始化新对象 <code>res</code>：获取原对象 <code>obj</code> 的构造函数，用于创建一个和原对象同类型的实例</li><li>这里遍历对象或者数组有三种方式，第一种是使用 <code>Reflect.ownKeys()</code> 获取自身所有属性（无论是否可以枚举），第二种是使用 <code>for……in</code> + <code>hasOwnProperty()</code> 获取自身所有可枚举属性，第三种是使用 <code>Object.keys()</code> 一次性获取自身所有可枚举属性</li></ul><h2 id="实现深拷贝">实现深拷贝</h2><h3 id="什么是深拷贝">什么是深拷贝？</h3><p>对原对象进行深拷贝，会生成一个和它“一样”的新对象。深拷贝会拷贝原对象所有层级上的基本类型属性和引用类型属性。还是通过一个例子理解一下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> obj1 <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="st">&#39;Jack&#39;</span><span class="op">,</span>
    <span class="dt">b</span><span class="op">:</span> <span class="op">&#123;</span>
        <span class="dt">c</span><span class="op">:</span> <span class="dv">1</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">let</span> obj2 <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(<span class="va">JSON</span>.<span class="at">stringify</span>(obj1))
<span class="va">obj1</span>.<span class="at">a</span> <span class="op">=</span> <span class="st">&#39;Tom&#39;</span>
<span class="va">obj1</span>.<span class="va">b</span>.<span class="at">c</span> <span class="op">=</span> <span class="dv">2</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">obj1</span>.<span class="at">a</span>)      <span class="co">// &#39;Tom&#39;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">obj2</span>.<span class="at">a</span>)      <span class="co">// &#39;Jack&#39;   </span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">obj1</span>.<span class="va">b</span>.<span class="at">c</span>)    <span class="co">// 2</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">obj2</span>.<span class="va">b</span>.<span class="at">c</span>)    <span class="co">// 1</span></code></pre></div><p>可以看到，无论对 <code>obj1</code> 作出什么修改，都不会影响到 <code>obj2</code>，反之亦然，两者是完全独立的。</p><h3 id="如何实现深拷贝">如何实现深拷贝？</h3><p>常见的实现深拷贝的方式是 <code>JSON.parse(JSON.stringify())</code>。它可以应付一般的深拷贝场景，但是也存在着不少问题，这些问题基本都是出现在序列化的环节。</p><ol style="list-style-type:decimal"><li>Date 类型的属性经过深拷贝之后会变成字符串：</li></ol><p><code>js let obj = &#123; date : new Date() &#125; JSON.parse(JSON.stringify(obj)) // &#123;date: &quot;2021-07-04T13:01:35.934Z&quot;&#125;</code></p><ol start="2" style="list-style-type:decimal"><li>正则类型和错误类型的属性经过深拷贝之后会变成空对象：</li></ol><p><code>js let obj = &#123; reg : /\d+/gi, error : new Error() &#125; JSON.parse(JSON.stringify(obj)) // &#123;reg:&#123;&#125;,error:&#123;&#125;&#125;</code></p><ol start="3" style="list-style-type:decimal"><li>如果 key 的 value 是函数类型、 <code>undefined</code> 类型、<code>Symbol</code> 类型，则经过深拷贝之后会丢失：</li></ol><p><code>js // 如果是对象，属性直接丢失 let obj = &#123; fn: function()&#123;&#125;, name: undefined, sym: Symbol(), age: 12 &#125; JSON.parse(JSON.stringify(obj)) // &#123;age:12&#125; // 如果是数组，则变为 &quot;null&quot; let arr = [ function()&#123;&#125;, undefined, Symbol(), 12 ] JSON.parse(JSON.stringify(arr)) // [&quot;null&quot;,&quot;null&quot;,&quot;null&quot;12]</code></p><ol start="4" style="list-style-type:decimal"><li>如果 key 是 <code>Symbol</code> 类型，则经过深拷贝之后会丢失：</li></ol><p><code>js let obj = &#123;a:1&#125; obj[Symbol()] = 2 JSON.parse(JSON.stringify(obj)) // &#123;a:1&#125;</code></p><ol start="5" style="list-style-type:decimal"><li><code>NaN</code>、<code>Infinity</code>、<code>-Infinity</code> 经过深拷贝之后会变成 null</li></ol><p><code>js let obj = &#123; a:NaN, b:Infinity, c:-Infinity &#125; JSON.parse(JSON.stringify(obj)) // &#123;a:null,b:null,c:null&#125;</code></p><ol start="6" style="list-style-type:decimal"><li>可能导致 <code>constructor</code> 指向丢失：</li></ol><p>```js function Super(){} let obj1 = new Super() let obj2 = JSON.parse(JSON.stringify(obj1))</p><p>console.log(obj1.constructor) // Super console.log(obj2.constructor) // Object<br>```</p><p><code>JSON.stringify()</code> 只能序列化对象自身的可枚举属性，而 <code>constructor</code> 并不是实例对象自身的属性，而是实例的原型对象的属性。因此在序列化实例对象 obj1 的时候，实际上并不会去处理 <code>constructor</code> 的指向，这样，它的指向就成为了默认的 Object。</p><ol start="7" style="list-style-type:decimal"><li>存在循环引用的问题</li></ol><p><code>js let obj = &#123;&#125; obj.a = obj JSON.parse(JSON.stringify(obj1))</code></p><p>上面的 obj 对象存在循环引用，也就是说，它是一个环状结构（非树状）的对象，这样的对象是无法转化为 JSON 的，因此会报错：can't convert circular structure to JSON。</p><p>此外，我们也可以考虑使用 Lodash 提供的深拷贝方法。不过，如果要自己实现深拷贝，应该怎么做呢？我们一步一步来看。</p><h4 id="基础版本">基础版本</h4><p>深拷贝的核心其实就是==浅拷贝 + 递归==，不管层级嵌套有多深，我们总可以通过不断的递归到达对象的最里层，完成基本类型属性以及不可遍历的引用类型属性的拷贝。</p><p>下面是最基础的深拷贝版本：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">deepClone</span>(target)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> target <span class="op">===</span> <span class="st">&#39;object&#39;</span>)<span class="op">&#123;</span>
        <span class="kw">let</span> cloneTarget <span class="op">=</span> <span class="va">Array</span>.<span class="at">isArray</span>(target) <span class="op">?</span> []:<span class="op">&#123;&#125;</span>
        <span class="va">Reflect</span>.<span class="at">ownKeys</span>(target).<span class="at">forEach</span>(key <span class="op">=&gt;</span> <span class="op">&#123;</span>
            cloneTarget[key] <span class="op">=</span> <span class="at">deepClone</span>(target[key])
        <span class="op">&#125;</span>)
        <span class="cf">return</span> cloneTarget
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        <span class="cf">return</span> target
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>这里只考虑数组和对象字面量的情况。根据初始传入的 <code>target</code> 是一个对象字面量还是数组，决定最终返回的 <code>cloneTarget</code> 是对象还是数组。接着遍历 <code>target</code> 的每一个自身属性，递归调用 <code>deepClone</code>，如果属性已经是基本类型，则直接返回；如果还是对象或者数组，就和初始的 <code>target</code> 进行一样的处理。最后，把处理好的结果一一添加给 <code>cloneTarget</code>。</p><h4 id="解决循环引用导致的爆栈问题">解决循环引用导致的爆栈问题</h4><p>但是，这里存在一个循环引用的问题。</p><p>假设深拷贝的目标是下面这样的对象：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> obj <span class="op">=</span> <span class="op">&#123;&#125;</span>
<span class="va">obj</span>.<span class="at">a</span> <span class="op">=</span> obj</code></pre></div><p>这样的对象，结构中存在回环，即存在循环引用：<code>obj</code> 通过属性 a 引用了自身，而 a 也一定会有一个属性 a 再次引用自身 …… 最终会导致 <code>obj</code> 无限嵌套下去。而深拷贝的过程中因为用到了递归，无限嵌套的对象就会导致无限的递归，不断地压栈最终会导致堆栈溢出。</p><p>如何解决循环引用带来的爆栈问题呢？其实也很简单，<strong>只需要给递归创建一个出口即可</strong>。对于初次传入的对象或者数组，会用一个 WeakMap 记录当前目标和拷贝结果的映射关系，当检测到再次传入相同的目标时，就不再进行重复的拷贝，而是直接从 WeakMap 中取出它对应的拷贝结果返回。</p><blockquote><p>这里的“返回”其实就给递归创建了一个出口，因此不会无限递归下去，也就不会爆栈了。</p></blockquote><p>因此改进后的代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">deepClone</span>(target<span class="op">,</span>map <span class="op">=</span> <span class="kw">new</span> <span class="at">WeakMap</span>())<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> target <span class="op">===</span> <span class="st">&#39;object&#39;</span>)<span class="op">&#123;</span>
        <span class="kw">let</span> cloneTarget <span class="op">=</span> <span class="va">Array</span>.<span class="at">isArray</span>(target) <span class="op">?</span> []:<span class="op">&#123;&#125;</span>
        
        <span class="co">// 处理循环引用的问题</span>
        <span class="cf">if</span>(<span class="va">map</span>.<span class="at">has</span>(target)) <span class="cf">return</span> <span class="va">map</span>.<span class="at">get</span>(target)
        <span class="va">map</span>.<span class="at">set</span>(target<span class="op">,</span>cloneTarget)
        <span class="va">Reflect</span>.<span class="at">ownKeys</span>(target).<span class="at">forEach</span>(key <span class="op">=&gt;</span> <span class="op">&#123;</span>
            cloneTarget[key] <span class="op">=</span> <span class="at">deepClone</span>(target[key]<span class="op">,</span>map)
        <span class="op">&#125;</span>)
        <span class="cf">return</span> cloneTarget
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        <span class="cf">return</span> target
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><h4 id="处理其它数据类型">处理其它数据类型</h4><p>始终记住，我们要处理的是三类目标：</p><ul><li>基本数据类型：直接返回即可</li><li>可以继续遍历的引用数据类型：除了上面已经处理的对象字面量和数组，还有类数组对象、Set、Map 。它们都属于可以继续遍历的、可能存在嵌套的引用类型，因此在处理的时候就需要递归</li><li>不能继续遍历的引用数据类型：包括函数、错误对象、日期对象、正则对象、基本类型的包装对象（String、Boolean、Symbol、Number）等。它们是不能继续遍历的，或者说是“没有层级嵌套”的，因此再处理的时候需要拷贝一份一样的副本返回</li></ul><h5 id="类型判断函数">1）类型判断函数</h5><p>为了更好地判断是引用数据类型还是基本数据类型，可以使用一个 <code>isObject</code> 函数：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">isObject</span>(o)<span class="op">&#123;</span>
    <span class="cf">return</span> o <span class="op">!==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> (<span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&#39;object&#39;</span> <span class="op">||</span> <span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&#39;function&#39;</span>)
<span class="op">&#125;</span></code></pre></div><p>为了更准确地判断具体是什么数据类型，可以使用一个 <code>getType</code> 函数：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">getType</span>(o)<span class="op">&#123;</span>
    <span class="cf">return</span> <span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>(o).<span class="at">slice</span>(<span class="dv">8</span><span class="op">,-</span><span class="dv">1</span>)
<span class="op">&#125;</span>
<span class="co">// getType(1)      &quot;Number&quot;</span>
<span class="co">// getType(null)   &quot;Null&quot;</span></code></pre></div><h5 id="初始化函数">2）初始化函数</h5><p>之前深拷贝对象字面量或者数组的时候，首先会将最终返回的结果 <code>cloneTarget</code> 初始化为 <code>[]</code> 或者 <code>&#123;&#125;</code>。同样地，对于 Set、Map 以及类数组对象，也需要进行相同的操作，所以最好用一个函数统一实现 <code>cloneTarget</code> 的初始化。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">initCloneTarget</span>(target)<span class="op">&#123;</span>
    <span class="cf">return</span> <span class="kw">new</span> <span class="va">target</span>.<span class="at">constructor</span>()
<span class="op">&#125;</span></code></pre></div><p>通过 <code>target.constructor</code> 可以获得传进来的实例的构造函数，利用这个构造函数新创建一个同类型的实例并返回。</p><h5 id="处理可以继续遍历的引用类型类数组对象setmap">3）处理可以继续遍历的引用类型：类数组对象、Set、Map</h5><p>类数组对象，其实和数组以及对象字面量的形式差不多，所以可以一块处理；处理 Set 和 Map 的流程也基本一样，但是不能采用直接赋值的方式，而要使用 <code>add</code> 方法或者 <code>set</code> 方法，所以稍微改进一下。</p><p>代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">deepClone</span>(target<span class="op">,</span>map <span class="op">=</span> <span class="kw">new</span> <span class="at">WeakMap</span>())<span class="op">&#123;</span>
    <span class="co">// 如果是基本类型，直接返回即可</span>
    <span class="cf">if</span>(<span class="op">!</span><span class="at">isObject</span>(target))    <span class="cf">return</span> target   
    
    <span class="co">// 初始化返回结果</span>
    <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target)
    <span class="kw">let</span> cloneTarget <span class="op">=</span> <span class="at">initCloneTarget</span>(target)
    
    <span class="co">// 处理循环引用</span>
    <span class="cf">if</span>(<span class="va">map</span>.<span class="at">has</span>(target))      <span class="cf">return</span> <span class="va">map</span>.<span class="at">get</span>(target)
    <span class="va">map</span>.<span class="at">set</span>(target<span class="op">,</span>cloneTarget)
    
    <span class="co">// 处理 Set    </span>
    <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Set&#39;</span>)<span class="op">&#123;</span>
        <span class="va">target</span>.<span class="at">forEach</span>(value <span class="op">=&gt;</span> <span class="op">&#123;</span>
            <span class="va">cloneTarget</span>.<span class="at">add</span>(<span class="at">deepClone</span>(value<span class="op">,</span>map))
        <span class="op">&#125;</span>)
    <span class="op">&#125;</span>
    <span class="co">// 处理 Map</span>
    <span class="cf">else</span> <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Map&#39;</span>)<span class="op">&#123;</span>
        <span class="va">target</span>.<span class="at">forEach</span>((value<span class="op">,</span>key) <span class="op">=&gt;</span> <span class="op">&#123;</span>
            <span class="va">cloneTarget</span>.<span class="at">set</span>(key<span class="op">,</span><span class="at">deepClone</span>(value<span class="op">,</span>map))
        <span class="op">&#125;</span>)
    <span class="op">&#125;</span>
    
    <span class="co">// 处理对象字面量、数组、类数组对象</span>
    <span class="cf">else</span> <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Object&#39;</span> <span class="op">||</span> type <span class="op">===</span> <span class="st">&#39;Array&#39;</span> <span class="op">||</span> type <span class="op">===</span> <span class="st">&#39;Arguments&#39;</span>)<span class="op">&#123;</span>
        <span class="va">Reflect</span>.<span class="at">ownKeys</span>(target).<span class="at">forEach</span>(key <span class="op">=&gt;</span> <span class="op">&#123;</span>
            cloneTarget[key] <span class="op">=</span> <span class="at">deepClone</span>(target[key]<span class="op">,</span>map)
        <span class="op">&#125;</span>)
    <span class="op">&#125;</span>
    <span class="cf">return</span> cloneTarget
<span class="op">&#125;</span></code></pre></div><h5 id="处理不能继续遍历的引用类型">4）处理不能继续遍历的引用类型</h5><p>现在来处理不能继续遍历的引用类型。对于这样的目标，我们不能像基本数据类型那样直接返回，因为它们本质上也是对象，直接返回将返回相同的引用，并没有达到拷贝的目的。正确的做法，应该是拷贝一份副本再返回。</p><p>如何拷贝呢？这里又分为两种情况。其中，String、Boolean、Number、错误对象、日期对象都可以通过 new 的方式返回一个实例副本；而 Symbol、函数、正则对象的拷贝则无法通过简单的 new 拷贝副本，需要单独处理。</p><p><strong>拷贝 Symbol</strong></p><pre class="//"><code>function cloneSymbol(target)&#123;
    return Object(target.valueOf())    
    // 或者
    return Object(Symbol.prototype.valueOf.call(target))
    // 或者
    return Object(Symbol(target.description))
&#125;</code></pre><p>PS：这里的 <code>target</code> 是 Symbol 基本类型的包装类型，调用 <code>valueOf</code> 可以获得它对应的拆箱结果，再把这个拆箱结果传给 Object，就可以构造原包装类型的副本了；为了保险起见，可以通过 Symbol 的原型调用 <code>valueOf</code>；可以通过 <code>.description</code> 获得 symbol 的描述符，基于此也可以构造原包装类型的副本。</p><p><strong>拷贝正则对象（参考 lodash 的做法）</strong></p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">cloneReg</span>(target) <span class="op">&#123;</span>
    <span class="kw">const</span> reFlags <span class="op">=</span> <span class="ss">/</span><span class="sc">\w*$</span><span class="ss">/</span><span class="op">;</span>
    <span class="kw">const</span> result <span class="op">=</span> <span class="kw">new</span> <span class="at">RegExp</span>(<span class="va">target</span>.<span class="at">source</span><span class="op">,</span> <span class="va">reFlags</span>.<span class="at">exec</span>(target))<span class="op">;</span>
    <span class="va">result</span>.<span class="at">lastIndex</span> <span class="op">=</span> <span class="va">target</span>.<span class="at">lastIndex</span><span class="op">;</span>
    <span class="cf">return</span> result<span class="op">;</span>
<span class="op">&#125;</span></code></pre></div><p><strong>拷贝函数（实际上函数没有必要拷贝）</strong></p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">cloneFunction</span>(target)<span class="op">&#123;</span>
    <span class="cf">return</span> <span class="at">eval</span>(<span class="vs">`(</span><span class="sc">$&#123;</span>target<span class="sc">&#125;</span><span class="vs">)`</span>)
    <span class="co">// 或者</span>
    <span class="cf">return</span> <span class="kw">new</span> <span class="at">Function</span>(<span class="vs">`return (</span><span class="sc">$&#123;</span>target<span class="sc">&#125;</span><span class="vs">)()`</span>)
<span class="op">&#125;</span></code></pre></div><p>PS：传给 new Function 的参数声明了新创建的函数实例的函数体内容</p><p>接下来，用一个 <code>directCloneTarget</code> 函数处理以上所有情况：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">directCloneTarget</span>(target<span class="op">,</span>type)<span class="op">&#123;</span>
    <span class="kw">let</span> _constructor <span class="op">=</span> <span class="va">target</span>.<span class="at">constructor</span>
    <span class="cf">switch</span>(type)<span class="op">&#123;</span>
        <span class="cf">case</span> <span class="st">&#39;String&#39;</span><span class="op">:</span>
        <span class="cf">case</span> <span class="st">&#39;Boolean&#39;</span><span class="op">:</span>
        <span class="cf">case</span> <span class="st">&#39;Number&#39;</span><span class="op">:</span>
        <span class="cf">case</span> <span class="st">&#39;Error&#39;</span><span class="op">:</span>
        <span class="cf">case</span> <span class="st">&#39;Date&#39;</span><span class="op">:</span>
            <span class="cf">return</span> <span class="kw">new</span> <span class="at">_constructor</span>(<span class="va">target</span>.<span class="at">valueOf</span>())
            <span class="co">// 或者</span>
            <span class="cf">return</span> <span class="kw">new</span> <span class="at">Object</span>(<span class="va">_constructor</span>.<span class="va">prototype</span>.<span class="va">valueOf</span>.<span class="at">call</span>(target))
        <span class="cf">case</span> <span class="st">&#39;RegExp&#39;</span><span class="op">:</span>
            <span class="cf">return</span> <span class="at">cloneReg</span>(target)        
        <span class="cf">case</span> <span class="st">&#39;Symbol&#39;</span><span class="op">:</span>
            <span class="cf">return</span> <span class="at">cloneSymbol</span>(target)        
        <span class="cf">case</span> <span class="st">&#39;Function&#39;</span><span class="op">:</span>            
            <span class="cf">return</span> <span class="at">cloneFunction</span>(target) 
        <span class="dt">default</span><span class="op">:</span>            
            <span class="cf">return</span> <span class="kw">null</span>               
    <span class="op">&#125;</span>             
<span class="op">&#125;</span></code></pre></div><p>PS：注意这里有一些坑。</p><ul><li>为什么使用 <code>return new _constructor(target.valueOf())</code> 而不是 <code>return new _constructor(target)</code> 呢？因为如果传进来的 <code>target</code> 是 <code>new Boolean(false)</code>，那么最终返回的实际上是 <code>new Boolean(new Boolean(false))</code> ，由于参数并非空对象，因此它的值对应的不是期望的 false，而是 true。所以，最好使用 <code>valueOf</code> 获得包装类型对应的真实值。</li><li>也可以不使用基本类型对应的构造函数 <code>_constructor</code>，而是直接 <code>new Object(target.valueOf())</code> 对基本类型进行包装</li><li>考虑到 valueOf 可能被重写，为了保险起见，可以通过基本类型对应的构造函数 <code>_constructor</code> 去调用 valueOf 方法</li></ul><h4 id="最终版本">最终版本</h4><p>最后的代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> objectToInit <span class="op">=</span> [<span class="st">&#39;Object&#39;</span><span class="op">,</span><span class="st">&#39;Array&#39;</span><span class="op">,</span><span class="st">&#39;Set&#39;</span><span class="op">,</span><span class="st">&#39;Map&#39;</span><span class="op">,</span><span class="st">&#39;Arguments&#39;</span>]

<span class="kw">function</span> <span class="at">deepClone</span>(target<span class="op">,</span>map <span class="op">=</span> <span class="kw">new</span> <span class="at">WeakMap</span>())<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="op">!</span><span class="at">isObject</span>(target))    <span class="cf">return</span> target    
    <span class="co">// 初始化</span>
    <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target)
    <span class="kw">let</span> cloneTarget
    <span class="cf">if</span>(<span class="va">objectToInit</span>.<span class="at">includes</span>(type))<span class="op">&#123;</span>
        cloneTarget <span class="op">=</span> <span class="at">initCloneTarget</span>(target)
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        <span class="cf">return</span> <span class="at">directCloneTarget</span>(target<span class="op">,</span>type)
    <span class="op">&#125;</span>
    <span class="co">// 解决循环引用   </span>
    <span class="cf">if</span>(<span class="va">map</span>.<span class="at">has</span>(target))       <span class="cf">return</span> <span class="va">map</span>.<span class="at">get</span>(target)
    <span class="va">map</span>.<span class="at">set</span>(target<span class="op">,</span>cloneTarget)
    <span class="co">// 拷贝 Set</span>
    <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Set&#39;</span>)<span class="op">&#123;</span>
        <span class="va">target</span>.<span class="at">forEach</span>(value <span class="op">=&gt;</span> <span class="op">&#123;</span>
            <span class="va">cloneTarget</span>.<span class="at">add</span>(<span class="at">deepClone</span>(value<span class="op">,</span>map))
        <span class="op">&#125;</span>)
    <span class="op">&#125;</span>
    <span class="co">// 拷贝 Map</span>
    <span class="cf">else</span> <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Map&#39;</span>)<span class="op">&#123;</span>
        <span class="va">target</span>.<span class="at">forEach</span>((value<span class="op">,</span>key) <span class="op">=&gt;</span> <span class="op">&#123;</span>
            <span class="va">cloneTarget</span>.<span class="at">set</span>(key<span class="op">,</span><span class="at">deepClone</span>(value<span class="op">,</span>map))
        <span class="op">&#125;</span>)
    <span class="op">&#125;</span>
    <span class="co">// 拷贝对象字面量、数组、类数组对象</span>
    <span class="cf">else</span> <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Object&#39;</span> <span class="op">||</span> type <span class="op">===</span> <span class="st">&#39;Array&#39;</span> <span class="op">||</span> type <span class="op">===</span> <span class="st">&#39;Arguments&#39;</span>)<span class="op">&#123;</span>
        <span class="va">Reflect</span>.<span class="at">ownKeys</span>(target).<span class="at">forEach</span>(key <span class="op">=&gt;</span> <span class="op">&#123;</span>
            cloneTarget[key] <span class="op">=</span> <span class="at">deepClone</span>(target[key]<span class="op">,</span>map)
        <span class="op">&#125;</span>)
    <span class="op">&#125;</span>
    <span class="cf">return</span> cloneTarget
<span class="op">&#125;</span></code></pre></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/07/08/F-JS原生方法原理探究（八）：如何实现 JSON.stringify()？/">JS 原生方法原理探究（八）：如何实现 JSON.stringify()？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-07-08&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp12 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/07/08/F-JS原生方法原理探究（八）：如何实现 JSON.stringify()？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第八篇文章。本文会介绍如何实现 <code>JSON.stringify()</code> 方法。</p><p><code>JSON.stringify()</code> 可以将对象或值转化为 JSON 字符串。理论上，它可以接受很多种不同的数据类型作为参数，而不同的数据类型，处理和转化的结果也不同。所以在实现这个方法之前，我们先弄清楚具体的处理规则。</p><h4 id="不同数据类型的处理结果">不同数据类型的处理结果</h4><p>先看基本数据类型：</p><table><thead><tr class="header"><th align="center">数据类型</th><th align="center">处理结果</th><th align="center">数据类型</th><th align="center">处理结果</th></tr></thead><tbody><tr class="odd"><td align="center">String</td><td align="center">返回<code>'&quot;string&quot;'</code></td><td align="center">Number</td><td align="center">返回 <code>&quot;1234&quot;</code>（NaN，±Infinity 返回 <code>&quot;null&quot;</code>）</td></tr><tr class="even"><td align="center">Null</td><td align="center">返回<code>“null”</code></td><td align="center">Undefined</td><td align="center">返回 <code>undefined</code></td></tr><tr class="odd"><td align="center">Symbol</td><td align="center">返回 <code>undefined</code></td><td align="center">Boolean</td><td align="center">返回 <code>&quot;true&quot;/&quot;false&quot;</code></td></tr></tbody></table><p>再看引用数据类型：</p><table style="width:100%"><colgroup><col width="12%"><col width="40%"><col width="7%"><col width="40%"></colgroup><thead><tr class="header"><th align="center">数据类型</th><th align="center">处理结果</th><th align="center">数据类型</th><th align="center">处理结果</th></tr></thead><tbody><tr class="odd"><td align="center">对象字面量</td><td align="center">递归序列化。但是值为 undefined / Symbol / 函数类型的属性、类型为 Symbol 的属性会丢失</td><td align="center">类数组对象</td><td align="center">同对象字面量</td></tr><tr class="even"><td align="center">基本类型的包装对象</td><td align="center">一般返回包装对象的 <code>valueOf</code>（string 类型前后要加引号）的字符串形式，但是 Symbol 类型返回 <code>&quot;&#123;&#125;&quot;</code></td><td align="center">数组</td><td align="center">递归序列化。但是 undefined、Symbol、函数类型的属性会返回 <code>&quot;null&quot;</code></td></tr><tr class="odd"><td align="center">Map</td><td align="center">返回 <code>&quot;&#123;&#125;&quot;</code></td><td align="center">Set</td><td align="center">返回 <code>&quot;&#123;&#125;&quot;</code></td></tr><tr class="even"><td align="center">Error</td><td align="center">返回 <code>&quot;&#123;&#125;&quot;</code></td><td align="center">RegExp</td><td align="center">返回 <code>&quot;&#123;&#125;&quot;</code></td></tr><tr class="odd"><td align="center">Function</td><td align="center">返回 <code>undefined</code></td><td align="center">Date</td><td align="center">返回调用 <code>toJSON</code> 后生成的字符串</td></tr></tbody></table><h4 id="实现的思路">实现的思路</h4><p>在接下来的代码实现中，首先会分为基本数据类型和引用数据类型两种情况：</p><ul><li>基本数据类型：按照上面的规则返回序列化结果。重点处理 undefined 类型、symbol 类型以及 number 类型中的 NaN、±Infinity。</li><li>引用数据类型（按照是否可以继续遍历再分为两种）：</li><li>可继续遍历的类型：包括对象字面量、数组、类数组对象、Set、Map。需要丢失的属性，在遍历时跳过即可。</li><li>不可继续遍历的类型：包括基本类型的包装对象、Error 对象、正则对象、日期对象函数。用一个函数集中进行处理</li></ul><p>此外，在遍历数组或对象的时候，还需要检测<strong>是否存在循环引用</strong>的情况，若存在需要抛出相应的错误</p><h4 id="数据类型判断">数据类型判断</h4><p>用 <code>getType</code> 获取具体的数据类型。因为对于基本类型 Symbol 和它的包装类型的处理方式不同，所以用 <code>&quot;Symbol_basic&quot;</code> 表示基本类型 Symbol，用 <code>&quot;Symbol&quot;</code> 表示它的包装类型。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">getType</span>(o) <span class="op">&#123;</span>
  <span class="cf">return</span> <span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&quot;symbol&quot;</span>
    <span class="op">?</span> <span class="st">&quot;Symbol_basic&quot;</span>
    : <span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>(o).<span class="at">slice</span>(<span class="dv">8</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span>)<span class="op">;</span>
<span class="op">&#125;</span></code></pre></div><p>用 <code>isObject</code> 判断是引用类型还是基本类型：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">isObject</span>(o)<span class="op">&#123;</span>
    <span class="cf">return</span> o <span class="op">!==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> (<span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&#39;object&#39;</span> <span class="op">||</span> <span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&#39;function&#39;</span>)
<span class="op">&#125;</span></code></pre></div><h4 id="处理不可继续遍历的类型">处理不可继续遍历的类型</h4><p>用 <code>processOtherTypes</code> 处理所有不可继续遍历的引用类型：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">processOtherTypes</span>(target<span class="op">,</span>type)<span class="op">&#123;</span>
    <span class="cf">switch</span>(type)<span class="op">&#123;</span>
        <span class="cf">case</span> <span class="st">&#39;String&#39;</span><span class="op">:</span>
            <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">$&#123;</span><span class="va">target</span>.<span class="at">valueOf</span>()<span class="sc">&#125;</span><span class="vs">&quot;`</span>
        <span class="cf">case</span> <span class="st">&#39;Number&#39;</span><span class="op">:</span>
        <span class="cf">case</span> <span class="st">&#39;Boolean&#39;</span><span class="op">:</span>    
            <span class="cf">return</span> <span class="va">target</span>.<span class="at">valueOf</span>().<span class="at">toString</span>()
        <span class="cf">case</span> <span class="st">&#39;Symbol&#39;</span><span class="op">:</span>    
        <span class="cf">case</span> <span class="st">&#39;Error&#39;</span><span class="op">:</span>
        <span class="cf">case</span> <span class="st">&#39;RegExp&#39;</span><span class="op">:</span>    
            <span class="cf">return</span> <span class="st">&quot;&#123;&#125;&quot;</span>
        <span class="cf">case</span> <span class="st">&#39;Date&#39;</span><span class="op">:</span>
            <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">$&#123;</span><span class="va">target</span>.<span class="at">toJSON</span>()<span class="sc">&#125;</span><span class="vs">&quot;`</span>
        <span class="cf">case</span> <span class="st">&#39;Function&#39;</span><span class="op">:</span>
            <span class="cf">return</span> <span class="kw">undefined</span>
        <span class="dt">default</span><span class="op">:</span>
            <span class="cf">return</span> “”
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>尤其需要注意 String 包装类型，不能直接返回它的 <code>valueOf()</code>，还要在前后加上引号。比如说 <code>&#123;a:&quot;bbb&quot;&#125;</code> ，我们期望的序列化结果应该是 <code>'&#123;a:&quot;bbb&quot;&#125;'</code>，而不是 <code>'&#123;a:bbb&#125;'</code>；同理，对于 Date 对象，直接返回它的 <code>toJSON()</code> 会得到 <code>'&#123;date: 1995-12-16T19:24:00.000Z&#125;'</code>，但我们想得到的是 <code>'&#123;date: &quot;1995-12-16T19:24:00.000Z&quot;&#125;'</code>，所以也要在前后加上引号。</p><h4 id="检测循环引用">检测循环引用</h4><p>循环引用指的是对象的结构是回环状的，不是树状的：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// 下面的对象/数组存在循环引用</span>
<span class="kw">let</span> obj <span class="op">=</span> <span class="op">&#123;&#125;;</span>
<span class="va">obj</span>.<span class="at">a</span> <span class="op">=</span> obj<span class="op">;</span>

<span class="kw">let</span> obj1 <span class="op">=</span> <span class="op">&#123;</span> <span class="dt">a</span><span class="op">:</span> <span class="op">&#123;</span> <span class="dt">b</span><span class="op">:</span> <span class="op">&#123;&#125;</span> <span class="op">&#125;</span> <span class="op">&#125;;</span>
<span class="va">obj1</span>.<span class="va">a</span>.<span class="va">b</span>.<span class="at">c</span> <span class="op">=</span> <span class="va">obj1</span>.<span class="at">a</span><span class="op">;</span>

<span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>]<span class="op">;</span>
arr[<span class="dv">2</span>] <span class="op">=</span> arr<span class="op">;</span>

<span class="co">// 注意这个对象不存在循环引用，只有平级引用</span>
<span class="kw">let</span> obj2 <span class="op">=</span> <span class="op">&#123;</span><span class="dt">a</span><span class="op">:&#123;&#125;&#125;;</span>
<span class="va">obj2</span>.<span class="at">b</span> <span class="op">=</span> <span class="va">obj2</span>.<span class="at">a</span><span class="op">;</span></code></pre></div><p>如何检测循环引用呢？</p><ul><li>考虑最简单的情况，只有 key 对应的 value 为对象或者数组时，才可能存在循环引用，因此在遍历 key 的时候，判断 value 为对象或者数组之后才往下处理循环引用。</li><li>每一个 key 会有自己的一个数组用来存放父级链，并且在递归的时候始终传递该数组。如果检测到当前 key 对应的 value 在数组中出现过，则证明引用了某个父级对象，就可以抛出错误；如果没出现过，则加入数组中，更新父级链</li></ul><p>所以一个通用的循环引用检测函数如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">checkCircular</span>(target<span class="op">,</span>parentArray <span class="op">=</span> [target])<span class="op">&#123;</span>
    <span class="va">Object</span>.<span class="at">keys</span>(target).<span class="at">forEach</span>(key <span class="op">=&gt;</span> <span class="op">&#123;</span>
        <span class="cf">if</span>(<span class="kw">typeof</span> target[key] <span class="op">==</span> <span class="st">&#39;object&#39;</span>)<span class="op">&#123;</span>
            <span class="cf">if</span>(<span class="va">parentArray</span>.<span class="at">inlcudes</span>(target[key])
              <span class="op">||</span> <span class="at">checkCircular</span>(target[key]<span class="op">,</span>[target[key]<span class="op">,</span>...<span class="at">parentArray</span>])
              )<span class="op">&#123;</span>
                <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;存在循环引用&#39;</span>)
            <span class="op">&#125;</span>
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>)
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;不存在循环引用&#39;</span>)
<span class="op">&#125;</span></code></pre></div><p>在 <code>JSON.stringify</code> 的实现中，遍历 key 的过程已经在主代码完成了，所以这里的 <code>checkCircular</code> 只需要包含检测过程。稍加改造如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">checkCircular</span>(target<span class="op">,</span>currentParent)<span class="op">&#123;</span>
    <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target)
    <span class="cf">if</span>(type <span class="op">==</span> <span class="st">&#39;Object&#39;</span> <span class="op">||</span> type <span class="op">==</span> <span class="st">&#39;Array&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&#39;Converting circular structure to JSON&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">currentParent</span>.<span class="at">push</span>(target)
<span class="op">&#125;</span></code></pre></div><h4 id="核心代码">核心代码</h4><p>最终实现的核心代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">jsonStringify</span>(target<span class="op">,</span>initParent <span class="op">=</span> [target])<span class="op">&#123;</span>
    <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target)
    <span class="kw">let</span> iterableList <span class="op">=</span> [<span class="st">&#39;Object&#39;</span><span class="op">,</span><span class="st">&#39;Array&#39;</span><span class="op">,</span><span class="st">&#39;Arguments&#39;</span><span class="op">,</span><span class="st">&#39;Set&#39;</span><span class="op">,</span><span class="st">&#39;Map&#39;</span>]
    <span class="kw">let</span> specialList <span class="op">=</span> [<span class="st">&#39;Undefined&#39;</span><span class="op">,</span><span class="st">&#39;Symbol_basic&#39;</span><span class="op">,</span><span class="st">&#39;Function&#39;</span>]
    <span class="co">// 如果是基本数据类型</span>
    <span class="cf">if</span>(<span class="op">!</span><span class="at">isObject</span>(target))<span class="op">&#123;</span>
       <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Symbol_basic&#39;</span> <span class="op">||</span> type <span class="op">===</span> <span class="st">&#39;Undefined&#39;</span>)<span class="op">&#123;</span>
            <span class="cf">return</span> <span class="kw">undefined</span>
       <span class="op">&#125;</span> <span class="cf">else</span> <span class="cf">if</span>(<span class="va">Number</span>.<span class="at">isNaN</span>(target) <span class="op">||</span> target <span class="op">===</span> <span class="kw">Infinity</span> <span class="op">||</span> target <span class="op">===</span> <span class="op">-</span><span class="kw">Infinity</span>) <span class="op">&#123;</span>
            <span class="cf">return</span> <span class="st">&quot;null&quot;</span>
       <span class="op">&#125;</span> <span class="cf">else</span> <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;String&#39;</span>)<span class="op">&#123;</span>
            <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">$&#123;</span>target<span class="sc">&#125;</span><span class="vs">&quot;`</span>
       <span class="op">&#125;</span> 
       <span class="cf">return</span>  <span class="at">String</span>(target)
    <span class="op">&#125;</span> 
    <span class="co">// 如果是引用数据类型</span>
    <span class="cf">else</span> <span class="op">&#123;</span>
        <span class="kw">let</span> res 
        <span class="co">// 如果是不可以遍历的类型</span>
        <span class="cf">if</span>(<span class="op">!</span><span class="va">iterableList</span>.<span class="at">includes</span>(type))<span class="op">&#123;</span>
            res <span class="op">=</span> <span class="at">processOtherTypes</span>(target<span class="op">,</span>type)
        <span class="op">&#125;</span> 
        <span class="co">// 如果是可以遍历的类型</span>
        <span class="cf">else</span> <span class="op">&#123;</span>
            <span class="co">// 如果是数组</span>
            <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Array&#39;</span>)<span class="op">&#123;</span>
                res <span class="op">=</span> <span class="va">target</span>.<span class="at">map</span>(item <span class="op">=&gt;</span> <span class="op">&#123;</span>
                    <span class="cf">if</span>(<span class="va">specialList</span>.<span class="at">includes</span>(<span class="at">getType</span>(item)))<span class="op">&#123;</span>
                        <span class="cf">return</span> <span class="st">&quot;null&quot;</span>
                    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
                        <span class="co">// 检测循环引用</span>
                        <span class="kw">let</span> currentParent <span class="op">=</span> [...<span class="at">initParent</span>]
                        <span class="at">checkCircular</span>(item<span class="op">,</span>currentParent)
                        <span class="cf">return</span> <span class="at">jsonStringify</span>(item<span class="op">,</span>currentParent)
                    <span class="op">&#125;</span>
                <span class="op">&#125;</span>)
                res <span class="op">=</span> <span class="vs">`[</span><span class="sc">$&#123;</span>res<span class="sc">&#125;</span><span class="vs">]`</span>.<span class="at">replace</span>(<span class="ss">/&#39;/g</span><span class="op">,</span><span class="st">&#39;&quot;&#39;</span>)
            <span class="op">&#125;</span>        
            <span class="co">// 如果是对象字面量、类数组对象、Set、Map</span>
            <span class="cf">else</span> <span class="op">&#123;</span>
                res <span class="op">=</span> []
                <span class="va">Object</span>.<span class="at">keys</span>(target).<span class="at">forEach</span>(key <span class="op">=&gt;</span> <span class="op">&#123;</span>
                    <span class="co">// Symbol 类型的 key 直接略过</span>
                    <span class="cf">if</span>(<span class="at">getType</span>(key) <span class="op">!==</span> <span class="st">&#39;Symbol_basic&#39;</span>)<span class="op">&#123;</span>
                        <span class="kw">let</span> keyType <span class="op">=</span> <span class="at">getType</span>(target[key])                        
                        <span class="cf">if</span>(<span class="op">!</span><span class="va">specialList</span>.<span class="at">includes</span>(keyType))<span class="op">&#123;</span>
                            <span class="co">// 检测循环引用</span>
                            <span class="kw">let</span> currentParent <span class="op">=</span> [...<span class="at">initParent</span>]
                            <span class="at">checkCircular</span>(target[key]<span class="op">,</span>currentParent)
                            <span class="co">// 往数组中 push 键值对</span>
                            <span class="va">res</span>.<span class="at">push</span>(
                                <span class="vs">`&quot;</span><span class="sc">$&#123;</span>key<span class="sc">&#125;</span><span class="vs">&quot;:</span><span class="sc">$&#123;</span><span class="at">jsonStringify</span>(target[key]<span class="op">,</span>currentParent)<span class="sc">&#125;</span><span class="vs">`</span>
                            )
                        <span class="op">&#125;</span>
                    <span class="op">&#125;</span>
                <span class="op">&#125;</span>)
                res <span class="op">=</span> <span class="vs">`&#123;</span><span class="sc">$&#123;</span>res<span class="sc">&#125;</span><span class="vs">&#125;`</span>.<span class="at">replace</span>(<span class="ss">/&#39;/g</span><span class="op">,</span><span class="st">&#39;&quot;&#39;</span>)
            <span class="op">&#125;</span>            
        <span class="op">&#125;</span>
        <span class="cf">return</span> res
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>基本上按照上面表格中的规则来处理就行了，有几个细节可以注意一下：</p><ul><li><code>iterableList</code> 用于存放可以继续遍历的数据类型；<code>specialList</code> 用于存放比较特殊的 <code>Undefined</code>、<code>Symbol_basic</code>、<code>Function</code> 三种类型，特殊在于：对象 key 的 value 如果是这些类型，则序列化的时候会丢失，数组的元素如果是这些类型，则序列化的时候会统一转化为 <code>&quot;null&quot;</code>。因为这三种类型要多次用到，所以先存起来。</li><li>为什么要将最终返回的 <code>res</code> 初始化为一个空数组？因为：</li><li>如果我们处理的 <code>target</code> 是数组，则只需要调用 <code>map</code> 就可以将数组的每一个元素映射为序列化之后的结果，调用后返回的数组赋给 <code>res</code>，再和 <code>[</code>、<code>]</code> 字符拼接，会隐式调用数组的 <code>toString</code> 方法，产生一个标准的序列化结果；</li><li>如果处理的 <code>target</code> 是对象字面量，则可以将它的每个 key-value 的序列化结果 push 到 <code>res</code> 中，最终再和 <code>&#123;</code>、<code>&#125;</code> 字符拼接，也同样会产生一个标准的序列化结果。</li><li>在整个过程中不需要去处理 JSON 字符串中的逗号分隔符。</li><li>对于对象字面量，类型为 <code>&quot;Symbol_basic&quot;</code> 的属性会丢失，属性值为 <code>Undefined</code>、<code>Symbol_basic</code>、<code>Function</code> 三种类型的属性也会丢失。属性丢失其实就是在遍历对象的时候略过这些属性</li><li>在检测循环引用的时候，存在嵌套关系的对象应该共享同一条父级链，所以递归的时候需要把存放父级链的数组传进去；同时，不存在嵌套关系的两个对象不应该共享同一条父级链（否则会将所有互相引用的情况都误认为是循环引用），所以每次遍历对象 key 的时候，都会重新生成一个 <code>currentArray</code>。</li><li>最后，为保险起见，记得将序列化结果中可能出现的所有单引号替换为双引号</li></ul><h4 id="最终代码和效果">最终代码和效果</h4><p>最终代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">getType</span>(o) <span class="op">&#123;</span>
  <span class="cf">return</span> <span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&quot;symbol&quot;</span>
    <span class="op">?</span> <span class="st">&quot;Symbol_basic&quot;</span>
    : <span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>(o).<span class="at">slice</span>(<span class="dv">8</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span>)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">isObject</span>(o) <span class="op">&#123;</span>
  <span class="cf">return</span> o <span class="op">!==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> (<span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&quot;object&quot;</span> <span class="op">||</span> <span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&quot;function&quot;</span>)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">processOtherTypes</span>(target<span class="op">,</span> type) <span class="op">&#123;</span>
  <span class="cf">switch</span> (type) <span class="op">&#123;</span>
    <span class="cf">case</span> <span class="st">&quot;String&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">$&#123;</span><span class="va">target</span>.<span class="at">valueOf</span>()<span class="sc">&#125;</span><span class="vs">&quot;`</span><span class="op">;</span>
    <span class="cf">case</span> <span class="st">&quot;Number&quot;</span><span class="op">:</span>
    <span class="cf">case</span> <span class="st">&quot;Boolean&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="va">target</span>.<span class="at">valueOf</span>().<span class="at">toString</span>()<span class="op">;</span>
    <span class="cf">case</span> <span class="st">&quot;Symbol&quot;</span><span class="op">:</span>
    <span class="cf">case</span> <span class="st">&quot;Error&quot;</span><span class="op">:</span>
    <span class="cf">case</span> <span class="st">&quot;RegExp&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="st">&quot;&#123;&#125;&quot;</span><span class="op">;</span>
    <span class="cf">case</span> <span class="st">&quot;Date&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">$&#123;</span><span class="va">target</span>.<span class="at">toJSON</span>()<span class="sc">&#125;</span><span class="vs">&quot;`</span><span class="op">;</span>
    <span class="cf">case</span> <span class="st">&quot;Function&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="kw">undefined</span><span class="op">;</span>
    <span class="dt">default</span><span class="op">:</span>
      <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">checkCircular</span>(obj<span class="op">,</span> currentParent) <span class="op">&#123;</span>
  <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(obj)<span class="op">;</span>
  <span class="cf">if</span> (type <span class="op">==</span> <span class="st">&quot;Object&quot;</span> <span class="op">||</span> type <span class="op">==</span> <span class="st">&quot;Array&quot;</span>) <span class="op">&#123;</span>
    <span class="cf">if</span> (<span class="va">currentParent</span>.<span class="at">includes</span>(obj)) <span class="op">&#123;</span>
      <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&quot;Converting circular structure to JSON&quot;</span>)<span class="op">;</span>
    <span class="op">&#125;</span>
    <span class="va">currentParent</span>.<span class="at">push</span>(obj)<span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">jsonStringify</span>(target<span class="op">,</span> initParent <span class="op">=</span> [target]) <span class="op">&#123;</span>
  <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target)<span class="op">;</span>
  <span class="kw">let</span> iterableList <span class="op">=</span> [<span class="st">&quot;Object&quot;</span><span class="op">,</span> <span class="st">&quot;Array&quot;</span><span class="op">,</span> <span class="st">&quot;Arguments&quot;</span><span class="op">,</span> <span class="st">&quot;Set&quot;</span><span class="op">,</span> <span class="st">&quot;Map&quot;</span>]<span class="op">;</span>
  <span class="kw">let</span> specialList <span class="op">=</span> [<span class="st">&quot;Undefined&quot;</span><span class="op">,</span> <span class="st">&quot;Symbol_basic&quot;</span><span class="op">,</span> <span class="st">&quot;Function&quot;</span>]<span class="op">;</span>
  <span class="cf">if</span> (<span class="op">!</span><span class="at">isObject</span>(target)) <span class="op">&#123;</span>
    <span class="cf">if</span> (type <span class="op">===</span> <span class="st">&quot;Symbol_basic&quot;</span> <span class="op">||</span> type <span class="op">===</span> <span class="st">&quot;Undefined&quot;</span>) <span class="op">&#123;</span>
      <span class="cf">return</span> <span class="kw">undefined</span><span class="op">;</span>
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="va">Number</span>.<span class="at">isNaN</span>(target) <span class="op">||</span> target <span class="op">===</span> <span class="kw">Infinity</span> <span class="op">||</span> target <span class="op">===</span> <span class="op">-</span><span class="kw">Infinity</span>) <span class="op">&#123;</span>
      <span class="cf">return</span> <span class="st">&quot;null&quot;</span><span class="op">;</span>
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="cf">if</span> (type <span class="op">===</span> <span class="st">&quot;String&quot;</span>) <span class="op">&#123;</span>
      <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">$&#123;</span>target<span class="sc">&#125;</span><span class="vs">&quot;`</span><span class="op">;</span>
    <span class="op">&#125;</span>
    <span class="cf">return</span> <span class="at">String</span>(target)<span class="op">;</span>
  <span class="op">&#125;</span>
  <span class="cf">else</span> <span class="op">&#123;</span>
    <span class="kw">let</span> res<span class="op">;</span>
    <span class="cf">if</span> (<span class="op">!</span><span class="va">iterableList</span>.<span class="at">includes</span>(type)) <span class="op">&#123;</span>
      res <span class="op">=</span> <span class="at">processOtherTypes</span>(target<span class="op">,</span> type)<span class="op">;</span>
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
      <span class="cf">if</span> (type <span class="op">===</span> <span class="st">&quot;Array&quot;</span>) <span class="op">&#123;</span>
        res <span class="op">=</span> <span class="va">target</span>.<span class="at">map</span>((item) <span class="op">=&gt;</span> <span class="op">&#123;</span>
          <span class="cf">if</span> (<span class="va">specialList</span>.<span class="at">includes</span>(<span class="at">getType</span>(item))) <span class="op">&#123;</span>
            <span class="cf">return</span> <span class="st">&quot;null&quot;</span><span class="op">;</span>
          <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
            <span class="kw">let</span> currentParent <span class="op">=</span> [...<span class="at">initParent</span>]<span class="op">;</span>
            <span class="at">checkCircular</span>(item<span class="op">,</span> currentParent)<span class="op">;</span>
            <span class="cf">return</span> <span class="at">jsonStringify</span>(item<span class="op">,</span> currentParent)<span class="op">;</span>
          <span class="op">&#125;</span>
        <span class="op">&#125;</span>)<span class="op">;</span>
        res <span class="op">=</span> <span class="vs">`[</span><span class="sc">$&#123;</span>res<span class="sc">&#125;</span><span class="vs">]`</span>.<span class="at">replace</span>(<span class="ss">/&#39;/g</span><span class="op">,</span> <span class="st">&#39;&quot;&#39;</span>)<span class="op">;</span>
      <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        res <span class="op">=</span> []<span class="op">;</span>
        <span class="va">Object</span>.<span class="at">keys</span>(target).<span class="at">forEach</span>((key) <span class="op">=&gt;</span> <span class="op">&#123;</span>
          <span class="cf">if</span> (<span class="at">getType</span>(key) <span class="op">!==</span> <span class="st">&quot;Symbol_basic&quot;</span>) <span class="op">&#123;</span>
            <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target[key])<span class="op">;</span>
            <span class="cf">if</span> (<span class="op">!</span><span class="va">specialList</span>.<span class="at">includes</span>(type)) <span class="op">&#123;</span>
              <span class="kw">let</span> currentParent <span class="op">=</span> [...<span class="at">initParent</span>]<span class="op">;</span>
              <span class="at">checkCircular</span>(target[key]<span class="op">,</span> currentParent)<span class="op">;</span>
              <span class="va">res</span>.<span class="at">push</span>(<span class="vs">`&quot;</span><span class="sc">$&#123;</span>key<span class="sc">&#125;</span><span class="vs">&quot;:</span><span class="sc">$&#123;</span><span class="at">jsonStringify</span>(target[key]<span class="op">,</span> currentParent)<span class="sc">&#125;</span><span class="vs">`</span>)<span class="op">;</span>
            <span class="op">&#125;</span>
          <span class="op">&#125;</span>
        <span class="op">&#125;</span>)<span class="op">;</span>
        res <span class="op">=</span> <span class="vs">`&#123;</span><span class="sc">$&#123;</span>res<span class="sc">&#125;</span><span class="vs">&#125;`</span>.<span class="at">replace</span>(<span class="ss">/&#39;/g</span><span class="op">,</span> <span class="st">&#39;&quot;&#39;</span>)<span class="op">;</span>
      <span class="op">&#125;</span>
    <span class="op">&#125;</span>
    <span class="cf">return</span> res<span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>拿下面的 <code>obj</code> 对象测试一下效果：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> obj <span class="op">=</span> <span class="op">&#123;</span>
   <span class="dt">tag</span><span class="op">:</span> <span class="at">Symbol</span>(<span class="st">&quot;student&quot;</span>)<span class="op">,</span>
   <span class="dt">money</span><span class="op">:</span> <span class="kw">undefined</span><span class="op">,</span>
   <span class="dt">girlfriend</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span> 
   <span class="dt">fn</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">&#123;&#125;,</span>
   <span class="dt">info1</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="st">&#39;str&#39;</span><span class="op">,</span><span class="kw">NaN</span><span class="op">,</span><span class="kw">Infinity</span><span class="op">,-</span><span class="kw">Infinity</span><span class="op">,</span><span class="kw">undefined</span><span class="op">,</span><span class="kw">null</span><span class="op">,</span>() <span class="op">=&gt;</span> <span class="op">&#123;&#125;,</span><span class="at">Symbol</span>()]<span class="op">,</span>
   <span class="dt">info2</span><span class="op">:</span> [<span class="kw">new</span> <span class="at">Set</span>()<span class="op">,</span><span class="kw">new</span> <span class="at">Map</span>()<span class="op">,</span><span class="kw">new</span> <span class="at">Error</span>()<span class="op">,</span><span class="ss">/a</span><span class="sc">+</span><span class="ss">b/</span>]<span class="op">,</span>
   <span class="dt">info2</span><span class="op">:</span> <span class="op">&#123;</span>
       <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;Chor&#39;</span><span class="op">,</span>
       <span class="dt">age</span><span class="op">:</span> <span class="dv">20</span><span class="op">,</span>
       <span class="dt">male</span><span class="op">:</span> <span class="kw">true</span>
   <span class="op">&#125;,</span>
   <span class="dt">info3</span><span class="op">:</span> <span class="op">&#123;</span>
       <span class="dt">date</span><span class="op">:</span> <span class="kw">new</span> <span class="at">Date</span>()<span class="op">,</span>
       <span class="dt">tag</span><span class="op">:</span> <span class="at">Symbol</span>()<span class="op">,</span>
       <span class="dt">fn</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">&#123;&#125;,</span>
       <span class="dt">un</span><span class="op">:</span> <span class="kw">undefined</span>
   <span class="op">&#125;,</span>
   <span class="dt">info4</span><span class="op">:&#123;</span>
       <span class="dt">str</span><span class="op">:</span> <span class="kw">new</span> <span class="at">String</span>(<span class="st">&#39;abc&#39;</span>)<span class="op">,</span>
       <span class="dt">no</span><span class="op">:</span> <span class="kw">new</span> <span class="at">Number</span>(<span class="dv">123</span>)<span class="op">,</span>
       <span class="dt">bool</span><span class="op">:</span> <span class="kw">new</span> <span class="at">Boolean</span>(<span class="kw">false</span>)<span class="op">,</span>
       <span class="dt">tag</span><span class="op">:</span> <span class="at">Object</span>(<span class="at">Symbol</span>())    
   <span class="op">&#125;</span>    
<span class="op">&#125;</span></code></pre></div><p>结果如下：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JS%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/2.jpeg"></div><p>说明我们的实现是没有问题的。最后，我并没有实现 <code>JSON.stringify()</code> 中的 replacer 参数和 space 参数，感兴趣的读者可以在上面代码的基础上进一步拓展。</p><p>本文到此结束，感谢你的阅读。若发现文中有错误之处，欢迎评论区指出。</p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/07/08/F-JS原生方法原理探究（七）：如何实现 Object.assign()？/">JS 原生方法原理探究（七）：如何实现 Object.assign()？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-07-08&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.1k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp4 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/07/08/F-JS原生方法原理探究（七）：如何实现 Object.assign()？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第七篇文章。本文会介绍如何实现 <code>Object.assign()</code> 方法。</p><h3 id="object.assign-的基本用法"><code>Object.assign()</code> 的基本用法</h3><p>要实现 <code>Object.assign()</code>，首先了解它的大概用法：</p><ul><li>接受的第一个参数表示目标对象（浅拷贝的结果），如果是 null 或者 undefined，直接报错；如果是对象字面量或者数组，直接使用；如果是基本类型，则装箱为对应的对象。</li><li>如果只接受了第一个参数，则将其包装为对象直接返回；如果不止接受了第一个参数，比如说接受了第二，第三 …… 等多个参数，那么这些参数表示源对象，它们的自身可枚举属性会一一添加到目标对象上，属性同名则以靠后的对象为准，进行属性覆盖。</li><li>第一个参数往后的参数，如果是 null 或者 undefined，那么直接跳过；其余的情况则尝试找出它们的可枚举属性，但实际上，只有字符串、数组、对象字面量这些类型是具有可枚举属性的。</li></ul><h3 id="实现代码">实现代码</h3><p>根据上面所讲的思路，实现的代码就是下面这样的：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myAssign</span>(target<span class="op">,</span>...<span class="at">objs</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(target <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> target <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&quot;can not convert null or undefined to object&quot;</span>)
    <span class="op">&#125;</span>
    <span class="kw">let</span> res <span class="op">=</span> <span class="at">Object</span>(target)
    <span class="va">objs</span>.<span class="at">forEach</span>(obj <span class="op">=&gt;</span> <span class="op">&#123;</span>
        <span class="st">&#39;use strict&#39;</span>
        <span class="cf">if</span>(obj <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> obj <span class="op">!=</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
            <span class="cf">for</span>(<span class="kw">let</span> key <span class="kw">in</span> obj)<span class="op">&#123;</span>
                <span class="cf">if</span>(<span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">hasOwnProperty</span>.<span class="at">call</span>(obj<span class="op">,</span>key))<span class="op">&#123;</span>
                    res[key] <span class="op">=</span> obj[key]
                <span class="op">&#125;</span>
            <span class="op">&#125;</span>
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>)
    <span class="cf">return</span> res
<span class="op">&#125;</span>
<span class="va">Object</span>.<span class="at">defineProperty</span>(Object<span class="op">,</span><span class="st">&#39;myAssign&#39;</span><span class="op">,&#123;</span>
    <span class="dt">value</span><span class="op">:</span> myAssign<span class="op">,</span>
    <span class="dt">writable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">configurable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">enumerable</span><span class="op">:</span> <span class="kw">false</span>
<span class="op">&#125;</span>)</code></pre></div><h3 id="需要注意的要点">需要注意的要点</h3><p>需要注意的要点如下：</p><h4 id="为什么不直接通过-.-给-object-添加-myassign-方法">为什么不直接通过 <code>.</code> 给 Object 添加 <code>myAssign</code> 方法？</h4><p><code>Object.myAssign()</code> 实际上是 Object 的一个静态方法，但是不要直接通过 <code>.</code> 添加，因为这种方式添加的方法是可以枚举的，而 <code>assign()</code> 方法不可枚举。所以这里使用 <code>Object.defineProperty()</code> 添加，同时设置该方法不可枚举、可读、可配置。</p><h4 id="为什么要使用严格模式">为什么要使用严格模式？</h4><p>考察参数出现字符串的情况。下面这两种情况容易理解：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">assign</span>(<span class="op">&#123;</span><span class="dt">a</span><span class="op">:</span><span class="dv">1</span><span class="op">&#125;,</span><span class="st">&quot;cd&quot;</span>)     
<span class="co">// 把 &quot;cd&quot; 的可枚举属性 0 和 1 添加到目标对象上，最后得到 &#123;a:1,0:“c”,1:&quot;d&quot;&#125;</span>

<span class="va">Object</span>.<span class="at">assign</span>(<span class="st">&quot;cd&quot;</span><span class="op">,&#123;</span><span class="dt">a</span><span class="op">:</span><span class="dv">1</span><span class="op">&#125;</span>)
<span class="co">// 把 &#123;a:1&#125; 的可枚举属性 a 添加到目标对象上，最后得到 String&#123;“cd”,a:1&#125;</span></code></pre></div><p>但如果是这种情况：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">assign</span>(<span class="st">&quot;ab&quot;</span><span class="op">,</span><span class="st">&quot;cd&quot;</span>)    
<span class="co">// 报错 Cannot assign to read only property &#39;0&#39; of object &#39;[object String]&#39;</span></code></pre></div><p>这里尝试把 <code>“cd”</code> 的可枚举属性 0 和 1 添加到目标对象上，但问题是，目标对象 <code>String&#123;“ab”&#125;</code> 也有可枚举属性 0 和 1，而且是只读的，这意味着我们尝试去修改目标对象的只读属性，所以报错也就很合理了。但是，在非严格模式下，这种行为只会静默失败，为了让它真的抛出错误，必须声明使用严格模式。</p><h4 id="为什么不使用-reflect.ownkeysobj">为什么不使用 <code>Reflect.ownKeys(obj)</code>？</h4><p>考虑目标对象和源对象都是数组的情况，使用 <code>Reflect.ownKeys(obj)</code>确实可以一次性获得 obj 的自身可枚举属性，但是这些属性除了数组索引之外，也包含数组长度，<strong>这会导致将源对象的数组长度作为目标对象的数组长度</strong>，但实际上，两者长度不一定相等。比如，<code>Objetc.myAssign([1,2,3],[8,9])</code> 的结果将不是期望得到的 <code>[8,9,3]</code>，而是 <code>[8,9]</code>，因为目标对象的长度被覆盖了。</p><h4 id="为什么不直接使用-obj.hasownpropertykey">为什么不直接使用 <code>obj.hasOwnProperty(key)</code> ？</h4><p>既然不能使用 <code>Reflect.ownKeys(obj)</code>，那么就只有先使用 <code>for(let key in obj)</code> 获得 obj 的自身属性 + 原型链属性，再使用 <code>obj.hasOwnProperty(key)</code> 筛选出自身属性了。但是为什么不直接使用 <code>obj.hasOwnProperty(key)</code> 呢？</p><p>这是因为，我们对源对象的情况并不了解。一方面，它可能重写了 <code>hasOwnProperty</code> 方法；另一方面，它可能是基于 <code>Object.create(null)</code> 构建的，这样的对象不会从 Object 原型上继承 <code>hasOwnProperty</code> 方法。所以这里借用 Object 原型的 <code>hasOwnProperty</code> 方法，是最保险的方式。</p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/28/F-JS原生方法原理探究（六）：从 Babel 转译过程谈谈 ES6 实现继承的原理/">JS原生方法原理探究（六）从 Babel 转译过程浅谈 ES6 实现继承的原理</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-28&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4.1k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp18 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/28/F-JS原生方法原理探究（六）：从 Babel 转译过程谈谈 ES6 实现继承的原理/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第六篇文章。</p><p>都说 ES6 的 Class 是 ES5 的语法糖，那么 ES6 的 Class 是如何实现的呢？其实现继承的原理又是什么呢？不妨我们通过 Babel 转译代码的方式，看看其中有什么门道。</p><p>这篇文章会从最简单的代码入手，一步步剖析相关的原理以及每个函数的作用。代码的转译直接在 <a target="_blank" rel="noopener" href="https://babeljs.io">Babel 官网</a>进行即可。</p><h3 id="es6-的-class-是如何实现的">ES6 的 Class 是如何实现的</h3><p>先从最简单的一个 Parent 类看起：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> Parent<span class="op">&#123;</span>
    <span class="at">constructor</span>()<span class="op">&#123;</span>
        <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">1</span>
        <span class="kw">this</span>.<span class="at">getA</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
   <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>转译之后的结果是：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">_classCallCheck</span>(instance<span class="op">,</span> Constructor) <span class="op">&#123;</span>
    <span class="cf">if</span> (<span class="op">!</span>(instance <span class="kw">instanceof</span> Constructor)) <span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&quot;Cannot call a class as a function&quot;</span>)<span class="op">;</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span>

<span class="kw">var</span> Parent <span class="op">=</span> <span class="kw">function</span> <span class="at">Parent</span>() <span class="op">&#123;</span>
    <span class="st">&quot;use strict&quot;</span><span class="op">;</span>

    <span class="at">_classCallCheck</span>(<span class="kw">this</span><span class="op">,</span> Parent)<span class="op">;</span>
    <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
    <span class="kw">this</span>.<span class="at">getA</span> <span class="op">=</span> <span class="kw">function</span> () <span class="op">&#123;&#125;;</span>
<span class="op">&#125;;</span></code></pre></div><p>可以看到，这里的类实质上就是 ES5 中的构造函数，除了添加实例属性和实例方法之外，它还调用了一个 <code>_classCallCheck</code> 函数。</p><blockquote><p><strong><code>_classCallCheck</code> 函数</strong></p></blockquote><p>这个函数会接受一个实例和构造函数作为参数，内部的 <code>instance instanceof Constructor</code> 用于判断这个类是不是通过 new 调用的，如果不是就抛出一个错误。</p><p>接下来我们尝试给这个类添加原型方法和静态方法：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> Parent<span class="op">&#123;</span>
   <span class="at">constructor</span>()<span class="op">&#123;</span>
     <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">1</span>
     <span class="kw">this</span>.<span class="at">getA</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
   <span class="op">&#125;</span>
   <span class="at">getB</span>()<span class="op">&#123;&#125;</span>
   <span class="at">getC</span>()<span class="op">&#123;&#125;</span>
   <span class="kw">static</span> <span class="at">getD</span>()<span class="op">&#123;&#125;</span>
   <span class="kw">static</span> <span class="at">getE</span>()<span class="op">&#123;&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>转译后得到：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">_classCallCheck</span>(instance<span class="op">,</span> Constructor) <span class="op">&#123;</span>
  <span class="cf">if</span> (<span class="op">!</span>(instance <span class="kw">instanceof</span> Constructor)) <span class="op">&#123;</span>
    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&quot;Cannot call a class as a function&quot;</span>)<span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_defineProperties</span>(target<span class="op">,</span> props) <span class="op">&#123;</span>
  <span class="cf">for</span> (<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">props</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">&#123;</span>
    <span class="kw">var</span> descriptor <span class="op">=</span> props[i]<span class="op">;</span>
    <span class="va">descriptor</span>.<span class="at">enumerable</span> <span class="op">=</span> <span class="va">descriptor</span>.<span class="at">enumerable</span> <span class="op">||</span> <span class="kw">false</span><span class="op">;</span>
    <span class="va">descriptor</span>.<span class="at">configurable</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
    <span class="cf">if</span> (<span class="st">&quot;value&quot;</span> <span class="kw">in</span> descriptor) <span class="va">descriptor</span>.<span class="at">writable</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
    <span class="va">Object</span>.<span class="at">defineProperty</span>(target<span class="op">,</span> <span class="va">descriptor</span>.<span class="at">key</span><span class="op">,</span> descriptor)<span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_createClass</span>(Constructor<span class="op">,</span> protoProps<span class="op">,</span> staticProps) <span class="op">&#123;</span>
  <span class="cf">if</span> (protoProps) <span class="at">_defineProperties</span>(<span class="va">Constructor</span>.<span class="at">prototype</span><span class="op">,</span> protoProps)<span class="op">;</span>
  <span class="cf">if</span> (staticProps) <span class="at">_defineProperties</span>(Constructor<span class="op">,</span> staticProps)<span class="op">;</span>
  <span class="cf">return</span> Constructor<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">var</span> Parent <span class="op">=</span> <span class="co">/*#__PURE__*/</span> (<span class="kw">function</span> () <span class="op">&#123;</span>
  <span class="st">&quot;use strict&quot;</span><span class="op">;</span>

  <span class="kw">function</span> <span class="at">Parent</span>() <span class="op">&#123;</span>
    <span class="at">_classCallCheck</span>(<span class="kw">this</span><span class="op">,</span> Parent)<span class="op">;</span>

    <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>

    <span class="kw">this</span>.<span class="at">getA</span> <span class="op">=</span> <span class="kw">function</span> () <span class="op">&#123;&#125;;</span>
  <span class="op">&#125;</span>

  <span class="at">_createClass</span>(
    Parent<span class="op">,</span>
    [
      <span class="op">&#123;</span>
        <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;getB&quot;</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span> <span class="at">getB</span>() <span class="op">&#123;&#125;</span>
      <span class="op">&#125;,</span>
      <span class="op">&#123;</span>
        <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;getC&quot;</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span> <span class="at">getC</span>() <span class="op">&#123;&#125;</span>
      <span class="op">&#125;</span>
    ]<span class="op">,</span>
    [
      <span class="op">&#123;</span>
        <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;getD&quot;</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span> <span class="at">getD</span>() <span class="op">&#123;&#125;</span>
      <span class="op">&#125;,</span>
      <span class="op">&#123;</span>
        <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;getE&quot;</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span> <span class="at">getE</span>() <span class="op">&#123;&#125;</span>
      <span class="op">&#125;</span>
    ]
  )<span class="op">;</span>

  <span class="cf">return</span> Parent<span class="op">;</span>
<span class="op">&#125;</span>)()<span class="op">;</span></code></pre></div><p>emmm 看起来好像有点复杂，不过没关系，我们一个一个函数理清楚就行了。</p><p>可以看到，此时的 <code>Parent</code> 变成了一个 IIFE，IIFE 执行之后仍然是返回 Parent 类，但内部还封装了一个 <code>_createClass</code> 函数的调用。</p><blockquote><p><strong><code>_createClass</code> 函数</strong></p></blockquote><p><code>_createClass</code> 函数做了什么事呢？首先，它可以接受三个参数：</p><ul><li>第一个参数： 类（这里是 <code>Parent</code> 类）</li><li>第二个参数：存放对象的数组，每个对象都是关于类的原型方法的特性描述对象（这里是 <code>getB</code> 和 <code>getC</code>）</li><li>第三个参数：存放对象的数组，每个对象都是关于类的静态方法的特性描述对象（这里是 <code>getD</code> 和 <code>getE</code>）</li></ul><p>接着，它会依次检查是否有传第二个和第三个参数，如果有，就调用 <code>_defineProperties</code> 函数，分别为类的原型定义原型方法，为类本身定义静态方法。</p><blockquote><p><strong><code>_defineProperties</code> 函数</strong></p></blockquote><p><code>_defineProperties</code> 函数做了什么事呢？它接受类（或者类的原型）和一个存放对象的数组作为参数，之后遍历数组中的每个对象，定义每个方法的特性，并将它们逐一添加到类（或者类的原型）上面。这里涉及到的特性包括：</p><ul><li><code>enumberable</code>：该属性（方法）是否可枚举。如果方法本身已经定义了该特性，则采用该特性；如果没有定义，则定义该方法为不可枚举</li><li><code>configurable</code>：该属性（方法）是否可以配置</li><li><code>writable</code>：如果该属性是数据属性而不是访问器属性，那么会有一个 <code>value</code>，此时设置该属性为可写</li></ul><h3 id="es6-的继承是如何实现的">ES6 的继承是如何实现的</h3><p>好了，基本搞清楚一个 class 的原理之后，现在我们来看一下 ES6 是如何实现继承的。</p><p>将下面的代码进行转译：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> Parent<span class="op">&#123;</span>
   <span class="at">constructor</span>()<span class="op">&#123;</span>
     <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">1</span> 
     <span class="kw">this</span>.<span class="at">getA</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span> 
   <span class="op">&#125;</span>
   <span class="at">getB</span>()<span class="op">&#123;&#125;</span>  
   <span class="at">getC</span>()<span class="op">&#123;&#125;</span>
   <span class="kw">static</span> <span class="at">getD</span>()<span class="op">&#123;&#125;</span>
   <span class="kw">static</span> <span class="at">getE</span>()<span class="op">&#123;&#125;</span>
<span class="op">&#125;</span>
<span class="kw">class</span> Son <span class="kw">extends</span> Parent<span class="op">&#123;</span>
    <span class="at">constructor</span>()<span class="op">&#123;</span>
        <span class="kw">super</span>()      
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>就得到了：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&quot;use strict&quot;</span><span class="op">;</span>

<span class="kw">function</span> <span class="at">_typeof</span>(obj) <span class="op">&#123;</span>
  <span class="st">&quot;@babel/helpers - typeof&quot;</span><span class="op">;</span>
  <span class="cf">if</span> (<span class="kw">typeof</span> Symbol <span class="op">===</span> <span class="st">&quot;function&quot;</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> <span class="va">Symbol</span>.<span class="at">iterator</span> <span class="op">===</span> <span class="st">&quot;symbol&quot;</span>) <span class="op">&#123;</span>
    _typeof <span class="op">=</span> <span class="kw">function</span> <span class="at">_typeof</span>(obj) <span class="op">&#123;</span>
      <span class="cf">return</span> <span class="kw">typeof</span> obj<span class="op">;</span>
    <span class="op">&#125;;</span>
  <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
    _typeof <span class="op">=</span> <span class="kw">function</span> <span class="at">_typeof</span>(obj) <span class="op">&#123;</span>
      <span class="cf">return</span> obj <span class="op">&amp;&amp;</span>
        <span class="kw">typeof</span> Symbol <span class="op">===</span> <span class="st">&quot;function&quot;</span> <span class="op">&amp;&amp;</span>
        <span class="va">obj</span>.<span class="at">constructor</span> <span class="op">===</span> Symbol <span class="op">&amp;&amp;</span>
        obj <span class="op">!==</span> <span class="va">Symbol</span>.<span class="at">prototype</span>
        <span class="op">?</span> <span class="st">&quot;symbol&quot;</span>
        : <span class="kw">typeof</span> obj<span class="op">;</span>
    <span class="op">&#125;;</span>
  <span class="op">&#125;</span>
  <span class="cf">return</span> <span class="at">_typeof</span>(obj)<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_inherits</span>(subClass<span class="op">,</span> superClass) <span class="op">&#123;</span>
  <span class="cf">if</span> (<span class="kw">typeof</span> superClass <span class="op">!==</span> <span class="st">&quot;function&quot;</span> <span class="op">&amp;&amp;</span> superClass <span class="op">!==</span> <span class="kw">null</span>) <span class="op">&#123;</span>
    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&quot;Super expression must either be null or a function&quot;</span>)<span class="op">;</span>
  <span class="op">&#125;</span>
  <span class="va">subClass</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(superClass <span class="op">&amp;&amp;</span> <span class="va">superClass</span>.<span class="at">prototype</span><span class="op">,</span> <span class="op">&#123;</span>
    <span class="dt">constructor</span><span class="op">:</span> <span class="op">&#123;</span> <span class="dt">value</span><span class="op">:</span> subClass<span class="op">,</span> <span class="dt">writable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span> <span class="dt">configurable</span><span class="op">:</span> <span class="kw">true</span> <span class="op">&#125;</span>
  <span class="op">&#125;</span>)<span class="op">;</span>
  <span class="cf">if</span> (superClass) <span class="at">_setPrototypeOf</span>(subClass<span class="op">,</span> superClass)<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_setPrototypeOf</span>(o<span class="op">,</span> p) <span class="op">&#123;</span>
  _setPrototypeOf <span class="op">=</span>
    <span class="va">Object</span>.<span class="at">setPrototypeOf</span> <span class="op">||</span>
    <span class="kw">function</span> <span class="at">_setPrototypeOf</span>(o<span class="op">,</span> p) <span class="op">&#123;</span>
      <span class="va">o</span>.<span class="at">__proto__</span> <span class="op">=</span> p<span class="op">;</span>
      <span class="cf">return</span> o<span class="op">;</span>
    <span class="op">&#125;;</span>
  <span class="cf">return</span> <span class="at">_setPrototypeOf</span>(o<span class="op">,</span> p)<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_createSuper</span>(Derived) <span class="op">&#123;</span>
  <span class="kw">var</span> hasNativeReflectConstruct <span class="op">=</span> <span class="at">_isNativeReflectConstruct</span>()<span class="op">;</span>
  <span class="cf">return</span> <span class="kw">function</span> <span class="at">_createSuperInternal</span>() <span class="op">&#123;</span>
    <span class="kw">var</span> Super <span class="op">=</span> <span class="at">_getPrototypeOf</span>(Derived)<span class="op">,</span>
      result<span class="op">;</span>
    <span class="cf">if</span> (hasNativeReflectConstruct) <span class="op">&#123;</span>
      <span class="kw">var</span> NewTarget <span class="op">=</span> <span class="at">_getPrototypeOf</span>(<span class="kw">this</span>).<span class="at">constructor</span><span class="op">;</span>
      result <span class="op">=</span> <span class="va">Reflect</span>.<span class="at">construct</span>(Super<span class="op">,</span> arguments<span class="op">,</span> NewTarget)<span class="op">;</span>
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
      result <span class="op">=</span> <span class="va">Super</span>.<span class="at">apply</span>(<span class="kw">this</span><span class="op">,</span> arguments)<span class="op">;</span>
    <span class="op">&#125;</span>
    <span class="cf">return</span> <span class="at">_possibleConstructorReturn</span>(<span class="kw">this</span><span class="op">,</span> result)<span class="op">;</span>
  <span class="op">&#125;;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_possibleConstructorReturn</span>(self<span class="op">,</span> call) <span class="op">&#123;</span>
  <span class="cf">if</span> (call <span class="op">&amp;&amp;</span> (<span class="at">_typeof</span>(call) <span class="op">===</span> <span class="st">&quot;object&quot;</span> <span class="op">||</span> <span class="kw">typeof</span> call <span class="op">===</span> <span class="st">&quot;function&quot;</span>)) <span class="op">&#123;</span>
    <span class="cf">return</span> call<span class="op">;</span>
  <span class="op">&#125;</span>
  <span class="cf">return</span> <span class="at">_assertThisInitialized</span>(self)<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_assertThisInitialized</span>(self) <span class="op">&#123;</span>
  <span class="cf">if</span> (self <span class="op">===</span> <span class="kw">void</span> <span class="dv">0</span>) <span class="op">&#123;</span>
    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">ReferenceError</span>(
      <span class="st">&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;</span>
    )<span class="op">;</span>
  <span class="op">&#125;</span>
  <span class="cf">return</span> self<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_isNativeReflectConstruct</span>() <span class="op">&#123;</span>
  <span class="cf">if</span> (<span class="kw">typeof</span> Reflect <span class="op">===</span> <span class="st">&quot;undefined&quot;</span> <span class="op">||</span> <span class="op">!</span><span class="va">Reflect</span>.<span class="at">construct</span>) <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>
  <span class="cf">if</span> (<span class="va">Reflect</span>.<span class="va">construct</span>.<span class="at">sham</span>) <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>
  <span class="cf">if</span> (<span class="kw">typeof</span> Proxy <span class="op">===</span> <span class="st">&quot;function&quot;</span>) <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>
  <span class="cf">try</span> <span class="op">&#123;</span>
    <span class="va">Boolean</span>.<span class="va">prototype</span>.<span class="va">valueOf</span>.<span class="at">call</span>(
      <span class="va">Reflect</span>.<span class="at">construct</span>(Boolean<span class="op">,</span> []<span class="op">,</span> <span class="kw">function</span> () <span class="op">&#123;&#125;</span>)
    )<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>
  <span class="op">&#125;</span> <span class="cf">catch</span> (e) <span class="op">&#123;</span>
    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_getPrototypeOf</span>(o) <span class="op">&#123;</span>
  _getPrototypeOf <span class="op">=</span> <span class="va">Object</span>.<span class="at">setPrototypeOf</span>
    <span class="op">?</span> <span class="va">Object</span>.<span class="at">getPrototypeOf</span>
    : <span class="kw">function</span> <span class="at">_getPrototypeOf</span>(o) <span class="op">&#123;</span>
        <span class="cf">return</span> <span class="va">o</span>.<span class="at">__proto__</span> <span class="op">||</span> <span class="va">Object</span>.<span class="at">getPrototypeOf</span>(o)<span class="op">;</span>
      <span class="op">&#125;;</span>
  <span class="cf">return</span> <span class="at">_getPrototypeOf</span>(o)<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_classCallCheck</span>(instance<span class="op">,</span> Constructor) <span class="op">&#123;</span>
  <span class="cf">if</span> (<span class="op">!</span>(instance <span class="kw">instanceof</span> Constructor)) <span class="op">&#123;</span>
    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&quot;Cannot call a class as a function&quot;</span>)<span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_defineProperties</span>(target<span class="op">,</span> props) <span class="op">&#123;</span>
  <span class="cf">for</span> (<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">props</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">&#123;</span>
    <span class="kw">var</span> descriptor <span class="op">=</span> props[i]<span class="op">;</span>
    <span class="va">descriptor</span>.<span class="at">enumerable</span> <span class="op">=</span> <span class="va">descriptor</span>.<span class="at">enumerable</span> <span class="op">||</span> <span class="kw">false</span><span class="op">;</span>
    <span class="va">descriptor</span>.<span class="at">configurable</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
    <span class="cf">if</span> (<span class="st">&quot;value&quot;</span> <span class="kw">in</span> descriptor) <span class="va">descriptor</span>.<span class="at">writable</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
    <span class="va">Object</span>.<span class="at">defineProperty</span>(target<span class="op">,</span> <span class="va">descriptor</span>.<span class="at">key</span><span class="op">,</span> descriptor)<span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_createClass</span>(Constructor<span class="op">,</span> protoProps<span class="op">,</span> staticProps) <span class="op">&#123;</span>
  <span class="cf">if</span> (protoProps) <span class="at">_defineProperties</span>(<span class="va">Constructor</span>.<span class="at">prototype</span><span class="op">,</span> protoProps)<span class="op">;</span>
  <span class="cf">if</span> (staticProps) <span class="at">_defineProperties</span>(Constructor<span class="op">,</span> staticProps)<span class="op">;</span>
  <span class="cf">return</span> Constructor<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">var</span> Parent <span class="op">=</span> <span class="co">/*#__PURE__*/</span> (<span class="kw">function</span> () <span class="op">&#123;</span>
  <span class="kw">function</span> <span class="at">Parent</span>() <span class="op">&#123;</span>
    <span class="at">_classCallCheck</span>(<span class="kw">this</span><span class="op">,</span> Parent)<span class="op">;</span>

    <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>

    <span class="kw">this</span>.<span class="at">getA</span> <span class="op">=</span> <span class="kw">function</span> () <span class="op">&#123;&#125;;</span>
  <span class="op">&#125;</span>

  <span class="at">_createClass</span>(
    Parent<span class="op">,</span>
    [
      <span class="op">&#123;</span>
        <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;getB&quot;</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span> <span class="at">getB</span>() <span class="op">&#123;&#125;</span>
      <span class="op">&#125;,</span>
      <span class="op">&#123;</span>
        <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;getC&quot;</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span> <span class="at">getC</span>() <span class="op">&#123;&#125;</span>
      <span class="op">&#125;</span>
    ]<span class="op">,</span>
    [
      <span class="op">&#123;</span>
        <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;getD&quot;</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span> <span class="at">getD</span>() <span class="op">&#123;&#125;</span>
      <span class="op">&#125;,</span>
      <span class="op">&#123;</span>
        <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;getE&quot;</span><span class="op">,</span>
        <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span> <span class="at">getE</span>() <span class="op">&#123;&#125;</span>
      <span class="op">&#125;</span>
    ]
  )<span class="op">;</span>

  <span class="cf">return</span> Parent<span class="op">;</span>
<span class="op">&#125;</span>)()<span class="op">;</span>

<span class="kw">var</span> Son <span class="op">=</span> <span class="co">/*#__PURE__*/</span> (<span class="kw">function</span> (_Parent) <span class="op">&#123;</span>
  <span class="at">_inherits</span>(Son<span class="op">,</span> _Parent)<span class="op">;</span>

  <span class="kw">var</span> _super <span class="op">=</span> <span class="at">_createSuper</span>(Son)<span class="op">;</span>

  <span class="kw">function</span> <span class="at">Son</span>() <span class="op">&#123;</span>
    <span class="at">_classCallCheck</span>(<span class="kw">this</span><span class="op">,</span> Son)<span class="op">;</span>

    <span class="cf">return</span> <span class="va">_super</span>.<span class="at">call</span>(<span class="kw">this</span>)<span class="op">;</span>
  <span class="op">&#125;</span>

  <span class="cf">return</span> Son<span class="op">;</span>
<span class="op">&#125;</span>)(Parent)<span class="op">;</span></code></pre></div><p>emmm 好像越来越复杂了，没事，我们先稍稍简化一下（前面解释过的函数这里就直接略过了），再一个一个慢慢分析：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&quot;use strict&quot;</span><span class="op">;</span>

<span class="kw">function</span> <span class="at">_typeof</span>(obj) <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_inherits</span>(subClass<span class="op">,</span> superClass) <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_setPrototypeOf</span>(o<span class="op">,</span> p) <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_createSuper</span>(Derived) <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_possibleConstructorReturn</span>(self<span class="op">,</span> call) <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_assertThisInitialized</span>(self) <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_isNativeReflectConstruct</span>() <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_getPrototypeOf</span>(o) <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_classCallCheck</span>() <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_defineProperties</span>() <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">function</span> <span class="at">_createClass</span>() <span class="op">&#123;</span> ... <span class="op">&#125;</span>

<span class="kw">var</span> Parent <span class="op">=</span> <span class="co">/*#__PURE__*/</span> (<span class="kw">function</span> () <span class="op">&#123;</span>
  <span class="kw">function</span> <span class="at">Parent</span>() <span class="op">&#123;</span> ... <span class="op">&#125;</span>

  <span class="at">_createClass</span>(...)<span class="op">;</span>

  <span class="cf">return</span> Parent<span class="op">;</span>
<span class="op">&#125;</span>)()<span class="op">;</span>

<span class="kw">var</span> Son <span class="op">=</span> <span class="co">/*#__PURE__*/</span> (<span class="kw">function</span> (_Parent) <span class="op">&#123;</span>
  <span class="at">_inherits</span>(Son<span class="op">,</span> _Parent)<span class="op">;</span>

  <span class="kw">var</span> _super <span class="op">=</span> <span class="at">_createSuper</span>(Son)<span class="op">;</span>

  <span class="kw">function</span> <span class="at">Son</span>() <span class="op">&#123;</span>
    <span class="at">_classCallCheck</span>(<span class="kw">this</span><span class="op">,</span> Son)<span class="op">;</span>

    <span class="cf">return</span> <span class="va">_super</span>.<span class="at">call</span>(<span class="kw">this</span>)<span class="op">;</span>
  <span class="op">&#125;</span>

  <span class="cf">return</span> Son<span class="op">;</span>
<span class="op">&#125;</span>)(Parent)<span class="op">;</span></code></pre></div><p>这里多出了很多新的函数，有的函数不是我们讨论的重点，而且也完全可以单独拎出来分析，所以这里先简单把它们的作用介绍了，之后如果忘记了函数的作用，翻到这里来看即可。</p><blockquote><p><strong><code>_typeof(obj)</code></strong></p></blockquote><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">_typeof</span>(obj) <span class="op">&#123;</span>
  <span class="st">&quot;@babel/helpers - typeof&quot;</span><span class="op">;</span>
  <span class="cf">if</span> (<span class="kw">typeof</span> Symbol <span class="op">===</span> <span class="st">&quot;function&quot;</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> <span class="va">Symbol</span>.<span class="at">iterator</span> <span class="op">===</span> <span class="st">&quot;symbol&quot;</span>) <span class="op">&#123;</span>
    _typeof <span class="op">=</span> <span class="kw">function</span> <span class="at">_typeof</span>(obj) <span class="op">&#123;</span>
      <span class="cf">return</span> <span class="kw">typeof</span> obj<span class="op">;</span>
    <span class="op">&#125;;</span>
  <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
    _typeof <span class="op">=</span> <span class="kw">function</span> <span class="at">_typeof</span>(obj) <span class="op">&#123;</span>
      <span class="cf">return</span> obj <span class="op">&amp;&amp;</span>
        <span class="kw">typeof</span> Symbol <span class="op">===</span> <span class="st">&quot;function&quot;</span> <span class="op">&amp;&amp;</span>
        <span class="va">obj</span>.<span class="at">constructor</span> <span class="op">===</span> Symbol <span class="op">&amp;&amp;</span>
        obj <span class="op">!==</span> <span class="va">Symbol</span>.<span class="at">prototype</span>
        <span class="op">?</span> <span class="st">&quot;symbol&quot;</span>
        : <span class="kw">typeof</span> obj<span class="op">;</span>
    <span class="op">&#125;;</span>
  <span class="op">&#125;</span>
  <span class="cf">return</span> <span class="at">_typeof</span>(obj)<span class="op">;</span>
<span class="op">&#125;</span></code></pre></div><p>这是 Babel 引入的一个工具函数，主要是为了对 <code>Symbol</code> 进行正确的处理。它首先会检查当前环境是否支持原生的 <code>Symbol</code>，如果支持就直接返回 <code>typeof obj</code> 表达式的计算结果；如果不支持，再检查 <code>obj</code> 是不是通过 polyfill 实现的 <code>Symbol</code> 的一个实例，如果是就返回它的类型（也就是返回 <code>&quot;symbol&quot;</code>），如果不是，就返回 <code>typeof obj</code> 的计算结果。在这里，这个函数假定了我们当前的环境是原生支持 <code>Symbol</code> 或者通过 polyfill 实现了支持的。</p><blockquote><p><strong><code>_setPrototypeOf()</code></strong></p></blockquote><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">_setPrototypeOf</span>(o<span class="op">,</span> p) <span class="op">&#123;</span>
  _setPrototypeOf <span class="op">=</span>
    <span class="va">Object</span>.<span class="at">setPrototypeOf</span> <span class="op">||</span>
    <span class="kw">function</span> <span class="at">_setPrototypeOf</span>(o<span class="op">,</span> p) <span class="op">&#123;</span>
      <span class="va">o</span>.<span class="at">__proto__</span> <span class="op">=</span> p<span class="op">;</span>
      <span class="cf">return</span> o<span class="op">;</span>
    <span class="op">&#125;;</span>
  <span class="cf">return</span> <span class="at">_setPrototypeOf</span>(o<span class="op">,</span> p)<span class="op">;</span>
<span class="op">&#125;</span></code></pre></div><p>首先检查当前环境是否支持直接调用 <code>Object.setPrototypeOf()</code> 方法，如果不支持，就通过 <code>__proto__</code> 手动给实例建立原型关系（ <code>__proto__</code> 是一个暴露的内部属性，一般不提倡直接进行操作）。</p><blockquote><p><strong><code>_possibleConstructorReturn(self,call)</code></strong></p></blockquote><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">_possibleConstructorReturn</span>(self<span class="op">,</span> call) <span class="op">&#123;</span>
  <span class="cf">if</span> (call <span class="op">&amp;&amp;</span> (<span class="at">_typeof</span>(call) <span class="op">===</span> <span class="st">&quot;object&quot;</span> <span class="op">||</span> <span class="kw">typeof</span> call <span class="op">===</span> <span class="st">&quot;function&quot;</span>)) <span class="op">&#123;</span>
    <span class="cf">return</span> call<span class="op">;</span>
  <span class="op">&#125;</span>
  <span class="cf">return</span> <span class="at">_assertThisInitialized</span>(self)<span class="op">;</span>
<span class="op">&#125;</span></code></pre></div><p>如果你看过 <code>new</code> 或者 <code>[[Construct]]</code> 的内部实现，就会知道，给构造函数指定了一个非空对象或者函数作为返回值之后，调用函数之后返回的将不是实例，而是这个对象或者函数。这里就是通过 <code>_possibleConstructorReturn</code> 这个函数来完成这件事的 —— 仔细看它的名字，意思不就是“构造函数可能返回的值”吗？</p><p>这个函数接受两个参数，<code>self</code> 代表构造函数的实例，<code>call</code> 代表构造函数的返回值。内部的判断也很简单，<code>call &amp;&amp; (_typeof(call) === &quot;object&quot; || typeof call === &quot;function&quot;)</code> 是检查 <code>call</code> 的类型，当它是一个对象（注意这里是使用 <code>typeof</code> 进行检查，需要排除可能为 <code>null</code> 的情况）或者函数的时候，直接将其作为返回值；否则就返回 <code>_assertThisInitialized(self)</code>。等等，怎么又来了一个新函数呢？不要急，我们接着就来看这个函数是干什么用的。</p><blockquote><p><strong><code>_assertThisInitialized(self)</code></strong></p></blockquote><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">_assertThisInitialized</span>(self) <span class="op">&#123;</span>
  <span class="cf">if</span> (self <span class="op">===</span> <span class="kw">void</span> <span class="dv">0</span>) <span class="op">&#123;</span>
    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">ReferenceError</span>(
      <span class="st">&quot;this hasn&#39;t been initialised - super() hasn&#39;t been called&quot;</span>
    )<span class="op">;</span>
  <span class="op">&#125;</span>
  <span class="cf">return</span> self<span class="op">;</span>
<span class="op">&#125;</span></code></pre></div><p>看这个函数的名字 —— “断言 <code>this</code> 已经初始化”，也就是说，在调用这个方法的时候，我们期望的结果是 <code>this</code> 已经得到初始化了。这里如果检查发现 <code>this</code> 是 <code>undefined</code>，就会抛出一个错误，提示我们由于没有调用 <code>super()</code>，所以无法得到 <code>this</code>；否则就返回 <code>this</code> 。为什么要使用 <code>void 0</code> 而不是 <code>undefined</code> 呢？因为非严格模式下 <code>undefined</code> 可能会被重写，这里使用 <code>void 0</code> 更加保险。</p><blockquote><p><strong><code>_isNativeReflectConstruct()</code></strong></p></blockquote><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">_isNativeReflectConstruct</span>() <span class="op">&#123;</span>
  <span class="cf">if</span> (<span class="kw">typeof</span> Reflect <span class="op">===</span> <span class="st">&quot;undefined&quot;</span> <span class="op">||</span> <span class="op">!</span><span class="va">Reflect</span>.<span class="at">construct</span>) <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>
  <span class="cf">if</span> (<span class="va">Reflect</span>.<span class="va">construct</span>.<span class="at">sham</span>) <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>
  <span class="cf">if</span> (<span class="kw">typeof</span> Proxy <span class="op">===</span> <span class="st">&quot;function&quot;</span>) <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>
  <span class="cf">try</span> <span class="op">&#123;</span>
    <span class="va">Boolean</span>.<span class="va">prototype</span>.<span class="va">valueOf</span>.<span class="at">call</span>(
      <span class="va">Reflect</span>.<span class="at">construct</span>(Boolean<span class="op">,</span> []<span class="op">,</span> <span class="kw">function</span> () <span class="op">&#123;&#125;</span>)
    )<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>
  <span class="op">&#125;</span> <span class="cf">catch</span> (e) <span class="op">&#123;</span>
    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>这个方法用于检测当前环境是否支持原生的 <code>Reflect</code>。为什么要做这个检查呢？后面我们再来解释。</p><p>好了，我们已经分析了这几个函数的作用，现在直接翻到最下面的代码，从 <code>Son</code> 子类看起：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> Son <span class="op">=</span> <span class="co">/*#__PURE__*/</span> (<span class="kw">function</span> (_Parent) <span class="op">&#123;</span>
  <span class="at">_inherits</span>(Son<span class="op">,</span> _Parent)<span class="op">;</span>

  <span class="kw">var</span> _super <span class="op">=</span> <span class="at">_createSuper</span>(Son)<span class="op">;</span>

  <span class="kw">function</span> <span class="at">Son</span>() <span class="op">&#123;</span>
    <span class="at">_classCallCheck</span>(<span class="kw">this</span><span class="op">,</span> Son)<span class="op">;</span>

    <span class="cf">return</span> <span class="va">_super</span>.<span class="at">call</span>(<span class="kw">this</span>)<span class="op">;</span>
  <span class="op">&#125;</span>

  <span class="cf">return</span> Son<span class="op">;</span>
<span class="op">&#125;</span>)(Parent)<span class="op">;</span></code></pre></div><p>这里的 <code>Son</code> 同样是一个 IIFE，并且实际上也是返回一个 <code>Son</code> 子类构造函数，不同的是，它内部还封装了其它方法的调用。我们逐一看一下这些方法的作用。</p><blockquote><p><strong><code>_inherits(Son,_Parent)</code></strong></p></blockquote><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">_inherits</span>(subClass<span class="op">,</span> superClass) <span class="op">&#123;</span>
  <span class="cf">if</span> (<span class="kw">typeof</span> superClass <span class="op">!==</span> <span class="st">&quot;function&quot;</span> <span class="op">&amp;&amp;</span> superClass <span class="op">!==</span> <span class="kw">null</span>) <span class="op">&#123;</span>
    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&quot;Super expression must either be null or a function&quot;</span>)<span class="op">;</span>
  <span class="op">&#125;</span>
  <span class="va">subClass</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(superClass <span class="op">&amp;&amp;</span> <span class="va">superClass</span>.<span class="at">prototype</span><span class="op">,</span> <span class="op">&#123;</span>
    <span class="dt">constructor</span><span class="op">:</span> <span class="op">&#123;</span> 
        <span class="dt">value</span><span class="op">:</span> subClass<span class="op">,</span> 
        <span class="dt">writable</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span> 
        <span class="dt">configurable</span><span class="op">:</span> <span class="kw">true</span> 
    <span class="op">&#125;</span>
  <span class="op">&#125;</span>)<span class="op">;</span>
  <span class="cf">if</span> (superClass) <span class="at">_setPrototypeOf</span>(subClass<span class="op">,</span> superClass)<span class="op">;</span>
<span class="op">&#125;</span></code></pre></div><p><code>_inherit</code> 是实现继承的其中一个核心方法，可以说它的本质就是 ES5 中的寄生组合式继承。这个方法接受一个父类和子类作为参数，首先会检查父类是不是函数或者 <code>null</code>，如果不是，则抛出错误（为什么父类可以是 <code>null</code>？<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903575613603853#heading-0">从 extends 看 JS 继承</a>这篇文章进行了解释，这里我就不重复了）。</p><p>接着，调用 <code>Object.create</code> 设置父类的原型为子类原型的 <code>__proto__</code>。这里我们会看到还传入了第二个参数，这个参数是子类原型的属性的特性描述对象（descriptor），我们对 <code>constructor</code> 属性进行了设置，将它设置为可写、可配置，同时利用 <code>value</code> 修复了因重写子类原型而丢失的 <code>constructor</code> 指向。为什么不设置 <code>enumerable: false</code> 呢？因为默认就是不可枚举的，不设置也行。</p><p>最后，我们设置子类的 <code>__proto__</code> 指向父类，这是 ES5 中没有的，目的是让子类继承父类的静态方法（可以直接通过类调用的方法）。</p><p>可以看到，通过调用 <code>_inherit</code> 函数，我们已经成功让子类继承了父类的原型方法和静态方法。不过，实例上的属性怎么继承呢？这就要继续往下看了，接下来我们调用 <code>_createSuper()</code> 函数并传入派生类（子类），这不是重点，重点是它创建并返回的另一个函数 <code>_super</code>。</p><blockquote><p><strong><code>_super.call(this)</code></strong></p></blockquote><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">_createSuper</span>(Derived) <span class="op">&#123;</span>
  <span class="kw">var</span> hasNativeReflectConstruct <span class="op">=</span> <span class="at">_isNativeReflectConstruct</span>()<span class="op">;</span>
  <span class="cf">return</span> <span class="kw">function</span> <span class="at">_createSuperInternal</span>() <span class="op">&#123;</span>
    <span class="kw">var</span> Super <span class="op">=</span> <span class="at">_getPrototypeOf</span>(Derived)<span class="op">,</span>
      result<span class="op">;</span>
    <span class="cf">if</span> (hasNativeReflectConstruct) <span class="op">&#123;</span>
      <span class="kw">var</span> NewTarget <span class="op">=</span> <span class="at">_getPrototypeOf</span>(<span class="kw">this</span>).<span class="at">constructor</span><span class="op">;</span>
      result <span class="op">=</span> <span class="va">Reflect</span>.<span class="at">construct</span>(Super<span class="op">,</span> arguments<span class="op">,</span> NewTarget)<span class="op">;</span>
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
      result <span class="op">=</span> <span class="va">Super</span>.<span class="at">apply</span>(<span class="kw">this</span><span class="op">,</span> arguments)<span class="op">;</span>
    <span class="op">&#125;</span>
    <span class="cf">return</span> <span class="at">_possibleConstructorReturn</span>(<span class="kw">this</span><span class="op">,</span> result)<span class="op">;</span>
  <span class="op">&#125;;</span>
<span class="op">&#125;</span></code></pre></div><p>这里的 <code>_createSuperInternal</code> 就是 <code>_super</code>，调用的时候我们绑定了其内部的 <code>this</code> 为子类实例。</p><p>它首先会根据之前的 <code>_isNativeReflectConstruct</code> 检查当前环境是否支持 <code>Reflect</code>，如果支持，则执行 <code>result = Reflect.construct(Super, arguments, NewTarget)</code>，否则执行 <code>result = Super.apply(this, arguments)</code>。</p><p>解释一下这里为什么要优先使用 <code>Reflect</code>。当执行 <code>Reflect.construct(Super, arguments, NewTarget)</code>的时候，最终会返回一个基于 <code>Super</code> 父类构造函数创建的实例，相当于执行了 <code>new Super(...arguments)</code>，但是，<strong>这个实例的 <code>__proto__</code> 的 <code>constructor</code> 是 <code>NewTarget</code></strong>，因此在某种程度上，你也可以说这就是一个子类实例，不过它拥有父类实例的所有属性。</p><p>可能你会说，这和下面的 <code>Super.apply</code> （借用构造函数继承）不是没区别吗？非也。我们使用 <code>Super.apply</code> 的时候，其实 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target">new.target</a> 属性是会丢失的，就像下面这样：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Super</span>()<span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">new</span>.<span class="at">target</span>)
<span class="op">&#125;</span>
<span class="kw">new</span> <span class="at">Super</span>()       <span class="co">// Super</span>
<span class="va">Super</span>.<span class="at">apply</span>(<span class="op">&#123;&#125;</span>)   <span class="co">// undefined</span></code></pre></div><p>但是如果使用 <code>Reflect.consturct</code> 来创建对象，则 <code>new.target</code> 不会丢失：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Super1</span>()<span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Super1&#39;</span>)
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">new</span>.<span class="at">target</span>)
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">Super2</span>()<span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Super2&#39;</span>)
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">new</span>.<span class="at">target</span>)
<span class="op">&#125;</span>
<span class="kw">const</span> obj1 <span class="op">=</span> <span class="va">Reflect</span>.<span class="at">construct</span>(Super1<span class="op">,&#123;&#125;</span>)              
<span class="co">// &#39;Super1&#39;</span>
<span class="co">//  Super1</span>
<span class="kw">const</span> obj2 <span class="op">=</span> <span class="va">Reflect</span>.<span class="at">construct</span>(Super1<span class="op">,&#123;&#125;,</span>Super2)
<span class="co">// &#39;Super1&#39;</span>
<span class="co">//  Super2</span></code></pre></div><p>可以看到，即便没有通过 <code>new</code> 去调用 <code>Super1</code>，<code>new.target</code> 也仍然指向 <code>Super1</code>；而在传了第三个参数之后，<code>new.target</code> 也没有丢失，只是指向了 <code>Super2</code>（前面我们说过了，某种程度上，可以说 <code>obj1</code> 就是 <code>Super2</code> 的实例）。</p><p>所以，这里优先使用 <code>Reflect</code>，是为了保证 <code>new.target</code> 不会丢失。</p><p>之后，<code>result</code> 可能有三种取值：</p><ul><li>一个继承了父类实例所有属性的子类实例</li><li>父类构造函数的调用结果，可能是父类构造函数中自定义返回的一个非空对象</li><li>父类构造函数的调用结果，可能是默认返回的 <code>undefined</code></li></ul><p>如何处理这些不同的情况呢？这里调用了前面讲过的 <code>_possibleConstructorReturn(this,result)</code>函数，如果判断 <code>result</code> 是一个非空对象，也就是第一种和第二种取值情况，那么就直接返回 <code>result</code>；否则就是第三种情况了，此时就对当初传进去的子类实例（已经通过 <code>Super.apply</code> 对它进行了增强），也就是 <code>this</code>，进行断言，然后返回出去。</p><p>现在，让我们再回到 <code>Son</code> 构造函数。可以看到，调用它之后返回的正是 <code>_super.call(this)</code>，也就是返回 <code>result</code> 或者经过增强的<code>this</code>。这里的 <code>result</code> 我们知道也有两种取值，如果是一个继承了父类实例所有属性的子类实例，那么实际上等价于经过增强的 <code>this</code>；如果是父类构造函数中自定义返回的一个非空对象，则意味着调用 <code>Son</code>构造函数之后返回的对象实际上并没有继承父类中声明的实例属性。类似下面这样：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Parent</span>()<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">1</span>
    <span class="cf">return</span> <span class="op">&#123;</span><span class="dt">b</span><span class="op">:</span><span class="dv">1</span><span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">Son</span>()<span class="op">&#123;</span>
    <span class="cf">return</span> <span class="va">Parent</span>.<span class="at">call</span>(<span class="kw">this</span>)
<span class="op">&#125;</span>
<span class="va">Son</span>.<span class="va">prototype</span>.<span class="at">__proto__</span> <span class="op">=</span> <span class="va">Parent</span>.<span class="at">prortotype</span>
<span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">Son</span>()
<span class="va">console</span>.<span class="at">log</span>(obj)     
<span class="co">// &#123;b:1&#125;      </span>
<span class="co">// 这里 `Son` 同样也是返回父类 `Parent` 的调用结果（一个对象），它并没有继承在父类上声明的实例属性 `a`。</span></code></pre></div><p>到这里，我们的分析基本就结束了。希望你阅读完本文之后有所收获，若发现文章有错误，也欢迎评论区指正。</p><p>`</p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（五）：如何实现 instanceof？/">JS 原生方法原理探究（五）：如何实现 instanceof？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp587&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp2 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（五）：如何实现 instanceof？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第五篇文章。本文会介绍如何实现 <code>instanceof</code> 方法。</p><p><code>typeof</code> 操作符返回一个表示数据类型的字符串，它可以应付常规场景下的数据类型判断。对基本数据类型 <code>undefined</code>、 <code>boolean</code>、<code>string</code>、 <code>number</code>、<code>Symbol</code> 和引用数据类型 <code>function</code> 都可以正确判断，但是对 null、数组、对象则统一返回 &quot;object&quot;。</p><p>比如说：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">F1</span>()<span class="op">&#123;&#125;</span>
<span class="kw">function</span> <span class="at">F2</span>()<span class="op">&#123;&#125;</span>
<span class="kw">const</span> obj1 <span class="op">=</span> <span class="kw">new</span> <span class="at">F1</span>()
<span class="kw">const</span> obj2 <span class="op">=</span> <span class="kw">new</span> <span class="at">F2</span>()
<span class="kw">typeof</span> obj1            <span class="co">// ‘object’</span>
<span class="kw">typeof</span> obj2           <span class="co">// &#39;object&#39; </span></code></pre></div><p>这里只能看出 <code>obj1</code> 和 <code>obj2</code> 是对象，但不知道具体是哪个构造函数创建的对象。</p><p>但使用 <code>instanceof</code> 之后，就一目了然了：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">console</span>.<span class="at">log</span>(obj1 <span class="kw">instanceof</span> F1)    <span class="co">// true</span>
<span class="va">console</span>.<span class="at">log</span>(obj1 <span class="kw">instanceof</span> F2)    <span class="co">// false</span>
<span class="va">console</span>.<span class="at">log</span>(obj2 <span class="kw">instanceof</span> F2)    <span class="co">// true</span></code></pre></div><p>根据 MDN 的描述：</p><blockquote><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p></blockquote><p><code>instanceof</code> 运算符有两个操作数，左操作数通常是一个实例对象，它的类型可以是对象或者函数，也可以是基本类型（这种情况下不会报错，但总返回 <code>false</code>），右操作数通常是一个可调用的（callable）对象，我们可以直接认为它的类型应该是一个函数。</p><p>那么 <code>instanceof</code> 的实现原理是什么呢？从定义中我们可以看到，它的原理和原型链的机制有关，具体地说，它会拿到右操作数的原型对象，然后在左操作数上通过 <code>__proto__</code> 不断查找实例的原型链，只要右操作数的 <code>prototype</code> 出现在左操作数的原型链上时，就返回 true。如果原型链一直查找到尽头 —— 也就是 <code>null</code>，还没有找到右操作数的原型，就返回 <code>false</code>。</p><p>所以，在模拟实现中，我们只要不断遍历左操作数的原型链，取得原型链上的原型对象，并与右操作数的原型对象比较即可。</p><p>下面是具体的代码实现：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myInstanceof</span>(instance<span class="op">,</span>constructor)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> instance <span class="op">!=</span> <span class="st">&#39;object&#39;</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> instance <span class="op">!=</span> <span class="st">&#39;function&#39;</span> <span class="op">||</span> instance <span class="op">==</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">return</span> <span class="kw">false</span>
    <span class="op">&#125;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> constructor <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="at">TypeError</span>(<span class="st">&#39;the right-hand-side of instanceof must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">let</span> proto <span class="op">=</span> <span class="va">constructor</span>.<span class="at">prototype</span>
    <span class="kw">let</span> p <span class="op">=</span> <span class="va">instance</span>.<span class="at">__proto__</span>
    <span class="cf">while</span>(p <span class="op">!=</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">if</span>(p <span class="op">==</span> proto)<span class="op">&#123;</span>
            <span class="cf">return</span> <span class="kw">true</span>
        <span class="op">&#125;</span>
        p <span class="op">=</span> <span class="va">p</span>.<span class="at">__proto__</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（四）：如何实现继承的几种方式？/">JS 原生方法原理探究（四）：如何实现继承的几种方式？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.1k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（四）：如何实现继承的几种方式？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第四篇文章。本文会介绍如何实现 JS 中常见的几种继承方式，同时简要它们的优缺点。</p><h3 id="实现继承的方法">实现继承的方法</h3><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/8.jpg"></div><p>实现继承的方法共有 7 种，这 7 种方法并不是互相独立的，它们之间更像是一种互补或者增强的关系。</p><ul><li>原型链继承和借用构造函数继承分别解决了<strong>继承父类方法</strong>和<strong>继承父类属性</strong>的问题，这两个方法结合就得到了组合继承；</li><li>原型式继承的核心是实现对象的浅拷贝并进行增强，寄生式继承则将这个过程封装成一个返回对象的函数；</li><li>寄生组合式继承结合了寄生式继承和组合式继承，是相对比较完美的方案。</li><li>Class extends 继承是 ES6 的，本质上是寄生组合式继承的一种运用</li></ul><p>下面的示例中，<code>SuperType</code> 表示父类，<code>SubType</code> 表示继承父类的子类。</p><h3 id="原型链继承">1）原型链继承</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">SuperType</span>()<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">names</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="va">SuperType</span>.<span class="va">prototype</span>.<span class="at">getNames</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
<span class="kw">function</span> <span class="at">SubType</span>()<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">ages</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="va">SubType</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">SuperTye</span>()
<span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">SubType</span>()</code></pre></div><p>原型链继承的核心就一句话：用父类实例作为子类原型，这使得子类实例最终可以访问父类上的属性和其原型上的方法。而它的缺点也很明显：</p><p>第一：由于父类构造函数只调用了一次，导致子类的原型都统一指向了这次调用所创建的父类实例，所以子类实例在访问一些自身没有的引用类型的属性时，实际上访问的都是那同一个父类实例上的属性。但通常，实例和实例之间应该都有自己的属性副本，不应该共享属性</p><p>第二：同样是由于只调用了一次父类构造函数，所以子类无法向父类传参</p><h3 id="借用构造函数继承">2）借用构造函数继承</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">SupterTye</span>(names)<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">names</span> <span class="op">=</span> names
    <span class="kw">this</span>.<span class="at">getNames</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">SubType</span>()<span class="op">&#123;</span>
    <span class="va">SuperType</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span>[])
    <span class="kw">this</span>.<span class="at">ages</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">SubType</span>()</code></pre></div><p>借用构造函数继承也称为经典继承，这里所谓的借用指的是借用父类构造函数，它的核心就是完全不使用原型，而是在子类构造函数中通过 call 调用父类构造函数，从而增强子类实例 —— 相当于把父类实例上的属性都搬到子类实例这里来。</p><p>这种继承方法的优点就在于，它解决了原型链继承的缺点，我们现在可以往父类传参了，而且每次 new 子类的时候都会重新调用一次父类，这使得子类的所有实例都有自己的属性副本。</p><p>属性是没问题了，方法的继承又有了问题。由于父类构造函数是重复调用的，所以每个实例都有自己的方法副本，但问题是，方法并不需要副本，所有实例完全应该共享同一个方法，所以这里为每个实例重复创建同一个方法，就存在一定的性能问题。此外，对于父类原型上的方法，子类是无法继承的，因为这种继承方式并没有使用到原型。</p><h3 id="组合继承">3）组合继承</h3><p>看起来，原型链继承擅长方法继承，而借用构造函数继承擅长属性继承，那么能不能取二者之长呢？实际上，结合两者的优点，就是所谓的组合继承了。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">SuperType</span>(names)<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">names</span> <span class="op">=</span> names
<span class="op">&#125;</span>
<span class="va">SuperType</span>.<span class="va">prototype</span>.<span class="at">getNames</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
<span class="kw">function</span> <span class="at">SubType</span>()<span class="op">&#123;</span>
    <span class="va">SuperType</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span>[])
    <span class="kw">this</span>.<span class="at">ages</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="va">SubType</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">SuperType</span>()
<span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">SubType</span>()</code></pre></div><p>组合继承使用原型链继承的方式去继承方法，使用构造函数继承的方式去继承属性。</p><p>PS：组合继承和原型链继承都重写了子类的原型，在重写之前，子类的原型的 <code>constructor</code> 是指向子类的，重写后就不是了，因为子类的原型被代之以一个 new 创建的对象字面量。这里可以通过 <code>SubType.prototype.constructor = SubType</code> 修复 constructor 的指向。</p><h3 id="原型式继承">4） 原型式继承</h3><p>原型式继承所做的事情类似于浅拷贝一个对象，再通过自定义的方式增强新对象。它能够方便地实现在不同对象之间共享信息，同时又不需要额外创建构造函数（内部做了处理）。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;jack&#39;</span><span class="op">,</span>
    <span class="dt">friends</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>]
<span class="op">&#125;</span>
fucntion <span class="at">createObject</span>(o)<span class="op">&#123;</span>
    <span class="kw">function</span> <span class="at">F</span>()<span class="op">&#123;&#125;</span>
    <span class="va">F</span>.<span class="at">prototype</span> <span class="op">=</span> o
    <span class="cf">return</span> <span class="kw">new</span> <span class="at">F</span>()
<span class="op">&#125;</span>
<span class="kw">const</span> anotherObj <span class="op">=</span> <span class="at">createObject</span>(obj)
<span class="va">anotherObj</span>.<span class="at">name</span> <span class="op">=</span> <span class="st">&#39;Tom&#39;</span>
<span class="va">anotherObj</span>.<span class="at">friends</span> <span class="op">=</span> [<span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]</code></pre></div><p>ES5 在规范层面实现了原型式继承，也就是所谓的 <code>Object.create()</code> 方法，上面代码可以改为：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;jack&#39;</span><span class="op">,</span>
    <span class="dt">friends</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>]
<span class="op">&#125;</span>
<span class="kw">const</span> anotherObj <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(obj)</code></pre></div><p>这个方法所做的事情和 createObject 方法是一样的，它最终会返回一个新对象，而这个新对象的原型是传入的参数（我们传入的参数一般充当一个原型对象）。而且，当我们传参 <code>null</code> 的时候，它最终会返回一个没有原型的纯粹的对象，也就是所谓的裸对象（naked object）。</p><h3 id="寄生式继承">5） 寄生式继承</h3><p>寄生式继承在原型式继承的基础上，为新对象增加了方法：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;jack&#39;</span><span class="op">,</span>
    <span class="dt">friends</span><span class="op">:</span> []
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">createObject</span>(o)<span class="op">&#123;</span>
    <span class="co">// 对象浅拷贝</span>
    <span class="kw">let</span> anotherObj <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(o)
    <span class="co">// 对象增强</span>
    <span class="va">anotherObj</span>.<span class="at">getFriends</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
    <span class="cf">return</span> anotherObj
<span class="op">&#125;</span>
<span class="kw">const</span> anotherObj <span class="op">=</span> <span class="at">createObject</span>(obj)</code></pre></div><h3 id="寄生组合式继承">6）寄生组合式继承</h3><p>寄生组合式继承的出现是为了解决组合继承存在的一些问题，这种继承基本上是完美的了。</p><p>组合继承最大的问题在于，它两次调用了父类构造函数。第一次是在子类构造函数中 call 调用父类构造函数，这个时候实际上已经使得子类实例拥有了父类的属性；第二次是 new 调用父类构造函数并作为子类的原型，这时候又使得子类原型上也有了父类的属性。因此这两次调用带来的开销问题不说，更关键的是出现了两组重复的属性，这完全是不必要的。所以，利用寄生组合式继承，我们可以做到<strong>只调用一次父类构造函数</strong>。</p><p>假设我们现在有一个父类，然后需要实现一个继承父类的子类。用寄生组合式继承的话，代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">SuperType</span>()<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> <span class="st">&#39;jack&#39;</span>
    <span class="kw">this</span>.<span class="at">friends</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="va">SuperType</span>.<span class="va">prototype</span>.<span class="at">getFriends</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>

<span class="kw">function</span> <span class="at">SubType</span>()<span class="op">&#123;</span>
    <span class="co">// 属性继承</span>
    <span class="va">SuperType</span>.<span class="at">call</span>(<span class="kw">this</span>)
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">inherit</span>(sup<span class="op">,</span>sub)<span class="op">&#123;</span>
    <span class="va">sub</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="va">sup</span>.<span class="at">prototype</span>)
    <span class="va">sub</span>.<span class="va">prototype</span>.<span class="at">constructor</span> <span class="op">=</span> sub
    <span class="co">// 或者直接</span>
    <span class="va">sub</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="va">sup</span>.<span class="at">prototype</span><span class="op">,&#123;</span>
        <span class="dt">constructor</span><span class="op">:</span> <span class="op">&#123;</span>
            <span class="dt">value</span><span class="op">:</span> sub
            <span class="co">// enumerable 默认为 false</span>
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>)
<span class="op">&#125;</span>
<span class="co">// 方法继承</span>
<span class="at">inherit</span>(SuperType<span class="op">,</span>SubType)
<span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">SubType</span>()</code></pre></div><p>注意几个要点：</p><ul><li>属性继承仍然是采用借用构造函数继承的方式，关键是方法继承。这里通过一个 <code>inherit</code> 函数接受父类和子类，让子类继承父类的方法。在具体实现中，我们不再像原型链继承或者组合继承那样，new 一个父类构造函数作为子类的原型 —— 虽然效果看起来一样，但这是一次多余的、应该避免的父类调用。相反，我们借鉴了寄生式继承的做法，创建了一个父类原型的副本作为子类的原型。子类原型和父类原型之间其实是通过 <code>__proto__</code> 联系起来的，因此在通过子类实例访问相关方法的时候，可以确保是沿着 <code>子类实例 =&gt; 子类实例.__proto__ = 子类原型 =&gt; 子类原型.__proto__ = 父类原型</code> 这样的原型链查找，最终一定可以找到父类原型上的方法，因此就实现了方法继承。</li><li>寄生组合式继承同样重写了子类原型，所以需要修复 constructor 的指向，指回子类本身。因为 <code>Object.create</code> 本身接受两个参数，第二个参数可以设置其返回对象的属性的特性，所以也可以在传参时顺便修复 constructor 的指向</li></ul><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（三）：如何实现 new？/">JS 原生方法原理探究（三）：如何实现 new 操作符？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp5 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（三）：如何实现 new？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第三篇文章。本文会介绍如何模拟实现 <code>new</code> 操作符。关于 <code>new</code> 的具体用法，MDN 已经描述得很清楚了，这里我们只做简单的介绍，具体的重点在于如何模拟实现。</p><h3 id="new-操作符的规范">new 操作符的规范</h3><blockquote><p>下面展示的所有规范都是 ES5 版本的，与现在最新的规范有些区别</p></blockquote><p>首先看一下根据<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-11.2.2">规范</a>的描述， <code>new</code> 操作符做了什么事：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/7.jpg"></div><p>全是英文，不过没关系，我简单翻译一下：</p><p>我在使用 <code>new</code> 操作符的时候，后面跟着的构造函数可能带参数，也可能不带参数，如果不带参数的话，比如说 <code>new Fn()</code>，那么这里这个 <code>Fn</code> 就是一个 <code>NewExpression</code>；如果带参数，比如说 <code>new Fn(name,age)</code>，那么这里的 <code>Fn</code> 就是一个 <code>MemberExpression</code>。</p><p>这两种情况下使用 <code>new</code> 操作符所进行的操作有点点不同，这里拿带参数的情况说明一下：</p><ol style="list-style-type:decimal"><li>首先会对 <code>Fn</code> 这个 <code>MemberExpression</code> 求值，其结果是指向实际函数对象的一个引用，我们把这个引用作为 <code>ref</code></li><li>接着调用 <code>GetValue(ref)</code> 进行求值，得到实际的函数对象，把这个对象作为 <code>constructor</code></li><li>对 <code>Arguments</code> 也就是传进来的参数求值，得到一个参数列表，作为 <code>argList</code></li><li>如果 <code>constructor</code> 不是对象，则抛出类型错误</li><li>如果 <code>constructor</code> 没有实现内部的 <code>[[Constructor]]</code> 方法，也抛出类型错误</li><li>调用 <code>constructor</code> 的 <code>[[Constructor]]</code>方法，并将 <code>argList</code> 传入作为参数，返回调用结果</li></ol><p>从这些描述可以看出，更多的实现细节放在函数的 <code>[[Constructor]]</code> 方法里。那么这个方法具体是做什么用的呢？</p><h3 id="constructor-的规范"><code>[[Constructor]]</code> 的规范</h3><p>在 JS 中，函数有两种调用方式，一种是正常调用，这将调用函数的内部方法 <code>[[Call]]</code>，还有一种是通过 new 调用，此时的函数作为一个构造函数，这将调用函数的另一个内部方法 <code>[[Consturct]]</code>。所以，要实现 <code>new</code> 操作的话，我们得先搞懂 <code>[[Construct]]</code> 内部方法做了什么事。</p><p>这里继续看<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/">规范</a>是怎么说的：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/5.jpg"></div><p>简单翻译一下：</p><p>当通过可能为空的参数列表调用函数 <code>F</code> 的内部方法 <code>[[Construct]]</code> 的时候，会执行如下步骤：</p><ol style="list-style-type:decimal"><li>让 <code>obj</code> 作为一个新创建的原生对象</li><li>按照规范指定的，为 <code>obj</code> 设置所有内部方法</li><li>将 <code>obj</code> 的内部属性 <code>[[Class]]</code> 设置为 <code>Object</code></li><li>传参 <code>prototype</code> 调用函数 <code>F</code> 的内部方法 <code>[[Get]]</code>，获取函数的原型对象，作为 <code>proto</code></li><li>如果 <code>proto</code> 是对象，则将 <code>obj</code> 的内部属性 <code>[[Prototype]]</code> 设置为 <code>proto</code></li><li>如果 <code>proto</code> 不是对象，则将 <code>obj</code> 的内部属性 <code>[[Prototype]]</code> 设置为标准内建的 <code>Object</code> 的原型对象</li><li>调用函数 <code>F</code> 的内部方法 <code>Call</code>， <code>obj</code> 作为调用时的 this 值，此前传给 <code>[[Construct]]</code> 的参数列表作为调用时的参数。将调用后得到的结果作为 <code>result</code></li><li>如果 <code>result</code> 是对象，则将其返回</li><li>否则，返回 <code>obj</code></li></ol><p>可以说，规范已经讲得很清楚了，简单地说，在 new 一个构造函数的时候，具体会做下面的事情：</p><ul><li>内部创建一个实例对象，并指定实例对象的原型：</li><li>如果构造函数的原型是对象，则让实例的 <code>__proto__</code> 等于构造函数的 <code>prototype</code></li><li>如果构造函数的原型不是对象，则让实例的 <code>__proto__</code> 等于 <code>Object</code> 的 <code>prototype</code></li><li>将实例对象绑定为构造函数中的 this，此前传递进来的参数作为参数，并执行一遍构造函数</li><li>如果构造函数返回了对象，则将其作为返回值，否则将实例对象作为返回值</li></ul><h3 id="代码实现">代码实现</h3><p>ES3 版本的实现如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myNew</span>(Fn)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> Fn <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(Fn <span class="op">+</span> <span class="st">&#39;is not a constructor&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">myNew</span>.<span class="at">target</span> <span class="op">=</span> Fn
    <span class="kw">var</span> instance <span class="op">=</span> <span class="op">&#123;&#125;</span>
    <span class="co">// 检测构造函数原型是不是对象</span>
    <span class="va">instance</span>.<span class="at">__proto__</span> <span class="op">=</span> <span class="va">Fn</span>.<span class="at">prototype</span> <span class="at">instanceof</span> <span class="at">Object</span> <span class="op">?</span> <span class="va">Fn</span>.<span class="at">prototype</span> : <span class="va">Object</span>.<span class="at">prototype</span> 
    <span class="kw">const</span> returnValue <span class="op">=</span> <span class="va">Fn</span>.<span class="at">apply</span>(instance<span class="op">,</span><span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">slice</span>.<span class="at">call</span>(arguments<span class="op">,</span><span class="dv">1</span>))
    <span class="cf">if</span>(<span class="kw">typeof</span> returnValue <span class="op">===</span> <span class="st">&#39;object&#39;</span> <span class="op">&amp;&amp;</span> returnValue <span class="op">!==</span> <span class="kw">null</span> <span class="op">||</span> <span class="kw">typeof</span> returnValue <span class="op">===</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">return</span> returnValue
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        <span class="cf">return</span> instance
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>ES6 版本的实现如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myNew</span>(Fn<span class="op">,</span>...<span class="at">args</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> Fn <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(Fn <span class="op">+</span> <span class="st">&#39;is not a constructor&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">myNew</span>.<span class="at">target</span> <span class="op">=</span> Fn
    <span class="kw">const</span> instance <span class="op">=</span> <span class="op">&#123;&#125;</span>
    <span class="co">// 检测构造函数原型是不是对象</span>
    <span class="va">instance</span>.<span class="at">__proto__</span> <span class="op">=</span> <span class="va">Fn</span>.<span class="at">prototype</span> <span class="at">instanceof</span> <span class="at">Object</span> <span class="op">?</span> <span class="va">Fn</span>.<span class="at">prototype</span> : <span class="va">Object</span>.<span class="at">prototype</span> 
    <span class="kw">const</span> returnValue <span class="op">=</span> <span class="va">Fn</span>.<span class="at">call</span>(instance<span class="op">,</span>...<span class="at">args</span>)
    <span class="cf">return</span> returnValue <span class="kw">instanceof</span> Object <span class="op">?</span> returnValue : instance
<span class="op">&#125;</span></code></pre></div><p>注意几个要点：</p><ul><li>当函数是通过 new 调用的时候，<code>new.target</code> 会指向函数自身，这个“指向”的操作在代码里就是通过 <code>myNew.target = Fn</code> 体现的</li><li>为什么不直接使用 <code>const instance = Object.create(Fn.prototype)</code> 创建实例呢？根据<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-13.2.2">规范</a>，我们在实现 new 的时候，需要检测构造函数的原型是不是对象，如果不是对象，比如说是 null，那么实例的 <code>__proto__</code> 会指向 Object 的原型，而这里如果使用了 <code>Object.create</code>，则会导致实例的 <code>__proto__</code> 仍然指向 null。网上很多 <code>new</code> 的模拟实现直接使用了 <code>Object.create</code>，或者根本没有对构造函数的原型进行类型检查，这是不够严谨的</li><li>如果无法使用 <code>instanceof</code>，我们也可以改用 <code>typeof Fn.prototype === 'Object' &amp;&amp; Fn.prototype !== null</code> 进行判断</li></ul><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（二）：如何实现 Object.create()？/">JS 原生方法原理探究（二）：如何实现 Object.create？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.2k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp4 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（二）：如何实现 Object.create()？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第二篇文章。本文会介绍如何实现 <code>Object.create()</code> 方法。关于这个方法的具体用法，MDN 已经描述得很清楚了，这里我们只做简单的介绍，具体的重点在于如何模拟实现。</p><h2 id="语法简介">语法简介</h2><blockquote><p>调用：Object.create ( proto , propertiesObject )</p><p>返回： 一个新的实例对象</p></blockquote><p>调用这个方法的时候接受两个参数，第一个参数作为返回对象的 <code>__proto__</code>，这个参数只能是 null 或者对象（而且不能是基本类型的包装对象）。</p><p>第二个参数作为返回对象的属性描述，它和 <code>Object.defineProperties()</code> 的第二个参数形式是一样的：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">&#123;</span>
    <span class="dt">propertyA</span><span class="op">:</span> <span class="op">&#123;</span>
        <span class="dt">value</span><span class="op">:</span> xxx<span class="op">,</span>
        <span class="dt">configurable</span><span class="op">:</span> xxx<span class="op">,</span>
        <span class="dt">enumerable</span><span class="op">:</span> xxx<span class="op">,</span>
        <span class="dt">writable</span><span class="op">:</span> xxx    
    <span class="op">&#125;,</span>
    <span class="dt">propertyB</span><span class="op">:</span> <span class="op">&#123;</span>...<span class="op">&#125;,</span>
    <span class="dt">propertyC</span><span class="op">:</span> <span class="op">&#123;</span>...<span class="op">&#125;</span>    
<span class="op">&#125;</span></code></pre></div><p>这个参数的每一个属性都会作为返回对象的属性，而属性值则是相应属性的特性描述（该属性的属性值、是否可读、是否可枚举、是否可配置）。第二个参数只能是对象或者 undefined（表示没有传第二个参数），不能是 null。</p><h2 id="es-规范">ES 规范</h2><p>对于 <code>Object.create()</code> 的具体实现，规范中其实已经描述得很清楚，可以进入http://es5.github.io/#x15.2.3.5查看：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/2.jpg"></div><p>我简单翻译一下这段话：</p><p><code>create()</code> 方法会创建一个具有指定原型的新对象，当调用该方法的时候，会有如下步骤：</p><ol style="list-style-type:decimal"><li>如果传入的参数 <code>O</code> 不是对象也不是 <code>null</code>，抛出 TypeError 错误</li><li>令 <code>obj</code> 作为调用 <code>new Object()</code> 方法所创建的新对象</li><li>将 <code>obj</code> 的内部属性 <code>[[prototype]]</code> 设置为 <code>O</code></li><li>如果提供了第二个参数 <code>Properties</code>，且不是 <code>undefined</code>，则调用 <code>Object.defineProperties</code> 方法并传入 <code>obj</code> 和 <code>Properties</code> 作为参数，从而为 <code>obj</code> 添加它自己的属性</li><li>返回 <code>obj</code></li></ol><p>可以说，整个过程是一目了然的，我们实现的时候也只需要按照上述步骤实现即可。</p><h2 id="代码实现">代码实现</h2><p>我们先看第一种实现：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">create</span> <span class="op">=</span> <span class="kw">function</span>(proto<span class="op">,</span>propertiesObject)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> proto <span class="op">!=</span> <span class="st">&#39;object&#39;</span> <span class="op">&amp;&amp;</span> proto <span class="op">!==</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the first param must be an object or null&#39;</span>)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> propertiesObject <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="st">&#39;TypeError&#39;</span>
    <span class="op">&#125;</span>
    <span class="kw">let</span> obj <span class="op">=</span> <span class="op">&#123;&#125;</span>
    <span class="va">obj</span>.<span class="at">__proto__</span> <span class="op">=</span> proto
    <span class="cf">if</span>(propertiesObject)<span class="op">&#123;</span>
        <span class="va">Object</span>.<span class="at">defineProperties</span>(obj<span class="op">,</span>propertiesObject)
    <span class="op">&#125;</span>
    <span class="cf">return</span> obj
<span class="op">&#125;</span></code></pre></div><p>基本上没有什么大问题。不过，我们要留意两个地方：</p><ul><li>在这个实现中，没有检测第一个参数是不是基本类型的包装对象，只要传进来的参数是对象，我们就认为是合法的</li><li>当传入 null 也即 <code>Object.create(null)</code> 的时候，我们实际上创建了一个很纯粹的空对象，这个对象的原型直接就是 null，<code>Object.prototype</code> 甚至没有出现在该对象的原型链中，这意味这个对象不会继承 Object 的任何方法。</li></ul><p>此外，你还可能在其他地方看到类似下面这样的实现：</p><p>具体实现如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">create</span> <span class="op">=</span> <span class="kw">function</span>(proto<span class="op">,</span>propertiesObject)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> proto <span class="op">!=</span> <span class="st">&#39;object&#39;</span> <span class="op">&amp;&amp;</span> proto <span class="op">!==</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the first param must be an object or null&#39;</span>)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(propertiesObject <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="st">&#39;TypeError&#39;</span>
    <span class="op">&#125;</span>
    <span class="kw">function</span> <span class="at">F</span>()<span class="op">&#123;&#125;</span>
    <span class="va">F</span>.<span class="at">prototype</span> <span class="op">=</span> proto
    <span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">F</span>()
    <span class="co">// 处理传参 null 的情况</span>
    <span class="cf">if</span>(proto <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="va">obj</span>.<span class="at">__proto__</span> <span class="op">=</span> proto
    <span class="op">&#125;</span>
    <span class="cf">if</span>(propertiesObject)<span class="op">&#123;</span>
        <span class="va">Object</span>.<span class="at">defineProperties</span>(obj<span class="op">,</span>propertiesObject)
    <span class="op">&#125;</span>
    <span class="cf">return</span> obj
<span class="op">&#125;</span></code></pre></div><p>这个实现和前面的实现有一个很关键的区别：代码中单独处理了传参 <code>proto</code> 为 <code>null</code> 的情况。可能你会觉得很奇怪：当 <code>proto</code> 为 <code>null</code> 的时候，<code>F.prototype = proto</code> 的效果和 <code>obj.__proto__ = proto</code> 应该是一样的，为什么还要在这种情况下执行一遍 <code>obj.__proto__ = proto</code> 呢？这似乎说明，用 null 重写 F 的原型后，新创建的实例的 <code>__proto__</code> 并不是 null —— 事实上确实不是。</p><p>关于调用构造函数时会执行的操作，<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-13.2.2">规范</a>明确提到了这一点：</p><blockquote><p>If <a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-8">Type</a>(<em>proto</em>) is not Object, set the [[Prototype]] internal property of <em>obj</em> to the standard built-in Object prototype object as described in <a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-15.2.4">15.2.4</a>.</p></blockquote><p>由于我们这里是通过 new 构造函数的方式创建新对象（而不是像之前那样通过对象字面量的形式），所以在 new F 的时候，内部会检测 F 的原型是不是对象，如果不是对象，那么会把实例的 <code>__proto__</code> 链接到内建的 <code>Object.prototype</code>。因此，这里新创建的实例的 <code>__proto__</code> 还真不是 null。</p><p>但根据 <code>Object.create</code> 的实现规范，这里必须让实例的 <code>__proto__</code> 指向 null，所以才需要执行 <code>obj.__proto__ = proto</code> 去手动设置对象原型。</p><p>当然，如果我们像第一个实现那样，直接去设置对象的 <code>__proto__</code>，而不是采用构造函数的方式，就不存在这个问题了。</p><div class="default">阅读全文......</div></a></div></article></section></div><nav class="pager-nav"><span class="page-number current">1</span><a class="page-number" href="/categories/Front-end/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/categories/Front-end/page/7/">7</a><a class="extend next" rel="next" href="/categories/Front-end/page/2/">Next »</a></nav></div></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->