<!-- build time:Sun Sep 05 2021 14:32:58 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><span class="local-search local-search-plugin"><i class="fa fa-search"></i> <input type="search" placeholder="Search here......" id="local-search-input" class="local-search-input-cls"> <span class="local-search-border"></span><div id="local-search-result" class="local-search-result-cls"></div></span><div id="blog-down-reach"></div><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（五）：如何实现 instanceof？/">JS 原生方法原理探究（五）：如何实现 instanceof？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp587&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp2 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（五）：如何实现 instanceof？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第五篇文章。本文会介绍如何实现 <code>instanceof</code> 方法。</p><p><code>typeof</code> 操作符返回一个表示数据类型的字符串，它可以应付常规场景下的数据类型判断。对基本数据类型 <code>undefined</code>、 <code>boolean</code>、<code>string</code>、 <code>number</code>、<code>Symbol</code> 和引用数据类型 <code>function</code> 都可以正确判断，但是对 null、数组、对象则统一返回 &quot;object&quot;。</p><p>比如说：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">F1</span>()<span class="op">&#123;&#125;</span>
<span class="kw">function</span> <span class="at">F2</span>()<span class="op">&#123;&#125;</span>
<span class="kw">const</span> obj1 <span class="op">=</span> <span class="kw">new</span> <span class="at">F1</span>()
<span class="kw">const</span> obj2 <span class="op">=</span> <span class="kw">new</span> <span class="at">F2</span>()
<span class="kw">typeof</span> obj1            <span class="co">// ‘object’</span>
<span class="kw">typeof</span> obj2           <span class="co">// &#39;object&#39; </span></code></pre></div><p>这里只能看出 <code>obj1</code> 和 <code>obj2</code> 是对象，但不知道具体是哪个构造函数创建的对象。</p><p>但使用 <code>instanceof</code> 之后，就一目了然了：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">console</span>.<span class="at">log</span>(obj1 <span class="kw">instanceof</span> F1)    <span class="co">// true</span>
<span class="va">console</span>.<span class="at">log</span>(obj1 <span class="kw">instanceof</span> F2)    <span class="co">// false</span>
<span class="va">console</span>.<span class="at">log</span>(obj2 <span class="kw">instanceof</span> F2)    <span class="co">// true</span></code></pre></div><p>根据 MDN 的描述：</p><blockquote><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p></blockquote><p><code>instanceof</code> 运算符有两个操作数，左操作数通常是一个实例对象，它的类型可以是对象或者函数，也可以是基本类型（这种情况下不会报错，但总返回 <code>false</code>），右操作数通常是一个可调用的（callable）对象，我们可以直接认为它的类型应该是一个函数。</p><p>那么 <code>instanceof</code> 的实现原理是什么呢？从定义中我们可以看到，它的原理和原型链的机制有关，具体地说，它会拿到右操作数的原型对象，然后在左操作数上通过 <code>__proto__</code> 不断查找实例的原型链，只要右操作数的 <code>prototype</code> 出现在左操作数的原型链上时，就返回 true。如果原型链一直查找到尽头 —— 也就是 <code>null</code>，还没有找到右操作数的原型，就返回 <code>false</code>。</p><p>所以，在模拟实现中，我们只要不断遍历左操作数的原型链，取得原型链上的原型对象，并与右操作数的原型对象比较即可。</p><p>下面是具体的代码实现：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myInstanceof</span>(instance<span class="op">,</span>constructor)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> instance <span class="op">!=</span> <span class="st">&#39;object&#39;</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> instance <span class="op">!=</span> <span class="st">&#39;function&#39;</span> <span class="op">||</span> instance <span class="op">==</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">return</span> <span class="kw">false</span>
    <span class="op">&#125;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> constructor <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="at">TypeError</span>(<span class="st">&#39;the right-hand-side of instanceof must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">let</span> proto <span class="op">=</span> <span class="va">constructor</span>.<span class="at">prototype</span>
    <span class="kw">let</span> p <span class="op">=</span> <span class="va">instance</span>.<span class="at">__proto__</span>
    <span class="cf">while</span>(p <span class="op">!=</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">if</span>(p <span class="op">==</span> proto)<span class="op">&#123;</span>
            <span class="cf">return</span> <span class="kw">true</span>
        <span class="op">&#125;</span>
        p <span class="op">=</span> <span class="va">p</span>.<span class="at">__proto__</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（四）：如何实现继承的几种方式？/">JS 原生方法原理探究（四）：如何实现继承的几种方式？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.1k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（四）：如何实现继承的几种方式？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第四篇文章。本文会介绍如何实现 JS 中常见的几种继承方式，同时简要它们的优缺点。</p><h3 id="实现继承的方法">实现继承的方法</h3><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/8.jpg"></div><p>实现继承的方法共有 7 种，这 7 种方法并不是互相独立的，它们之间更像是一种互补或者增强的关系。</p><ul><li>原型链继承和借用构造函数继承分别解决了<strong>继承父类方法</strong>和<strong>继承父类属性</strong>的问题，这两个方法结合就得到了组合继承；</li><li>原型式继承的核心是实现对象的浅拷贝并进行增强，寄生式继承则将这个过程封装成一个返回对象的函数；</li><li>寄生组合式继承结合了寄生式继承和组合式继承，是相对比较完美的方案。</li><li>Class extends 继承是 ES6 的，本质上是寄生组合式继承的一种运用</li></ul><p>下面的示例中，<code>SuperType</code> 表示父类，<code>SubType</code> 表示继承父类的子类。</p><h3 id="原型链继承">1）原型链继承</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">SuperType</span>()<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">names</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="va">SuperType</span>.<span class="va">prototype</span>.<span class="at">getNames</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
<span class="kw">function</span> <span class="at">SubType</span>()<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">ages</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="va">SubType</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">SuperTye</span>()
<span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">SubType</span>()</code></pre></div><p>原型链继承的核心就一句话：用父类实例作为子类原型，这使得子类实例最终可以访问父类上的属性和其原型上的方法。而它的缺点也很明显：</p><p>第一：由于父类构造函数只调用了一次，导致子类的原型都统一指向了这次调用所创建的父类实例，所以子类实例在访问一些自身没有的引用类型的属性时，实际上访问的都是那同一个父类实例上的属性。但通常，实例和实例之间应该都有自己的属性副本，不应该共享属性</p><p>第二：同样是由于只调用了一次父类构造函数，所以子类无法向父类传参</p><h3 id="借用构造函数继承">2）借用构造函数继承</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">SupterTye</span>(names)<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">names</span> <span class="op">=</span> names
    <span class="kw">this</span>.<span class="at">getNames</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">SubType</span>()<span class="op">&#123;</span>
    <span class="va">SuperType</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span>[])
    <span class="kw">this</span>.<span class="at">ages</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">SubType</span>()</code></pre></div><p>借用构造函数继承也称为经典继承，这里所谓的借用指的是借用父类构造函数，它的核心就是完全不使用原型，而是在子类构造函数中通过 call 调用父类构造函数，从而增强子类实例 —— 相当于把父类实例上的属性都搬到子类实例这里来。</p><p>这种继承方法的优点就在于，它解决了原型链继承的缺点，我们现在可以往父类传参了，而且每次 new 子类的时候都会重新调用一次父类，这使得子类的所有实例都有自己的属性副本。</p><p>属性是没问题了，方法的继承又有了问题。由于父类构造函数是重复调用的，所以每个实例都有自己的方法副本，但问题是，方法并不需要副本，所有实例完全应该共享同一个方法，所以这里为每个实例重复创建同一个方法，就存在一定的性能问题。此外，对于父类原型上的方法，子类是无法继承的，因为这种继承方式并没有使用到原型。</p><h3 id="组合继承">3）组合继承</h3><p>看起来，原型链继承擅长方法继承，而借用构造函数继承擅长属性继承，那么能不能取二者之长呢？实际上，结合两者的优点，就是所谓的组合继承了。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">SuperType</span>(names)<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">names</span> <span class="op">=</span> names
<span class="op">&#125;</span>
<span class="va">SuperType</span>.<span class="va">prototype</span>.<span class="at">getNames</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
<span class="kw">function</span> <span class="at">SubType</span>()<span class="op">&#123;</span>
    <span class="va">SuperType</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span>[])
    <span class="kw">this</span>.<span class="at">ages</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="va">SubType</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">SuperType</span>()
<span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">SubType</span>()</code></pre></div><p>组合继承使用原型链继承的方式去继承方法，使用构造函数继承的方式去继承属性。</p><p>PS：组合继承和原型链继承都重写了子类的原型，在重写之前，子类的原型的 <code>constructor</code> 是指向子类的，重写后就不是了，因为子类的原型被代之以一个 new 创建的对象字面量。这里可以通过 <code>SubType.prototype.constructor = SubType</code> 修复 constructor 的指向。</p><h3 id="原型式继承">4） 原型式继承</h3><p>原型式继承所做的事情类似于浅拷贝一个对象，再通过自定义的方式增强新对象。它能够方便地实现在不同对象之间共享信息，同时又不需要额外创建构造函数（内部做了处理）。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;jack&#39;</span><span class="op">,</span>
    <span class="dt">friends</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>]
<span class="op">&#125;</span>
fucntion <span class="at">createObject</span>(o)<span class="op">&#123;</span>
    <span class="kw">function</span> <span class="at">F</span>()<span class="op">&#123;&#125;</span>
    <span class="va">F</span>.<span class="at">prototype</span> <span class="op">=</span> o
    <span class="cf">return</span> <span class="kw">new</span> <span class="at">F</span>()
<span class="op">&#125;</span>
<span class="kw">const</span> anotherObj <span class="op">=</span> <span class="at">createObject</span>(obj)
<span class="va">anotherObj</span>.<span class="at">name</span> <span class="op">=</span> <span class="st">&#39;Tom&#39;</span>
<span class="va">anotherObj</span>.<span class="at">friends</span> <span class="op">=</span> [<span class="dv">3</span><span class="op">,</span><span class="dv">4</span>]</code></pre></div><p>ES5 在规范层面实现了原型式继承，也就是所谓的 <code>Object.create()</code> 方法，上面代码可以改为：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;jack&#39;</span><span class="op">,</span>
    <span class="dt">friends</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>]
<span class="op">&#125;</span>
<span class="kw">const</span> anotherObj <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(obj)</code></pre></div><p>这个方法所做的事情和 createObject 方法是一样的，它最终会返回一个新对象，而这个新对象的原型是传入的参数（我们传入的参数一般充当一个原型对象）。而且，当我们传参 <code>null</code> 的时候，它最终会返回一个没有原型的纯粹的对象，也就是所谓的裸对象（naked object）。</p><h3 id="寄生式继承">5） 寄生式继承</h3><p>寄生式继承在原型式继承的基础上，为新对象增加了方法：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;jack&#39;</span><span class="op">,</span>
    <span class="dt">friends</span><span class="op">:</span> []
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">createObject</span>(o)<span class="op">&#123;</span>
    <span class="co">// 对象浅拷贝</span>
    <span class="kw">let</span> anotherObj <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(o)
    <span class="co">// 对象增强</span>
    <span class="va">anotherObj</span>.<span class="at">getFriends</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
    <span class="cf">return</span> anotherObj
<span class="op">&#125;</span>
<span class="kw">const</span> anotherObj <span class="op">=</span> <span class="at">createObject</span>(obj)</code></pre></div><h3 id="寄生组合式继承">6）寄生组合式继承</h3><p>寄生组合式继承的出现是为了解决组合继承存在的一些问题，这种继承基本上是完美的了。</p><p>组合继承最大的问题在于，它两次调用了父类构造函数。第一次是在子类构造函数中 call 调用父类构造函数，这个时候实际上已经使得子类实例拥有了父类的属性；第二次是 new 调用父类构造函数并作为子类的原型，这时候又使得子类原型上也有了父类的属性。因此这两次调用带来的开销问题不说，更关键的是出现了两组重复的属性，这完全是不必要的。所以，利用寄生组合式继承，我们可以做到<strong>只调用一次父类构造函数</strong>。</p><p>假设我们现在有一个父类，然后需要实现一个继承父类的子类。用寄生组合式继承的话，代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">SuperType</span>()<span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> <span class="st">&#39;jack&#39;</span>
    <span class="kw">this</span>.<span class="at">friends</span> <span class="op">=</span> []
<span class="op">&#125;</span>
<span class="va">SuperType</span>.<span class="va">prototype</span>.<span class="at">getFriends</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>

<span class="kw">function</span> <span class="at">SubType</span>()<span class="op">&#123;</span>
    <span class="co">// 属性继承</span>
    <span class="va">SuperType</span>.<span class="at">call</span>(<span class="kw">this</span>)
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">inherit</span>(sup<span class="op">,</span>sub)<span class="op">&#123;</span>
    <span class="va">sub</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="va">sup</span>.<span class="at">prototype</span>)
    <span class="va">sub</span>.<span class="va">prototype</span>.<span class="at">constructor</span> <span class="op">=</span> sub
    <span class="co">// 或者直接</span>
    <span class="va">sub</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="va">sup</span>.<span class="at">prototype</span><span class="op">,&#123;</span>
        <span class="dt">constructor</span><span class="op">:</span> <span class="op">&#123;</span>
            <span class="dt">value</span><span class="op">:</span> sub
            <span class="co">// enumerable 默认为 false</span>
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>)
<span class="op">&#125;</span>
<span class="co">// 方法继承</span>
<span class="at">inherit</span>(SuperType<span class="op">,</span>SubType)
<span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">SubType</span>()</code></pre></div><p>注意几个要点：</p><ul><li>属性继承仍然是采用借用构造函数继承的方式，关键是方法继承。这里通过一个 <code>inherit</code> 函数接受父类和子类，让子类继承父类的方法。在具体实现中，我们不再像原型链继承或者组合继承那样，new 一个父类构造函数作为子类的原型 —— 虽然效果看起来一样，但这是一次多余的、应该避免的父类调用。相反，我们借鉴了寄生式继承的做法，创建了一个父类原型的副本作为子类的原型。子类原型和父类原型之间其实是通过 <code>__proto__</code> 联系起来的，因此在通过子类实例访问相关方法的时候，可以确保是沿着 <code>子类实例 =&gt; 子类实例.__proto__ = 子类原型 =&gt; 子类原型.__proto__ = 父类原型</code> 这样的原型链查找，最终一定可以找到父类原型上的方法，因此就实现了方法继承。</li><li>寄生组合式继承同样重写了子类原型，所以需要修复 constructor 的指向，指回子类本身。因为 <code>Object.create</code> 本身接受两个参数，第二个参数可以设置其返回对象的属性的特性，所以也可以在传参时顺便修复 constructor 的指向</li></ul><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（三）：如何实现 new？/">JS 原生方法原理探究（三）：如何实现 new 操作符？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp5 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（三）：如何实现 new？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第三篇文章。本文会介绍如何模拟实现 <code>new</code> 操作符。关于 <code>new</code> 的具体用法，MDN 已经描述得很清楚了，这里我们只做简单的介绍，具体的重点在于如何模拟实现。</p><h3 id="new-操作符的规范">new 操作符的规范</h3><blockquote><p>下面展示的所有规范都是 ES5 版本的，与现在最新的规范有些区别</p></blockquote><p>首先看一下根据<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-11.2.2">规范</a>的描述， <code>new</code> 操作符做了什么事：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/7.jpg"></div><p>全是英文，不过没关系，我简单翻译一下：</p><p>我在使用 <code>new</code> 操作符的时候，后面跟着的构造函数可能带参数，也可能不带参数，如果不带参数的话，比如说 <code>new Fn()</code>，那么这里这个 <code>Fn</code> 就是一个 <code>NewExpression</code>；如果带参数，比如说 <code>new Fn(name,age)</code>，那么这里的 <code>Fn</code> 就是一个 <code>MemberExpression</code>。</p><p>这两种情况下使用 <code>new</code> 操作符所进行的操作有点点不同，这里拿带参数的情况说明一下：</p><ol style="list-style-type:decimal"><li>首先会对 <code>Fn</code> 这个 <code>MemberExpression</code> 求值，其结果是指向实际函数对象的一个引用，我们把这个引用作为 <code>ref</code></li><li>接着调用 <code>GetValue(ref)</code> 进行求值，得到实际的函数对象，把这个对象作为 <code>constructor</code></li><li>对 <code>Arguments</code> 也就是传进来的参数求值，得到一个参数列表，作为 <code>argList</code></li><li>如果 <code>constructor</code> 不是对象，则抛出类型错误</li><li>如果 <code>constructor</code> 没有实现内部的 <code>[[Constructor]]</code> 方法，也抛出类型错误</li><li>调用 <code>constructor</code> 的 <code>[[Constructor]]</code>方法，并将 <code>argList</code> 传入作为参数，返回调用结果</li></ol><p>从这些描述可以看出，更多的实现细节放在函数的 <code>[[Constructor]]</code> 方法里。那么这个方法具体是做什么用的呢？</p><h3 id="constructor-的规范"><code>[[Constructor]]</code> 的规范</h3><p>在 JS 中，函数有两种调用方式，一种是正常调用，这将调用函数的内部方法 <code>[[Call]]</code>，还有一种是通过 new 调用，此时的函数作为一个构造函数，这将调用函数的另一个内部方法 <code>[[Consturct]]</code>。所以，要实现 <code>new</code> 操作的话，我们得先搞懂 <code>[[Construct]]</code> 内部方法做了什么事。</p><p>这里继续看<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/">规范</a>是怎么说的：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/5.jpg"></div><p>简单翻译一下：</p><p>当通过可能为空的参数列表调用函数 <code>F</code> 的内部方法 <code>[[Construct]]</code> 的时候，会执行如下步骤：</p><ol style="list-style-type:decimal"><li>让 <code>obj</code> 作为一个新创建的原生对象</li><li>按照规范指定的，为 <code>obj</code> 设置所有内部方法</li><li>将 <code>obj</code> 的内部属性 <code>[[Class]]</code> 设置为 <code>Object</code></li><li>传参 <code>prototype</code> 调用函数 <code>F</code> 的内部方法 <code>[[Get]]</code>，获取函数的原型对象，作为 <code>proto</code></li><li>如果 <code>proto</code> 是对象，则将 <code>obj</code> 的内部属性 <code>[[Prototype]]</code> 设置为 <code>proto</code></li><li>如果 <code>proto</code> 不是对象，则将 <code>obj</code> 的内部属性 <code>[[Prototype]]</code> 设置为标准内建的 <code>Object</code> 的原型对象</li><li>调用函数 <code>F</code> 的内部方法 <code>Call</code>， <code>obj</code> 作为调用时的 this 值，此前传给 <code>[[Construct]]</code> 的参数列表作为调用时的参数。将调用后得到的结果作为 <code>result</code></li><li>如果 <code>result</code> 是对象，则将其返回</li><li>否则，返回 <code>obj</code></li></ol><p>可以说，规范已经讲得很清楚了，简单地说，在 new 一个构造函数的时候，具体会做下面的事情：</p><ul><li>内部创建一个实例对象，并指定实例对象的原型：</li><li>如果构造函数的原型是对象，则让实例的 <code>__proto__</code> 等于构造函数的 <code>prototype</code></li><li>如果构造函数的原型不是对象，则让实例的 <code>__proto__</code> 等于 <code>Object</code> 的 <code>prototype</code></li><li>将实例对象绑定为构造函数中的 this，此前传递进来的参数作为参数，并执行一遍构造函数</li><li>如果构造函数返回了对象，则将其作为返回值，否则将实例对象作为返回值</li></ul><h3 id="代码实现">代码实现</h3><p>ES3 版本的实现如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myNew</span>(Fn)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> Fn <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(Fn <span class="op">+</span> <span class="st">&#39;is not a constructor&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">myNew</span>.<span class="at">target</span> <span class="op">=</span> Fn
    <span class="kw">var</span> instance <span class="op">=</span> <span class="op">&#123;&#125;</span>
    <span class="co">// 检测构造函数原型是不是对象</span>
    <span class="va">instance</span>.<span class="at">__proto__</span> <span class="op">=</span> <span class="va">Fn</span>.<span class="at">prototype</span> <span class="at">instanceof</span> <span class="at">Object</span> <span class="op">?</span> <span class="va">Fn</span>.<span class="at">prototype</span> : <span class="va">Object</span>.<span class="at">prototype</span> 
    <span class="kw">const</span> returnValue <span class="op">=</span> <span class="va">Fn</span>.<span class="at">apply</span>(instance<span class="op">,</span><span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">slice</span>.<span class="at">call</span>(arguments<span class="op">,</span><span class="dv">1</span>))
    <span class="cf">if</span>(<span class="kw">typeof</span> returnValue <span class="op">===</span> <span class="st">&#39;object&#39;</span> <span class="op">&amp;&amp;</span> returnValue <span class="op">!==</span> <span class="kw">null</span> <span class="op">||</span> <span class="kw">typeof</span> returnValue <span class="op">===</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">return</span> returnValue
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        <span class="cf">return</span> instance
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>ES6 版本的实现如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myNew</span>(Fn<span class="op">,</span>...<span class="at">args</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> Fn <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(Fn <span class="op">+</span> <span class="st">&#39;is not a constructor&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">myNew</span>.<span class="at">target</span> <span class="op">=</span> Fn
    <span class="kw">const</span> instance <span class="op">=</span> <span class="op">&#123;&#125;</span>
    <span class="co">// 检测构造函数原型是不是对象</span>
    <span class="va">instance</span>.<span class="at">__proto__</span> <span class="op">=</span> <span class="va">Fn</span>.<span class="at">prototype</span> <span class="at">instanceof</span> <span class="at">Object</span> <span class="op">?</span> <span class="va">Fn</span>.<span class="at">prototype</span> : <span class="va">Object</span>.<span class="at">prototype</span> 
    <span class="kw">const</span> returnValue <span class="op">=</span> <span class="va">Fn</span>.<span class="at">call</span>(instance<span class="op">,</span>...<span class="at">args</span>)
    <span class="cf">return</span> returnValue <span class="kw">instanceof</span> Object <span class="op">?</span> returnValue : instance
<span class="op">&#125;</span></code></pre></div><p>注意几个要点：</p><ul><li>当函数是通过 new 调用的时候，<code>new.target</code> 会指向函数自身，这个“指向”的操作在代码里就是通过 <code>myNew.target = Fn</code> 体现的</li><li>为什么不直接使用 <code>const instance = Object.create(Fn.prototype)</code> 创建实例呢？根据<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-13.2.2">规范</a>，我们在实现 new 的时候，需要检测构造函数的原型是不是对象，如果不是对象，比如说是 null，那么实例的 <code>__proto__</code> 会指向 Object 的原型，而这里如果使用了 <code>Object.create</code>，则会导致实例的 <code>__proto__</code> 仍然指向 null。网上很多 <code>new</code> 的模拟实现直接使用了 <code>Object.create</code>，或者根本没有对构造函数的原型进行类型检查，这是不够严谨的</li><li>如果无法使用 <code>instanceof</code>，我们也可以改用 <code>typeof Fn.prototype === 'Object' &amp;&amp; Fn.prototype !== null</code> 进行判断</li></ul><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（二）：如何实现 Object.create()？/">JS 原生方法原理探究（二）：如何实现 Object.create？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.2k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp4 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（二）：如何实现 Object.create()？/"><span id="more"></span><p>这是JS 原生方法原理探究系列的第二篇文章。本文会介绍如何实现 <code>Object.create()</code> 方法。关于这个方法的具体用法，MDN 已经描述得很清楚了，这里我们只做简单的介绍，具体的重点在于如何模拟实现。</p><h2 id="语法简介">语法简介</h2><blockquote><p>调用：Object.create ( proto , propertiesObject )</p><p>返回： 一个新的实例对象</p></blockquote><p>调用这个方法的时候接受两个参数，第一个参数作为返回对象的 <code>__proto__</code>，这个参数只能是 null 或者对象（而且不能是基本类型的包装对象）。</p><p>第二个参数作为返回对象的属性描述，它和 <code>Object.defineProperties()</code> 的第二个参数形式是一样的：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">&#123;</span>
    <span class="dt">propertyA</span><span class="op">:</span> <span class="op">&#123;</span>
        <span class="dt">value</span><span class="op">:</span> xxx<span class="op">,</span>
        <span class="dt">configurable</span><span class="op">:</span> xxx<span class="op">,</span>
        <span class="dt">enumerable</span><span class="op">:</span> xxx<span class="op">,</span>
        <span class="dt">writable</span><span class="op">:</span> xxx    
    <span class="op">&#125;,</span>
    <span class="dt">propertyB</span><span class="op">:</span> <span class="op">&#123;</span>...<span class="op">&#125;,</span>
    <span class="dt">propertyC</span><span class="op">:</span> <span class="op">&#123;</span>...<span class="op">&#125;</span>    
<span class="op">&#125;</span></code></pre></div><p>这个参数的每一个属性都会作为返回对象的属性，而属性值则是相应属性的特性描述（该属性的属性值、是否可读、是否可枚举、是否可配置）。第二个参数只能是对象或者 undefined（表示没有传第二个参数），不能是 null。</p><h2 id="es-规范">ES 规范</h2><p>对于 <code>Object.create()</code> 的具体实现，规范中其实已经描述得很清楚，可以进入http://es5.github.io/#x15.2.3.5查看：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/2.jpg"></div><p>我简单翻译一下这段话：</p><p><code>create()</code> 方法会创建一个具有指定原型的新对象，当调用该方法的时候，会有如下步骤：</p><ol style="list-style-type:decimal"><li>如果传入的参数 <code>O</code> 不是对象也不是 <code>null</code>，抛出 TypeError 错误</li><li>令 <code>obj</code> 作为调用 <code>new Object()</code> 方法所创建的新对象</li><li>将 <code>obj</code> 的内部属性 <code>[[prototype]]</code> 设置为 <code>O</code></li><li>如果提供了第二个参数 <code>Properties</code>，且不是 <code>undefined</code>，则调用 <code>Object.defineProperties</code> 方法并传入 <code>obj</code> 和 <code>Properties</code> 作为参数，从而为 <code>obj</code> 添加它自己的属性</li><li>返回 <code>obj</code></li></ol><p>可以说，整个过程是一目了然的，我们实现的时候也只需要按照上述步骤实现即可。</p><h2 id="代码实现">代码实现</h2><p>我们先看第一种实现：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">create</span> <span class="op">=</span> <span class="kw">function</span>(proto<span class="op">,</span>propertiesObject)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> proto <span class="op">!=</span> <span class="st">&#39;object&#39;</span> <span class="op">&amp;&amp;</span> proto <span class="op">!==</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the first param must be an object or null&#39;</span>)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> propertiesObject <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="st">&#39;TypeError&#39;</span>
    <span class="op">&#125;</span>
    <span class="kw">let</span> obj <span class="op">=</span> <span class="op">&#123;&#125;</span>
    <span class="va">obj</span>.<span class="at">__proto__</span> <span class="op">=</span> proto
    <span class="cf">if</span>(propertiesObject)<span class="op">&#123;</span>
        <span class="va">Object</span>.<span class="at">defineProperties</span>(obj<span class="op">,</span>propertiesObject)
    <span class="op">&#125;</span>
    <span class="cf">return</span> obj
<span class="op">&#125;</span></code></pre></div><p>基本上没有什么大问题。不过，我们要留意两个地方：</p><ul><li>在这个实现中，没有检测第一个参数是不是基本类型的包装对象，只要传进来的参数是对象，我们就认为是合法的</li><li>当传入 null 也即 <code>Object.create(null)</code> 的时候，我们实际上创建了一个很纯粹的空对象，这个对象的原型直接就是 null，<code>Object.prototype</code> 甚至没有出现在该对象的原型链中，这意味这个对象不会继承 Object 的任何方法。</li></ul><p>此外，你还可能在其他地方看到类似下面这样的实现：</p><p>具体实现如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">create</span> <span class="op">=</span> <span class="kw">function</span>(proto<span class="op">,</span>propertiesObject)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> proto <span class="op">!=</span> <span class="st">&#39;object&#39;</span> <span class="op">&amp;&amp;</span> proto <span class="op">!==</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the first param must be an object or null&#39;</span>)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(propertiesObject <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="st">&#39;TypeError&#39;</span>
    <span class="op">&#125;</span>
    <span class="kw">function</span> <span class="at">F</span>()<span class="op">&#123;&#125;</span>
    <span class="va">F</span>.<span class="at">prototype</span> <span class="op">=</span> proto
    <span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">F</span>()
    <span class="co">// 处理传参 null 的情况</span>
    <span class="cf">if</span>(proto <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        <span class="va">obj</span>.<span class="at">__proto__</span> <span class="op">=</span> proto
    <span class="op">&#125;</span>
    <span class="cf">if</span>(propertiesObject)<span class="op">&#123;</span>
        <span class="va">Object</span>.<span class="at">defineProperties</span>(obj<span class="op">,</span>propertiesObject)
    <span class="op">&#125;</span>
    <span class="cf">return</span> obj
<span class="op">&#125;</span></code></pre></div><p>这个实现和前面的实现有一个很关键的区别：代码中单独处理了传参 <code>proto</code> 为 <code>null</code> 的情况。可能你会觉得很奇怪：当 <code>proto</code> 为 <code>null</code> 的时候，<code>F.prototype = proto</code> 的效果和 <code>obj.__proto__ = proto</code> 应该是一样的，为什么还要在这种情况下执行一遍 <code>obj.__proto__ = proto</code> 呢？这似乎说明，用 null 重写 F 的原型后，新创建的实例的 <code>__proto__</code> 并不是 null —— 事实上确实不是。</p><p>关于调用构造函数时会执行的操作，<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-13.2.2">规范</a>明确提到了这一点：</p><blockquote><p>If <a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-8">Type</a>(<em>proto</em>) is not Object, set the [[Prototype]] internal property of <em>obj</em> to the standard built-in Object prototype object as described in <a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-15.2.4">15.2.4</a>.</p></blockquote><p>由于我们这里是通过 new 构造函数的方式创建新对象（而不是像之前那样通过对象字面量的形式），所以在 new F 的时候，内部会检测 F 的原型是不是对象，如果不是对象，那么会把实例的 <code>__proto__</code> 链接到内建的 <code>Object.prototype</code>。因此，这里新创建的实例的 <code>__proto__</code> 还真不是 null。</p><p>但根据 <code>Object.create</code> 的实现规范，这里必须让实例的 <code>__proto__</code> 指向 null，所以才需要执行 <code>obj.__proto__ = proto</code> 去手动设置对象原型。</p><p>当然，如果我们像第一个实现那样，直接去设置对象的 <code>__proto__</code>，而不是采用构造函数的方式，就不存在这个问题了。</p><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/25/F-你的手写new实现足够严谨吗？/">你的手写 new 实现足够严谨吗？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-25&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.5k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp5 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/25/F-你的手写new实现足够严谨吗？/"><span id="more"></span><p>在开始阅读这篇文章之前，你可以对比下面这两段代码的输出结果是否一致（假设 <code>myNew</code> 是你自己实现的 new 操作）：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">F</span>()<span class="op">&#123;&#125;</span>
<span class="va">F</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">null</span>
<span class="kw">const</span> obj1 <span class="op">=</span> <span class="kw">new</span> <span class="at">F</span>()
<span class="kw">const</span> obj2 <span class="op">=</span> <span class="at">myNew</span>(F)

<span class="va">console</span>.<span class="at">log</span>(<span class="va">Object</span>.<span class="at">getPrototypeOf</span>(obj1))
<span class="va">console</span>.<span class="at">log</span>(<span class="va">Object</span>.<span class="at">getPrototypeOf</span>(obj2))</code></pre></div><p>如果不一样，那么可能说明你的 <code>myNew</code> 方法和标准的 <code>new</code> 操作之间存在着些许出入，这篇文章也许能够让你的方法更加完善 / 严谨。</p><h4 id="从-object.create-说起">从 <code>Object.create</code> 说起</h4><p>最近在刷一些手写实现原生方法的面试题，偶然看到了有一个 <code>Object.create()</code> 方法的实现是这么写的：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">myCreate</span> <span class="op">=</span> <span class="kw">function</span> (proto<span class="op">,</span> propertyObject <span class="op">=</span> <span class="kw">undefined</span>) <span class="op">&#123;</span>
  <span class="cf">if</span> (propertyObject <span class="op">===</span> <span class="kw">null</span>) <span class="op">&#123;</span>
    <span class="co">// 这里没有判断propertyObject是否是原始包装对象</span>
    <span class="cf">throw</span> <span class="st">&#39;TypeError&#39;</span>
  <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
    <span class="kw">function</span> <span class="at">Fn</span> () <span class="op">&#123;&#125;</span>
    <span class="va">Fn</span>.<span class="at">prototype</span> <span class="op">=</span> proto
    <span class="kw">const</span> obj <span class="op">=</span> <span class="kw">new</span> <span class="at">Fn</span>()
    <span class="cf">if</span> (propertyObject <span class="op">!==</span> <span class="kw">undefined</span>) <span class="op">&#123;</span>
      <span class="va">Object</span>.<span class="at">defineProperties</span>(obj<span class="op">,</span> propertyObject)
    <span class="op">&#125;</span>
    <span class="cf">if</span> (proto <span class="op">===</span> <span class="kw">null</span>) <span class="op">&#123;</span>
      <span class="co">// 创建一个没有原型对象的对象，Object.create(null)</span>
      <span class="va">obj</span>.<span class="at">__proto__</span> <span class="op">=</span> <span class="kw">null</span>
    <span class="op">&#125;</span>
    <span class="cf">return</span> obj
  <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>而这个方法在<a target="_blank" rel="noopener" href="http://es5.github.io/#x15.2.3.5">规范</a>里的实现是这样的：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/2.jpg"></div><p>简单地说，它会接受两个参数，第一个参数作为调用后返回对象的 <code>__proto__</code>，第二个参数负责配置该对象的相关属性。而<strong>这里的第一个参数，可以是对象也可以是 <code>null</code></strong>。</p><p>基本上，上面代码的实现没有什么问题，但是我突然产生了一个疑问：当第一个参数是 <code>null</code> 的时候，<code>Fn.prototype = proto</code> 已经把构造函数的原型对象设置为 <code>null</code>了，为什么后面还要在判断第一个参数为 <code>null</code> 之后设置 <code>obj.__proto__ = null</code> 呢？这两个语句的作用难道不是一样的吗？毕竟 <code>Fn.prototype</code> 和 <code>obj.__proto__</code> 都是指向同一个原型对象呀！</p><p>于是我将代码中的 <code>if (proto === null)</code> 判断去掉，并分别测试了 <code>Object.create()</code> 方法和 <code>Object.myCreate()</code> 方法：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/3.jpg"></div><p>可以看到，第二个打印是符合预期的，返回对象的 <code>__proto__</code>确实指向传入的参数 <code>null</code>；但第一个打印却和预想的不一样，展开打印对象后会发现，它其实是 <code>Object.prototype</code>。这是怎么回事呢？难道说代码中执行 <code>Fn.prototype = proto</code> 的时候，实际上实例的 <code>__proto__</code> 并没有跟着改变？</p><p>于是继续测试：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/4.jpg"></div><p>这里可以看到：用 <code>null</code> 重写构造函数的原型后，通过 new 构造函数创建的实例的 <code>__proto__</code> 并没有跟着变成 <code>null</code>，而是指向了 <code>Object.prototype</code>。</p><h4 id="调用构造函数的时候做了什么">调用构造函数的时候做了什么？</h4><p>这时候，我们可能会想到，通过 new 调用构造函数的时候，内部可能做了一些处理，导致最终返回的实例对象的 <code>__proto__</code> 和我们预期的不一致。既然如此，我们通过<a target="_blank" rel="noopener" href="https://262.ecma-international.org/5.1/#sec-13.2.2">规范</a>看一下调用构造函数的时候，具体做了什么事：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/5.jpg"></div><p>这里我们只需要关注第六步和第七步。这两步会检查构造函数的原型对象的类型，如果是一个对象，则会将其作为实例的 <code>__proto__</code>；如果不是对象，则会将 <code>Object.prototype</code> 作为实例的 <code>__proto__</code>。这就能解释为什么用 <code>null</code> 重写构造函数的原型后，实例的 <code>__proto__</code> 没有跟着改变了，因为在调用构造函数的过程中，它链接上了 <code>Object.prototype</code>，可以说，这里实例的原型链并没有断开。</p><h4 id="实现一个更严谨的-new">实现一个更严谨的 <code>new</code></h4><p>在大部分的手写 <code>new</code> 实现中，通常都没有去检查构造函数的原型是否是一个对象。有的实现中甚至直接使用了 <code>Object.create()</code> 方法以快速地建立原型关系，就像这样：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myNew</span>(Fn<span class="op">,</span>...<span class="at">args</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> Fn <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(Fn <span class="op">+</span> <span class="st">&#39;is not a constructor&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">const</span> instance <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="va">Fn</span>.<span class="at">prototype</span>)    
    <span class="kw">const</span> returnValue <span class="op">=</span> <span class="va">Fn</span>.<span class="at">call</span>(instance<span class="op">,</span>...<span class="at">args</span>)
    <span class="cf">return</span> returnValue <span class="kw">instanceof</span> Object <span class="op">?</span> returnValue : instance
<span class="op">&#125;</span></code></pre></div><p>这里直接使用<code>Object.create()</code> 方法，是有问题的。</p><p>在前面阅读规范的时候我们已经知道了，即使传给 <code>Object.create</code> 的参数是 <code>null</code>，也会将其作为创建的对象的 <code>__proto__</code>，所以这里如果使用了 <code>Object.create</code>，并且构造函数的原型 <code>Fn.prototype</code> 还恰好就是 <code>null</code> 的话，就会导致实例的 <code>__proto__</code> 也是 <code>null</code>，这和 <code>new</code> 的实际实现是有出入的。</p><p>所以，如果想实现一个更加严谨的 <code>new</code>，那么就不应该在内部去调用 <code>Object.create</code> 方法，而应该选择手动创建一个对象并和构造函数建立原型关系，同时，我们还应该加入对构造函数原型的类型判断，看它到底是不是一个对象。</p><p>因此，上面的代码可以修改如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">myNew</span>(Fn<span class="op">,</span>...<span class="at">args</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> Fn <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(Fn <span class="op">+</span> <span class="st">&#39;is not a constructor&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">const</span> instance <span class="op">=</span> <span class="op">&#123;&#125;</span>
    <span class="co">// 检测构造函数原型是不是对象</span>
    <span class="va">instance</span>.<span class="at">__proto__</span> <span class="op">=</span> <span class="va">Fn</span>.<span class="at">prototype</span> <span class="at">instanceof</span> <span class="at">Object</span> <span class="op">?</span> <span class="va">Fn</span>.<span class="at">prototype</span> : <span class="va">Object</span>.<span class="at">prototype</span> 
    <span class="kw">const</span> returnValue <span class="op">=</span> <span class="va">Fn</span>.<span class="at">call</span>(instance<span class="op">,</span>...<span class="at">args</span>)
    <span class="cf">return</span> returnValue <span class="kw">instanceof</span> Object <span class="op">?</span> returnValue : instance
<span class="op">&#125;</span></code></pre></div><p>现在，我们再用这个改进之后的 <code>new</code> 去测试文章开头的代码：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/6.jpg"></div><p>可以看到，加入了对构造函数原型可能为 <code>null</code> 的处理之后，返回的实例的 <code>__proto__</code> 明确指向了 <code>Object.prototype</code>。现在我们实现的 <code>new</code> 就更加严谨了，而且也更接近原生的 <code>new</code> 操作。</p><p>本文到这里就结束了。不过，从语言设计的角度来说，为什么不将实例的 <code>__proto__</code> 也跟着设置为 <code>null</code> 呢？这里不断开实例的原型链，而是将其链接到 <code>Object.prototype</code> 有什么好处？大家可以在评论区留言讨论一下。另外，不排除本文存在原理性的错误或者说法上的偏颇，如果你发现了，也欢迎在评论区指正。</p><h4 id="参考">参考</h4><p>https://262.ecma-international.org/5.1/#sec-13.2.2</p><p>http://es5.github.io/#x15.2.3.5</p><p>https://stackoverflow.com/questions/18198178/null-prototype-object-prototype-and-object-create</p><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/21/F-JS原生方法原理探究（一）：如何实现call、apply 和 bind？/">JS 原生方法原理探究（一）：如何实现 call、apply 和 bind？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-21&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.9k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp11 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/21/F-JS原生方法原理探究（一）：如何实现call、apply 和 bind？/"><span id="more"></span><p>这是 JS 原生方法原理探究系列的第一篇文章。本文会介绍如何实现 call、apply 和 bind 方法。关于这几个方法的具体用法，MDN 已经描述得很清楚了，这里不再赘述。</p><h2 id="手写实现-call">手写实现 call</h2><h3 id="es3-版本">ES3 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myCall</span> <span class="op">=</span> <span class="kw">function</span>(thisArg)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;The caller must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">undefined</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">&#125;</span>   
    <span class="kw">var</span> args <span class="op">=</span> []
    <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>i <span class="op">&lt;</span> <span class="va">arguments</span>.<span class="at">length</span><span class="op">;</span>i <span class="op">++</span>)<span class="op">&#123;</span>
        <span class="va">args</span>.<span class="at">push</span>(<span class="st">&#39;arguments[&#39;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&#39;]&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">var</span> res <span class="op">=</span> <span class="at">eval</span>(<span class="st">&#39;thisArg.fn(&#39;</span> <span class="op">+</span> args <span class="op">+</span> <span class="st">&#39;)&#39;</span>)
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">&#125;</span></code></pre></div><h3 id="es6-版本">ES6 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myCall</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>...<span class="at">args</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;The caller must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">undefined</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">null</span>)<span class="op">&#123;</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">&#125;</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">const</span> res <span class="op">=</span> <span class="va">thisArg</span>.<span class="at">fn</span>(...<span class="at">args</span>)
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">&#125;</span></code></pre></div><p>通过 <code>call</code> 调用函数的时候，可以通过传给 <code>call</code> 的 thisArg 指定函数中的 this。而只要使得函数是通过 thisArg 调用的，就能实现这一点，这就是我们的主要目标。</p><h3 id="实现要点">实现要点</h3><ol style="list-style-type:decimal"><li>最终是通过函数去调用 <code>myCall</code> 的，所以 <code>myCall</code> 和 <code>call</code> 一样挂载在函数原型上。同时，也正因为是通过函数去调用 <code>myCall</code> 的，所以在 <code>myCall</code> 内部我们可以通过 this 拿到 <code>myCall</code>的调用者，也就是实际执行的那个函数。</li><li>按理说，<code>myCall</code> 是挂载在函数原型上，当我们通过一个非函数去调用 <code>myCall</code> 的时候，肯定会抛出错误，那么为什么还要在 <code>myCall</code> 中检查调用者的类型，并自定义一个错误呢？这是因为，当一个调用者 <code>obj = &#123;&#125;</code> 是一个对象，但是继承自 <code>Function</code> 的时候（<code>obj.__proto__ = Function.prototype</code>），它作为一个非函数实际上也是可以调用 <code>myCall</code> 方法的，这时候如果不进行类型检查以确保它是个函数，那么后面直接将它当作函数调用的时候，就会抛出错误了</li><li>传给 <code>call</code> 的 thisArg 如果是 null 或者 undefined，那么 thisArg 实际上会指向全局对象；如果 thisArg 是一个基本类型，那么可以使用 <code>Object()</code> 做一个装箱操作，将其转化为一个对象 —— 主要是为了确保后续可以以方法调用的方式去执行函数。那么可不可以写成 <code>thisArg = thisArg ? Object(thisArg) : globalThis</code> 呢？其实是不可以的，如果 thisArg 是布尔值 false，那么会导致 thisArg 最终等于 globalThis，但实际上它应该等于 <code>Boolean &#123;false&#125;</code>。</li><li>前面说过，可以在 <code>myCall</code> 里通过 this 拿到实际执行的那个函数，所以 <code>thisArg.fn = this</code> 相当于将这个函数作为 thisArg 的一个方法，后面我们就可以通过 thisArg 对象去调用这个函数了。</li><li><code>thisArg.fn = this</code> 相当于是给 thisArg 增加了一个 fn 属性，所以返回执行结果之前要 delete 这个属性。此外，为了避免覆盖 thisArg 上可能存在的同名属性 fn，这里也可以使用 <code>const fn = Symbol('fn')</code> 构造一个唯一属性，然后 <code>thisArg[fn] = this</code>。</li><li>ES3 版本和 ES6 版本主要的区别在于参数的传递以及函数的执行上：</li><li>ES6 因为引入了剩余参数，所以不管实际执行函数的时候传入了多少个参数，都可以通过 args 数组拿到这些参数，同时因为引入了展开运算符，所以可以展开 args 参数数组，把参数一个个传递给函数执行</li><li>但在 ES3 中没有剩余参数这个东西，所以在定义 <code>myCall</code> 的时候只接收一个 thisArg 参数，然后在函数体中通过 arguments 类数组拿到所有参数。我们需要的是 arguments 中除第一个元素（thisArg）之外的所有元素，怎么做呢？如果是 ES6，直接<code>[...arguments].slice(1)</code>就可以了，但这是 ES3，于是我们只能从索引 1 开始遍历 arguments，然后 push 到一个 args 数组中了。而且还要注意的是，这里 push 进去的是字符串形式的参数，这主要是为了方便后续通过 eval 执行函数的时候，将参数一个一个传递给函数。</li><li>为什么必须通过 eval 才能执行函数呢？因为我们不知道函数实际上要接收多少个参数，况且也用不了展开运算符，所以只能构造一个可执行的字符串表达式，显式地传入函数的所有参数。</li></ol><h2 id="手写实现-apply">手写实现 apply</h2><p>apply 的用法和 call 很类似，因此实现也很类似。需要注意的区别是，call 在接受一个 thisArg 参数之后还可以接收多个参数（即接受的是参数列表），而 apply 在接收一个 thisArg 参数之后，通常第二个参数是一个数组或者类数组对象：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">fn</span>.<span class="at">call</span>(thisArg<span class="op">,</span>arg1<span class="op">,</span>arg2<span class="op">,</span>...)
<span class="va">fn</span>.<span class="at">apply</span>(thisArg<span class="op">,</span>[arg1<span class="op">,</span>arg2<span class="op">,</span>...])        </code></pre></div><p>如果第二个参数传的是 null 或者 undefined，那么相当于是整体只传了 thisArg 参数。</p><h3 id="es3-版本-1">ES3 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myApply</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>args)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">&#125;</span> 
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(args <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> args <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
        args <span class="op">=</span> []
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="cf">if</span>(<span class="op">!</span><span class="va">Array</span>.<span class="at">isArray</span>(args))<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;CreateListFromArrayLike called on non-object&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">var</span> _args <span class="op">=</span> []
    <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>i <span class="op">&lt;</span> <span class="va">args</span>.<span class="at">length</span><span class="op">;</span>i <span class="op">++</span>)<span class="op">&#123;</span>
        <span class="va">_args</span>.<span class="at">push</span>(<span class="st">&#39;args[&#39;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&#39;]&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">var</span> res <span class="op">=</span> <span class="va">_args</span>.<span class="at">length</span> <span class="op">?</span> <span class="at">eval</span>(<span class="st">&#39;thisArg.fn(&#39;</span> <span class="op">+</span> _args <span class="op">+</span> <span class="st">&#39;)&#39;</span>):<span class="va">thisArg</span>.<span class="at">fn</span>()
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">&#125;</span></code></pre></div><h3 id="es6-版本-1">ES6 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myApply</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>args)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> thisArg <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">&#125;</span> 
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">&#125;</span>
    <span class="cf">if</span>(args <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> args <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">&#123;</span>
        args <span class="op">=</span> []
    <span class="op">&#125;</span> 
    <span class="co">// 如果传入的不是数组，仿照 apply 抛出错误</span>
    <span class="cf">else</span> <span class="cf">if</span>(<span class="op">!</span><span class="va">Array</span>.<span class="at">isArray</span>(args))<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;CreateListFromArrayLike called on non-object&#39;</span>)
    <span class="op">&#125;</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">const</span> res <span class="op">=</span> <span class="va">thisArg</span>.<span class="at">fn</span>(...<span class="at">args</span>)
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">&#125;</span></code></pre></div><h3 id="实现要点-1">实现要点</h3><p>基本上和 call 的实现是差不多的，只是我们需要检查第二个参数的类型。</p><h2 id="手写实现-bind">手写实现 bind</h2><p><code>bind</code> 也可以像 <code>call</code> 和 <code>apply</code> 那样给函数绑定一个 this，但是有一些不同的要点需要注意：</p><ul><li><code>bind</code> 不是指定完 this 之后直接调用原函数，而是基于原函数返回一个内部完成了 this 绑定的新函数</li><li>原函数的参数可以分批次传递，第一批可以在调用 <code>bind</code> 的时候作为第二个参数传入，第二批可以在调用新函数的时候传入，这两批参数最终会合并在一起，一次传递给新函数去执行</li><li>新函数如果是通过 new 方式调用的，那么函数内部的 this 会指向实例，而不是当初调用 <code>bind</code> 的时候传入的 thisArg。换句话说，这种情况下的 <code>bind</code> 相当于是无效的</li></ul><h3 id="es3-版本-2">ES3 版本</h3><p>这个版本更接近 MDN 上的 polyfill 版本。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myBind</span> <span class="op">=</span> <span class="kw">function</span>(thisArg)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">var</span> fnToBind <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">var</span> args1 <span class="op">=</span> <span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">slice</span>.<span class="at">call</span>(arguments<span class="op">,</span><span class="dv">1</span>)
    <span class="kw">var</span> fnBound <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;</span>
        <span class="co">// 如果是通过 new 调用</span>
        <span class="cf">return</span> <span class="va">fnToBind</span>.<span class="at">apply</span>(<span class="kw">this</span> <span class="kw">instanceof</span> fnBound <span class="op">?</span> <span class="kw">this</span>:thisArg<span class="op">,</span><span class="va">args1</span>.<span class="at">concat</span>(args2))
    <span class="op">&#125;</span>
    <span class="co">// 实例继承</span>
    <span class="kw">var</span> Fn <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;</span>
    <span class="va">Fn</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">this</span>.<span class="at">prototype</span>
    <span class="va">fnBound</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">Fn</span>()
    <span class="cf">return</span> fnBound
<span class="op">&#125;</span></code></pre></div><h3 id="es6-版本-2">ES6 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myBind</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>...<span class="at">args1</span>)<span class="op">&#123;</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">&#123;</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">&#125;</span>
    <span class="kw">const</span> fnToBind <span class="op">=</span> <span class="kw">this</span>
    <span class="cf">return</span> <span class="kw">function</span> <span class="at">fnBound</span>(...<span class="at">args2</span>)<span class="op">&#123;</span>
        <span class="co">// 如果是通过 new 调用的</span>
        <span class="cf">if</span>(<span class="kw">this</span> <span class="kw">instanceof</span> fnBound)<span class="op">&#123;</span>
            <span class="cf">return</span> <span class="kw">new</span> <span class="at">fnToBind</span>(...<span class="at">args1</span><span class="op">,</span>...<span class="at">args2</span>)
        <span class="op">&#125;</span> <span class="cf">else</span> <span class="op">&#123;</span>
            <span class="cf">return</span> <span class="va">fnToBind</span>.<span class="at">apply</span>(thisArg<span class="op">,</span>[...<span class="at">args1</span><span class="op">,</span>...<span class="at">args2</span>])
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><h3 id="实现要点-2">实现要点</h3><ol style="list-style-type:decimal"><li><p><code>bind</code> 实现内部 this 绑定，需要借助于 <code>apply</code>，这里假设我们可以直接使用 <code>apply</code> 方法</p></li><li><p>先看比较简单的 ES6 版本:</p></li><li><strong>参数获取</strong>：因为 ES6 可以使用剩余参数，所以很容易就可以获取执行原函数所需要的参数，而且也可以用展开运算符轻松合并数组。</li><li><p><strong>调用方式</strong>：前面说过，如果返回的新函数 fnBound 是通过 new 调用的，那么其内部的 this 会是 fnBound 构造函数的实例，而不是当初我们指定的 thisArg，因此 <code>this instanceof fnBound</code>会返回 true，这种情况下，相当于我们指定的 thisArg 是无效的，new 返回的新函数等价于 new 原来的旧函数，即 new fnBound 等价于 new fnToBind，所以我们返回一个 new fnToBind 即可；反之，如果 fnBound 是普通调用，则通过 apply 完成 thisArg 的绑定，再返回最终结果。从这里可以看出，bind 的 this 绑定，本质上是通过 apply 完成的。</p></li><li><p>再来看比较麻烦一点的 ES3 版本：</p></li><li><p><strong>参数获取</strong>：现在我们用不了剩余参数了，所以只能在函数体内部通过 arguments 获取所有参数。对于 <code>myBind</code>，我们实际上需要的是除开第一个传入的 thisArg 参数之外的剩余所有参数构成的数组，所以这里可以通过 <code>Array.prototype.slice.call</code> 借用数组的 slice 方法（arguments 是类数组，无法直接调用 slice），这里的借用有两个目的：一是除去 arguments 中的第一个参数，二是将除去第一个参数之后的 arguments 转化为数组（slice 本身的返回值就是一个数组，这也是类数组转化为数组的一种常用方法）。同样地，返回的新函数 fnBound 后面调用的时候也可能传入参数，再次借用 slice 将 arguments 转化为数组</p></li><li><p><strong>调用方式</strong>：同样，这里也要判断 fnBound 是 new 调用还是普通调用。在 ES6 版本的实现中，如果是 new 调用 fnBound，那么直接返回 <code>new fnToBind()</code>，这实际上是最简单也最容易理解的方式，我们在访问实例属性的时候，天然就是按照 <code>实例 =&gt; 实例.__proto__ = fnToBind.prototype</code> 这样的原型链来寻找的，可以确保实例成功访问其构造函数 fnToBInd 的原型上面的属性；但在 ES3 的实现中（或者在网上部分 bind 方法的实现中），我们的做法是返回一个 <code>fnToBind.apply(this)</code>，实际上相当于返回一个 undefined 的函数执行结果，根据 new 的原理，我们没有在构造函数中自定义一个返回对象，因此 new 的结果就是返回实例本身，这点是不受影响的。这个返回语句的问题在于，它的作用仅仅只是确保 fnToBind 中的 this 指向 new fnBound 之后返回的实例，而并没有确保这个实例可以访问 fnToBind 的原型上面的属性。实际上，它确实不能访问，因为它的构造函数是 fnBound 而不是 fnToBind，所以我们要想办法在 fnBound 和 fnToBind 之间建立一个原型链关系。这里有几种我们可能会使用的方法：</p><p><code>js // 这里的 this 指的是 fnToBind fnBound.prototype = this.prototype</code></p><p>这样只是拷贝了原型引用，如果修改 <code>fnBound.prototype</code>，则会影响到 <code>fnToBind.prototype</code>，所以不能用这种方法</p><p><code>js // this 指的是 fnToBind fnBound.prototype = Object.create(this.prototype)</code></p><p>通过 <code>Object.create</code> 可以创建一个 <code>__proto__</code> 指向 <code>this.prototype</code> 的实例对象，之后再让 <code>fnBound.prototype</code> 指向这个对象，则可以在 fnToBind 和 fnBound 之间建立原型关系。但由于 <code>Object.create</code> 是 ES6 的方法，所以无法在我们的 ES3 代码中使用。</p><p><code>js // this 指的是 fnToBind const Fn = function()&#123;&#125; Fn.prototype = this.prototype fnBound.prototype = new Fn()</code></p><p>这是上面代码采用的方法：通过空构造函数 Fn 在 fnToBind 和 fnBound 之间建立了一个联系。如果要通过实例去访问 fnToBind 的原型上面的属性，可以沿着如下原型链查找：</p><p><code>实例 =&gt; 实例.__proto__ = fnBound.prototype = new Fn() =&gt; new Fn().__proto__ = Fn.prototype = fnToBind.prototype</code></p></li></ol><p>​</p><div class="default">阅读全文......</div></a></div></article></section><nav class="pager-nav"><a class="extend prev" rel="prev" href="/">« Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/3/">Next »</a></nav></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->