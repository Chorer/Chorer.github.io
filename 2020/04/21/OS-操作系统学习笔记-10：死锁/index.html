<!-- build time:Sun Sep 05 2021 18:44:29 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/prism.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">操作系统学习笔记-10：死锁</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-04-21&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp6.4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp22 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-0.png"></div><span id="more"></span><h2 id="死锁的概念">死锁的概念</h2><h3 id="关于死锁">1. 关于死锁</h3><blockquote><p>Deadlocks are a set of <strong>blocked</strong> processes each <strong>holding</strong> a resource and <strong>waiting</strong> to acquire a resource held by another process int the set. ——《Inners of Operating Systems》</p></blockquote><p>死锁现象指的是：在并发环境下，两个或者以上的进程由于竞争资源而造成的一种互相等待（你等我，我等你）的现象，在这种情况下，A 进程拿着 A 资源，需要 B 资源，B 进程拿着 B 资源，需要 C 资源 ...... 各个进程互相等待，都会被阻塞，无法继续向前推进。</p><h3 id="死锁的必要条件">2. 死锁的必要条件</h3><p>只有<strong>同时满足</strong>以下四个条件，才会发生死锁现象：</p><p><strong>① 互斥：</strong></p><p>要求进程竞争的资源必须是互斥使用的资源。因为如果是可以共享使用的资源，多个进程直接同时使用就好，不会陷入等待的僵局。</p><p><strong>② 非抢占：</strong></p><p>要求进程占有的资源只能由进程使用完之后自己主动释放，其它进程不能抢占该资源。因为如果其它进程可以抢占资源，那么就是直接拿到资源了，也不会陷入等待的僵局。</p><p><strong>③ 占有和请求：</strong></p><p>要求进程是在占有（holding）至少一个资源的前提下，请求（waiting）新的资源的。由于新的资源被其它进程占有，此时，发出请求的进程就会带着自己占有的资源进入阻塞状态。假设 P1，P2 分别都需要 R1，R2 资源，如果是下面这种方式：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">P1</span><span class="token operator">:</span>          <span class="token constant">P2</span><span class="token operator">:</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果 P1 请求到了 R1 资源之后，P2 请求到了 R2 资源，那么此后不管是哪个进程再次请求资源，都是在占有资源的前提下请求的，此时就会带着这个资源陷入阻塞状态。P1 和 P2 需要互相等待，发生了死锁。</p><p>换一种情况：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">P1</span><span class="token operator">:</span>          <span class="token constant">P2</span><span class="token operator">:</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果 P1 请求到了 R1 资源，那么 P2 在请求 R1 的时候虽然也会阻塞，但是<strong>是在不占有资源的情况下阻塞的</strong>，不像之前那样占有 R2。所以，此时 P1 可以正常完成任务并释放 R1，P2 拿到 R1 之后再去执行任务。这种情况就不会发生死锁。</p><p><strong>④ 循环等待：</strong></p><p>要求存在一条进程资源的循环等待链，链中的每一个进程占有的资源同时被另一个进程所请求。</p><p>发生死锁时一定有循环等待（因为是死锁的必要条件），但是发生循环等待的时候不一定会发生死锁。这是因为，如果循环等待链中的 P1 和 链外的 P6 都占有某个进程 P2 请求的资源，那么 P2 完全可以选择不等待 P1 释放该资源，而是等待 P6 释放资源。这样就不会发生死锁了。</p><h3 id="死锁的出现场景">3. 死锁的出现场景</h3><p><strong>① 对系统资源的竞争：</strong></p><p>各个进程对互斥的、不可抢占的资源的竞争可能会引起死锁。需要注意的是，正如我们在上面讲到的，对可抢占的资源的竞争是不会引起死锁的。比如说 CPU 就是可抢占的资源，可以借助很多种进程调度算法让进程抢占到处理机，一般不存在死锁的情况。</p><p><strong>② 进程推进顺序不当：</strong></p><p>比如上面的 P1，P2，R1，R2 的例子。换顺序之前，发生了死锁，两个进程都被阻塞；换顺序之后，就避免了死锁的发生。</p><p><strong>③ 信号量使用不当：</strong></p><p>信号量如果使用不当，也会发生死锁。这里选取在 <a href="https://chorer.github.io/2020/03/28/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/">操作系统学习笔记-6：进程同步与进程互斥（三）：经典问题</a> 中提到过的生产者—消费者问题进行解释：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-1.png" style="zoom:67%"></p><h2 id="死锁的处理">死锁的处理</h2><p>对于死锁，可以采取三种方式进行处理。第一种是预防死锁，核心是破坏导致死锁产生的一个或多个必要条件；第二种是避免死锁，核心是用某种方法防止系统进入不安全状态，从而避免死锁；第三种不像前面两种，它没有规避死锁的发生，但是会在死锁发生后进行检测，然后通过某种方法解除死锁。</p><blockquote><p>预防和避免这两个词意思差不多，英文分别是 deadlock prevention 和 deadlock avoidance，也是差不多的。主要是处理方式不同，所以不要在意名字本身。</p></blockquote><h3 id="预防死锁">1. 预防死锁</h3><p>前面讲到，死锁的产生需要同时满足四个条件。现在逐一看每一个条件是否有被破坏的可能。</p><p><strong>① 破坏互斥条件</strong></p><p>如果可以把某个互斥资源转化成共享资源，那么就不存在互相等待资源的情况了，也就不会发生死锁。借助 SPOOLing 假脱机技术，可以把互斥资源在<strong>逻辑上</strong>转化为共享资源。</p><p>在引入 SPOOLing 技术之前，进程 P1 和 P2 如果要利用打印机进行输出，那么它们是直接请求打印机资源的，比如 P1 请求并使用打印机进行输出，那么 P2 如果再请求的话就会被阻塞。</p><p>但是在引入 SPOOLing 技术之后，各个进程会把各自的输出内容放到一个新开辟的缓冲区里，缓冲区里形成一个输出内容队列，之后进程再继续向后执行。后面要利用打印机进行输出的时候，只需要读取队列上的内容即可。在整个过程中，由于各个进程面向的缓冲区是共享资源，所以轮到自己执行的时候只管把内容放到缓冲区即可，是不会发生死锁的。</p><p><strong>② 破坏非抢占条件</strong></p><p>如果资源是可以抢占的，那么在进程需要资源的时候，就可以直接抢占了，不存在互相等待资源的情况，也就不会发生死锁。要破坏非抢占条件，做到可抢占，可以从两个角度（方案）考虑：</p><ul><li>从占有资源的进程的角度考虑，如果它请求不到新的资源，那么它必须立即释放占有的全部资源，以后需要的时候重新申请</li><li>从请求资源的进程的角度考虑，如果它需要请求资源，那么操作系统会帮助它抢占相关资源。比如现在有一个优先级更高的进程，如果是采用优先级调度算法，那么它将有机会在操作系统的帮助下抢占到资源。</li></ul><p>这种做法的问题在于：</p><ul><li>实现起来复杂</li><li>某个占有资源的进程释放占有的全部资源时，可能会导致工作进度丢失</li><li>反复的申请和释放资源会增加系统开销</li><li>可能导致饥饿</li></ul><p><strong>③ 破坏占有和请求条件</strong></p><p>一般来说，资源是在进程运行的时候动态请求的，这就可能导致某个进程在占有资源的同时去请求资源，如果资源请求不到，就会带着占有的资源进入阻塞状态。所以可以考虑采用静态分配的方法，在进程运行之前就一次申请完需要的全部资源，如果资源不到位，就先不让它运行；如果资源到位，就让它带着资源运行。这样就确保了进程一定可以拿到资源执行任务，没有动态请求资源的过程，自然不会发生死锁。</p><p>该方法可能导致饥饿现象。设想有 ABC 三类进程，A 用到 a 资源，B 用到 b 资源，C 用到 ab 资源，那么 AB 会在运行前事先申请到 ab 资源，之后运行，如果 AB 源源不断进入就绪队列，那么 ab 资源就会不断被分配给 AB 进程，这样 C 进程由于没有办法在运行前拿到 ab 资源，所以迟迟无法运行，就进入了饥饿状态。</p><p><strong>④ 破坏循环等待条件</strong></p><p>循环等待就是 A 等 B，B 等 C，C 又回过头来等 A，形成了一个互相循环等待的闭环，从而陷入死锁。所以可以考虑“打破”这个闭环，具体做法是：给所有的资源编号，规定每个进程必须按照编号递增的顺序请求资源：必须先请求小编号资源，后请求大编号资源，请求大编号资源后，后续请求的资源只会比该资源编号更大。这样就成功打破了闭环。</p><p>以之前的例子讲解：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">P1</span><span class="token operator">:</span>          <span class="token constant">P2</span><span class="token operator">:</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种情况下资源请求是无序的，尤其是 P2，它没有按照递增的顺序请求资源，因此很容易发生死锁。但是如果是这种情况：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token constant">P1</span><span class="token operator">:</span>          <span class="token constant">P2</span><span class="token operator">:</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实际上，这里除了破坏“占有和请求条件”之外，更重要的是破坏了循环等待条件 —— 因为这里是按照编号递增的顺序请求资源了，不管是 P1 还是 P2，都是先请求小编号的 R1，后请求大编号的 R2，这样的话就不会发生死锁，因为此时两个进程对资源的请求并没有形成一个闭环。</p><p>也可以拿之前在 <a href="https://chorer.github.io/2020/03/28/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/">操作系统学习笔记-6：进程同步与进程互斥（三）：经典问题</a> 提到的哲学家就餐问题解释，如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-4.png" style="zoom:50%"></p><p>最初的情况......</p><p>在最初的哲学家问题中，之所以发生死锁，本质上是因为每个哲学家都是先拿左边筷子，后拿右边筷子，由于 4 号右边的筷子是 0 号左边的筷子，最终形成了一个闭环。设想当每个哲学家都拿起左手筷子，当他们去申请右手筷子的时候，无一例外都会被阻塞，陷入死锁。</p><p>如果试图打破循环......</p><p>但是如果我们按照上图给每个筷子进行编号，规定必须按照编号递增的顺序申请资源，那么从 0 号到 3 号，它们依然会拿起左手边小编号的筷子，但是轮到 4 号的时候，情况就不一样了。因为对于 4 号来说，右手筷子编号更小，所以在拿到左手筷子之前，它会先试图拿右手筷子，又由于该筷子已经被 0 号拿走，此时 4 号被阻塞。而对于 3 号来说，没人和自己抢 4 号筷子了，所以 3 号哲学家此时可以拿到左右筷子，这样就避免了死锁。</p><p>还可以从另一个角度考虑，因为我们是按照编号递增的顺序请求资源的，设想在某一时刻，若干个进程中必定有一个进程的资源编号暂时是所有进程中最大的，那么该进程在此后申请新的资源的时候，只可能申请编号更大的资源，一方面避开了小编号、可能已经被拿走的资源（也就避开了阻塞和死锁），另一方面，大编号资源并没有被其他进程拿走，因此这个时候，该进程一定可以拿到资源，不会有死锁现象。</p><p>但这种预防死锁的方法，问题在于：</p><ul><li><p>如何进行编号？从什么角度考虑？这是一个问题</p></li><li>如果增加资源或设备，需要重新进行编号吗？怎么编号？</li><li><p>虽然资源请求上是先小编号资源，后大编号资源，但是实际使用的时候可能是得先使用大编号资源，这就意味着小编号资源暂时用不到 —— 虽然用不到，但还是被进程占用，明显有资源浪费的问题。</p></li></ul><h3 id="避免死锁">2. 避免死锁</h3><p>避免死锁的核心在于，如果<strong>资源在分配给某个进程后会在将来导致死锁</strong>，那么就不同意资源请求，取消资源的分配。</p><p>问题是，怎么知道将来是否会导致死锁呢？</p><h4 id="安全序列和安全状态">2.1 安全序列和安全状态</h4><ul><li>如果系统按照某种序列分配资源，可以使得每个进程都拿到资源并顺利完成，那么这样的序列就叫做<strong>安全序列</strong>。只要至少有一个安全序列，就可以认为系统处于<strong>安全状态</strong>。</li><li>反之，如果这样的序列一个都没有，那么就会有进程拿不到资源，进而无法顺利完成，此时就认为系统处于<strong>不安全状态</strong>。当系统处于不安全状态的时候，<strong>有可能发生死锁</strong>。</li></ul><p>如下图：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-2.png"></div><p>虽然进入不安全状态，并不一定意味着会发生死锁，但是本着以防万一的想法，我们可以设法让系统永远不会进入不安全状态，从而从根源上避免死锁的发生。这样，我们的思路就<strong>从避免死锁变成了避免不安全状态</strong>。</p><blockquote><p>在确定要分配资源给进程之前，首先检测此次分配是否会导致进入不安全状态，进而导致可能发生的死锁。如果会，那么就取消此次资源的分配。</p></blockquote><p>下面介绍具体的检测方法。</p><h4 id="资源分配图算法">2.2 资源分配图算法</h4><p>资源分配图算法即 Resource-Allocation Graph Algorithm，当各类资源都<strong>只有一个</strong>的时候，可以使用这种方法求解。资源分配图是描述进程和资源之间请求和分配关系的有向图，从进程指向资源的虚线代表资源需求（要使用），从进程指向资源的实线代表资源请求（申请使用），从资源指向进程的实线代表资源分配（正在使用）。</p><p>比如有 P1 P2 两个进程，它们都需要用到 R1 R2 两种资源。当前状态如下：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-3.png"></div><ul><li>如果 P1 请求 R2 资源：那么就把 P1 到 R2 的需求边改为 R2 到 P1 的分配边，此时整个图中不存在回路，那么就认为系统处于安全状态，不会发生死锁。可以分配资源。</li><li>如果 P2 请求 R2 资源：那么就把 P2 到 R2 的需求边改为 R2 到 P2 的分配边，此时整个图中存在一条回路，那么就认为系统处于不安全状态，有可能发生死锁。不可以分配资源</li></ul><p>根据前面的说法，即使进入不安全状态仅仅意味着有可能发生死锁，也要杜绝，所以 P2 不会请求到想要的资源。</p><h4 id="银行家算法">2.3 银行家算法</h4><p>银行家算法即 Banker's Algorithm，当各类资源<strong>有多个</strong>的时候，可以使用这种方法求解。</p><p>银行家算法的基本思路如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-5.png" style="zoom:50%"></p><p>由于涉及到了安全性算法，所以这里先解释安全性算法。安全性算法是银行家算法的一环，用于检测某个状态是安全状态还是不安全状态，并决定资源分配。</p><p>假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-15.png" style="zoom:67%"></p><p>如何检测当前是否处于安全状态呢？尝试寻找安全序列：</p><ul><li>当前剩余资源（3,3,2），无法满足 P0 需要的（7,4,3），所以不能首先分配给 P0；但是可以满足 P1 需要的（1,2,2），P3 需要的（0,1,1），所以可以分配给 P1 和 P3，P1 和 P3 进入安全序列。</li><li>P1 和 P3 执行完之后，归还资源，剩余资源（3,3,2）+（2,0,0）+（2,1,1）=（7,4,3），可以满足 P0 需要的（7,4,3），P2 需要的（6,0,0），P4 需要的（4,3,1），所以 P0、P2、P4 依次进入安全序列</li><li>所以存在安全序列 <code>P1-&gt;P3-&gt;P0-&gt;P2-&gt;P4</code> ，使得按照这个顺序分配资源后，每个进程都能拿到需要的资源并顺利完成，所以该状态是安全状态。</li></ul><p>看另一种情况。假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-16.png" style="zoom:67%"></p><p>当尝试寻找安全序列的时候，容易发现 P1 P3 可以满足，所以 P1 P3 进入安全序列，此后剩余资源为（7,4,3）。又由于 P0 P2 P4 都是无法满足的，所以实际上并不存在一个安全序列使得所有进程都能被分配资源。因此状态是不安全状态，可能发生死锁，取消资源分配。</p><p>现在来看银行家算法。</p><p>假设系统中有 n 个进程，m 种资源，规定：</p><ul><li>每个进程在运行前先声明自己需要的最大资源数，用一个 n*m 的最大需求矩阵 <code>Max</code> 表示各个进程的需求情况，比如 <code>Max[i][j]= K</code> 就表示进程 i 需要 K 个 j 类型资源</li><li>用一个 n*m 的分配矩阵 <code>Allocation</code> 表示各个进程的已分配资源情况</li><li>用一个 n*m 的需求矩阵 <code>Need</code> 表示各个进程的最多还需要资源情况，<code>Need = Max - Allocation</code></li><li>用一个 m 长度的一维数组 <code>Avaliable</code> 表示剩余资源数目</li><li>用一个 m 长度的一维数组 <code>Request_i</code> 表示某个进程 i 某次申请的资源数目</li></ul><p>按照之前说过的流程图，银行家算法的工作过程是：</p><ul><li>请求资源数是否超过最大资源数？<code>Request_i[j]&lt;=Need[i][j]</code>，则到下一步；否则出错</li><li>请求资源数是否超过剩余资源数？<code>Request_i[j]&lt;=Available[j]</code>，则到下一步；否则说明资源不够，进程等待</li><li>尝试进行资源分配。</li><li>剩余资源减少：<code>Available = Available - Request</code></li><li>已分配资源增加：<code>Allocation[i][j] = Allocation[i][j] + Request_i[j]</code></li><li>需求资源减少：<code>Need[i][j] = Need[i][j] - Request_i[j]</code></li><li>对分配后的状态通过安全性算法进行预判：</li><li>安全状态：不会发生死锁，可以分配资源</li><li>不安全状态：可能发生死锁，不分配资源</li></ul><h3 id="检测和解除死锁">3. 检测和解除死锁</h3><p>死锁的第三种处理策略是检测和解除死锁，与前面不同的是，这种策略没有规避死锁的发生，而是在死锁发生后进行检测，检测到死锁就将其解除。</p><h4 id="检测死锁">3.1 检测死锁</h4><p>检测死锁依然可以利用前面讲到的资源分配图，这里分为两种情况的死锁检测：</p><p>①<strong>各类资源只有一个</strong></p><p>当各类资源只有一个的时候，可以把资源分配图化简为一个等待图（wait-for graph），比如说 A 进程请求 X 资源、X 资源被 B 进程占有，这个过程可以被简化为 A 进程等待 B 进程。比如说下面，左图被转化为对应的右图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-8.png" style="zoom:67%"></p><p>之后检测是否有回路，因为有回路，所以认为此时是存在死锁的。</p><p>②<strong>各类资源有多个</strong></p><p>各类资源有多个的时候，我们可能需要根据给定表检测是否有死锁，还可能根据给定图检测是否有死锁。对于前者，可以沿用之前的安全性算法进行检测；对于后者，可以尝试化简资源分配图。</p><p>比如说，现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（7,2,6）。在某一时刻，资源剩余量为（0,0,0），各个进程的最大需求量、已分配量和需求量如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-9.png" style="zoom:67%"></p><p>对于给定的表，可以用安全性算法检测是否处于死锁状态。因为剩余资源（0,0,0），所以 P0 P2 可执行；之后归还资源，剩余资源（3,1,3），所以 P1，P3，P4 可执行。所以存在安全序列 <code>P0-&gt;P2-&gt;P1-&gt;P3-&gt;P4</code> ，此时认为该状态是安全状态，不会发生死锁。</p><p>但是如果稍微做一下改动（P2 对 C 资源的需求量加一）：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-10.png" style="zoom:67%"></p><p>因为剩余资源（0,0,0），所以 P0 可执行；之后归还资源，剩余资源（0,1,0），此时其它四个进程都没有执行所需要的足够的资源数，因此不存在安全序列。此时认为该状态是不安全状态，<strong>一定发生死锁</strong>。并且发生死锁的进程是 P1，P2，P3，P4。</p><p>PS：这里需要注意的是，在避免死锁中使用的安全性算法，检测到不存在安全序列的时候，就认为处于不安全状态，可能发生死锁；但是在这里使用的安全性算法，一旦检测到不存在安全序列，就认为处于不安全状态，一定发生了死锁。</p><p>上面介绍的是给定表的死锁检测，如果给定的是资源分配图，应该如何检测死锁呢？以下图为例：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-12.png" style="zoom:67%"></p><p>约定蓝色线为请求边，黑色线为分配边，资源中的一个圆点代表一个该类资源。那么 P1 占有两个 R1 资源，请求一个 R2 资源；P2 占有一个 R2 资源，一个 R1 资源，请求一个 R1 资源。</p><ul><li>首先找出非阻塞非孤立的进程点。P1 P2 都不是孤立的，所谓非阻塞指的是<strong>进程请求的资源数量足够</strong>，比如说 P2 请求 R1，由于 R1 已经有两个被 P1 占有，一个被 P2 占有，无多余资源，所以 P2 请求的资源数量不够，P2 是阻塞的；而 P1 请求 R2，因为 R2 只有一个被 P2 占有，所以有多于资源，P1 请求的资源数量足够，P1 是非阻塞的。这样就找到了符合条件的进程点 P1</li><li>去除这样的点的所有边。那么就会去除 P1 的所有边，归还所有资源。P1 成为孤立点。</li><li>重复第一步和第二步。此时，因为这次 P2 请求的 R2 资源是足够的（被 P1 释放了），所以 P2 是非阻塞非孤立的点，把他的全部边去除</li><li>由于图中所有的边都能被消除，所以称该图<strong>可以被简化</strong>，因此它不存在死锁（如果不可简化，则存在死锁）</li></ul><p>又比如下面这种情况：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81-14.png" style="zoom:67%"></p><p>首先还是找一个非孤立非阻塞的点，很显然只有 P3 符合要求。之后把 P3 的分配边去掉，会发现 P1 和 P2 都是非孤立阻塞的点，它们的边都无法消除。此时就说该资源分配图不能简化，因此存在死锁。</p><h4 id="解除死锁">3.2 解除死锁</h4><p>检测到死锁后，下一步就是解除死锁。有以下三种方法：</p><p><strong>① 资源剥夺法：</strong></p><p>将部分死锁的进程挂起（对换到外存上），并抢占它的资源，将这些资源分配给其它的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</p><p>PS：注意不是抢占非死锁进程的资源。</p><p><strong>② 撤销/终止进程法：</strong></p><p>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止就功亏一篑了，以后还得从头再来。</p><p><strong>③ 进程回退法：</strong></p><p>让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统必须记录进程的历史信息，设置还原点。</p><p>无论是哪种方法，都会有进程需要做出牺牲，那么应该对谁下手呢？可以从下面这些角度考虑：</p><ul><li>优先级比较低的进程做出牺牲</li><li>占用过多资源的进程做出牺牲</li><li>执行时间长的进程不做出牺牲（不然就功亏一篑了）</li><li>快要完成的进程不做出牺牲</li><li>交互式进程不做出牺牲</li></ul><p>参考：</p><p>《王道考研》</p><p><a target="_blank" rel="noopener" href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/7_Deadlocks.html">OS CourseNotes</a></p><hr><p>操作系统系列学习笔记：</p><p><a href="https://chorer.github.io/2020/03/10/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">操作系统学习笔记-1：基础概念</a></p><p><a href="https://chorer.github.io/2020/03/17/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">操作系统学习笔记-2：体系结构和运行机制</a></p><p><a href="https://chorer.github.io/2020/03/17/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/">操作系统学习笔记-3：初识进程和进程控制</a></p><p><a href="https://chorer.github.io/2020/03/23/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%80%EF%BC%89/">操作系统学习笔记-4：进程同步与进程互斥（一）</a></p><p><a href="https://chorer.github.io/2020/03/25/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/">操作系统学习笔记-5：进程同步与进程互斥（二）：信号量机制</a></p><p><a href="https://chorer.github.io/2020/03/28/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/">操作系统学习笔记-6：进程同步与进程互斥（三）：经典问题</a></p><p><a href="https://chorer.github.io/2020/04/04/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7%EF%BC%9A%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">操作系统学习笔记-7：进程通信</a></p><p><a href="https://chorer.github.io/2020/04/05/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8%EF%BC%9A%E7%BA%BF%E7%A8%8B/">操作系统学习笔记-8：线程</a></p><p><a href="https://chorer.github.io/2020/04/11/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/">操作系统学习笔记-9：调度</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/04/24/CP-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="prev" title="编译原理学习笔记-4：词法分析(二)等价转换与DFA的化简"><i class="fa fa-angle-double-left"></i>&nbsp编译原理学习笔记-4：词法分析(二)等价转换与DFA的化简</a></div><div class="post-nav-next"><a href="/2020/04/18/Trs-%E8%B0%81%E5%8A%A8%E4%BA%86%E6%88%91%E7%9A%84%E6%8C%89%E9%92%AE%EF%BC%9F/" rel="next" title="「译」谁动了我的按钮？ 🧀">「译」谁动了我的按钮？ 🧀&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81"><span class="toc-text">1. 关于死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">2. 死锁的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%87%BA%E7%8E%B0%E5%9C%BA%E6%99%AF"><span class="toc-text">3. 死锁的出现场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">死锁的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-text">1. 预防死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">2. 避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%BA%8F%E5%88%97%E5%92%8C%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="toc-text">2.1 安全序列和安全状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="toc-text">2.2 资源分配图算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2.3 银行家算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81"><span class="toc-text">3. 检测和解除死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="toc-text">3.1 检测死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81"><span class="toc-text">3.2 解除死锁</span></a></li></ol></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->