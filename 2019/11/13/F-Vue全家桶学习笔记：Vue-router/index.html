<!-- build time:Sun Sep 05 2021 16:01:26 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">Vue 全家桶学习笔记：Vue-router</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-11-13&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.1k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp13 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue-router/Vue-router-1.jpg"></div><span id="more"></span><h4 id="前端路由的出现">1. 前端路由的出现</h4><p>在以前，前后端是不分离的，这个阶段通常是由服务端渲染好页面（SSR），再发送页面给前端去展示；接着到了前后端分离的阶段，前端向静态资源服务器拿资源，再通过 js 渲染页面，此时仍然是一个 url 对应一份 html+css+js。再后来出现了 SPA 单页面应用的概念，实际上它只有一个页面，但给我们的体验是多页面之间的切换。</p><p>SPA 是基于路由和组件的，其中路由可以看作是它的一个路径管理器，路由和组件之间互相映射，路由的切换就是组件的切换。Vue 的前端路由也就是 vue-router。</p><h4 id="vue-router-的模式">2. vue-router 的模式</h4><p>vue-router 提供了 hash 和 history 两种模式。</p><ul><li><strong>hash 模式</strong>：url 中带有 hash（#），hash 的改变并不会触发刷新或者请求，同时每一次改变 hash 后的部分，都会在浏览器的访问历史中增加一个记录 ，这使得我们可以来回切换；而要监听切换可以依靠 <code>onhashchange</code> 事件；</li><li><strong>history 模式</strong>：html5 提供了 <code>window.history</code> 的 API，url 的改变同样不会触发页面刷新，并且由于历史记录是在 history 栈压入或弹出的，这使得我们可以来回切换。</li></ul><p>实例化 vue-router 时会传入一个对象，可以给对象一个 <code>option</code>，如 <code>mode:'history'</code>，从而决定 vue-router 使用哪种模式。</p><h4 id="安装">3. 安装</h4><p>在安装 vue-cli 的时候可以顺便安装 vue-router，或者之后我们通过 <code>npm install</code> 的方式手动安装。</p><h4 id="使用">4. 使用</h4><p>如果是通过脚手架安装 vue-router，<code>src</code> 下会多出一个 <code>router</code> 文件夹，里面的 <code>index.js</code> 帮我们生成了配置的基础结构。</p><p><code>index.js</code> 大致是这样的：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// 导入要使用到的组件</span>
<span class="im">import</span> VueRouter <span class="im">from</span> <span class="st">&#39;vue-router&#39;</span><span class="op">;</span>     
<span class="im">import</span> Vue <span class="im">from</span> <span class="st">&#39;vue&#39;</span><span class="op">;</span>                
<span class="im">import</span> Home <span class="im">from</span> <span class="st">&#39;../components/Home.vue&#39;</span><span class="op">;</span>
<span class="im">import</span> About <span class="im">from</span> <span class="st">&#39;../components/About.vue&#39;</span><span class="op">;</span>

<span class="va">Vue</span>.<span class="at">use</span>(VueRouter)<span class="op">;</span>        <span class="co">// 安装 vue-router</span>

<span class="kw">const</span> routes <span class="op">=</span> [                  <span class="co">// 配置路由和组件的映射关系</span>
    <span class="op">&#123;</span>
       <span class="dt">path</span><span class="op">:</span><span class="st">&#39;/&#39;</span><span class="op">,</span>
       <span class="dt">redirect</span><span class="op">:</span> <span class="st">&#39;/home&#39;</span>
    <span class="op">&#125;</span>
    <span class="op">&#123;</span>
       <span class="dt">path</span><span class="op">:</span><span class="st">&#39;/home&#39;</span><span class="op">,</span>
       <span class="dt">components</span><span class="op">:</span>Home
    <span class="op">&#125;,</span>
    <span class="op">&#123;</span>
       <span class="dt">path</span><span class="op">:</span><span class="st">&#39;/about&#39;</span><span class="op">,</span>
       <span class="dt">components</span><span class="op">:</span>About
    <span class="op">&#125;</span>
]

<span class="kw">const</span> router <span class="op">=</span> <span class="kw">new</span> <span class="at">VueRouter</span>(<span class="op">&#123;</span>         <span class="co">// 实例化 VueRouter 对象</span>
  routers
<span class="op">&#125;</span>)

<span class="im">export</span> <span class="im">default</span> router<span class="op">;</span>                <span class="co">// 导出 router 对象</span></code></pre></div><p>同时，<code>main.js</code> 文件中，导入 router 并在 Vue 实例下挂载：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// main.js</span>

<span class="im">import</span> Vue <span class="im">from</span> <span class="st">&#39;vue&#39;</span>
<span class="im">import</span> App <span class="im">from</span> <span class="st">&#39;./App.vue&#39;</span>
<span class="im">import</span> router <span class="im">from</span> <span class="st">&#39;./router&#39;</span>

<span class="va">Vue</span>.<span class="va">config</span>.<span class="at">productionTip</span> <span class="op">=</span> <span class="kw">false</span>

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">&#123;</span>
  router<span class="op">,</span>
  <span class="dt">render</span><span class="op">:</span> <span class="kw">function</span> (h) <span class="op">&#123;</span> <span class="cf">return</span> <span class="at">h</span>(App) <span class="op">&#125;</span>
<span class="op">&#125;</span>).<span class="at">$mount</span>(<span class="st">&#39;#app&#39;</span>)</code></pre></div><p>接下来通过 <code>&lt;router-link&gt;</code> 和 <code>&lt;router-view&gt;</code> 使用路由：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// App.vue</span>

<span class="op">&lt;</span>div id<span class="op">=</span><span class="st">&quot;app&quot;</span><span class="op">&gt;</span>
    <span class="op">&lt;</span>router<span class="op">-</span>link to<span class="op">=</span><span class="st">&quot;/home&quot;</span><span class="op">&gt;</span>首页<span class="op">&lt;</span><span class="ss">/router-link&gt;        </span>
<span class="ss">    &lt;router-link to=&quot;/about</span><span class="st">&quot;&gt;关于&lt;/router-link&gt;</span>
    <span class="op">&lt;</span>router<span class="op">-</span>view<span class="op">&gt;&lt;</span><span class="ss">/router-view&gt;</span>
<span class="ss">&lt;/div</span><span class="op">&gt;</span></code></pre></div><h4 id="路由嵌套二级路由">5. 路由嵌套（二级路由）</h4><p>假设 <code>home</code> 路由下嵌套着两个子路由 <code>news</code> 和 <code>message</code>，即 <code>/home/news</code> 和 <code>/home/message</code>，那么首先创建两个对应的组件，之后在 <code>index.js</code> 下配置好映射关系：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">import</span> HomeNews <span class="im">from</span> <span class="st">&#39;../components/HomeNews.vue&#39;</span>
<span class="im">import</span> HomeMessage <span class="im">from</span> <span class="st">&#39;../components/HomeMessage.vue&#39;</span>

<span class="kw">const</span> routes <span class="op">=</span> [                  <span class="co">// 配置 url和组件的映射关系</span>
    <span class="op">&#123;</span>
       <span class="dt">path</span><span class="op">:</span><span class="st">&#39;/&#39;</span><span class="op">,</span>
       <span class="dt">redirect</span><span class="op">:</span> <span class="st">&#39;/home&#39;</span>
    <span class="op">&#125;</span>
    <span class="op">&#123;</span>
       <span class="dt">path</span><span class="op">:</span><span class="st">&#39;/home&#39;</span><span class="op">,</span>
       <span class="dt">component</span><span class="op">:</span>Home<span class="op">,</span>
       <span class="dt">children</span><span class="op">:</span>[
        <span class="op">&#123;</span>
           <span class="dt">path</span><span class="op">:</span><span class="st">&#39;/&#39;</span><span class="op">,</span>                 <span class="co">// 默认展示 news</span>
           <span class="dt">redirect</span><span class="op">:</span> <span class="st">&#39;news&#39;</span>
        <span class="op">&#125;</span>
        <span class="op">&#123;</span>
           <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;news&#39;</span><span class="op">,</span>
           <span class="dt">component</span><span class="op">:</span> HomeNews
        <span class="op">&#125;,</span>
        <span class="op">&#123;</span>
           <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;message&#39;</span><span class="op">,</span>
           <span class="dt">component</span><span class="op">:</span> HomeMessage
        <span class="op">&#125;</span>
    ]
    <span class="op">&#125;,</span>
    <span class="op">&#123;</span>
       <span class="dt">path</span><span class="op">:</span><span class="st">&#39;/about&#39;</span><span class="op">,</span>
       <span class="dt">component</span><span class="op">:</span>About
    <span class="op">&#125;</span>
]</code></pre></div><p>在 <code>Home.vue</code> 中使用子路由：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">// Home.vue

<span class="kw">&lt;div&gt;</span>
    <span class="kw">&lt;h1&gt;</span>我是Home<span class="kw">&lt;/h1&gt;</span>
    <span class="kw">&lt;router-link</span><span class="ot"> to=</span><span class="st">&quot;/home/news&quot;</span><span class="kw">&gt;</span>news<span class="kw">&lt;/router-link&gt;</span>
    <span class="kw">&lt;router-link</span><span class="ot"> to=</span><span class="st">&quot;/home/messaage&quot;</span><span class="kw">&gt;</span>message<span class="kw">&lt;/router-link&gt;</span>
    <span class="kw">&lt;router-view&gt;&lt;/router-view&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div><h4 id="动态路由匹配">5. 动态路由匹配</h4><p>有的时候，path 并不是固定的。比方 <code>/user/Tom</code>，<code>/user/Jack</code>，这些 path 根据用户不同而不同，但都是展示用户页面的，我们希望满足这种格式的 path 都映射 <code>User</code> 组件，怎么办呢？可以在 path 中使用动态路径参数。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">import</span> HomeMessage <span class="im">from</span> <span class="st">&#39;../components/User.vue&#39;</span>

<span class="kw">const</span> routes <span class="op">=</span> <span class="op">&#123;</span>
    <span class="op">&#123;</span>
        <span class="dt">path</span><span class="op">:</span><span class="st">&#39;/user/:userId&#39;</span><span class="op">,</span>
        <span class="dt">component</span><span class="op">:</span> User
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>注意，这里我们不再是写 <code>/user/</code>，而是写 <code>/user/:userId</code>，这是因为路径 user 后面的东西是动态的。那么，对于下面的三种 <code>&lt;router-link&gt;</code>，最后都可以成功映射到 <code>User</code> 组件：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// App.vue</span>

<span class="op">&lt;</span>router<span class="op">-</span>link to<span class="op">=</span><span class="st">&quot;/user/Tom&quot;</span><span class="op">&gt;&lt;</span><span class="ss">/router-link&gt;           // 路径：/user/Tom</span>
<span class="ss">&lt;router-link to=&quot;/user/Jack&quot;&gt;&lt;/router</span><span class="op">-</span>link<span class="op">&gt;</span>          <span class="co">// 路径：/user/Jack</span>
<span class="op">&lt;</span>router<span class="op">-</span>link <span class="op">:</span>to<span class="op">=</span><span class="st">&quot;`/user/$&#123;userId&#125;`&quot;</span><span class="op">&gt;&lt;</span><span class="ss">/router-link&gt;   // 路径：/user/Bake</span>
<span class="ss">&lt;router-view&gt;&lt;/router</span><span class="op">-</span>view<span class="op">&gt;</span>

<span class="im">export</span> <span class="im">default</span><span class="op">&#123;</span>
    <span class="at">data</span>()<span class="op">&#123;</span>
        <span class="cf">return</span> <span class="op">&#123;</span>
            <span class="dt">userId</span><span class="op">:</span><span class="st">&#39;Bake&#39;</span>
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>如果想要在具体的 <code>User.vue</code> 中展示用户名，可以通过 <code>$route.params</code> 去访问：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// User.vue</span>

<span class="op">&lt;</span>div<span class="op">&gt;</span>我的用户名是：<span class="op">&lt;!--</span>swig￼<span class="dv">0</span><span class="op">--&gt;&lt;</span><span class="ss">/div&gt;</span>
<span class="ss">&lt;div&gt;我的用户名是：&#123;&#123;id&#125;&#125;&lt;/div</span><span class="op">&gt;</span>

<span class="im">export</span> <span class="im">default</span><span class="op">&#123;</span>
    <span class="dt">computed</span><span class="op">:&#123;</span>
        <span class="at">id</span>()<span class="op">&#123;</span>
            <span class="cf">return</span> <span class="kw">this</span>.<span class="va">$route</span>.<span class="va">params</span>.<span class="at">userId</span><span class="op">;</span>
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><h4 id="路由传参">6. 路由传参</h4><h5 id="基于动态路由">6.1 基于动态路由</h5><p>实际上，上面讲的动态路由就可以用来传递参数。上面例子的 <code>path</code> 还可以根据需要添加更多动态路径参数，如 <code>'/user/:userId/:userJob/:userEmail'</code>，首先在 App.vue 拿到数据，传给<code>&lt;router-link&gt;</code> 的 <code>to</code>，接着就可以在 User.vue 中通过 <code>$route.params</code> 去访问了。</p><h5 id="给-to-传入对象">6.2 给 <code>to</code> 传入对象</h5><p>首先要明白，<code>to</code> 除了接收字符串之外，也可以接受对象。以前面的动态路由为例：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--可以这样写（直接传字符串）--&gt;</span>
<span class="co">&lt;router-link :to=&quot;`/user/$&#123;userId&#125;`&quot;&gt;&lt;/router-link&gt;</span>

<span class="co">&lt;!</span><span class="er">--</span><span class="co">也可以这样写（传对象，直接用字符串表示完整路径）--&gt;</span>
<span class="kw">&lt;router-link</span><span class="ot"> :to=</span><span class="st">&quot;&#123;path:&#39;`/user/$&#123;userId&#125;`&#39;&#125;&quot;</span><span class="kw">&gt;&lt;/router-link&gt;</span></code></pre></div><p>那么，我们会自然想到，对于一个普通的路由，要传参的话把参数放在给 <code>to</code> 传入的对象中不就可以了吗？</p><p>于是可能会这么写：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;router-link</span><span class="ot"> :to=</span><span class="st">&quot;&#123;path:&#39;/article&#39;,params:&#123;date:2020-1-1,title:&#39;A new year&#39;&#125;&#125;&quot;</span><span class="kw">&gt;&lt;/router-link&gt;</span></code></pre></div><p>然而这是<strong>错误</strong>的用法，事实上我们应该将 <code>path</code> 改为 <code>name</code>。不过在这之前，我们还是先给路由一个 <code>name</code>吧：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">import</span> Article <span class="im">from</span> <span class="st">&#39;../components/Article.vue&#39;</span>

<span class="co">// 首先给路由一个名字（命名路由）</span>
<span class="kw">const</span> routes <span class="op">=</span> <span class="op">&#123;</span>
    <span class="op">&#123;</span>
        <span class="dt">path</span><span class="op">:</span><span class="st">&#39;/article&#39;</span><span class="op">,</span>
        <span class="dt">name</span><span class="op">:</span><span class="st">&#39;article&#39;</span><span class="op">,</span>
        <span class="dt">component</span><span class="op">:</span> Article
    <span class="op">&#125;</span>
<span class="op">&#125;</span></code></pre></div><p>接着使用路由：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;router-link</span><span class="ot"> :to=</span><span class="st">&quot;&#123;name:&#39;article&#39;,params:&#123;date:2020-1-1,title:&#39;A new year&#39;&#125;&#125;&quot;</span><span class="kw">&gt;&lt;/router-link&gt;</span></code></pre></div><p>获取参数：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--Article.vue--&gt;</span>
 
<span class="kw">&lt;div&gt;</span><span class="co">&#123;&#123;$route.params.date&#125;&#125;</span><span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;div&gt;</span><span class="co">&#123;&#123;$route.params.title&#125;&#125;</span><span class="kw">&lt;/div&gt;</span></code></pre></div><h5 id="使用-query">6.3 使用 <code>query</code></h5><p>这和上面的是差不多的，不同的是我们不使用 <code>params</code>，而是使用 <code>query</code>。query 实际上就是 url 中的查询参数。</p><p>这种情况下，我们给 <code>to</code> 传入的对象可以使用 <code>path</code>，也可以使用 <code>name</code>：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;router-link</span><span class="ot"> :to=</span><span class="st">&quot;&#123;name:&#39;article&#39;,query:&#123;date:2020-1-1,title:&#39;A new year&#39;&#125;&#125;&quot;</span><span class="kw">&gt;&lt;/router-link&gt;</span>
<span class="co">&lt;!--等价于--&gt;</span>
<span class="co">&lt;router-link :to=&quot;&#123;path:&#39;/article&#39;,query:&#123;date:2020-1-1,title:&#39;A new year&#39;&#125;&#125;&quot;&gt;&lt;/router-link&gt;</span></code></pre></div><p>获取参数：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--Article.vue--&gt;</span>
 
<span class="kw">&lt;div&gt;</span><span class="co">&#123;&#123;$route.query.date&#125;&#125;</span><span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;div&gt;</span><span class="co">&#123;&#123;$route.query.title&#125;&#125;</span><span class="kw">&lt;/div&gt;</span></code></pre></div><h4 id="路由跳转声明式-vs-编程式">7. 路由跳转：声明式 VS 编程式</h4><p>前面介绍的路由跳转/导航是通过<strong>声明式</strong>的 <code>&lt;router-link :to='...'&gt;</code> 实现的，我们也可以使用<strong>编程式</strong>的 <code>this.$router.push('...')</code> 实现：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">// App.vue

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;router-link</span><span class="ot"> to=</span><span class="st">&#39;/home&#39;</span><span class="kw">&gt;</span>可以点击这里进入首页<span class="kw">&lt;/router-link&gt;</span> 
    <span class="co">&lt;!--</span>
<span class="co">    or: &lt;router-link :to=&quot;&#123;path:&#39;/home&#39;&#125;&quot;&gt;  </span>
<span class="co">    --&gt;</span>
    <span class="kw">&lt;button</span> <span class="er">@click</span><span class="ot">=</span><span class="st">&quot;change&quot;</span><span class="kw">&gt;</span>也可以点击这里进入首页<span class="kw">&lt;/button&gt;</span>
    <span class="kw">&lt;router-view&gt;&lt;/router-view&gt;</span>
<span class="kw">&lt;/div&gt;</span>

<span class="kw">&lt;script&gt;</span>
    <span class="im">export</span> <span class="im">default</span><span class="op">&#123;</span>
        <span class="dt">name</span><span class="op">:</span><span class="st">&#39;App&#39;</span><span class="op">,</span>
        <span class="dt">methods</span><span class="op">:&#123;</span>
            <span class="at">change</span>()<span class="op">&#123;</span>
                <span class="kw">this</span>.<span class="va">$router</span>.<span class="at">push</span>(<span class="st">&#39;/home&#39;</span>)<span class="op">;</span>
              <span class="co">//or: this.$router.push(&#123;path:&#39;/home&#39;&#125;) </span>
            <span class="op">&#125;</span>
        <span class="op">&#125;</span>
    <span class="op">&#125;</span>
<span class="kw">&lt;/script&gt;</span>    </code></pre></div><p><code>&lt;router-link :to='...'&gt;</code> 实质上也是在内部调用了 <code>push</code> 方法，从而向 history 栈压入新记录，由于是栈的数据结构，所以可以自由前进和后退。除了 <code>push</code>，还有 <code>replace</code>（注意是直接替换而不是采用入栈出栈方式），<code>go</code>，这些和 <code>window.history</code> 的 API 是类似的。</p><p><code>this.$router.push('...')</code> 同样接受字符串参数或者对象参数。</p><h4 id="router-和-route-的区别">8. <code>$router</code> 和 <code>$route</code> 的区别</h4><ul><li><p><code>$router</code> 是我们 new 出来的 VueRouter 实例，它提供了一些跳转方法（ <code>push</code> ， <code>replace</code>，<code>go</code> ）和钩子函数（后面导航守卫部分会讲解）；</p></li><li><p><code>$route</code> 是<strong>路由信息对象</strong>，可以理解为是当前活跃的路由，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。</p></li></ul><h4 id="导航守卫">9. 导航守卫</h4><p>路由的导航守卫其实就是一些钩子函数，可以在路由跳转的流程中针对性地进行操作控制。</p><h5 id="全局守卫">1. 全局守卫</h5><ul><li>全局前置守卫：<code>router.beforeEach((to,from,next) =&gt; &#123;...&#125;)</code>。可以在 <code>index.js</code> 或者路由组件中使用（通过 <code>this.$router</code>），next 必须调用。</li><li>全局解析守卫： <code>router.beforeResolve</code>。</li><li>全局后置钩子：<code>router.afterEach((to,from) =&gt; &#123;...&#125;)</code>。可以在 <code>index.js</code> 或者路由组件中使用（通过 <code>this.$router</code>），next 不需要调用。</li></ul><h5 id="路由独享守卫">2. 路由独享守卫</h5><p>单个路由独享的守卫只有 <code>beforeEnter</code> 这一个，可以在配置路由时定义。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> router <span class="op">=</span> <span class="kw">new</span> <span class="at">VueRouter</span>(<span class="op">&#123;</span>
  <span class="dt">routes</span><span class="op">:</span> [
    <span class="op">&#123;</span>
      <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/home&#39;</span><span class="op">,</span>
      <span class="dt">component</span><span class="op">:</span> Home<span class="op">,</span>
      <span class="dt">beforeEnter</span><span class="op">:</span> (to<span class="op">,</span> <span class="im">from</span><span class="op">,</span> next) <span class="op">=&gt;</span> <span class="op">&#123;</span>
        <span class="co">// ...</span>
        <span class="at">next</span>()  
      <span class="op">&#125;</span>
    <span class="op">&#125;</span>
  ]
<span class="op">&#125;</span>)</code></pre></div><h5 id="组件守卫">3. 组件守卫</h5><p>组件守卫只能在路由组件中定义：</p><ul><li><code>beforeRouteEnter((to,from,next) =&gt; &#123;...&#125;)</code>： 进入路由前，此时实例还没创建，无法获取到 this</li><li><code>beforeRouteUpdate((to,from,next) =&gt; &#123;...&#125;)</code> ：路由复用同一个组件时触发，比如 <code>/user/Tom</code> 和 <code>/user/Jack</code></li><li><code>beforeRouteLeave((to,from,next) =&gt; &#123;...&#125;)</code>： 离开当前路由，此时可以用来保存数据，或数据初始化，或关闭定时器等等</li></ul><h5 id="导航解析流程">4. 导航解析流程</h5><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue-router/Vue-router-2.jpg"></div><h4 id="路由懒加载">10. 路由懒加载</h4><p>懒加载也叫延迟加载，即<strong>在需要的时候进行加载</strong>，随用随载。在单页应用中，如果没有应用懒加载，运用webpack 打包后的文件将会异常的大，导致进入首页时，需要加载的内容过多，延时过长，不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时</p><p>要使用路由懒加载，只需要替换掉原来的引用语句即可：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// import Home from &#39;../components/Home.vue&#39;;</span>
<span class="co">// import About from &#39;../components/About.vue&#39;;</span>

<span class="kw">const</span> Home <span class="op">=</span> () <span class="op">=&gt;</span> <span class="im">import</span>(<span class="st">&#39;../components/Home&#39;</span>)<span class="op">;</span>
<span class="kw">const</span> About <span class="op">=</span> () <span class="op">=&gt;</span> <span class="im">import</span>(<span class="st">&#39;../components/About&#39;</span>)<span class="op">;</span></code></pre></div><h4 id="keep-alive">11. keep-alive</h4><p>路由跳转的时候，比如 <code>home -&gt; about -&gt; home</code>，<code>home</code> 路由组件实际上是在不断地创建和销毁，我们可以用生命周期钩子函数证明这一点：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue-router/Vue-router-3.jpg"></div><p>上图中，每次跳转的时候都会经历一次生命周期。但大部分时候，这种重新渲染是没有必要的，所以 Vue 提供了一个内置组件 <code>keep-alive</code> 来 <strong>缓存组件内部状态，避免重新渲染</strong> 。</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;keep-alive&gt;</span>
    <span class="kw">&lt;router-view&gt;&lt;/router-view&gt;</span>
<span class="kw">&lt;/keep-alive&gt;</span></code></pre></div><p>被 <code>keep-alive</code> 包裹的路由/组件，状态会得到缓存。以上图为例，从 home 跳转到 about，home 不会被销毁，同样的，从 about 跳转到 home，about 不会被销毁，home 也不会被重新创建，而是用之前缓存好的组件。</p><ul><li>keep-alive 提供了 <code>activated</code> 和 <code>deactivated</code> 两个钩子函数（在路由组件中定义），前者在当前路由组件激活时调用，后者在当前路由组件失活时调用。</li><li>keep-alive 提供了 3 个属性定义具体的缓存情况：</li><li><code>include</code> 包含的组件(可以是字符串，数组，以及正则表达式,只有匹配的组件会被缓存)</li><li><code>exclude</code> 排除的组件(可以是字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存)</li><li><code>max</code> 缓存组件的最大值(类型为字符或者数字,可以控制缓存组件的个数)</li></ul><p>参考：</p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b0281b851882542845257e7">从头开始学习vue-router</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b82bcfcf265da4345153343">可能比文档还详细--VueRouter完全指北</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/11/21/F-Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AVuex/" rel="prev" title="Vue 全家桶学习笔记：Vuex"><i class="fa fa-angle-double-left"></i>&nbspVue 全家桶学习笔记：Vuex</a></div><div class="post-nav-next"><a href="/2019/11/09/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%89%EF%BC%89/" rel="next" title="AJAX 与跨域通信（三）：跨域解决方案">AJAX 与跨域通信（三）：跨域解决方案&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="toc-text">1. 前端路由的出现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue-router-%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-text">2. vue-router 的模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-text">3. 安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">4. 使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%B5%8C%E5%A5%97%E4%BA%8C%E7%BA%A7%E8%B7%AF%E7%94%B1"><span class="toc-text">5. 路由嵌套（二级路由）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D"><span class="toc-text">5. 动态路由匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-text">6. 路由传参</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-text">6.1 基于动态路由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%99-to-%E4%BC%A0%E5%85%A5%E5%AF%B9%E8%B1%A1"><span class="toc-text">6.2 给 to 传入对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-query"><span class="toc-text">6.3 使用 query</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%A3%B0%E6%98%8E%E5%BC%8F-vs-%E7%BC%96%E7%A8%8B%E5%BC%8F"><span class="toc-text">7. 路由跳转：声明式 VS 编程式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#router-%E5%92%8C-route-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8. $router 和 $route 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-text">9. 导航守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%AE%88%E5%8D%AB"><span class="toc-text">1. 全局守卫</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E5%AE%88%E5%8D%AB"><span class="toc-text">2. 路由独享守卫</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%AE%88%E5%8D%AB"><span class="toc-text">3. 组件守卫</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">4. 导航解析流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-text">10. 路由懒加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#keep-alive"><span class="toc-text">11. keep-alive</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->