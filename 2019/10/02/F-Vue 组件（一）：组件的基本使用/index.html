<!-- build time:Sat Apr 11 2020 23:54:21 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">Vue 组件（一）：组件的基本使用</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-10-02&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp5 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/Vue/">Vue</a> <a href="/tags/组件/">组件</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-8.png" alt=""><br><a id="more"></a></p><h2 id="1-组件化"><a href="#1-组件化" class="headerlink" title="1.组件化"></a>1.组件化</h2><p>组件实际上是可以复用的 Vue 实例，它们与 new Vue 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>methods</code> 以及生命周期钩子等。<br>何谓复用？如果把页面看作是组件的容器，那么导航栏、搜索框其实都是可以复用的组件。作为对可重用代码的封装，它们自身具有独立的数据和逻辑。</p><p>前端组件化的核心思路就是将一个巨大复杂的东西<strong>拆分</strong>成若干个小东西（组件），这些组件可以自由组合、替换和删除，同时不影响整个应用的运行，这就是组件化开发。</p><p>组件化的好处是：</p><ul><li>提高开发效率</li><li>方便重复使用，简化调试步骤，方便单元测试</li><li>提升整个项目的可维护性，方便团队成员的协同开发</li><li>高内聚（功能必须是完整的）、低耦合（解耦业务逻辑和数据）</li></ul><h2 id="2-创建组件"><a href="#2-创建组件" class="headerlink" title="2.创建组件"></a>2.创建组件</h2><h3 id="2-1-全局组件"><a href="#2-1-全局组件" class="headerlink" title="2.1 全局组件"></a>2.1 全局组件</h3><p>全局组件在 <code>new Vue</code> 之前创建，创建之后可用于所有根实例的模板中。<br>2.x 之前全局组件的创建过程如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*option*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 创建组件构造器对象</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span>TagName<span class="token punctuation">,</span>obj<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">// 注册组件</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.x 之后语法糖的写法如下：</p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"TagName"</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*option*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 同时创建并注册组件</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-局部组件"><a href="#2-2-局部组件" class="headerlink" title="2.2 局部组件"></a>2.2 局部组件</h3><p>更多的是创建局部组件，让其只能在当前所处的 Vue 实例的模板中使用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*option*/</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token string">"aaa"</span><span class="token punctuation">:</span>obj
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要创建父子组件，那么可以这样写：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*option*/</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`&lt;div>&lt;h2>something&lt;/h2>&lt;bbb>&lt;/bbb>&lt;/div>`</span></span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token string">"bbb"</span><span class="token punctuation">:</span>son
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token string">"aaa"</span><span class="token punctuation">:</span>parent
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后在 dom 中书写 <code>&lt;aaa&gt;&lt;/aaa&gt;</code> ，会发现父子组件都可以渲染，但是单独书写 <code>&lt;bbb&gt;&lt;/bbb&gt;</code> 则无法渲染子组件，这是因为子组件是在父组件中注册的，因此它只能在父组件的模板中使用。</p><h3 id="2-3-模板抽离"><a href="#2-3-模板抽离" class="headerlink" title="2.3 模板抽离"></a>2.3 模板抽离</h3><p>上面的 <code>&lt;div&gt;&lt;h2&gt;something&lt;/h2&gt;&lt;bbb&gt;&lt;/bbb&gt;&lt;/div&gt;</code> 可以单独抽离出来放在一个有 id 的 <code>&lt;template&gt;&lt;/template&gt;</code> 中，之后直接 <code>#id</code> 引用该模板即可。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>template id<span class="token operator">=</span><span class="token string">"temp"</span><span class="token operator">></span>
  <span class="token operator">&lt;</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span>h2<span class="token operator">></span>something<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>
    <span class="token operator">&lt;</span>bbb<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bbb<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span>

<span class="token comment" spellcheck="true">// 改写如下：</span>
<span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`&lt;div>&lt;h2>something&lt;/h2>&lt;bbb>&lt;/bbb>&lt;/div>`</span></span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span><span class="token punctuation">{</span>
    bbb<span class="token punctuation">:</span><span class="token string">"#temp"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<strong>每个组件都必须有且仅能有一个根元素</strong>，这意味着组件所有的内容必须包裹在一个最外层元素中。</p><h2 id="3-组件的命名"><a href="#3-组件的命名" class="headerlink" title="3. 组件的命名"></a>3. 组件的命名</h2><p>组件创建后，直接在 dom 中书写组件名即可使用组件。但是组件的命名有一定的规则。<br>定义组件名的方式有两种:</p><p><strong>(1)</strong> 使用 kebab-case(字母全小写+连字符)，例如：</p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-component'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*option*/</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用时也必须是 kebab-case。即 <code>&lt;my-component&gt;&lt;/my-component&gt;</code>，否则会报错。</p><p><strong>(2)</strong> 使用 PascalCase（帕斯卡），例如：</p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'MyComponent'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* option*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是在<strong>父组件模板</strong>（模板没有抽离到 HTML 中的）中使用，则允许 kebab-case 和 PascalCase 两种方式，即 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 或者 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 都是允许的；但是如果直接在 DOM （非字符串的模板）中，则只能使用相应的 kebab-case，否则会报错。</p><p>我们来看一个例子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1.png" alt=""></p><p>上图中我们创建了父子组件，其中子组件采用 PascalCase 命名，之后在父组件模板中引用子组件时，发现不管是 kebab-case 命名还是 PascalCase 命名都是可以成功渲染的。</p><p>再来看第二张图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-2.png" alt=""></p><p>我们创建了 <code>HisCpn</code> 组件，之后直接在 DOM 中引用（没有转换为 kebab-case 命名），结果报错了；同样的，我们创建了 <code>cpn1</code> 和 <code>MyCpn</code> 父子组件，之后直接在 DOM 中引用，发现转换为 kebab-case 命名<br>的子组件可以正常渲染，而仍然采用 PascalCase 命名的子组件则报错了，因为前面我们说过：如果直接在 DOM （非字符串的模板）中，则只能使用相应的 kebab-case，否则会报错。</p><blockquote><p>注意： PascalCase 每个单词首字母都大写，而 camelCase 即驼峰式命名第一个单词首字母不大写。</p></blockquote><h2 id="4-为什么组件的-data-必须是函数？"><a href="#4-为什么组件的-data-必须是函数？" class="headerlink" title="4. 为什么组件的 data 必须是函数？"></a>4. 为什么组件的 <code>data</code> 必须是函数？</h2><p>另外还有一个需要注意的地方是，根实例的 <code>data</code> 是对象，但是组件的 <code>data</code> 却是函数。<br>这是因为组件是可复用的，每次使用一次 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 就会创建一个组件实例，如果定义组件时 <code>data</code> 依然返回的是对象，那么一个组件数据的更改将会同步影响到其它组件，因为<strong>它们共享一个 <code>data</code> 对象</strong>。如下图所示，我们只操作了一个组件，但三个组件数据都同步改变：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-6.png" alt=""></p><p>相反，如果 <code>data</code> 是函数，那么每次函数执行时都会开辟新的内存空间，创建并返回一个新的对象副本，这使得<strong>每个实例都有自己的 <code>data</code> 对象</strong>，实例互相之间不影响。如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-5.png" alt=""></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/10/03/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/" rel="prev" title="Vue 组件（二）：父子组件通信"><i class="fa fa-angle-double-left"></i>&nbspVue 组件（二）：父子组件通信</a></div><div class="post-nav-next"><a href="/2019/09/28/F-%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/" rel="next" title="用 :key 管理可复用元素">用 :key 管理可复用元素&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-组件化"><span class="toc-text">1.组件化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-创建组件"><span class="toc-text">2.创建组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-全局组件"><span class="toc-text">2.1 全局组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-局部组件"><span class="toc-text">2.2 局部组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-模板抽离"><span class="toc-text">2.3 模板抽离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-组件的命名"><span class="toc-text">3. 组件的命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-为什么组件的-data-必须是函数？"><span class="toc-text">4. 为什么组件的 data 必须是函数？</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->