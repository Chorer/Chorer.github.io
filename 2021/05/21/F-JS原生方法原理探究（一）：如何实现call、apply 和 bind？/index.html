<!-- build time:Sun Sep 05 2021 14:05:20 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">JS 原生方法原理探究（一）：如何实现 call、apply 和 bind？</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-21&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.9k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp11 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><a id="more"></a><p>这是 JS 原生方法原理探究系列的第一篇文章。本文会介绍如何实现 call、apply 和 bind 方法。关于这几个方法的具体用法，MDN 已经描述得很清楚了，这里不再赘述。</p><h2 id="手写实现-call">手写实现 call</h2><h3 id="es3-版本">ES3 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myCall</span> <span class="op">=</span> <span class="kw">function</span>(thisArg)<span class="op">{</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;The caller must be a function&#39;</span>)
    <span class="op">}</span>
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">undefined</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">null</span>)<span class="op">{</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">}</span>   
    <span class="kw">var</span> args <span class="op">=</span> []
    <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>i <span class="op">&lt;</span> <span class="va">arguments</span>.<span class="at">length</span><span class="op">;</span>i <span class="op">++</span>)<span class="op">{</span>
        <span class="va">args</span>.<span class="at">push</span>(<span class="st">&#39;arguments[&#39;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&#39;]&#39;</span>)
    <span class="op">}</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">var</span> res <span class="op">=</span> <span class="at">eval</span>(<span class="st">&#39;thisArg.fn(&#39;</span> <span class="op">+</span> args <span class="op">+</span> <span class="st">&#39;)&#39;</span>)
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">}</span></code></pre></div><h3 id="es6-版本">ES6 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myCall</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>...<span class="at">args</span>)<span class="op">{</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;The caller must be a function&#39;</span>)
    <span class="op">}</span>
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">undefined</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">null</span>)<span class="op">{</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">}</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">const</span> res <span class="op">=</span> <span class="va">thisArg</span>.<span class="at">fn</span>(...<span class="at">args</span>)
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">}</span></code></pre></div><p>通过 <code>call</code> 调用函数的时候，可以通过传给 <code>call</code> 的 thisArg 指定函数中的 this。而只要使得函数是通过 thisArg 调用的，就能实现这一点，这就是我们的主要目标。</p><h3 id="实现要点">实现要点</h3><ol style="list-style-type:decimal"><li>最终是通过函数去调用 <code>myCall</code> 的，所以 <code>myCall</code> 和 <code>call</code> 一样挂载在函数原型上。同时，也正因为是通过函数去调用 <code>myCall</code> 的，所以在 <code>myCall</code> 内部我们可以通过 this 拿到 <code>myCall</code>的调用者，也就是实际执行的那个函数。</li><li>按理说，<code>myCall</code> 是挂载在函数原型上，当我们通过一个非函数去调用 <code>myCall</code> 的时候，肯定会抛出错误，那么为什么还要在 <code>myCall</code> 中检查调用者的类型，并自定义一个错误呢？这是因为，当一个调用者 <code>obj = {}</code> 是一个对象，但是继承自 <code>Function</code> 的时候（<code>obj.__proto__ = Function.prototype</code>），它作为一个非函数实际上也是可以调用 <code>myCall</code> 方法的，这时候如果不进行类型检查以确保它是个函数，那么后面直接将它当作函数调用的时候，就会抛出错误了</li><li>传给 <code>call</code> 的 thisArg 如果是 null 或者 undefined，那么 thisArg 实际上会指向全局对象；如果 thisArg 是一个基本类型，那么可以使用 <code>Object()</code> 做一个装箱操作，将其转化为一个对象 —— 主要是为了确保后续可以以方法调用的方式去执行函数。那么可不可以写成 <code>thisArg = thisArg ? Object(thisArg) : globalThis</code> 呢？其实是不可以的，如果 thisArg 是布尔值 false，那么会导致 thisArg 最终等于 globalThis，但实际上它应该等于 <code>Boolean {false}</code>。</li><li>前面说过，可以在 <code>myCall</code> 里通过 this 拿到实际执行的那个函数，所以 <code>thisArg.fn = this</code> 相当于将这个函数作为 thisArg 的一个方法，后面我们就可以通过 thisArg 对象去调用这个函数了。</li><li><code>thisArg.fn = this</code> 相当于是给 thisArg 增加了一个 fn 属性，所以返回执行结果之前要 delete 这个属性。此外，为了避免覆盖 thisArg 上可能存在的同名属性 fn，这里也可以使用 <code>const fn = Symbol('fn')</code> 构造一个唯一属性，然后 <code>thisArg[fn] = this</code>。</li><li>ES3 版本和 ES6 版本主要的区别在于参数的传递以及函数的执行上：</li><li>ES6 因为引入了剩余参数，所以不管实际执行函数的时候传入了多少个参数，都可以通过 args 数组拿到这些参数，同时因为引入了展开运算符，所以可以展开 args 参数数组，把参数一个个传递给函数执行</li><li>但在 ES3 中没有剩余参数这个东西，所以在定义 <code>myCall</code> 的时候只接收一个 thisArg 参数，然后在函数体中通过 arguments 类数组拿到所有参数。我们需要的是 arguments 中除第一个元素（thisArg）之外的所有元素，怎么做呢？如果是 ES6，直接<code>[...arguments].slice(1)</code>就可以了，但这是 ES3，于是我们只能从索引 1 开始遍历 arguments，然后 push 到一个 args 数组中了。而且还要注意的是，这里 push 进去的是字符串形式的参数，这主要是为了方便后续通过 eval 执行函数的时候，将参数一个一个传递给函数。</li><li>为什么必须通过 eval 才能执行函数呢？因为我们不知道函数实际上要接收多少个参数，况且也用不了展开运算符，所以只能构造一个可执行的字符串表达式，显式地传入函数的所有参数。</li></ol><h2 id="手写实现-apply">手写实现 apply</h2><p>apply 的用法和 call 很类似，因此实现也很类似。需要注意的区别是，call 在接受一个 thisArg 参数之后还可以接收多个参数（即接受的是参数列表），而 apply 在接收一个 thisArg 参数之后，通常第二个参数是一个数组或者类数组对象：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">fn</span>.<span class="at">call</span>(thisArg<span class="op">,</span>arg1<span class="op">,</span>arg2<span class="op">,</span>...)
<span class="va">fn</span>.<span class="at">apply</span>(thisArg<span class="op">,</span>[arg1<span class="op">,</span>arg2<span class="op">,</span>...])        </code></pre></div><p>如果第二个参数传的是 null 或者 undefined，那么相当于是整体只传了 thisArg 参数。</p><h3 id="es3-版本-1">ES3 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myApply</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>args)<span class="op">{</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">}</span> 
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">{</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">}</span>
    <span class="cf">if</span>(args <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> args <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">{</span>
        args <span class="op">=</span> []
    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span>(<span class="op">!</span><span class="va">Array</span>.<span class="at">isArray</span>(args))<span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;CreateListFromArrayLike called on non-object&#39;</span>)
    <span class="op">}</span>
    <span class="kw">var</span> _args <span class="op">=</span> []
    <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>i <span class="op">&lt;</span> <span class="va">args</span>.<span class="at">length</span><span class="op">;</span>i <span class="op">++</span>)<span class="op">{</span>
        <span class="va">_args</span>.<span class="at">push</span>(<span class="st">&#39;args[&#39;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&#39;]&#39;</span>)
    <span class="op">}</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">var</span> res <span class="op">=</span> <span class="va">_args</span>.<span class="at">length</span> <span class="op">?</span> <span class="at">eval</span>(<span class="st">&#39;thisArg.fn(&#39;</span> <span class="op">+</span> _args <span class="op">+</span> <span class="st">&#39;)&#39;</span>):<span class="va">thisArg</span>.<span class="at">fn</span>()
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">}</span></code></pre></div><h3 id="es6-版本-1">ES6 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myApply</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>args)<span class="op">{</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> thisArg <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">}</span> 
    <span class="cf">if</span>(thisArg <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> thisArg <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">{</span>
        thisArg <span class="op">=</span> globalThis
    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
        thisArg <span class="op">=</span> <span class="at">Object</span>(thisArg)
    <span class="op">}</span>
    <span class="cf">if</span>(args <span class="op">===</span> <span class="kw">null</span> <span class="op">||</span> args <span class="op">===</span> <span class="kw">undefined</span>)<span class="op">{</span>
        args <span class="op">=</span> []
    <span class="op">}</span> 
    <span class="co">// 如果传入的不是数组，仿照 apply 抛出错误</span>
    <span class="cf">else</span> <span class="cf">if</span>(<span class="op">!</span><span class="va">Array</span>.<span class="at">isArray</span>(args))<span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;CreateListFromArrayLike called on non-object&#39;</span>)
    <span class="op">}</span>
    <span class="va">thisArg</span>.<span class="at">fn</span> <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">const</span> res <span class="op">=</span> <span class="va">thisArg</span>.<span class="at">fn</span>(...<span class="at">args</span>)
    <span class="kw">delete</span> <span class="va">thisArg</span>.<span class="at">fn</span>
    <span class="cf">return</span> res
<span class="op">}</span></code></pre></div><h3 id="实现要点-1">实现要点</h3><p>基本上和 call 的实现是差不多的，只是我们需要检查第二个参数的类型。</p><h2 id="手写实现-bind">手写实现 bind</h2><p><code>bind</code> 也可以像 <code>call</code> 和 <code>apply</code> 那样给函数绑定一个 this，但是有一些不同的要点需要注意：</p><ul><li><code>bind</code> 不是指定完 this 之后直接调用原函数，而是基于原函数返回一个内部完成了 this 绑定的新函数</li><li>原函数的参数可以分批次传递，第一批可以在调用 <code>bind</code> 的时候作为第二个参数传入，第二批可以在调用新函数的时候传入，这两批参数最终会合并在一起，一次传递给新函数去执行</li><li>新函数如果是通过 new 方式调用的，那么函数内部的 this 会指向实例，而不是当初调用 <code>bind</code> 的时候传入的 thisArg。换句话说，这种情况下的 <code>bind</code> 相当于是无效的</li></ul><h3 id="es3-版本-2">ES3 版本</h3><p>这个版本更接近 MDN 上的 polyfill 版本。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myBind</span> <span class="op">=</span> <span class="kw">function</span>(thisArg)<span class="op">{</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">}</span>
    <span class="kw">var</span> fnToBind <span class="op">=</span> <span class="kw">this</span>
    <span class="kw">var</span> args1 <span class="op">=</span> <span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">slice</span>.<span class="at">call</span>(arguments<span class="op">,</span><span class="dv">1</span>)
    <span class="kw">var</span> fnBound <span class="op">=</span> <span class="kw">function</span>()<span class="op">{</span>
        <span class="co">// 如果是通过 new 调用</span>
        <span class="cf">return</span> <span class="va">fnToBind</span>.<span class="at">apply</span>(<span class="kw">this</span> <span class="kw">instanceof</span> fnBound <span class="op">?</span> <span class="kw">this</span>:thisArg<span class="op">,</span><span class="va">args1</span>.<span class="at">concat</span>(args2))
    <span class="op">}</span>
    <span class="co">// 实例继承</span>
    <span class="kw">var</span> Fn <span class="op">=</span> <span class="kw">function</span>()<span class="op">{}</span>
    <span class="va">Fn</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">this</span>.<span class="at">prototype</span>
    <span class="va">fnBound</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">Fn</span>()
    <span class="cf">return</span> fnBound
<span class="op">}</span></code></pre></div><h3 id="es6-版本-2">ES6 版本</h3><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">myBind</span> <span class="op">=</span> <span class="kw">function</span>(thisArg<span class="op">,</span>...<span class="at">args1</span>)<span class="op">{</span>
    <span class="cf">if</span>(<span class="kw">typeof</span> <span class="kw">this</span> <span class="op">!=</span> <span class="st">&#39;function&#39;</span>)<span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;the caller must be a function&#39;</span>)
    <span class="op">}</span>
    <span class="kw">const</span> fnToBind <span class="op">=</span> <span class="kw">this</span>
    <span class="cf">return</span> <span class="kw">function</span> <span class="at">fnBound</span>(...<span class="at">args2</span>)<span class="op">{</span>
        <span class="co">// 如果是通过 new 调用的</span>
        <span class="cf">if</span>(<span class="kw">this</span> <span class="kw">instanceof</span> fnBound)<span class="op">{</span>
            <span class="cf">return</span> <span class="kw">new</span> <span class="at">fnToBind</span>(...<span class="at">args1</span><span class="op">,</span>...<span class="at">args2</span>)
        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
            <span class="cf">return</span> <span class="va">fnToBind</span>.<span class="at">apply</span>(thisArg<span class="op">,</span>[...<span class="at">args1</span><span class="op">,</span>...<span class="at">args2</span>])
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div><h3 id="实现要点-2">实现要点</h3><ol style="list-style-type:decimal"><li><p><code>bind</code> 实现内部 this 绑定，需要借助于 <code>apply</code>，这里假设我们可以直接使用 <code>apply</code> 方法</p></li><li><p>先看比较简单的 ES6 版本:</p></li><li><strong>参数获取</strong>：因为 ES6 可以使用剩余参数，所以很容易就可以获取执行原函数所需要的参数，而且也可以用展开运算符轻松合并数组。</li><li><p><strong>调用方式</strong>：前面说过，如果返回的新函数 fnBound 是通过 new 调用的，那么其内部的 this 会是 fnBound 构造函数的实例，而不是当初我们指定的 thisArg，因此 <code>this instanceof fnBound</code>会返回 true，这种情况下，相当于我们指定的 thisArg 是无效的，new 返回的新函数等价于 new 原来的旧函数，即 new fnBound 等价于 new fnToBind，所以我们返回一个 new fnToBind 即可；反之，如果 fnBound 是普通调用，则通过 apply 完成 thisArg 的绑定，再返回最终结果。从这里可以看出，bind 的 this 绑定，本质上是通过 apply 完成的。</p></li><li><p>再来看比较麻烦一点的 ES3 版本：</p></li><li><p><strong>参数获取</strong>：现在我们用不了剩余参数了，所以只能在函数体内部通过 arguments 获取所有参数。对于 <code>myBind</code>，我们实际上需要的是除开第一个传入的 thisArg 参数之外的剩余所有参数构成的数组，所以这里可以通过 <code>Array.prototype.slice.call</code> 借用数组的 slice 方法（arguments 是类数组，无法直接调用 slice），这里的借用有两个目的：一是除去 arguments 中的第一个参数，二是将除去第一个参数之后的 arguments 转化为数组（slice 本身的返回值就是一个数组，这也是类数组转化为数组的一种常用方法）。同样地，返回的新函数 fnBound 后面调用的时候也可能传入参数，再次借用 slice 将 arguments 转化为数组</p></li><li><p><strong>调用方式</strong>：同样，这里也要判断 fnBound 是 new 调用还是普通调用。在 ES6 版本的实现中，如果是 new 调用 fnBound，那么直接返回 <code>new fnToBind()</code>，这实际上是最简单也最容易理解的方式，我们在访问实例属性的时候，天然就是按照 <code>实例 =&gt; 实例.__proto__ = fnToBind.prototype</code> 这样的原型链来寻找的，可以确保实例成功访问其构造函数 fnToBInd 的原型上面的属性；但在 ES3 的实现中（或者在网上部分 bind 方法的实现中），我们的做法是返回一个 <code>fnToBind.apply(this)</code>，实际上相当于返回一个 undefined 的函数执行结果，根据 new 的原理，我们没有在构造函数中自定义一个返回对象，因此 new 的结果就是返回实例本身，这点是不受影响的。这个返回语句的问题在于，它的作用仅仅只是确保 fnToBind 中的 this 指向 new fnBound 之后返回的实例，而并没有确保这个实例可以访问 fnToBind 的原型上面的属性。实际上，它确实不能访问，因为它的构造函数是 fnBound 而不是 fnToBind，所以我们要想办法在 fnBound 和 fnToBind 之间建立一个原型链关系。这里有几种我们可能会使用的方法：</p><p><code>js // 这里的 this 指的是 fnToBind fnBound.prototype = this.prototype</code></p><p>这样只是拷贝了原型引用，如果修改 <code>fnBound.prototype</code>，则会影响到 <code>fnToBind.prototype</code>，所以不能用这种方法</p><p><code>js // this 指的是 fnToBind fnBound.prototype = Object.create(this.prototype)</code></p><p>通过 <code>Object.create</code> 可以创建一个 <code>__proto__</code> 指向 <code>this.prototype</code> 的实例对象，之后再让 <code>fnBound.prototype</code> 指向这个对象，则可以在 fnToBind 和 fnBound 之间建立原型关系。但由于 <code>Object.create</code> 是 ES6 的方法，所以无法在我们的 ES3 代码中使用。</p><p><code>js // this 指的是 fnToBind const Fn = function(){} Fn.prototype = this.prototype fnBound.prototype = new Fn()</code></p><p>这是上面代码采用的方法：通过空构造函数 Fn 在 fnToBind 和 fnBound 之间建立了一个联系。如果要通过实例去访问 fnToBind 的原型上面的属性，可以沿着如下原型链查找：</p><p><code>实例 =&gt; 实例.__proto__ = fnBound.prototype = new Fn() =&gt; new Fn().__proto__ = Fn.prototype = fnToBind.prototype</code></p></li></ol><p>​</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2021/05/25/F-%E4%BD%A0%E7%9A%84%E6%89%8B%E5%86%99new%E5%AE%9E%E7%8E%B0%E8%B6%B3%E5%A4%9F%E4%B8%A5%E8%B0%A8%E5%90%97%EF%BC%9F/" rel="prev" title="你的手写 new 实现足够严谨吗？"><i class="fa fa-angle-double-left"></i>&nbsp你的手写 new 实现足够严谨吗？</a></div><div class="post-nav-next"><a href="/2021/05/09/Trs-1984%20%E5%B9%B4%E7%9A%84%E8%8B%B9%E6%9E%9C%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%91%A2%EF%BC%9F/" rel="next" title="「译」1984 年的苹果麦金塔电脑长什么样呢？">「译」1984 年的苹果麦金塔电脑长什么样呢？&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0-call"><span class="toc-text">手写实现 call</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#es3-%E7%89%88%E6%9C%AC"><span class="toc-text">ES3 版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6-%E7%89%88%E6%9C%AC"><span class="toc-text">ES6 版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9"><span class="toc-text">实现要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0-apply"><span class="toc-text">手写实现 apply</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#es3-%E7%89%88%E6%9C%AC-1"><span class="toc-text">ES3 版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6-%E7%89%88%E6%9C%AC-1"><span class="toc-text">ES6 版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9-1"><span class="toc-text">实现要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0-bind"><span class="toc-text">手写实现 bind</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#es3-%E7%89%88%E6%9C%AC-2"><span class="toc-text">ES3 版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6-%E7%89%88%E6%9C%AC-2"><span class="toc-text">ES6 版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A6%81%E7%82%B9-2"><span class="toc-text">实现要点</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->