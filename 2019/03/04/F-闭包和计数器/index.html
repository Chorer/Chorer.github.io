<!-- build time:Tue Mar 26 2019 12:08:38 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Chor&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="icon" href="/images/NARUTO.gif"><link rel="stylesheet" href="/css/prism-coy.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-coy.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="header"><span><i class="point"></i> <a href="https://github.com/Chorer/hexo-theme-PureBlue/tree/master/PureBlue">PureBlue</a></span><div class="blog-title"><a href="/" class="logo">Chor&#39;s Blog</a></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link">Home</a></li><li class="menu-item"><a href="/categories" class="menu-item-link">Categories</a></li><li class="menu-item"><a href="/archives" class="menu-item-link">Archives</a></li><li class="menu-item"><a href="/tags" class="menu-item-link">Tags</a></li><li class="menu-item"><a href="/about" class="menu-item-link">About</a></li></ul></nav></header><main class="main"><section class="posts"><article class="post"><div class="post-title"><a class="post-title-link" href="/2019/03/04/F-闭包和计数器/">闭包和计数器</a></div><div class="post-time"><span class="time-text">Date:&nbsp </span><span class="time">2019-03-04</span></div><div class="post-content"><p>之前想不通的一道题—–主要是不知道思路怎么来的，为何会想到用闭包。本来打算就将原博客转载过来，但是刚刚重新审视这道题的时候，好像看到了以前没有发现的东西，有种恍然大悟的感觉，所以决定用自己的话来解释这道题的思路。<br><a id="more"></a></p><p>假如我们想制作一个计数器，每点击一次就加一，代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把计数器counter设置成全局变量</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">return</span> counter<span class="token operator">+</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//此时counter=3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;&gt;</code>固然可以实现功能，但问题就在于其他语句也有可能会改动到counter，这样的计数器是不安全的。</p><p>如果把counter改为外部访问不到的局部变量呢？</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">var</span> counter<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
counter<span class="token operator">+</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;&gt;</code>固然保证了counter不会被其他语句影响到，但问题就在于每次调用函数都会重置counter，无法实现计数功能。</p><p>所以我们需要的counter应该满足：1.不会被重置；2.在函数内部</p><p>第2点容易满足，但是由上面的例子我们知道，如果单纯把counter写在一个函数里，则每次调用都会重置，所以我们定义这样一个嵌套函数：将counter放在父函数里，子函数作为操作counter的函数，每次我们只调用子函数。<br>但是，全局作用域是无法访问嵌套函数中的子函数的，所以我们必须将子函数作为闭包返回出来，使其暴露在全局作用域下。依照这个想法，代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> add <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//counter为1</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//counter为1</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//counter为1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;&gt;</code>意思是把add函数（父函数）执行后返回的函数（子函数）执行一次（注意这里是两次执行）。但这样的问题在于：每次调用add()()时依然执行了一次父函数，结果就是依然重置了counter。</p><p>那么有没有办法让父函数只执行一次，仅在那一次初始化counter，之后每次都只通过执行子函数来操作counter呢？<br>可以用自执行函数来解决这个问题—–也就是通过自执行函数（而不是通过add()）来调用父函数，在这一次调用初始化counter，之后将返回的子函数赋给add，通过调用add()来操作counter。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">//这里add已经是父函数的执行结果了，即add已经是返回的那个子函数了</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来就是闭包的知识了：<br>在每次调用闭包add——-即<code>function(){return(++counter)</code>时，由于add中存在自由变量counter，所以它必须到定义该函数时所在的那个作用域中去寻找该变量，也就是到父函数中去寻找。恰好父函数中有一个为0的counter可以被引用，所以这时候完成加一操作，counter变成1。注意，接下来我们尝试调用了console.log(counter)，但是输出的是undefined，这说明了即使add函数执行后返回了值为1的counter，但是该返回值并不是返回到全局作用域中（不然不会输出undefined），而是覆盖了父函数中原来定义的counter，使counter变为1；第二次调用add函数依然同上，只是此时引用counter时，引用的是为1的counter，加1后变为2；同理第三次，引用的是为2的counter，加1后变为3。<br><br><br>基于这道题，我们不难看出使用闭包函数的好处：</p><p>1、<span style="background-color:#fffa7d">缓存</span>：<br>最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量作为相对于闭包函数的自由变量，在闭包函数里直接使用它。因此该自由变量只初始化一次，但却可以通过多次调用闭包函数来使用。这比起我们直接在闭包函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是上面例子中的—–实现计数功能。</p><p>2、<span style="background-color:#fffa7d">实现封装</span>：<br>自由变量只能被闭包函数本身或者其子函数访问，而不能被闭包函数之外的函数访问。这就实现了面向对象的封装性，更安全更可靠。</p><p>参考：<br><a href="http://www.cnblogs.com/haidaojiege/p/7070560.html" target="_blank" rel="noopener">http://www.cnblogs.com/haidaojiege/p/7070560.html</a><br><a href="https://www.cnblogs.com/leoin2012/p/3978979.html" target="_blank" rel="noopener">https://www.cnblogs.com/leoin2012/p/3978979.html</a></p></div></article><span class="top"><a class="to-top"><svg><path d="M9.314 0l9.313 9.314-2.12 2.121-7.193-7.192-7.193 7.192L0 9.314z"/></svg></a></span><div id="vcomments"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script><div class="leancloud"><span id="{{ page.url }}" class="leancloud-visitors" data-flag-title="{{ page.title }}">Visited: <a href="#"><span class="leancloud-visitors-count"></span>次</a></span></div><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("fXt4w0eF2SsymyYU8UQEkcwM-gzGzoHsz","IrB7QLSJQWyGP9T3GL7rNsud")</script><script>function addCount(e){var t=$(".leancloud_visitors"),o=t.attr("id").trim(),s=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("post_url",o),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("visited_times"),i.save(null,{success:function(e){var t=$(document.getElementById(o)),s=e.get("visited_times");t.find(".leancloud-visitors-count").text(s)},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new e,r=new AV.ACL;r.setPublicReadAccess(!0),r.setPublicWriteAccess(!0),n.setACL(r),n.set("post_title",s),n.set("post_url",o),n.set("visited_times",1),n.save(null,{success:function(e){var t=$(document.getElementById(o)),s=e.get("visited_times");t.find(".leancloud-visitors-count").text(s)},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}function showCount(e){var t=$(".leancloud_visitors"),o=t.attr("id").trim(),s=(t.attr("data-flag-title").trim(),new AV.Query(e));s.equalTo("post_url",o),s.find({success:function(e){if(e.length>0){var t=e[0],s=$(document.getElementById(o)),i=t.get("visited_times");s.find(".leancloud-visitors-count").text(i)}else console.log("异常情况，不应该没记录的")},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}function getVisitorIpAndJudge(){var e,t={type:"POST",dataType:"json",url:"https://freegeoip.net/json/?callback=?"};$.ajax(t).done(function(t,o,s){"success"==o&&(e=t.ip),judgeVisitor(e)})}function judgeVisitor(e){var t=AV.Object.extend("visited_times"),o=AV.Object.extend("visitors_record"),s=$(".leancloud_visitors"),i=s.attr("id").trim(),n=new AV.Query(o);n.equalTo("visitor_ip",e),n.equalTo("post_url",i),n.find({success:function(s){if(s.length>0){console.log("该IP已访问过该文章");var n=s[0],r=n.updatedAt,c=new Date,l=c.getTime()-r.getTime();l>6e4?(console.log("距离该IP上一次访问该文章已超过了1分钟，更新访问记录，并增加访问次数"),addCount(t),n.fetchWhenSave(!0),n.save(null,{success:function(e){},error:function(e,t){console.log("Failed to save visitor record, with error message: "+t.message)}})):(console.log("这是该IP 1分钟内重复访问该文章，不更新访问记录，不增加访问次数"),showCount(t))}else{console.log("该IP第一次访问该文章，保存新的访问记录，并增加访问次数"),addCount(t);var u=new o,a=new AV.ACL;a.setPublicReadAccess(!0),a.setPublicWriteAccess(!0),u.setACL(a),u.set("visitor_ip",e),u.set("post_url",i),u.save(null,{success:function(e){},error:function(e,t){console.log("Failed to create visitor record, with error message: "+t.message)}})}},error:function(e){console.log("Error:"+e.code+" "+e.message),addCount(t)}})}$(function(){1==$(".leancloud_visitors").length?getVisitorIpAndJudge():$(".post-link").length>1})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 Chor's Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue/tree/master/PureBlue">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/jquery.toTop.js"></script><script src="/js/tagscloud.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:150,height:300,vOffset:-120,hOffset:-5},mobile:{show:!1},react:{opacityDefault:1e3,opacityOnHover:1e3},log:!1})</script></body></html><!-- rebuild by neat -->