<!-- build time:Fri Apr 17 2020 19:51:33 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">编译原理学习笔记-3：词法分析(一)基本过程、正规式和有限自动机</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-04-11&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp6.8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp25 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1.jpg" alt=""></p><a id="more"></a><blockquote><p>编译有五大步骤，本篇笔记将会讲解编译的第一步：词法分析。</p></blockquote><p>词法分析的任务是：从左往右逐个字符地扫描源程序，产生一个个的单词符号。也就是说，它会对输入的字符流进行处理，再输出单词流。执行词法分析的程序即<strong>词法分析器</strong>，或者说扫描器。</p><h2 id="1-词法分析的成果"><a href="#1-词法分析的成果" class="headerlink" title="1.词法分析的成果"></a>1.词法分析的成果</h2><p>词法分析的成果就是由一系列单词符号构成的单词流。单词符号其实就是 token，一般有以下五大类：</p><ul><li>关键字：例如 <code>while</code>，<code>if</code>，<code>int</code> 等</li><li>标识符：变量名、常量名、函数名等</li><li>常数：例如，<code>100</code>，<code>&#39;text&#39;</code>，<code>TRUE</code> 等</li><li>运算符：例如 <code>+</code>，<code>*</code>，<code>/</code> 等</li><li>界符：逗号，分号，括号，点等</li></ul><p>具体来说，一个单词符号在形式上是这样的一个二元式：<code>（单词种别，单词符号的属性值）</code>。</p><p><strong>单词种别：</strong></p><p>单词种别通常用整数编码。一个语言的单词符号如何分种，分成几种，怎样编码是一个技术问题。它取决于处理上的方便。</p><ul><li><p>标识符一般统归为一种。比如说变量 <code>a</code> 和 <code>b</code>，可能我们都只用 <code>1</code> 作为它们的单词种别。</p></li><li><p>常数则宜按类型（整、实、布尔等）分种，比如说整数可能用 <code>2</code> 表示，布尔值可能用 <code>3</code> 表示。</p></li><li><p>关键字可以把全体视为一种，也可以一字一种。</p></li><li><p>运算符可以把具有一定共性的运算符视为一种，也可以一符一种。</p></li><li><p>界符一般是一符一种。</p></li></ul><p><strong>单词符号的属性值</strong></p><p>由上面的单词种别可以知道，关键字、运算符、界符基本都是一字（或者一符）对应一个种别，所以只依靠单词种别即可确切地判断出具体是哪一种单词符号了。但是标识符和常数却不是这样，一个种别可能对应好几个单词符号。所以我们需要借助单词符号的属性值<strong>做进一步的区分</strong>。</p><p>对于标识符类型的单词符号，它的属性值通常是一个指针，这个指针指向符号表的某个表项，这个表项包含了该单词符号的相关信息；对于常数类型的单词符号，它的属性值也是一个指针，这个指针指向常数表的某个表项，这个表项包含了该单词符号的相关信息。</p><p>以 <code>while(i&gt;=j)i++</code> 为例，它的单词符号流大概如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token keyword">while</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token operator">></span>
<span class="token operator">&lt;</span>id<span class="token punctuation">,</span>pointer1<span class="token operator">></span>  
<span class="token operator">&lt;</span><span class="token operator">>=</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token operator">></span>  
<span class="token operator">&lt;</span>id<span class="token punctuation">,</span>pointer2<span class="token operator">></span>  
<span class="token operator">&lt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token operator">></span>  
<span class="token operator">&lt;</span>id<span class="token punctuation">,</span>pointer3<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">++</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token operator">></span>    
<span class="token operator">&lt;</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token operator">></span>    
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：实际上，对于关键字、界符这些，应该用整数表示单词种别，不过这里为了便于区分，直接用对应的单词符号表示了。对于标识符，由于 id 这个单词种别可能对应多个标识符，所以可以看到我们用不同的指针进行了标识。其它不需要标识的，则统一用短横线代替。</p><h2 id="2-词法分析的要点"><a href="#2-词法分析的要点" class="headerlink" title="2. 词法分析的要点"></a>2. 词法分析的要点</h2><h3 id="2-1-是否作为一趟？"><a href="#2-1-是否作为一趟？" class="headerlink" title="2.1 是否作为一趟？"></a>2.1 是否作为一趟？</h3><p>按照我们常规的想法，应该是词法分析器扫描整个源程序，产生单词流，之后再由语法分析器分析生成的单词。如果是这样，那么就说词法分析器独立负责了一趟的扫描。但其实，更多的时候我们认为词法分析器并不负责独立的一趟，而是作为语法分析器的子程序被调用。也就是说，一上来就准备对源程序进行语法分析，但是语法分析无法处理字符流，所以它又回过头调用了词法分析器，将字符流转化成单词流，再去分析它的语法。以此类推，后面每次遇到字符串流，都是这样的一个过程。</p><h3 id="2-2-输入和预处理"><a href="#2-2-输入和预处理" class="headerlink" title="2.2 输入和预处理"></a>2.2 输入和预处理</h3><p>字符流输入后首先到达<strong>输入缓冲区</strong>，在词法分析器正式对它进行扫描之前，还得先做一些预处理的工作。预处理子程序会对<strong>一定长度</strong>的字符流进行处理，包括去除注释、合并多个空白符、处理回车符和换行符等。处理完之后再把这部分字符流送到<strong>扫描缓冲区</strong>。此时，词法分析器才正式开始拆分字符流的工作。</p><p>词法分析器对扫描缓冲区进行扫描时一般使用两个指示器：<strong>起点指示器</strong>指向当前正在识别单词的开始位置，<strong>搜索指示器</strong>用于向前搜索以寻找单词的终点。问题在于，就算缓冲区再大，也难保不会出现突破缓冲区长度的单词符号。也就是说，输入缓冲区把处理好的一段字符流送到扫描缓冲区时，扫描缓冲区可能装不下这段字符流，在这种情况下，如果依然只用一个缓冲区存放字符流，可能会导致某个过长的单词符号无法被正确读取。因此，扫描缓冲区最好使用如下一分为二的区域：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-7.png" style="zoom:67%"></p><p>这样，在搜索指示器向前搜索到 A 半区边缘时，如果发现还没有找到单词符号的终点，那么就会调用预处理程序把剩下的部分送到 B 半区，搜索指示器再来到 B 半区扫描。这样就可以避免截断，从而将这个过长的单词符号顺利衔接起来。如果单词符号实在太长，两个半区都无法解决，那就没辙了。所以应该对单词符号的长度加以限制。</p><h3 id="2-3-超前扫描"><a href="#2-3-超前扫描" class="headerlink" title="2.3 超前扫描"></a>2.3 超前扫描</h3><p>像 FORTRAN 这样的语言，关键字不加保护（只要不引起矛盾，用户可以用它们作为普通标识符），关键字和用户自定义的标识符或标号之间没有特殊的界符作间隔。这使得关键字的识别变得很麻烦。比如 <code>DO99K=1,10</code> 和 <code>DO99K=1.10</code>。前者的意思是，K 从 1 变到 10 之后，跳转到第 99 行执行；后者的意思是，为变量 DO99K 赋值 1.10。问题在于，我们并不能在扫描到 <code>DO</code> 的时候就肯定这是一个关键字，事实上，它既有可能是关键字，也有可能作为标识符的一部分。而具体是哪一种，只有在我们扫描到 <code>=1</code> 后面才能确定 —— 如果后面是逗号，则这是关键字，如果是点号，则是标识符的一部分。</p><p>也就是说，我们需要<strong>超前扫描</strong>到达第一个界符 <code>=</code>，但是 <code>=</code> 还不能确定，再<strong>继续超前扫描</strong>到达第二个界符（逗号或者点号），这时候才能完全确定。</p><h2 id="3-词法分析的模型"><a href="#3-词法分析的模型" class="headerlink" title="3. 词法分析的模型"></a>3. 词法分析的模型</h2><h3 id="3-1-状态转换图"><a href="#3-1-状态转换图" class="headerlink" title="3.1 状态转换图"></a>3.1 状态转换图</h3><p>状态转换图是设计词法分析程序的一种模型，我们可以借助这个模型体会<strong>识别某个特定字符串</strong>的过程。它是一张有限方向图，结点表示状态，结点之间的箭弧上有字符，表示遇到该字符就将其读进来，并且转换到另一个状态。以下面这张图为例，在状态 0 下如果输入的是字母，则将字母读进来，并进入状态 1 ；在状态 1 下如果输入的是字母或者数字，则将其读进来并重新进入状态 1 。不断重复，直到输入的不是字母和数字，这时候也<strong>将其读进来</strong>，并进入状态 2。状态 2 是终态，有一个 <code>*</code> 作为标记，标记着多读进来一个不属于目标的符号，应该把它退还给原输入串。这张图实际表示的是标识符类型的输入串。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-3.png" style="zoom:50%"></p><p>状态转换图的结点（状态）个数是有限的，其中有一个初态，以及至少一个终态（同心圆表示）。</p><p>左图是 FORTRAN 语言的一些单词符号，右图是对应的状态转换图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-8.png" alt=""></p><p><strong>状态转换图的实现：</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-5.png" style="zoom:67%"></p><p>比如上面的状态转换图，它的词法分析器大概如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-9.png" alt=""></p><h3 id="3-2-正规式与有限自动机"><a href="#3-2-正规式与有限自动机" class="headerlink" title="3.2 正规式与有限自动机"></a>3.2 正规式与有限自动机</h3><p>状态转换图是制造词法分析器的模型，不过这个模型过于具体，我们应该想个办法，用一种<strong>更接近数学的、更为形式化</strong>的方法来表示状态转换图。而这种状态转化图的形式化表达，就是<strong>有限自动机</strong>。由于有限自动机涉及到了正规式、正规集等其它概念，所以我们这里先普及一下这些概念。</p><h4 id="①-正规式与正规集"><a href="#①-正规式与正规集" class="headerlink" title="① 正规式与正规集"></a>① 正规式与正规集</h4><p><strong>推导</strong></p><p>正规式和正规集都是相对于字母表来说的概念，通常说“xx 字母表的正规式是……，字母表的正规集是……”。对于正规式和正规集，我们采用<strong>递归</strong>的方式进行定义。即，对于某个给定的字母表 <code>∑</code>，规定：</p><ul><li><code>ε</code> 和 <code>Ø</code> 都是该字母表的正规式，这两个正规式分别表示了 <code>{ε}</code> 和 <code>Ø</code> 这两个正规集</li><li>字母表上的任意一个元素 <code>a</code> 都是字母表的正规式，它表示了 <code>{a}</code> 这个正规集</li><li>如果 <code>a</code> 和 <code>b</code> 都是字母表上的正规式，且分别表示了 <code>L(a)</code> 和 <code>L(b)</code> 这两个正规集。那么，<code>(a|b)</code>，<code>(ab)</code>，<code>(a)*</code> 也都是正规式，它们分别代表了 <code>L(a)∪L(b)</code>，<code>L(a)L(b)</code> 和 <code>(L(a))*</code> 这几个正规集。（笛卡尔积和闭包）</li><li>仅由有限次使用上面三条规则而得到的表达式才是字母表上的正规式，仅由这些正规式表示的字集才是字母表上的正规集</li></ul><p>根据上面这四条规则，我们可以递归列举出某个字母表的正规式和对应的正规集</p><p>例如对于给定的字母表 <code>∑ = {a,b}</code>，我们可以像下面这样推导出它的正规式和对应的正规集：</p><p><code>ba*</code> ：<code>a</code> 是正规式，所以 <code>a*</code> 也是正规式（规则二），所以 <code>ba*</code> 也是正规式（规则二）。<code>a</code> 表示 <code>{a}</code> 这个集合，加上星号则表示该集合的闭包，<code>b</code> 表示 <code>{b}</code> 这个集合，所以并排放在一起表示两个集合作笛卡尔积运算</p><p><strong>等价的正规式</strong></p><p>如果两个正规式 <code>U</code> 和 <code>V</code> 表示的正规集相同，则认为这两个正规式等价，记作 <code>U = V</code>。例如，<code>b(ab)*</code> 和 <code>(ba)*b</code> 就是等价的两个正规式。它们表示的集合形如 <code>{ba,bb,bab,babab,babababab,......}</code>。可以看出这个集合的元素特点是，以 <code>b</code> 开头，后面跟着 a 和 b 自由组合的符号串。在没有引入正规式的概念之前，要表示这样的集合是比较麻烦的，但现在则方便很多。</p><p><strong>正规式运算规则</strong></p><p>对于正规式 <code>U</code>，<code>V</code>，<code>W</code>，它们满足下面的运算规律：</p><p>1、交换律：U|V＝V|U</p><p>2、结合律：U|(V|W)＝(U|V)|W</p><p>3、结合律：(UV)W=U(VW)</p><p>4、分配律：U(V|W) = UV|UW</p><p>5、分配律： (V|W)U = VU|WU</p><p>6、零一律：εU=U</p><p>7、零一律：Uε=U</p><p>最后再来看一道题：</p><blockquote><p>令 ∑＝｛d，. ，e，＋，－｝，其中d为 0～9 中的数字，则 ∑ 上的正规式</p><p><code>d*(.dd*|ε)(e(+|-|ε)dd*|ε)</code>表示的是？</p></blockquote><p>先来划分结构，以 <code>d*</code> 开头，说明第一个部分是一个整数，第二个部分是 <code>(.dd*|ε)</code>，可以取空，第三个部分是 <code>(e(+|-|ε)dd*|ε)</code>，同样可以取空。如果后面两个部分都取空，则肯定代表一个整数；如果第二个部分不取空，则会出现小数点，表明这时候会是一个小数；如果第三个部分不取空，则会出现 <code>e</code>，表明这是一个用科学计数法表示的数字。综上，这个正规式表示的是所有无符号数构成的集合。</p><p>有个需要注意的地方是，<code>d*</code> 已经可以表示所有整数了，为什么小数点后使用的是 <code>dd*</code> 而不是 <code>d*</code> 呢？这里其实是起到一个占位的作用，因为单纯用 <code>d*</code> 的话，其实也包括了空符号串，但是既然出现了小数点，后面至少要跟一位数，不能为空。所以这里用 <code>dd*</code>。对于 <code>e</code> 后面也是同理，既然出现了 <code>e</code>，后面就不能为空了。</p><h4 id="②-确定有限自动机"><a href="#②-确定有限自动机" class="headerlink" title="② 确定有限自动机"></a>② 确定有限自动机</h4><p><strong>1. 确定有限自动机的结构</strong></p><p>我们先来回顾一下这副状态转换图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-8.png" alt=""></p><p>考虑到要用形式化的方法来表示它，我们得先考虑转换图的一些重要组成因素。</p><ul><li>首先想到的是，必须得有一个集合用来保存所有的状态</li><li>还需要有一个集合用来保存所有的输入字符</li><li>在某一个状态下，根据输入的字符不同，会跳转到不同的状态，这三者构成一个联系，多个联系自然也需要保存起来</li><li>初态是特殊的，需要单独保存</li><li>终态也是特殊的，需要单独保存</li></ul><p>那么，我们可以构造一个有限的状态集合 S ，用以保存该转换图的所有状态；构造一个有限的字母集合 ∑，用以保存每一个输入的字符；构造包括多个<strong>单值映射对</strong> 的 δ，每一对都表示从“当前状态和输入字符”到“跳转状态”的映射关系。具体地说，用 <code>δ(s,a) = a&#39;</code> 表示，当前状态为 <code>s</code> 且输入字符为 <code>a</code> 时，跳转到状态 <code>a&#39;</code>；此外，需要用来自于状态集合 S 的 s0 作为唯一的初态；最后，构造一个终态集合 F，它是 S 的子集，可取空。</p><p>这样，我们就有了 S，∑，δ，s0，F。这五个元素在一起就构成了我们要讲的是<strong>确定有限自动机</strong>。即，确定有限自动机 DFA 可用如下的五元式表示：</p><blockquote><p>M = {S，∑，δ，s0，F}</p></blockquote><p><strong>2. 确定有限自动机的其它表示</strong></p><p>正如我们所说的，有限自动机是抽象层面上的形式化表达，而它在具体层面上的表达就是之前所讲的状态转换图。另外，确定有限自动机还可以用一个矩阵来表示，这样的矩阵即 <strong>状态转换矩阵</strong>。它的行表示当前状态，列表示输入字符，而矩阵元素则表示跳转状态，也就是 <code>δ(s,a)</code> 的值。</p><p>以 <code>DFA M = （{0，1，2，3，4}，{a,b}，δ，0，{3}）</code> 为例，如果它的映射如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span>

<span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span>  <span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span>

<span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span>

<span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span>  <span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么它的状态转换矩阵如下所示：</p><table><thead><tr><th style="text-align:center">当前状态</th><th style="text-align:center">a</th><th style="text-align:center">b</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr></tbody></table><p><strong>3. 确定有限自动机的作用</strong></p><p>确定有限自动机是状态转换图的形式化表达，它可以用于识别（或者说读出、接受）<strong>正规集</strong>。</p><blockquote><p>对于 ∑* 中的任何一个字 a，若存在一条从初态结点到某一终态结点的通路，且这条通路上所有箭弧的标记符连接成的字等于 a，则称 a 为 DFA M 所识别（读出或接受）。</p></blockquote><p>如果 M 的初态结点同时也是终态结点，那么就说空符号串可以被 M 所识别。</p><p>DFA M 可以识别的字的全体记为 L(M)。</p><p>看下面的例子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-10.png" style="zoom:50%"></p><p>这是某个确定有限自动机对应的状态转换图，那么这个 DFA M 可以识别什么样的正规集呢？我们可以先走几条路线看看（假定在遇到状态 3 就停止），不难发现它可以识别出诸如 <code>aa</code>，<code>bb</code>，<code>abb</code>，<code>baa</code> 这样的符号串。这样的符号串的特点是，中间要么是 <code>aa</code> ，要么是 <code>bb</code>，所以首先确定中间是 <code>(aa|bb)</code>。由于 <code>aa</code> 和 <code>bb</code> 都可以独立存在，说明 <code>(aa|bb)</code>的前面和后面必须可以是空符号串，说到空符号串，我们会想到闭包，所以它的前面后面必定会分别出现一个闭包。考虑前面，可以出现 <code>a</code> 或者 <code>b</code>，所以前面应该是 <code>(a|b)*</code>；考虑后面，我们在遇到状态 3 的时候就停止了，但实际上，在这之后遇到 <code>a</code> 或者 <code>b</code>，状态变化会循环往复，也就是说，不管遇到什么样的 <code>ab</code> 组合符号串，都能够被识别并循环转换到状态 3，这里说明后面的状态是任意的，所以确定后面是 <code>(a|b)*</code>。</p><p>结合起来，这个有限自动机可以识别的正规集可以用正规式 <code>(a|b)*(aa|bb)(a|b)*</code> 表示。</p><h4 id="③-非确定有限自动机"><a href="#③-非确定有限自动机" class="headerlink" title="③ 非确定有限自动机"></a>③ 非确定有限自动机</h4><p><strong>1. “确定”和“不确定”指的是什么？</strong></p><p>“确定”指的是，五元式中的映射是一个单值函数，也就是说，在当前状态下，面对某个输入字符，<strong>其跳转状态是唯一确定的</strong>，即只会跳转到某一个值。但是，有的时候映射是多值函数，也就是说，在某个输入字符下<strong>有多个跳转状态可供选择</strong>。具有这样特点的有限自动机，就叫做<strong>非确定有限自动机</strong>。</p><p><strong>2. 非确定有限自动机的结构</strong></p><p>非确定有限自动机可以用如下的五元式表示：</p><blockquote><p>M = {S，∑，δ，s0，F}</p></blockquote><ul><li>S 仍然是状态集合，∑ 仍然是输入字符集合，F 仍然是终态集合。</li><li>但是，s0 不再表示单个初态，而是表示一个非空的初态集合</li><li>另外，正如前面所说的，δ 不再是一个从“当前状态和输入字符”到“跳转状态”的单值映射，而是从<strong>“当前状态和输入字符集合闭包”</strong>到<strong>“跳转状态集合”</strong>的子集映射。简单地说就是，它接受的不一定是单个字符，且在单一输入下可以跳转到多个状态</li></ul><p><strong>3. 非确定有限自动机的作用</strong></p><p>非确定有限自动机同样可以用于识别（或者说读出、接受）<strong>正规集</strong>。</p><blockquote><p>对于 ∑* 中的任何一个字 a，若存在一条从初态结点到某一终态结点的通路，且这条通路上所有箭弧的标记符连接成的字等于 a，则称 a 为 NFA M 所识别（读出或接受）。</p></blockquote><p>如果 M 的初态结点同时也是终态结点，或者<strong>存在一条从某个初态结点到某个终态结点的 ε 通路</strong>，那么就说空符号串 ε 可以被 M 所识别。（因为输入符号来自于集合闭包，所以输入符号接受空符号串 ε）</p><p>看下面的例子：</p><p>假设有非确定有限自动机 <code>NFA M＝({0,1,2,3,4},{a,b},δ,{0},{2,4})</code>，其中，</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>    <span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span>

<span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span>    <span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span>

<span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span>      <span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span>

<span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span>      <span class="token function">δ</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，有不少 δ 是被映射到 S 的一个子集，而不是像确定 DFA 那样映射到一个输入字符。这个 NFA 对应的状态转换图如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-11.png" style="zoom:50%"></p><p>这里会发现，这个 NFA 所能识别的正规集和之前的 DFA 是一样的，都是含有相继两个 a 或者相继两个 b 的符号串。事实上，尽管 DFA 是 NFA 的特例，但是对于每个 NFA M，都会有一个 DFA M‘ 与之对应，使得 <code>L(M) = L(M&#39;)</code>。这时候，我们就说 NFA M 等价于 DFA M’。</p><h4 id="③-非确定有限自动机的确定化"><a href="#③-非确定有限自动机的确定化" class="headerlink" title="③ 非确定有限自动机的确定化"></a>③ 非确定有限自动机的确定化</h4><p>非确定有限自动机的确定化，指的就是将非确定有限自动机转换为一个<strong>与之等价</strong>的确定有限自动机。总的来说分为两步，第一步是利用等价转换规则细化 NFA 状态转换的过程；第二步是利用子集法对第一步转化得到的 NFA 进行确定化。由于第二步又涉及到了一些概念，所以这里我们先来对这些概念进行解释。</p><h5 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h5><p><strong>（1）空闭包集合</strong></p><p>若 <code>I</code> 是一个状态集合的子集，那么 <code>I</code> 会有一个空闭包集合，记作 <code>ε-closure(I)</code>。这个空闭包集合同样是一个状态集合，它的元素符合以下几点：</p><ul><li><code>I</code> 的所有元素都是空闭包集合的元素</li><li>对于 <code>I</code> 中的每一个元素，从该元素出发经过任意条 ε 弧能够到达的状态，都是空闭包集合的元素</li></ul><p>以下面这张图为例：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-12.png" style="zoom:50%"></p><p><code>ε-closure({5,3,4})</code> 会等于多少呢？这里的 <code>I</code> 是 <code>{5,3,4}</code>，所以空闭包集合一定包含了5，3，4。从 5 出发，经过一条 ε 弧到达 6，两条 ε 弧到达 2，所以 6 和 2 也是闭包集合的元素；从 3 出发，经过一条 ε 弧到达 8，所以 8 也是；从 4 出发，经过一条 ε 弧 7，所以 7 也是。综上，<code>ε-closure({5,3,4}) = {5，3，4，6，2，8，7}</code> 。</p><p><strong>（2）<code>Ia</code></strong></p><p>若 <code>I</code> 是一个状态集合的子集，那么它相对于状态 <code>a</code> 的 <code>Ia</code> 等于 <code>ε-closure(J)</code>。其中，<code>J</code> 表示的是，从 <code>I</code> 中每个状态出发，<strong>经过标记为 a 的单条弧而到达的状态</strong>的集合。也就是说，<code>Ia</code> 表示的是从 <code>I</code> 中每个状态出发，经过标记为 a 的弧而到达的状态，再加上从这些状态出发，经过任意条 ε 弧能够到达的状态。</p><p>还是以这幅图为例：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-12.png" style="zoom:50%"></p><p>当 <code>I</code> 是 <code>{1，2}</code> 的时候，<code>Ia</code> 等于多少呢？</p><ul><li>从 1 出发，经过 a 弧能够到达 5 和 4，所以 5，4 属于 <code>Ia</code>。从 5，4 出发，经过 ε 弧能够到达 6，2，7，所以 6，2，7 属于 <code>Ia</code></li><li>从 2 出发，经过 a 弧能够到达 3，所以 3 属于 <code>Ia</code>。从 3 出发，经过 ε 弧能够到达 8，2，7，所以 8 属于 <code>Ia</code></li></ul><p>综上，<code>Ia = {5,4,6,2,7,3,8}</code></p><p>下面，介绍具体的确定化过程。</p><h5 id="第一步：规则转换"><a href="#第一步：规则转换" class="headerlink" title="第一步：规则转换"></a>第一步：规则转换</h5><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-13.png" style="zoom:33%"></p><p>第一条和第二条都好理解，重点在第三条规则。为什么右边的图可以等价于左边的图呢？<code>A*</code> 其实表示的是类似 <code>{ε，A，AA，AAA，AAAA，......}</code> 这样的集合，因为 <code>A</code> 自由组合形成的符号串是可以用一个 <code>A</code> 的自循环来表示的，所以中间有一个自循环，而 ε 则可以用 εε 来表示，所以考虑在前后各加一个 ε，对于 <code>A</code> 的符号串不影响。</p><h5 id="第二步：子集法转换"><a href="#第二步：子集法转换" class="headerlink" title="第二步：子集法转换"></a>第二步：子集法转换</h5><p>子集法的核心是，针对上面规则转换后得到的 NFA，画出它的状态转换矩阵，这个矩阵的矩阵元素是映射的子集，不是单值，而我们要做的事情就是把这个子集用一个单值来表示。也就是说，对于 NFA 的每一组映射状态集，都用一个来自 DFA 的映射单值与之对应，从而求出等价的 DFA。</p><p>假设经过第一步，我们已经得到下面的 NFA：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-14.png" style="zoom:67%"></p><p>选取 NFA 的<strong>初态集合的空闭包</strong>作为初始集合 <code>I</code>，这个集合 <code>I</code> 将是 <code>ε-closure({i}) = {i,1,2}</code> 。同时由于输入符号只有 a 和 b，所以第二列为 <code>Ia</code> ，第三列为 <code>Ib</code>。得到如下这个表：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>Ia</code></th><th style="text-align:center"><code>Ib</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>{i，1，2}</code></td><td style="text-align:center"></td></tr></tbody></table><p>根据前面的说法求解 <code>Ia</code> 和 <code>Ib</code>。从 i 出发没有 a 弧，无视之；从 1 出发经过 a 弧 到达 1，从 2 出发经过 a 弧到达 3；从 1 出发经过 ε 弧到达 2，从 1 出发没有 ε 弧。所以，<code>Ia = {1,2,3}</code>。从 i 出发没有 b 弧，无视之；从 1 出发经过 b 弧到达 1，从 2 出发经过 b 弧到达 4。从 1 出发经过 ε 弧到达 2，从 4 出发没有 ε 弧，所以 <code>Ib = {1,2,4}</code>。记新得到的两个</p><p>集合为 A 和 B，得到下面的表：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>Ia</code></th><th style="text-align:center"><code>Ib</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>{i，1，2}</code></td><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">B：<code>{1,2,4}</code></td></tr></tbody></table><p>将新得到的集合 A 和 B 作为第一列的元素，得到下面的表：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>Ia</code></th><th style="text-align:center"><code>Ib</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>{i，1，2}</code></td><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">B：<code>{1,2,4}</code></td></tr><tr><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">B：<code>{1,2,4}</code></td><td style="text-align:center"></td></tr></tbody></table><p>分别对 A 集合和 B 集合求解对应的 <code>Ia</code> 和 <code>Ib</code>，得到下表（对于同样形式的集合仍采取之前命名，仅对新出现集合给定新的命名）：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>Ia</code></th><th style="text-align:center"><code>Ib</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>{i，1，2}</code></td><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">B：<code>{1,2,4}</code></td></tr><tr><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">C：<code>{1,2,3,5,6,f}</code></td><td style="text-align:center">B：<code>{1,2,4}</code></td></tr><tr><td style="text-align:center">B：<code>{1,2,4}</code></td><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">D：<code>{1,2,4,5,6,f}</code></td></tr></tbody></table><p>将新得到的 C、D 集合作为第一列的元素，同样求解 <code>Ia</code> 和 <code>Ib</code>，得到下面的表：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>Ia</code></th><th style="text-align:center"><code>Ib</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>{i，1，2}</code></td><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">B：<code>{1,2,4}</code></td></tr><tr><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">C：<code>{1,2,3,5,6,f}</code></td><td style="text-align:center">B：<code>{1,2,4}</code></td></tr><tr><td style="text-align:center">B：<code>{1,2,4}</code></td><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">D：<code>{1,2,4,5,6,f}</code></td></tr><tr><td style="text-align:center">C：<code>{1,2,3,5,6,f}</code></td><td style="text-align:center">C：<code>{1,2,3,5,6,f}</code></td><td style="text-align:center">E：<code>{1,2,4,6,f}</code></td></tr><tr><td style="text-align:center">D：<code>{1,2,4,5,6,f}</code></td><td style="text-align:center">F：<code>{1,2,3,6,f}</code></td><td style="text-align:center">D：<code>{1,2,4,5,6,f}</code></td></tr></tbody></table><p>同理，继续推导，直到再也没有新集合出现：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>Ia</code></th><th style="text-align:center"><code>Ib</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>{i，1，2}</code></td><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">B：<code>{1,2,4}</code></td></tr><tr><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">C：<code>{1,2,3,5,6,f}</code></td><td style="text-align:center">B：<code>{1,2,4}</code></td></tr><tr><td style="text-align:center">B：<code>{1,2,4}</code></td><td style="text-align:center">A：<code>{1,2,3}</code></td><td style="text-align:center">D：<code>{1,2,4,5,6,f}</code></td></tr><tr><td style="text-align:center">C：<code>{1,2,3,5,6,f}</code></td><td style="text-align:center">C：<code>{1,2,3,5,6,f}</code></td><td style="text-align:center">E：<code>{1,2,4,6,f}</code></td></tr><tr><td style="text-align:center">D：<code>{1,2,4,5,6,f}</code></td><td style="text-align:center">F：<code>{1,2,3,6,f}</code></td><td style="text-align:center">D：<code>{1,2,4,5,6,f}</code></td></tr><tr><td style="text-align:center">E：<code>{1,2,4,6,f}</code></td><td style="text-align:center">F：<code>{1,2,3,6,f}</code></td><td style="text-align:center">D：<code>{1,2,4,5,6,f}</code></td></tr><tr><td style="text-align:center">F：<code>{1,2,3,6,f}</code></td><td style="text-align:center">C：<code>{1,2,3,5,6,f}</code></td><td style="text-align:center">E：<code>{1,2,4,6,f}</code></td></tr></tbody></table><p>现在，用字母命名代替所有的集合（初始集合给定名字 <code>S</code>），得到下面的矩阵：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>Ia</code></th><th style="text-align:center"><code>Ib</code></th></tr></thead><tbody><tr><td style="text-align:center">S</td><td style="text-align:center">A</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">C</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">A</td><td style="text-align:center">D</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">C</td><td style="text-align:center">E</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">F</td><td style="text-align:center">D</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">F</td><td style="text-align:center">D</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">C</td><td style="text-align:center">E</td></tr></tbody></table><p>这个矩阵实际上已经是一个 DFA 矩阵。我们再以初始集合 <code>S</code> 将作为初态，包含原始 NFA 终态的集合（即 C、D、E、F）作为终态，画出它对应的状态转换图，如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-15.png" style="zoom:50%"></p><p>那么，这个转换图实际上就是与最初 NFA 等价的 DFA 所对应的转换图了，到这里，我们就完成了对非确定有限自动机进行确定化的工作了。</p><p>最后我们再对这篇笔记涉及的知识点做一下回顾。首先我们解释了词法分析的结果，也就是单词符号，之后讲解了一些词法分析过程中的要点（预处理、超前扫描），最后则是本篇笔记的重点，词法分析的模型，包括状态转换图以及它的形式化表达 —— 有限自动机。</p><blockquote><p>到这里，词法分析的内容还没有结束。剩下的内容我们将在下一篇笔记中继续讲解。</p></blockquote></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/04/11/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9%EF%BC%9A%E8%B0%83%E5%BA%A6/" rel="prev" title="操作系统学习笔记-9：调度"><i class="fa fa-angle-double-left"></i>&nbsp操作系统学习笔记-9：调度</a></div><div class="post-nav-next"><a href="/2020/04/05/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8%EF%BC%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="操作系统学习笔记-8：线程">操作系统学习笔记-8：线程&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-词法分析的成果"><span class="toc-text">1.词法分析的成果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-词法分析的要点"><span class="toc-text">2. 词法分析的要点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-是否作为一趟？"><span class="toc-text">2.1 是否作为一趟？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-输入和预处理"><span class="toc-text">2.2 输入和预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-超前扫描"><span class="toc-text">2.3 超前扫描</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-词法分析的模型"><span class="toc-text">3. 词法分析的模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-状态转换图"><span class="toc-text">3.1 状态转换图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-正规式与有限自动机"><span class="toc-text">3.2 正规式与有限自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#①-正规式与正规集"><span class="toc-text">① 正规式与正规集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#②-确定有限自动机"><span class="toc-text">② 确定有限自动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#③-非确定有限自动机"><span class="toc-text">③ 非确定有限自动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#③-非确定有限自动机的确定化"><span class="toc-text">③ 非确定有限自动机的确定化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#相关概念："><span class="toc-text">相关概念：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第一步：规则转换"><span class="toc-text">第一步：规则转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第二步：子集法转换"><span class="toc-text">第二步：子集法转换</span></a></li></ol></li></ol></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2020</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->