<!-- build time:Sun Sep 05 2021 14:05:20 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">JS 原生方法原理探究（八）：如何实现 JSON.stringify()？</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-07-08&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp11 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><a id="more"></a><p>这是JS 原生方法原理探究系列的第八篇文章。本文会介绍如何实现 <code>JSON.stringify()</code> 方法。</p><p><code>JSON.stringify()</code> 可以将对象或值转化为 JSON 字符串。理论上，它可以接受很多种不同的数据类型作为参数，而不同的数据类型，处理和转化的结果也不同。所以在实现这个方法之前，我们先弄清楚具体的处理规则。</p><h4 id="不同数据类型的处理结果">不同数据类型的处理结果</h4><p>先看基本数据类型：</p><table><thead><tr class="header"><th align="center">数据类型</th><th align="center">处理结果</th><th align="center">数据类型</th><th align="center">处理结果</th></tr></thead><tbody><tr class="odd"><td align="center">String</td><td align="center">返回<code>'&quot;string&quot;'</code></td><td align="center">Number</td><td align="center">返回 <code>&quot;1234&quot;</code>（NaN，±Infinity 返回 <code>&quot;null&quot;</code>）</td></tr><tr class="even"><td align="center">Null</td><td align="center">返回<code>“null”</code></td><td align="center">Undefined</td><td align="center">返回 <code>undefined</code></td></tr><tr class="odd"><td align="center">Symbol</td><td align="center">返回 <code>undefined</code></td><td align="center">Boolean</td><td align="center">返回 <code>&quot;true&quot;/&quot;false&quot;</code></td></tr></tbody></table><p>再看引用数据类型：</p><table style="width:100%"><colgroup><col width="12%"><col width="40%"><col width="7%"><col width="40%"></colgroup><thead><tr class="header"><th align="center">数据类型</th><th align="center">处理结果</th><th align="center">数据类型</th><th align="center">处理结果</th></tr></thead><tbody><tr class="odd"><td align="center">对象字面量</td><td align="center">递归序列化。但是值为 undefined / Symbol / 函数类型的属性、类型为 Symbol 的属性会丢失</td><td align="center">类数组对象</td><td align="center">同对象字面量</td></tr><tr class="even"><td align="center">基本类型的包装对象</td><td align="center">一般返回包装对象的 <code>valueOf</code>（string 类型前后要加引号）的字符串形式，但是 Symbol 类型返回 <code>&quot;{}&quot;</code></td><td align="center">数组</td><td align="center">递归序列化。但是 undefined、Symbol、函数类型的属性会返回 <code>&quot;null&quot;</code></td></tr><tr class="odd"><td align="center">Map</td><td align="center">返回 <code>&quot;{}&quot;</code></td><td align="center">Set</td><td align="center">返回 <code>&quot;{}&quot;</code></td></tr><tr class="even"><td align="center">Error</td><td align="center">返回 <code>&quot;{}&quot;</code></td><td align="center">RegExp</td><td align="center">返回 <code>&quot;{}&quot;</code></td></tr><tr class="odd"><td align="center">Function</td><td align="center">返回 <code>undefined</code></td><td align="center">Date</td><td align="center">返回调用 <code>toJSON</code> 后生成的字符串</td></tr></tbody></table><h4 id="实现的思路">实现的思路</h4><p>在接下来的代码实现中，首先会分为基本数据类型和引用数据类型两种情况：</p><ul><li>基本数据类型：按照上面的规则返回序列化结果。重点处理 undefined 类型、symbol 类型以及 number 类型中的 NaN、±Infinity。</li><li>引用数据类型（按照是否可以继续遍历再分为两种）：</li><li>可继续遍历的类型：包括对象字面量、数组、类数组对象、Set、Map。需要丢失的属性，在遍历时跳过即可。</li><li>不可继续遍历的类型：包括基本类型的包装对象、Error 对象、正则对象、日期对象函数。用一个函数集中进行处理</li></ul><p>此外，在遍历数组或对象的时候，还需要检测<strong>是否存在循环引用</strong>的情况，若存在需要抛出相应的错误</p><h4 id="数据类型判断">数据类型判断</h4><p>用 <code>getType</code> 获取具体的数据类型。因为对于基本类型 Symbol 和它的包装类型的处理方式不同，所以用 <code>&quot;Symbol_basic&quot;</code> 表示基本类型 Symbol，用 <code>&quot;Symbol&quot;</code> 表示它的包装类型。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">getType</span>(o) <span class="op">{</span>
  <span class="cf">return</span> <span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&quot;symbol&quot;</span>
    <span class="op">?</span> <span class="st">&quot;Symbol_basic&quot;</span>
    : <span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>(o).<span class="at">slice</span>(<span class="dv">8</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span>)<span class="op">;</span>
<span class="op">}</span></code></pre></div><p>用 <code>isObject</code> 判断是引用类型还是基本类型：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">isObject</span>(o)<span class="op">{</span>
    <span class="cf">return</span> o <span class="op">!==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> (<span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&#39;object&#39;</span> <span class="op">||</span> <span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&#39;function&#39;</span>)
<span class="op">}</span></code></pre></div><h4 id="处理不可继续遍历的类型">处理不可继续遍历的类型</h4><p>用 <code>processOtherTypes</code> 处理所有不可继续遍历的引用类型：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">processOtherTypes</span>(target<span class="op">,</span>type)<span class="op">{</span>
    <span class="cf">switch</span>(type)<span class="op">{</span>
        <span class="cf">case</span> <span class="st">&#39;String&#39;</span><span class="op">:</span>
            <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">${</span><span class="va">target</span>.<span class="at">valueOf</span>()<span class="sc">}</span><span class="vs">&quot;`</span>
        <span class="cf">case</span> <span class="st">&#39;Number&#39;</span><span class="op">:</span>
        <span class="cf">case</span> <span class="st">&#39;Boolean&#39;</span><span class="op">:</span>    
            <span class="cf">return</span> <span class="va">target</span>.<span class="at">valueOf</span>().<span class="at">toString</span>()
        <span class="cf">case</span> <span class="st">&#39;Symbol&#39;</span><span class="op">:</span>    
        <span class="cf">case</span> <span class="st">&#39;Error&#39;</span><span class="op">:</span>
        <span class="cf">case</span> <span class="st">&#39;RegExp&#39;</span><span class="op">:</span>    
            <span class="cf">return</span> <span class="st">&quot;{}&quot;</span>
        <span class="cf">case</span> <span class="st">&#39;Date&#39;</span><span class="op">:</span>
            <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">${</span><span class="va">target</span>.<span class="at">toJSON</span>()<span class="sc">}</span><span class="vs">&quot;`</span>
        <span class="cf">case</span> <span class="st">&#39;Function&#39;</span><span class="op">:</span>
            <span class="cf">return</span> <span class="kw">undefined</span>
        <span class="dt">default</span><span class="op">:</span>
            <span class="cf">return</span> “”
    <span class="op">}</span>
<span class="op">}</span></code></pre></div><p>尤其需要注意 String 包装类型，不能直接返回它的 <code>valueOf()</code>，还要在前后加上引号。比如说 <code>{a:&quot;bbb&quot;}</code> ，我们期望的序列化结果应该是 <code>'{a:&quot;bbb&quot;}'</code>，而不是 <code>'{a:bbb}'</code>；同理，对于 Date 对象，直接返回它的 <code>toJSON()</code> 会得到 <code>'{date: 1995-12-16T19:24:00.000Z}'</code>，但我们想得到的是 <code>'{date: &quot;1995-12-16T19:24:00.000Z&quot;}'</code>，所以也要在前后加上引号。</p><h4 id="检测循环引用">检测循环引用</h4><p>循环引用指的是对象的结构是回环状的，不是树状的：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// 下面的对象/数组存在循环引用</span>
<span class="kw">let</span> obj <span class="op">=</span> <span class="op">{};</span>
<span class="va">obj</span>.<span class="at">a</span> <span class="op">=</span> obj<span class="op">;</span>

<span class="kw">let</span> obj1 <span class="op">=</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="op">{</span> <span class="dt">b</span><span class="op">:</span> <span class="op">{}</span> <span class="op">}</span> <span class="op">};</span>
<span class="va">obj1</span>.<span class="va">a</span>.<span class="va">b</span>.<span class="at">c</span> <span class="op">=</span> <span class="va">obj1</span>.<span class="at">a</span><span class="op">;</span>

<span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>]<span class="op">;</span>
arr[<span class="dv">2</span>] <span class="op">=</span> arr<span class="op">;</span>

<span class="co">// 注意这个对象不存在循环引用，只有平级引用</span>
<span class="kw">let</span> obj2 <span class="op">=</span> <span class="op">{</span><span class="dt">a</span><span class="op">:{}};</span>
<span class="va">obj2</span>.<span class="at">b</span> <span class="op">=</span> <span class="va">obj2</span>.<span class="at">a</span><span class="op">;</span></code></pre></div><p>如何检测循环引用呢？</p><ul><li>考虑最简单的情况，只有 key 对应的 value 为对象或者数组时，才可能存在循环引用，因此在遍历 key 的时候，判断 value 为对象或者数组之后才往下处理循环引用。</li><li>每一个 key 会有自己的一个数组用来存放父级链，并且在递归的时候始终传递该数组。如果检测到当前 key 对应的 value 在数组中出现过，则证明引用了某个父级对象，就可以抛出错误；如果没出现过，则加入数组中，更新父级链</li></ul><p>所以一个通用的循环引用检测函数如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">checkCircular</span>(target<span class="op">,</span>parentArray <span class="op">=</span> [target])<span class="op">{</span>
    <span class="va">Object</span>.<span class="at">keys</span>(target).<span class="at">forEach</span>(key <span class="op">=&gt;</span> <span class="op">{</span>
        <span class="cf">if</span>(<span class="kw">typeof</span> target[key] <span class="op">==</span> <span class="st">&#39;object&#39;</span>)<span class="op">{</span>
            <span class="cf">if</span>(<span class="va">parentArray</span>.<span class="at">inlcudes</span>(target[key])
              <span class="op">||</span> <span class="at">checkCircular</span>(target[key]<span class="op">,</span>[target[key]<span class="op">,</span>...<span class="at">parentArray</span>])
              )<span class="op">{</span>
                <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&#39;存在循环引用&#39;</span>)
            <span class="op">}</span>
        <span class="op">}</span>
    <span class="op">}</span>)
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;不存在循环引用&#39;</span>)
<span class="op">}</span></code></pre></div><p>在 <code>JSON.stringify</code> 的实现中，遍历 key 的过程已经在主代码完成了，所以这里的 <code>checkCircular</code> 只需要包含检测过程。稍加改造如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">checkCircular</span>(target<span class="op">,</span>currentParent)<span class="op">{</span>
    <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target)
    <span class="cf">if</span>(type <span class="op">==</span> <span class="st">&#39;Object&#39;</span> <span class="op">||</span> type <span class="op">==</span> <span class="st">&#39;Array&#39;</span>)<span class="op">{</span>
        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&#39;Converting circular structure to JSON&#39;</span>)
    <span class="op">}</span>
    <span class="va">currentParent</span>.<span class="at">push</span>(target)
<span class="op">}</span></code></pre></div><h4 id="核心代码">核心代码</h4><p>最终实现的核心代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">jsonStringify</span>(target<span class="op">,</span>initParent <span class="op">=</span> [target])<span class="op">{</span>
    <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target)
    <span class="kw">let</span> iterableList <span class="op">=</span> [<span class="st">&#39;Object&#39;</span><span class="op">,</span><span class="st">&#39;Array&#39;</span><span class="op">,</span><span class="st">&#39;Arguments&#39;</span><span class="op">,</span><span class="st">&#39;Set&#39;</span><span class="op">,</span><span class="st">&#39;Map&#39;</span>]
    <span class="kw">let</span> specialList <span class="op">=</span> [<span class="st">&#39;Undefined&#39;</span><span class="op">,</span><span class="st">&#39;Symbol_basic&#39;</span><span class="op">,</span><span class="st">&#39;Function&#39;</span>]
    <span class="co">// 如果是基本数据类型</span>
    <span class="cf">if</span>(<span class="op">!</span><span class="at">isObject</span>(target))<span class="op">{</span>
       <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Symbol_basic&#39;</span> <span class="op">||</span> type <span class="op">===</span> <span class="st">&#39;Undefined&#39;</span>)<span class="op">{</span>
            <span class="cf">return</span> <span class="kw">undefined</span>
       <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span>(<span class="va">Number</span>.<span class="at">isNaN</span>(target) <span class="op">||</span> target <span class="op">===</span> <span class="kw">Infinity</span> <span class="op">||</span> target <span class="op">===</span> <span class="op">-</span><span class="kw">Infinity</span>) <span class="op">{</span>
            <span class="cf">return</span> <span class="st">&quot;null&quot;</span>
       <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;String&#39;</span>)<span class="op">{</span>
            <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">${</span>target<span class="sc">}</span><span class="vs">&quot;`</span>
       <span class="op">}</span> 
       <span class="cf">return</span>  <span class="at">String</span>(target)
    <span class="op">}</span> 
    <span class="co">// 如果是引用数据类型</span>
    <span class="cf">else</span> <span class="op">{</span>
        <span class="kw">let</span> res 
        <span class="co">// 如果是不可以遍历的类型</span>
        <span class="cf">if</span>(<span class="op">!</span><span class="va">iterableList</span>.<span class="at">includes</span>(type))<span class="op">{</span>
            res <span class="op">=</span> <span class="at">processOtherTypes</span>(target<span class="op">,</span>type)
        <span class="op">}</span> 
        <span class="co">// 如果是可以遍历的类型</span>
        <span class="cf">else</span> <span class="op">{</span>
            <span class="co">// 如果是数组</span>
            <span class="cf">if</span>(type <span class="op">===</span> <span class="st">&#39;Array&#39;</span>)<span class="op">{</span>
                res <span class="op">=</span> <span class="va">target</span>.<span class="at">map</span>(item <span class="op">=&gt;</span> <span class="op">{</span>
                    <span class="cf">if</span>(<span class="va">specialList</span>.<span class="at">includes</span>(<span class="at">getType</span>(item)))<span class="op">{</span>
                        <span class="cf">return</span> <span class="st">&quot;null&quot;</span>
                    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
                        <span class="co">// 检测循环引用</span>
                        <span class="kw">let</span> currentParent <span class="op">=</span> [...<span class="at">initParent</span>]
                        <span class="at">checkCircular</span>(item<span class="op">,</span>currentParent)
                        <span class="cf">return</span> <span class="at">jsonStringify</span>(item<span class="op">,</span>currentParent)
                    <span class="op">}</span>
                <span class="op">}</span>)
                res <span class="op">=</span> <span class="vs">`[</span><span class="sc">${</span>res<span class="sc">}</span><span class="vs">]`</span>.<span class="at">replace</span>(<span class="ss">/&#39;/g</span><span class="op">,</span><span class="st">&#39;&quot;&#39;</span>)
            <span class="op">}</span>        
            <span class="co">// 如果是对象字面量、类数组对象、Set、Map</span>
            <span class="cf">else</span> <span class="op">{</span>
                res <span class="op">=</span> []
                <span class="va">Object</span>.<span class="at">keys</span>(target).<span class="at">forEach</span>(key <span class="op">=&gt;</span> <span class="op">{</span>
                    <span class="co">// Symbol 类型的 key 直接略过</span>
                    <span class="cf">if</span>(<span class="at">getType</span>(key) <span class="op">!==</span> <span class="st">&#39;Symbol_basic&#39;</span>)<span class="op">{</span>
                        <span class="kw">let</span> keyType <span class="op">=</span> <span class="at">getType</span>(target[key])                        
                        <span class="cf">if</span>(<span class="op">!</span><span class="va">specialList</span>.<span class="at">includes</span>(keyType))<span class="op">{</span>
                            <span class="co">// 检测循环引用</span>
                            <span class="kw">let</span> currentParent <span class="op">=</span> [...<span class="at">initParent</span>]
                            <span class="at">checkCircular</span>(target[key]<span class="op">,</span>currentParent)
                            <span class="co">// 往数组中 push 键值对</span>
                            <span class="va">res</span>.<span class="at">push</span>(
                                <span class="vs">`&quot;</span><span class="sc">${</span>key<span class="sc">}</span><span class="vs">&quot;:</span><span class="sc">${</span><span class="at">jsonStringify</span>(target[key]<span class="op">,</span>currentParent)<span class="sc">}</span><span class="vs">`</span>
                            )
                        <span class="op">}</span>
                    <span class="op">}</span>
                <span class="op">}</span>)
                res <span class="op">=</span> <span class="vs">`{</span><span class="sc">${</span>res<span class="sc">}</span><span class="vs">}`</span>.<span class="at">replace</span>(<span class="ss">/&#39;/g</span><span class="op">,</span><span class="st">&#39;&quot;&#39;</span>)
            <span class="op">}</span>            
        <span class="op">}</span>
        <span class="cf">return</span> res
    <span class="op">}</span>
<span class="op">}</span></code></pre></div><p>基本上按照上面表格中的规则来处理就行了，有几个细节可以注意一下：</p><ul><li><code>iterableList</code> 用于存放可以继续遍历的数据类型；<code>specialList</code> 用于存放比较特殊的 <code>Undefined</code>、<code>Symbol_basic</code>、<code>Function</code> 三种类型，特殊在于：对象 key 的 value 如果是这些类型，则序列化的时候会丢失，数组的元素如果是这些类型，则序列化的时候会统一转化为 <code>&quot;null&quot;</code>。因为这三种类型要多次用到，所以先存起来。</li><li>为什么要将最终返回的 <code>res</code> 初始化为一个空数组？因为：</li><li>如果我们处理的 <code>target</code> 是数组，则只需要调用 <code>map</code> 就可以将数组的每一个元素映射为序列化之后的结果，调用后返回的数组赋给 <code>res</code>，再和 <code>[</code>、<code>]</code> 字符拼接，会隐式调用数组的 <code>toString</code> 方法，产生一个标准的序列化结果；</li><li>如果处理的 <code>target</code> 是对象字面量，则可以将它的每个 key-value 的序列化结果 push 到 <code>res</code> 中，最终再和 <code>{</code>、<code>}</code> 字符拼接，也同样会产生一个标准的序列化结果。</li><li>在整个过程中不需要去处理 JSON 字符串中的逗号分隔符。</li><li>对于对象字面量，类型为 <code>&quot;Symbol_basic&quot;</code> 的属性会丢失，属性值为 <code>Undefined</code>、<code>Symbol_basic</code>、<code>Function</code> 三种类型的属性也会丢失。属性丢失其实就是在遍历对象的时候略过这些属性</li><li>在检测循环引用的时候，存在嵌套关系的对象应该共享同一条父级链，所以递归的时候需要把存放父级链的数组传进去；同时，不存在嵌套关系的两个对象不应该共享同一条父级链（否则会将所有互相引用的情况都误认为是循环引用），所以每次遍历对象 key 的时候，都会重新生成一个 <code>currentArray</code>。</li><li>最后，为保险起见，记得将序列化结果中可能出现的所有单引号替换为双引号</li></ul><h4 id="最终代码和效果">最终代码和效果</h4><p>最终代码如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">getType</span>(o) <span class="op">{</span>
  <span class="cf">return</span> <span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&quot;symbol&quot;</span>
    <span class="op">?</span> <span class="st">&quot;Symbol_basic&quot;</span>
    : <span class="va">Object</span>.<span class="va">prototype</span>.<span class="va">toString</span>.<span class="at">call</span>(o).<span class="at">slice</span>(<span class="dv">8</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span>)<span class="op">;</span>
<span class="op">}</span>
<span class="kw">function</span> <span class="at">isObject</span>(o) <span class="op">{</span>
  <span class="cf">return</span> o <span class="op">!==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> (<span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&quot;object&quot;</span> <span class="op">||</span> <span class="kw">typeof</span> o <span class="op">===</span> <span class="st">&quot;function&quot;</span>)<span class="op">;</span>
<span class="op">}</span>
<span class="kw">function</span> <span class="at">processOtherTypes</span>(target<span class="op">,</span> type) <span class="op">{</span>
  <span class="cf">switch</span> (type) <span class="op">{</span>
    <span class="cf">case</span> <span class="st">&quot;String&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">${</span><span class="va">target</span>.<span class="at">valueOf</span>()<span class="sc">}</span><span class="vs">&quot;`</span><span class="op">;</span>
    <span class="cf">case</span> <span class="st">&quot;Number&quot;</span><span class="op">:</span>
    <span class="cf">case</span> <span class="st">&quot;Boolean&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="va">target</span>.<span class="at">valueOf</span>().<span class="at">toString</span>()<span class="op">;</span>
    <span class="cf">case</span> <span class="st">&quot;Symbol&quot;</span><span class="op">:</span>
    <span class="cf">case</span> <span class="st">&quot;Error&quot;</span><span class="op">:</span>
    <span class="cf">case</span> <span class="st">&quot;RegExp&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="st">&quot;{}&quot;</span><span class="op">;</span>
    <span class="cf">case</span> <span class="st">&quot;Date&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">${</span><span class="va">target</span>.<span class="at">toJSON</span>()<span class="sc">}</span><span class="vs">&quot;`</span><span class="op">;</span>
    <span class="cf">case</span> <span class="st">&quot;Function&quot;</span><span class="op">:</span>
      <span class="cf">return</span> <span class="kw">undefined</span><span class="op">;</span>
    <span class="dt">default</span><span class="op">:</span>
      <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span>
<span class="kw">function</span> <span class="at">checkCircular</span>(obj<span class="op">,</span> currentParent) <span class="op">{</span>
  <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(obj)<span class="op">;</span>
  <span class="cf">if</span> (type <span class="op">==</span> <span class="st">&quot;Object&quot;</span> <span class="op">||</span> type <span class="op">==</span> <span class="st">&quot;Array&quot;</span>) <span class="op">{</span>
    <span class="cf">if</span> (<span class="va">currentParent</span>.<span class="at">includes</span>(obj)) <span class="op">{</span>
      <span class="cf">throw</span> <span class="kw">new</span> <span class="at">TypeError</span>(<span class="st">&quot;Converting circular structure to JSON&quot;</span>)<span class="op">;</span>
    <span class="op">}</span>
    <span class="va">currentParent</span>.<span class="at">push</span>(obj)<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span>
<span class="kw">function</span> <span class="at">jsonStringify</span>(target<span class="op">,</span> initParent <span class="op">=</span> [target]) <span class="op">{</span>
  <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target)<span class="op">;</span>
  <span class="kw">let</span> iterableList <span class="op">=</span> [<span class="st">&quot;Object&quot;</span><span class="op">,</span> <span class="st">&quot;Array&quot;</span><span class="op">,</span> <span class="st">&quot;Arguments&quot;</span><span class="op">,</span> <span class="st">&quot;Set&quot;</span><span class="op">,</span> <span class="st">&quot;Map&quot;</span>]<span class="op">;</span>
  <span class="kw">let</span> specialList <span class="op">=</span> [<span class="st">&quot;Undefined&quot;</span><span class="op">,</span> <span class="st">&quot;Symbol_basic&quot;</span><span class="op">,</span> <span class="st">&quot;Function&quot;</span>]<span class="op">;</span>
  <span class="cf">if</span> (<span class="op">!</span><span class="at">isObject</span>(target)) <span class="op">{</span>
    <span class="cf">if</span> (type <span class="op">===</span> <span class="st">&quot;Symbol_basic&quot;</span> <span class="op">||</span> type <span class="op">===</span> <span class="st">&quot;Undefined&quot;</span>) <span class="op">{</span>
      <span class="cf">return</span> <span class="kw">undefined</span><span class="op">;</span>
    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="va">Number</span>.<span class="at">isNaN</span>(target) <span class="op">||</span> target <span class="op">===</span> <span class="kw">Infinity</span> <span class="op">||</span> target <span class="op">===</span> <span class="op">-</span><span class="kw">Infinity</span>) <span class="op">{</span>
      <span class="cf">return</span> <span class="st">&quot;null&quot;</span><span class="op">;</span>
    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (type <span class="op">===</span> <span class="st">&quot;String&quot;</span>) <span class="op">{</span>
      <span class="cf">return</span> <span class="vs">`&quot;</span><span class="sc">${</span>target<span class="sc">}</span><span class="vs">&quot;`</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="cf">return</span> <span class="at">String</span>(target)<span class="op">;</span>
  <span class="op">}</span>
  <span class="cf">else</span> <span class="op">{</span>
    <span class="kw">let</span> res<span class="op">;</span>
    <span class="cf">if</span> (<span class="op">!</span><span class="va">iterableList</span>.<span class="at">includes</span>(type)) <span class="op">{</span>
      res <span class="op">=</span> <span class="at">processOtherTypes</span>(target<span class="op">,</span> type)<span class="op">;</span>
    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
      <span class="cf">if</span> (type <span class="op">===</span> <span class="st">&quot;Array&quot;</span>) <span class="op">{</span>
        res <span class="op">=</span> <span class="va">target</span>.<span class="at">map</span>((item) <span class="op">=&gt;</span> <span class="op">{</span>
          <span class="cf">if</span> (<span class="va">specialList</span>.<span class="at">includes</span>(<span class="at">getType</span>(item))) <span class="op">{</span>
            <span class="cf">return</span> <span class="st">&quot;null&quot;</span><span class="op">;</span>
          <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
            <span class="kw">let</span> currentParent <span class="op">=</span> [...<span class="at">initParent</span>]<span class="op">;</span>
            <span class="at">checkCircular</span>(item<span class="op">,</span> currentParent)<span class="op">;</span>
            <span class="cf">return</span> <span class="at">jsonStringify</span>(item<span class="op">,</span> currentParent)<span class="op">;</span>
          <span class="op">}</span>
        <span class="op">}</span>)<span class="op">;</span>
        res <span class="op">=</span> <span class="vs">`[</span><span class="sc">${</span>res<span class="sc">}</span><span class="vs">]`</span>.<span class="at">replace</span>(<span class="ss">/&#39;/g</span><span class="op">,</span> <span class="st">&#39;&quot;&#39;</span>)<span class="op">;</span>
      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
        res <span class="op">=</span> []<span class="op">;</span>
        <span class="va">Object</span>.<span class="at">keys</span>(target).<span class="at">forEach</span>((key) <span class="op">=&gt;</span> <span class="op">{</span>
          <span class="cf">if</span> (<span class="at">getType</span>(key) <span class="op">!==</span> <span class="st">&quot;Symbol_basic&quot;</span>) <span class="op">{</span>
            <span class="kw">let</span> type <span class="op">=</span> <span class="at">getType</span>(target[key])<span class="op">;</span>
            <span class="cf">if</span> (<span class="op">!</span><span class="va">specialList</span>.<span class="at">includes</span>(type)) <span class="op">{</span>
              <span class="kw">let</span> currentParent <span class="op">=</span> [...<span class="at">initParent</span>]<span class="op">;</span>
              <span class="at">checkCircular</span>(target[key]<span class="op">,</span> currentParent)<span class="op">;</span>
              <span class="va">res</span>.<span class="at">push</span>(<span class="vs">`&quot;</span><span class="sc">${</span>key<span class="sc">}</span><span class="vs">&quot;:</span><span class="sc">${</span><span class="at">jsonStringify</span>(target[key]<span class="op">,</span> currentParent)<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span>
            <span class="op">}</span>
          <span class="op">}</span>
        <span class="op">}</span>)<span class="op">;</span>
        res <span class="op">=</span> <span class="vs">`{</span><span class="sc">${</span>res<span class="sc">}</span><span class="vs">}`</span>.<span class="at">replace</span>(<span class="ss">/&#39;/g</span><span class="op">,</span> <span class="st">&#39;&quot;&#39;</span>)<span class="op">;</span>
      <span class="op">}</span>
    <span class="op">}</span>
    <span class="cf">return</span> res<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div><p>拿下面的 <code>obj</code> 对象测试一下效果：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> obj <span class="op">=</span> <span class="op">{</span>
   <span class="dt">tag</span><span class="op">:</span> <span class="at">Symbol</span>(<span class="st">&quot;student&quot;</span>)<span class="op">,</span>
   <span class="dt">money</span><span class="op">:</span> <span class="kw">undefined</span><span class="op">,</span>
   <span class="dt">girlfriend</span><span class="op">:</span> <span class="kw">null</span><span class="op">,</span> 
   <span class="dt">fn</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">{},</span>
   <span class="dt">info1</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="st">&#39;str&#39;</span><span class="op">,</span><span class="kw">NaN</span><span class="op">,</span><span class="kw">Infinity</span><span class="op">,-</span><span class="kw">Infinity</span><span class="op">,</span><span class="kw">undefined</span><span class="op">,</span><span class="kw">null</span><span class="op">,</span>() <span class="op">=&gt;</span> <span class="op">{},</span><span class="at">Symbol</span>()]<span class="op">,</span>
   <span class="dt">info2</span><span class="op">:</span> [<span class="kw">new</span> <span class="at">Set</span>()<span class="op">,</span><span class="kw">new</span> <span class="at">Map</span>()<span class="op">,</span><span class="kw">new</span> <span class="at">Error</span>()<span class="op">,</span><span class="ss">/a</span><span class="sc">+</span><span class="ss">b/</span>]<span class="op">,</span>
   <span class="dt">info2</span><span class="op">:</span> <span class="op">{</span>
       <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;Chor&#39;</span><span class="op">,</span>
       <span class="dt">age</span><span class="op">:</span> <span class="dv">20</span><span class="op">,</span>
       <span class="dt">male</span><span class="op">:</span> <span class="kw">true</span>
   <span class="op">},</span>
   <span class="dt">info3</span><span class="op">:</span> <span class="op">{</span>
       <span class="dt">date</span><span class="op">:</span> <span class="kw">new</span> <span class="at">Date</span>()<span class="op">,</span>
       <span class="dt">tag</span><span class="op">:</span> <span class="at">Symbol</span>()<span class="op">,</span>
       <span class="dt">fn</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">{},</span>
       <span class="dt">un</span><span class="op">:</span> <span class="kw">undefined</span>
   <span class="op">},</span>
   <span class="dt">info4</span><span class="op">:{</span>
       <span class="dt">str</span><span class="op">:</span> <span class="kw">new</span> <span class="at">String</span>(<span class="st">&#39;abc&#39;</span>)<span class="op">,</span>
       <span class="dt">no</span><span class="op">:</span> <span class="kw">new</span> <span class="at">Number</span>(<span class="dv">123</span>)<span class="op">,</span>
       <span class="dt">bool</span><span class="op">:</span> <span class="kw">new</span> <span class="at">Boolean</span>(<span class="kw">false</span>)<span class="op">,</span>
       <span class="dt">tag</span><span class="op">:</span> <span class="at">Object</span>(<span class="at">Symbol</span>())    
   <span class="op">}</span>    
<span class="op">}</span></code></pre></div><p>结果如下：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JS%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97/2.jpeg"></div><p>说明我们的实现是没有问题的。最后，我并没有实现 <code>JSON.stringify()</code> 中的 replacer 参数和 space 参数，感兴趣的读者可以在上面代码的基础上进一步拓展。</p><p>本文到此结束，感谢你的阅读。若发现文中有错误之处，欢迎评论区指出。</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2021/07/09/F-JS%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/" rel="prev" title="JS 原生方法原理探究（九）：如何手写实现浅拷贝和深拷贝？"><i class="fa fa-angle-double-left"></i>&nbspJS 原生方法原理探究（九）：如何手写实现浅拷贝和深拷贝？</a></div><div class="post-nav-next"><a href="/2021/07/08/F-JS%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20Object.assign()%EF%BC%9F/" rel="next" title="JS 原生方法原理探究（七）：如何实现 Object.assign()？">JS 原生方法原理探究（七）：如何实现 Object.assign()？&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C"><span class="toc-text">不同数据类型的处理结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-text">实现的思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">数据类型判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%B8%8D%E5%8F%AF%E7%BB%A7%E7%BB%AD%E9%81%8D%E5%8E%86%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">处理不可继续遍历的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-text">检测循环引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="toc-text">核心代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%88%E6%9E%9C"><span class="toc-text">最终代码和效果</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->