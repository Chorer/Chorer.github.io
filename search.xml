<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「译」提升 Web 开发效率的 VS Code 扩展]]></title>
    <url>%2F2019%2F09%2F21%2FTrs-%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84vs%20code%20%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[原文地址：VS Code Extensions For Web Dev Productivity原文作者：Deepak Gupta译者：Chor在我们开始之前，先看看你能否回答这个问题：Visual studio Code 和 Visual Studio 的区别是什么？怕有人不知道，我还是简单说明一下。Visual Studio 是一个功能全面且便捷的集成开发环境，而 VS Code 则是一个开源、跨平台的源码编辑器，在 web 开发群体中尤其出名。它不仅快速、可扩展、可自定义，而且还有大量功能。我已经使用 VS Code 很久了，作为一名全栈开发者，我也尝试过各种扩展。本文将介绍一些对我的开发工作起到很大帮助的扩展，希望能对你有所帮助。让代码易于阅读和维护Bracket Pair Colorizer 2：可以让配对的括号显示相同的颜色。Indent Rainbow：为文本前面的缩进着色，每一个缩进都有 4 种可选颜色。使用上面两个扩展后，你的编辑器就会铺满各种颜色，这可以让代码块更容易阅读，同时起到护目的效果。一旦你习惯了它们，VS Code 就不再平淡无奇了。AutoClose Tag 和 Auto Rename Tag：手动输入标签对每一个 web 开发者来说都是一件痛苦的事情。我们需要一个可以快速简便生成标签以及子标签的工具。AutoClose 可以在你输入开始标签的时候生成闭合标签。Auto Rename 则可以在你修改一半标签时，自动同步修改另一半标签。Indenticator： 高亮当前的缩进位置，当代码很长时可以派上用场。VS Code Icons： 提供文件图标，可以提高编辑器的颜值Dracula：这是一直以来钟爱的一个主题Prettier：通过解析代码并根据自己的规则重新打印，从而实现一致的代码风格。Prettier 考虑了最大行长，并可以在必要的时候进行换行。尝试自己安装一下并领略它的魅力。Path Intellisense：这是最佳的自动补齐文件名的扩展ESlint 或者 TSlint：想要让代码保持一致并且避免 bug，这些代码检查工具是必不可少的。基本操作Code Spell Checker：一个可以搭配驼峰式代码使用的拼写检查扩展。高度推荐。Change-case：改变当前所选词的大小写。Pegex Previewer：在并排的文档中高亮当前正则表达式的匹配项，通常用于添加验证检查。Partial Diff：可以让你比较一个文件中、文件之间或者剪贴板上的 diff 文本段。Copy With Line Number：复制选中的行以及行号和文件路径。这在协同编程以及向同事求助时很有用，可以让他们快速定位到代码位置。当然，对于编写文档也是很有帮助的。Paste Image：直接从剪贴板上粘贴图片到 Markdown，AsciiDoc 或者其它文件。我习惯在 Git README 文件或者 Markdown 文档中使用这个扩展。TinyPNG: 可以无损压缩 jpg 和 png 图片文件Polacode: 可以为你的代码块创建好看的截图。只需要安装扩展并启动，之后复制粘贴代码到 Polacode 即可。接着你就可以下载这个截图了。我很喜欢这个扩展。调试Turbo Console.log: 这个扩展可以自动编写 log 信息打印语句，从而让调试更加简单。Debugger for Chrome: 可以在 Chrome 浏览器中对 JavaScript 代码进行调试版本控制Git Lens: GitLens 增强了内置的 Git，它包含了大量功能，例如通过 code lens 展示的 authorship，提交检索、历史记录以及 Gitlens 浏览器等。如果你进行的工作与 Git 相关，那么这个插件必不可少。和 GitLens 类似的扩展：Git History: 将提交历史等记录以漂亮的图表展示出来。Checkpoints: 在各个提交之间保留正在进行的工作的本地短期历史纪录。Git Blame: 可以在状态栏显示当前选中行的 Git Blame 信息。GitLens 也提供了类似的功能。Git Indicators: 可以在状态栏查看受影响的文件以及新增或者删减的行数。Open in GitHub/Bitbucket/Gitlab/VisualStudio.com: 可以用单命令在浏览器中开启仓库。Version Lens: 在 Visual Studio Code 编辑器中展示 npm， jspm， DUB 以及 Dotnet Core 中安装包的版本信息。MarkdownMarkdown Shortcuts: 快捷编写 Markdown.我一般用它来写 README 文件。Markdown Preview Enhanced: 这个动态的预览扩展可以让你一边编写 markdown 文件，一边预览效果。衡量开发效率WakaTime 或者 Code Time: 通过编程活动自动生成的指标、统计以及时间追踪。其它Settings Sync: 可以将你的 VS Code 配置同步到 Github 上，包括基础设置、热键和 VS Code 扩展。此后可以在任何打算用来编程的设备上将这些配置进行同步，而不需要在一台新设备的原生 VS Code 环境中进行编程，也不需要再重复配置。Project Manager: 可以直接在 VS Code 中打开指向某个 Git 仓库的新窗口。基本上，你现在可以在不离开 VS Code 界面的情况下打开任意一个仓库。Quokka.js: 在输入代码的时候即时运行代码，同时在编辑器中显示不同的执行结果。你可以自己尝试一下。TODO Highlighter: 在将代码发布到生产环境之前，你可能会忘记 review 一下之前写的 TODOs。之前我一直都希望有一个扩展可以将这些 TODOs 高亮，并且提醒我还有一些未完成的工作。Import Cost: 这个扩展可以用在行内展示导入包的大小，它利用带有 babili-webpack-plugin 的 webpack 来检测大小。REST Client: REST Client 允许你发送 HTTP 请求并在编辑器中直接查看响应结果。Live Server: 开启一个本地服务器，可以为静态或者动态页面提供实时刷新功能。Code Runner: 在 VS Code 中运行代码，支持大部分编程语言。Live Share: 允许你实时共享工作空间：实时编辑、固定并跟随用户指针、联合调试以及其它。这对远程工作或者异地协同工作很有用。JSON to code: 只需要一个命令就可以将 JSON 转换为可用于强类型语言的接口。Remote SSH: 可以使用任何带有 SSH 服务器的远程计算机作为开发环境，从而在各种情况下极大地简化开发和故障排查的过程。React Native/React/Redux snippets for es6/es7: 如果你使用 React 、 React Native 或者 JavaScript，那么这个扩展很有用。我的工作决定我用哪些扩展，所以有的时候我会选择性地开启或者关闭一些扩展，从而节省内存使用量。注意： 此外还有用于其它开发的各种扩展: HTML，CSS，React，React Native，Node，Python 等。每一个都有自己对应的扩展。你可以在 Visual Studio Marketplace 查找各种相关扩展。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统cp2：定点数的表示和运算]]></title>
    <url>%2F2019%2F09%2F20%2FCB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%2F</url>
    <content type="text"><![CDATA[在深入理解计算机系统cp1：存储单位、数制、编码中解释了字符编码，我们知道了计算机是怎么把字符转化为二进制的；本文将解释数字编码，介绍计算机如何把数字转化为二进制，以及相关的运算问题。1.定点数的表示1.1 无符号数定义：无符号数就是没有体现正负号的数（这意味着所有的无符号数实际上都是正数），整个机器字长的全部二进制位均为数值位，没有符号位。以108D为例，它对应的二进制数是 1101100，这实际上也就是它的无符号数，可以看到所有的位都是数值位。表示范围：以八位二进制数为准，范围就是 00000000 到 11111111，也就是 0 到 2551.2 有符号数定义：有符号数就是有体现正负号的数，整个机器字长的全部二进制位中，最高位作为符号位，0 表示正数，1 表示负数，其余位则是数值位。依然以108D为例，它对应的二进制数是 1101100，而对应的有符号数则要在最前面加上符号位 0，即它的有符号数是 01101100.表示范围：以八位二进制数为准，范围应该是从负数到正数，即从 11111111 到 01111111，也就是 -127 到 1271.2.1.真值和机器数真值：就是带有正负号的实际十进制数，比如上面例子中，+108D就是真值机器数：机器数就是一个数在计算机中的二进制表示形式，注意机器数是由符号位和数值位构成的，比如上面例子中，01101100 就是机器数。-156D（真值）= 110011100B(机器数)1.2.2.原码、反码、补码和移码(1)原码表示法简单点理解，原码就是符号位加上真值（二进制）的绝对值，同时用逗号将符号位和数值位隔开。比如，+1 就是 0,0000001，-1 就是 1,0000001。原码的特点是简单、直观，但是原码在进行加法运算的时候会出现问题。正数加正数或者负数加负数是正常的，但是正数加负数就会出错。比如我们现在想要计算 -1+3，我们心想：-1 是 10000001，+3 是 00000011，加起来得到的是 10000100，所以结果是 -4，但 -1+3 应该是等于 2，所以这个结果是错的。我们发现，本来应该做的是加法运算，但实际上变成了减法运算（-1-3=-4）。我们首先想到，可以通过将“正数加负数”转化为“正数减正数”来手动纠正这个错误。上面的例子就变成 00000011 减 00000001，结果是 00000010，也就是 2，这个结果是正确的。但是每次都这样手动转化，计算起来还是太麻烦了。于是我们接着想：有没有一种方法，可以让“正数加负数”中的负数等价于一个正数，从而确保始终进行的是相加操作呢？于是这时候就引出了补码的概念。(2)补码表示法补数和模：理解补码之前，我们先来理解两个概念：补数和模。拿时钟举例，想要从10点拨到8点，有两种做法，一种是逆时针拨2个单位，记作-2；一种是顺时针拨10个单位，记作+10，这两种操作是等效的(有点负数等价于一个正数的意思)。这时候我们就说，-2 是 +10 以 12 为模的补数，记作-2≡+10(mod 12)，同理，-5 相当于 +7，-4 相当于 +8。那么怎么基于补数和模的概念将“正数加负数”转化为“正数加正数” —— 即怎么令负数等价于一个正数呢？假设我们现在有一个寄存器可以存放四位二进制数（此时，模为16），我们想要让 1011 变成 0000，最容易想到的办法就是 1011-1011=0000，注意这里是正数加负数。想要变成正数加正数，就要找到等价于 -1011 的正数，-1011 就是 -11，-11 以 16 为模的补数就是 +5，+5 就是 +0101，这个正是我们要找的那个等价正数，因此这时候，1011-1011 变成了 1011+0101，其结果是 10000，不要忘了寄存器只能存放四位，所以结果其实是 0000，恰好与我们“正数加负数”时得到的结果无异。接着引入补码的概念：对于正数：正数的补码和原码相同；对于负数：负数的补码等于其原码在保持符号位不变的情况下，其余各位取反，末位加一（取反加一）。注意，补码的补码等于原码，这可以用来根据补码求原码。也可以用下图方法计算补码：还是上面的例子，1011-1011，也就是11-11，我们考虑+11和-11，+11的原码=补码=01011，-11的原码是11011，因此补码是10101，那么01011+10101就会等于100000，因为寄存器是五位的，把前面的1去掉，那么结果就是00000，也就是0，和上面的运算结果一致。(3)反码表示法反码很好理解：正数：反码等于原码等于补码；负数：反码等于原码保持符号位不变的情况下其余各位取反。也就是说，补码=反码+1反码的反码等于原码，这可以用来根据反码求原码。(4)移码表示法补码存在的问题是，仅从补码本身来看，很难比较两个数的大小，为此引入了移码的概念。移码指的是在真值（二进制）的基础上加上一个偏移量，通常这个偏移量是2^n。其中，n是数值位的位数。例如，对于-10101，其移码是2^7+(-10101)=10000000+(010101)=0,1101011。当然，我们有简单的方法可以计算一个数的移码：不管正数还是负数，其移码都等于补码的符号位取反。2.定点数的加减运算2.1 补码的加减运算定点数的加减运算实际上就是补码的加减运算。我们来看一个例子：假设机器字长为 8 位（含1位符号位），A=15，B=-24，现在求 A+B 和 A-B。A 的补码是 0,0001111，B 的补码是 1,1101000，那么 0,0001111+1,1101000=1,1110111，转化为原码，再转化为真值，得到 -9，这是正确的。同理，A-B 就是 A+(-B)，-B 的补码是 0,0011000，那么 0,0001111+0,0011000=0,0100111，最后转化为真值，得到 +39，这也是正确的。我们再来看另一个例子：假设机器字长为 8 位（含1位符号位），A=15，B=-24，C=124，现在求 A+C 和 B-C。我们同样按照上面的流程来进行计算，最后得出：A+C 结果是 -117，B-C 结果是 +108，这两个都是错误的。为什么会出现这样的情况呢？2.2 溢出这种情况就叫溢出。出现的原因，简单来说就是：运算结果太大了，或者运算结果太小了。就上面的题而言，8 位二进制数所能表示的数字的范围是有限的，当正数加正数的时候，结果可能过大，超出了最大值，此时称为上溢；当负数加负数的时候，结果可能过小，够不到最小值，此时称为下溢。如下图所示：我们拿 3 位二进制数来理解这个问题。假设 3 位二进制数可以表示的范围如下：现在我们进行 2+2 操作，那么就是 010+010，结果就是 100，这已经超出了正数可以表示的最大范围，也就是发生了上溢。所以此时得到的是 -4，这是一个错误的结果。2.3 溢出的判断前面说过，溢出的原因要么是运算结果太大，要么是运算结果太小，其实从这句话我们可以看出，正数和负数相加是不会发生溢出的，因为其结果必然在可以表示的范围内，唯一可能会发生溢出的情况，要么是正数加正数，要么是负数加负数。那么，如何判断在这两种情况下是否会发生溢出呢？有三个方法：(1) 一位符号位：比较操作数符号位与结果数符号位我们还是拿上面的第二个例子解释：可以看到，A+C 中，两个操作数符号位都是 0，也就是都是正数，但结果数的符号位却是 1 ，也就是负数，那么很明显它发生了上溢；同理，B-C 中，两个操作数符号位都是 1，也就是都是负数，但结果数的符号位却是 0，也就是正数，那么很明显它发生了下溢。(2) 一位符号位：看符号位与最高数值位的进位情况看第一个式子，进行运算的时候，符号位没有产生进位，但是最高数值位向前产生了进位，这时候判断它发生了上溢；看第二个式子，进行运算的时候，最高数值位没有产生进位，但是符号位向前产生了进位，这时候判断它发生了下溢。(3) 两位符号位：这种方法是将一位符号位改为两位符号位表示：正数符号为 00，负数符号为 11。那么前面的例子就会变为：因为溢出只发生在两个正数或者两个负数相加的时候，所以两个操作数的符号要么都是 00（正数），要么都是 11（负数）。如果是 00，结果应该也是 00（正数），但是图里结果却是 01，说明发生了溢出，而且是上溢；如果是 11，结果应该也是 11（负数），但是图里结果却是 10，说明发生了溢出，而且是下溢。也就是说，当我们发现操作数的符号与结果数的符号相异的时候，就可以断定这个操作发生了溢出。同理，我们回过头看第一个没有溢出的例子：第一个式子其实一眼就可以断定不会溢出，但我们还是用上面的方法判断一下。操作数符号一个是 00，一个是 11，结果数符号是 00+11=11，所以这是正确的，没有溢出发生；第二个式子，操作数符号都是 00，结果数符号也是 00，所以这个式子也没有发生溢出（尽管是两个正数相加，但是并没有超出最大范围）。参考：https://www.bilibili.com/video/av66952721]]></content>
      <categories>
        <category>Computer System</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统cp1：存储单位、数制、编码]]></title>
    <url>%2F2019%2F09%2F16%2FCB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%2F</url>
    <content type="text"><![CDATA[1.存储单位位：即 bit，表示二进制位，要么是 0 ，要么是 1。它是计算机内部数据存储的最小单位。比如 11010100 共有8个二进制位，是一个8位二进制数。字节：即 byte，它由8个二进制位构成，即 1byte=8bit，是计算机内部计量的基本单位。一个英文字符占1个字节（8位），一个汉字占2个字节（16位）字：即word，它由若干个字节构成，是计算机内部进行数据处理和运算的基本单位。字的总的位数称为字长，不同档次的计算机字长是不一样的，比如32位机，它的1个字由4个字节构成，字长为32位，也就是说其CPU一次操作处理的实际位数是32位。同理，64位机可以处理64位。由此可见，计算机的字长越大，其性能越优越。KB，MB：1024byte = 1KB，1024KB = 1MB。往上还有GB，TB。PS：数据传输大多以 bit 为单位，比如我们常说的网速100M/s，M/s其实Mbit/s，也就是兆比特每秒，我们还可以写成100Mbps。2.数制2.1 定义数制也叫进制/进位制，是人们规定的一种进位方法。对于任何一种进制 —— X 进制，就表示某一位置上的数运算时是逢 X 进一位。比如，十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x 进制就是逢 x 进位。2.2 常见制和相关概念进位制二进制八进制十进制十六进制进位规则逢二进一逢八进一逢十进一逢十六进一基数281016数码0,10,1…70,1…90,1…9,A…F位权2^i8^i10^i16^i前缀0b0o无0x后缀BODH例如，16进制数101可以表示为101H、(101)下标16，或者0x101。2.3 数制之间的对应关系2.4 数制之间的转换x 转十：按权展开求和，比如二进制101对应十进制是1x2²+0x2¹+1x2º十转 x：整数部分，除X取余，倒序；小数部分，乘X取整，正序。二转八/十六：以小数点为界，分别向左向右分成三位一组，不够三位补0，分组后对应成八进制数；二转十六同理，只是四位一组。八/十六转二：每一位八进制数转化为对应的三位二进制数；十六转二同理，只是四位二进制数。PS：八进制和十六进制之间不能直接转换，八进制需要先转成二进制或十进制，在由对应的二进制或十进制转成十六进制，反过来也一样。3.编码3.1 数字编码数字编码在深入理解计算机系统cp2：定点数的表示和运算中再进行详细介绍。3.2 BCD码3.2.1 什么是 BCD码？用四位二进制数来表示一位十进制数，称为二–十进制编码，简称 BCD（Binary Coded Decimal）码。3.2.2 为什么需要 BCD码？BCD 码其实是为了处理十进制转化为二进制的问题而存在的。前面我们介绍了二进制与十进制之间的转换，但这种转换对计算密集型应用友好，对输入/输出密集型应用则不友好 —— 因此设计了 BCD码。拿 8421BCD码 举例，它将 0~9 一一映射为一个四位二进制数，从而做到快捷转换。比如， 321 的 8421BCD码 直接就是 0011 0010 0001，而无需再想之前那样乘2取余的麻烦运算。3.2.3 8421BCD码BCD码有很多，比如 8421BCD码，余三码等，这里我们只讲第一种。具体的对应关系如下：注意：8421BCD码 只有 0000～1001 共十个，而 1010、1011…等等不是8421BCD码。3.3 字符编码3.3.1 为什么需要字符编码？计算机只能理解0和1，无法理解英文、字母、汉字和其他特殊字符，这些字符需要经过编码才能成为计算机可以理解的二进制数。由字符到二进制数称为编码，反过来则是解码。从字符到二进制数，需要有一个一一对应的映射，这个映射通过编码规则来实现。通常所说的编码其实包括编码+字符集（即字符的集合体），比如 Unicode 字符集，就有 UTF-8，UTF-16 等多种编码。3.3.2 编码规则的演变ASCII：1) /ˈæski/，即 American Standard Code for Information Interchange，美国信息交换标准代码。本来一个字节有8位，每一位有0和1两种状态，则一个字节共有2^8=256种状态，可以表示256种字符。但是美国佬比较自私，觉得只要可以表示自己的字母和一些特殊字符就足够了，所以 ASCII 没有占用最高位（而是固定为0），实际只用到了后面7位，它可以表示 2^7=128 种状态，也就是表示128个字符。2) 很显然，这用来表示字母是足够的，但要想表示其它语言的字符，128还是太少了。PS：附送 ASCII 对照表一张：GB2312：1) 既然美国佬只解决了字母和特殊符号的编码问题，那么我们中国人只好实现自己的编码，从而来表示汉字了。所以这时候出现了 GB2312 编码（国标码）。2) 问题：不幸的是，各个国家都是这么想的，所以小日本有了 Shift_JIS 编码，棒子有了 Euc-kr 编码…..一时之间各国都有了自己的标准，那么对于一个多语言混合的文本来说，存在着不同的编码规则，最终必然导致乱码。Unicode：1) Unicode 解决了编码统一的问题。每种语言的每个字符在 Unicode 的规则下，都只有统一且唯一的对应二进制编码。它的表示方法是U+[16进制数]。例如，大写字母 A 编码为 U+0041，汉字“严”编码为 U+4E25。2) 问题：Unicode 一般用2个字节（也就是16位）表示一个字符，这在表示 ASCII 字符的时候会出现问题。我们知道，ASCII 字符实际只需要一个字节就够了，并且最高位甚至都还不需要用到，但是 Unicode 又规定表示一个字符至少需要2个字节，那么一个 ASCII 字符前面就必须要补0以满足这个规则，例如字母 A 就需要用 00000000 01000001 表示，这些多余的0是一个极大的资源浪费。UTF-8：1) UTF：实际传输过程中，基于不同的系统平台，对 Unicode 会有不不同的实现方式，其实现方式称为 Unicode Transformation Format，即 UTF。2) 作为 Unicode 的一种实现方式，UTF-8 展现了一定的灵活性——它是一种变长编码，会根据具体字符来改变所需要的表示字节。其编码规则只有两条：i&gt;. 对于 128 个 ASCII 字符只需一个字节表示，字节的第一位补 0，后面 7 位为这个字符的 ASCII 二进制数。Unicode 范围为 U+0000 至U+007F。ii&gt;. 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码二进制数。Unicode 范围由 U+0080 起。也可以看下面这张图：以汉字“严”为例，演示如何实现 UTF-8 编码。“严”的 Unicode 是 U+4E25（二进制数 100111000100101），据表，U+4E25 处在第三行的范围内（U+0800 ~ U+FFFF），因此“严”的UTF-8 编码需要三个字节，即格式 1110xxxx 10xxxxxx 10xxxxxx。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的 x，多出的位补 0。这样就得到 UTF-8 编码（二进制）是 11100100 10111000 10100101，转换成十六进制就是 E4B8A5。参考：https://segmentfault.com/a/1190000005936800https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896]]></content>
      <categories>
        <category>Computer System</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法笔记:cp1]]></title>
    <url>%2F2019%2F09%2F10%2FCB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp1%2F</url>
    <content type="text"><![CDATA[1.数据结构1.1 基本概念：数据元素：也称为记录，是数据的基本单位。比如把动物看作数据，那么数据元素指的就是牛、羊、马等。数据项：这是数据的最小单位，多个数据项构成了一个数据元素。比如把牛看作数据元素，那么数据项指的就是牛的年龄、体态等。数据对象：这是数据的子集，表示性质相同的数据元素的集合。所谓性质相同，指的是各数据元素之间有相同数目和类型的数据项。数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。结构，指的就是这些元素互相之间的关系，这是重点。1.2 分类：逻辑结构（思路）：从广义上分为线性结构和非线性结构。非线性结构：集合（同在一块）、树（一对多）、图（多对多）；线性结构：表、栈、队列、串、数组物理/存储结构（实现）：顺序存储结构链接存储结构索引存储结构散列存储结构1.3 抽象数据类型 ADTADT 即 Abstract data type，抽象数据类型的三个主体是数据对象 + 关系 + 操作。我们可以用下面的格式描述抽象数据类型：ADT 抽象数据类型名{ 数据对象：it is..... 数据关系：they are..... 基本操作： 操作1：done sth.... 初始条件：.... 操作结果：.... 操作2：done sth.... 初始条件：.... 操作结果：.... } ADT 抽象数据类型名 2.算法2.1 基本特性：有穷性（时间有穷、步骤有穷）、确定性（没有歧义）、可行性、输入、输出2.2 优劣标准：正确性（至少可以得到正确结果，对于非法输入也应有提示）、可读性、健壮性、高效性（时间 + 空间）2.3 时间复杂度一个算法的执行总时间应该等于每条语句执行时间之和，假定执行时间都为单位 1，那么则等于语句总数，同时我们只考虑耗时长的操作语句 —— 即基本操作语句，那么基本操作语句的执行次数（语句频度）就可以在某种关系上反映算法的执行总时间。大 O 表示法：给定问题规模 n 以及关于 n 的函数 f(n)，其中，f(n) 代表基本语句执行次数。那么，时间复杂度 T(n) = O(f(n))，它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同。大 O 阶推导（分析时间复杂度）：找出语句频度最高的基本语句；基于该语句的频度推导出对应的 f(n)；取 f(n) 的数量级得到最终的 f(n)。这意味着允许我们忽略低次幂和最高次幂的系数。经过大 O 阶推导，可以得到常数阶、平方阶、对数阶等。需要注意的是，当算法可以在常数时间内完成时（与问题规模无关），其时间复杂度依然是常数阶 O(1)。2.4 空间复杂度空间复杂度 S(n)=O(f(n))，其中，n 为问题规模，f(n) 表示关于 n 所占存储空间的函数。若算法执行时所需的辅助空间相对于问题规模来说是一个常数，则称此算法为原地工作，空间复杂度为 O(1)。也就是说，不管我问题规模多大，所需要的辅助空间始终是固定的。比如下面两个算法：//算法1 for(i = 0;i &lt; n/2;i++){ t = a[i]; a[i] = a[n-i-1]; a[n-i-1] = t; } //算法2 for(i = 0;i &lt; n;i++) b[i] = a[n-i-1]; for(i = 0;i &lt; n;i++) a[i] = b[i]; 对于算法1，不管问题规模多大，总是只需要一个临时变量 t 暂存值即可，因此其空间复杂度为 O(1)；对于算法2，采用的是逆序输出原数组到新数组中，之后再覆盖原数组，很显然，随着 n 的增大，新数组要求的存储空间也要增大，所以其空间复杂度为 O(n)。]]></content>
      <categories>
        <category>Data Structures/Algorithms</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue生命周期与钩子函数]]></title>
    <url>%2F2019%2F09%2F08%2FF-Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1.Vue 生命周期Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载 dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。2.Vue 生命周期函数Vue 的生命周期共有 8 个阶段，即创建前/后, 载入前/后,更新前/后,销毁前/销毁后，并对应地有很多钩子函数，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。3.Vue 生命周期图Vue 官网图片：4. Vue 生命周期进程根据上面的图来分析 Vue 生命周期的进程：1.实例化 Vue（组件）对象，确定 this 指向 Vue 实例2.初始化事件（events）和生命周期（cycle）3.beforeCreate 函数这一阶段，虽然 Vue 对象已经创建，但是它的属性还没有绑定，诸如 data、computed 这些属性还没有赋值。所以 $el,$data 以及 message 都是 undefined。4.初始化注入和响应这一阶段，Vue 对象的属性注入绑定，完成属性赋值。5.Created 函数这一阶段可以访问数据，但是还没有挂载 dom，不能访问到 $el。因为这个原因，此时改变数据不会触发 updated 函数。6.两次判断这个阶段会进行两次判断：判断对象是否有 el 选项如果有则继续向下编译；如果没有则停止编译，也即停止生命周期，直到在实例上再次调用 vm.$mount(el) 才会继续向下编译判断 el 是否有 template 模板如果有则将该模板编译为渲染函数，最后渲染出来；如果没有则直接调用 $el 的 outerHTML 进行渲染。另外，如果 Vue 对象中有渲染函数（render function），则它会优先于 template 进行渲染。综上，优先级是：render function &gt; template &gt; outerHTML7.beforeMount 函数这个阶段，this.$el 有值，但是数据还没有挂载到页面上，`{{}}` 还没有被替换8.用vue对象的数据（属性）替换模板中的内容9.mounted 函数模板编译完成，数据挂载完毕，页面上已经能够看到正确的数据了。10.beforeUpdate 函数数据更新后首先触发该函数，但更新的只是数据，innerHTML 尚未更新11.虚拟 dom 重新渲染并打补丁12.updated 函数这一阶段，innerHTML 已经得到更新。PS：这里解释一个问题。在 beforeUpdate 函数中访问 this.$el，innerHTML 时得到的是旧数据，这是正常的;但访问 this.$el 的时候，得到的却是新数据，这是因为：1.console.log 是异步的，我们期望打印的时候是打印那一刻的快照，但实际上它不能做到这一点，所以在后面点击展开 this.$el 的内容时，实际上只能访问到最新更新的对象；2.this.$el 保存的是对象的引用。13.beforeDestroy 函数这一阶段，实例还没有销毁，仍然完全可用14.销毁实例14.destroyed 函数实例销毁之后调用该函数，使 Vue 实例指示的所有东西解绑定，所有的监听器被移除，所有的子实例销毁。5.通过控制台观察生命周期的过程&lt;!DOCTYPE html> &lt;html> &lt;head> &lt;title>&lt;/title> &lt;script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app"> &lt;p>{{ message }}&lt;/p> &lt;/div> &lt;script type="text/javascript"> var app = new Vue({ el: '#app', data: { message : "Vue" }, beforeCreate: function () { console.group('beforeCreate 创建前状态===============》'); console.log("%c%s", "color:red" , "el : " + this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, created: function () { console.group('created 创建完毕状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, beforeMount: function () { console.group('beforeMount 挂载前状态===============》'); console.log("%c%s", "color:red","el : "); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, mounted: function () { console.group('mounted 挂载结束状态===============》'); console.log("%c%s", "color:red","el : "); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, beforeUpdate: function () { console.group('beforeUpdate 更新前状态===============》'); console.log("%c%s", "color:red","el : "); console.log(this.$el); console.log("%c%s", "color:red","el.outerHTML : " + this.$el.outerHTML); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, updated: function () { console.group('updated 更新完成状态===============》'); console.log("%c%s", "color:red","el : "); console.log(this.$el); console.log("%c%s", "color:red","el.outerHTML : " + this.$el.outerHTML); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, beforeDestroy: function () { console.group('beforeDestroy 销毁前状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); }, destroyed: function () { console.group('destroyed 销毁完成状态===============》'); console.log("%c%s", "color:red","el : " + this.$el); console.log(this.$el); console.log("%c%s", "color:red","data : " + this.$data); console.log("%c%s", "color:red","message: " + this.message); } }); &lt;/script> &lt;/body> &lt;/html> 第一次渲染，可以在控制台看到：之后手动修改 message 的值为“Vue2”，可以在控制台看到：这里注意之前提到的 log 异步的问题，看 outerHTML 可以知道 beforeUpdate 的时候视图实际上还没有重新渲染。]]></content>
      <categories>
        <category>Front-end</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型判断]]></title>
    <url>%2F2019%2F08%2F06%2FF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[常用的数据类型判断方法typeoftypeof 操作符返回一个表示数据类型的字符串，它可以应付常规场景下的数据类型判断。对基本数据类型 undefined, boolean, string, number 和引用数据类型 function 都可以正确判断，但是对 null，数组，对象则统一返回 “object”。也就是说，typeof 不适合用来判断引用数据类型。var a = 1 typeof a // "number" var b = [1,2,3] typeof b // "object" var c = {} typeof c // "object" instanceofinstanceof 解决了上述问题，它的原理就是判断右操作数（通常是构造函数）的原型对象是否出现在左操作数（通常是实例）的原型链上，如果在则返回 true。据此可以判断引用数据类型具体是哪种类型。var b = [1,2,3] b instanceof Array // true var c = {} c instanceof Object // true 需要注意的是，instanceof 对于不是通过 new 创建的基本数据类型无法做出正确的判断：var a = 1 a instanceof Number // false 这是因为此时的 a 仅仅是一个基本类型的值，而不是实例对象，如果我们通过 new 创建 a，那么就能正确判断var a = new Number(1); a instanceof Number // true 结合 instanceof 的原理其实就很好理解其中原因了。&gt;&gt; 另外要注意，instanceof 这个方法并非百试百灵 —— 假定脚本中有多个全局环境，例如 html 中有多个子 iframe，那么对于每一个全局环境而言，它都有自己版本的构造函数，进而有自己版本的原型链。instanceof 左右两边的操作数来自于不同全局环境时，即使实例和构造函数对应，也只会返回 false。Object.getPrototypeOf()let arr = [1，2]; console.log(Array.prototype.isPrototypeOf(arr)); // true 利用原型链。存在同上问题。isPrototypeOf()let arr = [1，2]; console.log(Object.getPrototypeOf(arr) === Array.prototype); // true 利用原型链。存在同上问题。Object.prototype.toString.call()let arr = [1，2]; `Object.prototype.toString.call(arr)`; //"[object Array]" 这个方法基本很完善，原理就是：在任何值上调用 Object 原生的 toString() 方法，都会返回一个格式为 [object NativeconstructorName] 的字符串。据此可以准确判断任何值的数据类型。这里注意几个点：arr 作为对象，也是 Object 的一个实例，为什么不直接使用 arr.toString()？这是因为它的这个方法被重写了，即 Array.prototype.toString()。在使用 arr.toString() 的时候，它优先在原型链上找到并调用了重写的方法，最后输出的是 &quot;1,2&quot;。对象字面量调用 toString() 的时候则依然输出 &quot;[object Object]&quot;，这是因为它没有重写这个方法，所以找到的是 Object.prototype 的该方法。同样的，函数对象的 toString() 方法也被重写了，即 Function.prototype.toString()。调用的时候返回一个表示当前函数源代码的字符串。当对内置函数对象调用该方法时，返回如下格式的字符串：Object.toString(); // "function Object() { // [native code] // }" Array.toString(); // "function Array() { // [native code] // }" 实际上，这里的 Object 是构造函数，既然是函数，就可以看作是 Function 构造函数实例化的对象，因此这里相当于函数对象调用了 toString() 方法，也就是调用的 Function.prototype.toString() 方法。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call() 和 apply() 的相关介绍和应用场景]]></title>
    <url>%2F2019%2F08%2F05%2FF-call%2Capply%E5%92%8Cbind%2F</url>
    <content type="text"><![CDATA[基本语法：fun.call(thisArg, param1, param2, ...) fun.apply(thisArg, [param1,param2,...]) fun.bind(thisArg, param1, param2, ...) 返回值call() 和 apply() 返回函数应该返回的值，bind() 返回一个经过硬绑定的新函数。参数介绍：第一个参数为 thisArg，其取值有以下几种情况：不传/ 传null/ 传undefined：非严格模式下，this 指向 window 对象；严格模式下指向 undefined；传递基本类型：this 指向其对应的包装对象，如 String、Number、Boolean传递一个对象：函数中的 this 指向这个对象第二个参数有以下几种情况：不传/ 传null/ 传undefined：表示不需要传入任何参数call() 和 bind() 的第二个参数都是参数列表，而 apply() 则是参数数组（或者类数组）—— 尽管如此，在这些参数传递给调用函数时，仍然是以参数列表的形式传递的（这一点很重要）。执行call() 和 apply() 一经调用则立即执行函数，而 bind() 则只是完成了函数的 this 绑定。因为函数不会立刻执行，所以适合在事件绑定函数中使用 bind() ，这样既完成了绑定，也确保了仅当事件触发时才执行函数。应用场景在这篇文章说过，call()，apply() 和 bind() 都可以改变 this 的指向，什么时候需要改变 this 的指向呢？大部分时候其实是为了借用方法，即在对象上调用其自身不具备的方法。看一下下面的例子：1.判断数据类型利用 Object.prototype.toString.call() 可以准确地判断数据类型，如：var a = "abc"; var b = [1,2,3]; Object.prototype.toString.call(a) == "[object String]" //true Object.prototype.toString.call(b) == "[object Array]" //true 原理就是：在任何值上调用 Object 原生的 toString() 方法，都会返回一个格式为 [object NativeconstructorName] 的字符串。据此可以准确判断任何值的数据类型。既然 Array 和 Function 都继承了 Object 的该方法，为什么不直接在它们身上调用？这是因为 toString() 被重写过了，不是原生方法，因此这里改为调用 Object 的该方法，并将 this 绑定给对应的值。2.模拟浅拷贝模拟浅拷贝的过程中，需要剔除原型链上的属性，考虑到源对象可能基于 Object.create() 创建，而这样的对象是没有 hasOwnProperty() 方法的，因此我们不在源对象身上直接调用该方法，而是通过 Object.prototype.hasOwnProperty.call() 的方式去调用，因为 Object 一定是有这个方法的，我们可以借用一下。if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) { to[nextKey] = nextSource[nextKey]; } 3.继承JavaScript 的几种继承方式中，有一种就是借用构造函数：假设有子构造函数 Son 和父构造函数 Parent。对于 Son 而言，其内部的 this 将指向稍后实例化的对象，利用这一点，我们在 Son 的内部通过 call() 或者 apply() 调用 Parent，同时传参 this，这样就可以增强子类实例。4.类数组借用数组的方法例如 arguments 是类数组，并不具备数组的 forEach() 方法，那么我们可以通过 call() 调用数组的该方法，同时将方法里面的 this 绑定到 arguments 上：Array.prototype.forEach.call(arguments,function(item){ console.log(item); }); 5.求数组的最值核心是 apply() 可用于展开数组，即我们前面说过的将参数数组转化为参数列表。例如我们要求一个数组的最大值，虽然 Math 对象有 max() 方法，但该方法只接受参数列表。那么这时候，我们可以通过 apply() 去调用该方法，从而展开数组var arr = [2,3,1,5,4]; Math.max.apply(null,arr);// 5 参考：https://www.cnblogs.com/onepixel/p/6034307.htmlhttps://juejin.im/post/5d469e0851882544b85c32ef]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript 高级程序设计》阅读笔记 1：最佳实践]]></title>
    <url>%2F2019%2F08%2F03%2FF-JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[可维护性可维护性包括：可理解性、直观性、可适应性、可扩展性和可调试性代码约定：可读性（缩进、注释）；变量和函数命名（有意义的命名）；变量类型透明（var a =null var a = iSpeed）松散耦合：HTML 或者 CSS 与 JavaScript 的解耦（如 CSS 仍然保留样式信息，通过改变类名来改变样式）；事件监听器和应用逻辑的解耦（监听器只发挥监听作用，而将应用逻辑独立成可以复用的函数）编程实践：尊重对象所有权（尽量不要改动原生对象）；尽量避免创建全局变量和函数；避免与 null 比较使用常量性能优化优先使用局部变量。根据作用域链查找的原理，访问全局变量速度会较慢避免 with 语句。会延长作用域链长度避免多次的属性查找。属性查找涉及原型链的追溯，花费时间长优化循环：减值迭代、简化终止条件、简化循环体、使用 do...while...、展开循环使用数组字面量和对象字面量最小化现场更新。对于已经加载出来的 dom 的直接操作（现场更新）会影响性能，可以考虑在新建的 fragment 文档片段中进行修改，之后只进行一次现场更新。innnerHTML 比普通的创建 dom 节点的方法更快同胞节点有相同的事件时利用事件委托冒泡给父节点，父节点的事件监听器里结合 switch 进行 event.target 判断访问 HTMLCollection 的属性或者方法时，都是在文档上进行查询，这个过程会有性能开销，应该最小化访问 HTMLCollection 的次数。例如可以将 for 循环的终止条件判断保存在一个值里，而不是每次都重新计算一次。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解析赋值、浅拷贝和深拷贝]]></title>
    <url>%2F2019%2F07%2F11%2FF-%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[1.相关数据结构堆（stack）和栈（heap）都是内存中划分出来用来存储的区域。栈数据结构栈遵循后进先出（LIFO），执行上下文的基础结构就是栈。堆数据结构堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的 key-value 可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。队列数据结构队列遵循先进先出（FIFO），事件循环的基础结构就是队列。2.数据类型2.1 基本数据类型：js 有 6 种基本数据类型：undefined，null，boolean，number，string，symbol基本数据类型在内存中分别占有固定大小的空间，所以都是保存在栈内存中的（闭包的自由变量是例外，其保存在堆内存中，因此 context stack 销毁后依然存在）基本数据类型是按值访问的比较：值的比较2.2 引用数据类型：一般指的是 object对象在内存中的大小不固定，所以保存在堆内存中，又由于对象的地址大小固定，所以地址保存在栈内存中引用数据类型是按引用访问的。访问对象时，先从栈中读取内存地址，然后再根据这个地址找到堆中的对象比较：引用的比较3.赋值、浅拷贝和深拷贝的区别3.1 赋值赋值是将某一数值或对象赋给某个变量的过程，包括两种：基本数据类型：就是简单的赋值。因为在内存中开辟了一块新的栈空间，所以赋值之后两个变量独立、互不影响引用数据类型：赋址。实际操作的是对象内存的地址，最后使两个变量具有相同的引用，都指向同一个对象，因此这两个变量相互之间有影响3.2 浅拷贝定义：浅拷贝即 swallow copy，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是其内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。简而言之，浅拷贝的“浅”在于它的拷贝只停留在一层，即：拷贝第一层的基本类型值，以及第一层的引用类型地址。如图：拷贝第一层的基本类型值，以及第一层的引用类型地址。哪些地方是浅拷贝？Object.assign()Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，最后再将目标对象返回。let a = { author: "Jack", article: { title: "Understanding event loop", date: "2019-1-1" } } let b = Object.assign({}, a); console.log(b); /* { author: "Jack", article: { title: "Understanding event loop", date: "2019-1-1" } } */ a.author = "Bob"; a.article.date = "2019.2.1"; console.log(a); /* { author: "Bob", article: { title: "Understanding event loop", date: "2019-2-1" } } */ console.log(b); /* { author: "Jack", article: { title: "Understanding event loop", date: "2019-2-1" } } */ 可以看到，因为 a 和 b 有各自的基本类型属性，所以对这种属性的修改是独立的；但是由于 a 和 b 的引用类型属性指向内存中的同一个对象，所以 a 对该对象的修改会反映到 b 上，这是浅拷贝的特点。展开语法...展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者字符串在语法层面展开；还可以在构造字面量对象时, 将对象表达式按 key-value 的方式展开。let a = { author: "Jack", article: { title: "Understanding event loop", date: "2019-1-1" } } let b = {...a}; console.log(b); /* { author: "Jack", article: { title: "Understanding event loop", date: "2019-1-1" } } */ a.author = "Bob"; a.article.date = "2019.2.1"; console.log(a); /* { author: "Bob", article: { title: "Understanding event loop", date: "2019-2-1" } } */ console.log(b); /* { author: "Jack", article: { title: "Understanding event loop", date: "2019-2-1" } } */ Array.prototype.slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括 end ）决定的原数组的浅拷贝。原始数组不会被改变。let a = [0, "1", [2, 3]]; let b = a.slice(1); console.log(b); // ["1", [2, 3]] a[1] = "99"; a[2][0] = 4; console.log(a); // [0, "99", [4, 3]] console.log(b); // ["1", [4, 3]] 可以看到，因为 a 和 b 都有各自的基本类型属性，所以修改 a[1] 对 b 没有影响；但是由于 a 和 b 的引用类型属性指向内存中的同一个数组对象，所以对 a[2][0] 的修改会反映到 b 上。3.3 深拷贝定义：深拷贝即 deep copy，它会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。简而言之，深拷贝的“深”在于它的拷贝不仅仅停留在一层，而是连同里面的子对象也一同拷贝。如图：哪些地方是深拷贝？JSON.parse(JSON.stringify(object))对象（包括数组）的序列化和反序列化let a = { author: "Jack", article: { title: "Understanding event loop", date: "2019-1-1" } } let b = JSON.parse(JSON.stringfy(a)); console.log(b); /* { author: "Jack", article: { title: "Understanding event loop", date: "2019-1-1" } } */ a.author = "Bob"; a.article.date = "2019.2.1"; console.log(a); /* { author: "Bob", article: { title: "Understanding event loop", date: "2019-2-1" } } */ console.log(b); /* { author: "Jack", article: { title: "Understanding event loop", date: "2019-1-1" } } */ 改变 a.article.date 之后对 b 没有影响，可见这是深拷贝，a 和 b 有各自的 article 对象。不过，JSON.parse(JSON.stringify(object)) 有以下几个问题：1、会忽略 undefined2、会忽略 symbol3、会忽略函数（不能序列化函数）4、不能解决循环引用的对象5、不能正确处理 new Date()6、不能处理正则3.4 总结--和原数据是否指向同一对象第一层数据为基本数据类型原数据中包含子对象赋值是改变会使原数据一同改变改变会使原数据一同改变浅拷贝否改变不会使原数据一同改变改变会使原数据一同改变深拷贝否改变不会使原数据一同改变改变不会使原数据一同改变4.模拟实现 Object.assign() 的浅拷贝4.1 Object.assign() 浅拷贝的特点：如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后来的源对象的属性将类似地覆盖早先的属性；string、symbol、null 和 undefined 类型的属性都会被拷贝4.2 实现 Object.assign() 的基本思路：1、判断原生 Object 是否支持该函数，如果不存在的话创建一个 assign 函数，并使用 Object.defineProperty 将该函数绑定到 Object 上。2、判断参数是否正确（目标对象不能为空，我们可以直接设置 {} 传递进去,但必须设置值）。3、使用 Object() 转成对象，并保存为 to，最后返回这个对象 to。4、使用 for..in 循环遍历出所有可枚举属性，配合 hasOwnProperty 获取所有可枚举自有（非原型链上的）属性，再复制给新的目标对象。4.3 具体实现代码：下面是 MDN 上 assign() 的 polyfill（注意：此 polyfill 不支持 symbol 属性，因为 ES5 中根本没有 symbol）：if (typeof Object.assign != 'function') { // Must be writable: true, enumerable: false, configurable: true Object.defineProperty(Object, "assign", { value: function assign(target, varArgs) { // .length of function is 2 'use strict'; if (target == null) { // TypeError if undefined or null throw new TypeError('Cannot convert undefined or null to object'); } let to = Object(target); for (var index = 1; index &lt; arguments.length; index++) { var nextSource = arguments[index]; if (nextSource != null) { // Skip over if undefined or null for (let nextKey in nextSource) { // Avoid bugs when hasOwnProperty is shadowed if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) { to[nextKey] = nextSource[nextKey]; } } } } return to; }, writable: true, configurable: true }); } 4.4 重点注意经过测试，该模拟实现的 assign() 可以达到和原生 Object 的 assign() 一样的浅拷贝效果。下面说几个重点需要注意的地方：为什么使用 Object。defineProperty() 添加方法，而不是直接挂载？我们知道，for...in 可以遍历出自身以及原型链上的可枚举属性，而 Object.keys() 只能遍历出自身的可枚举属性for(var i in Object) { console.log(Object[i]); } // 无输出 Object.keys( Object ); // [] 可见，Object 的属性默认都是不可枚举的，但是，直接挂载在 Object 上面的属性却是可枚举的：Object.a = 1; for(var i in Object){ console.log(Object[i]); } // 1 Object.keys( Object ); // ["a"] 所以，只有 assign() 确实是可枚举属性时，才可以将其直接挂载在 assign() 上。但是， assign() 实际上是不可枚举的。我们可以使用 2 种方法查看 assign() 是否可枚举：Object.getOwnPropertyDescriptor()Object.propertyIsEnumerable()其中，后者会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable: true。具体用法如下：// 方法1 Object.getOwnPropertyDescriptor(Object, "assign"); // { // value: ƒ, // writable: true, // 可写 // enumerable: false, // 不可枚举，注意这里是 false // configurable: true // 可配置 // } // 方法2 Object.propertyIsEnumerable("assign"); // false 上面代码说明 Object.assign() 是不可枚举的。因此，这里适合用Object.defineProperty() 给 Object 添加属性，用这个方法时也可以不显式指定 enumerable 为 false，因为它默认就是 false。参数判断：if (target === undefined || target === null) { throw new TypeError('Cannot convert undefined or null to object'); } 上面这种参数判断也可以，但是由于 null 和 undefined 的相等性判断返回 true，所以实际上直接写 if(target == null) 即可为什么要用 Obejct() 将 target 参数包装成对象？正常情况下传入的参数应该是一个对象，但是模拟实现的时候需要考虑传入参数不一定为对象的情况。1.如果作为源对象的参数不是对象：null 和 undefined 会被忽略；除了这两者之外的原始类型则将被包装成对象，在这种情况下，只有自身拥有可枚举属性的包装对象才会被拷贝，其它类型的包装对象会被忽略var v1 = "abc"; var v2 = true; var v3 = 10; var v4 = Symbol("foo"); Object.keys( v1 ); // [ '0', '1', '2' ] Object.keys( v2 ); // [] Object.keys( v3 ); // [] Object.keys( v4 ); // [] // 可以看到，只有字符串类型的包装对象，才有自身的可枚举属性 var obj = Object.assign({}, null, undefined, v1, v2, v3, v4); // 只有 v1 会被拷贝 console.log(obj); // { "0": "a", "1": "b", "2": "c" } 2.如果作为目标对象的参数不是对象：同理，我们还要考虑 target 参数也可能不是对象的情况，所以在上面的 polyfill 中，要使用 Object() 将 target 参数包装成对象。为什么要用严格模式？使用 Object() 对参数进行包装后，对于得到的包装对象而言，其既有属性的 writable 为 false，也就是说不能对其既有属性进行改写，否则会报错var str1 = "abc"; var str2 = "def"; Object.assign(str1, str2); assign() 的内部实现中将 str1 和 str2 包装为对象，因此这两者在内部是这样的：// str1 { 0:"a", 1:"b", 2:"c" } // str2 { 0:"d", 1:"e", 2:"f" } Object.assign(str1, str2) 相当于用 str2 的同名属性依次覆盖 str1 的属性，从而实现拷贝。但是由于 str1 是用 Object() 进行包装的，所以这个拷贝是不生效的，会报错。但是，如果在 assign() 的实现内部不使用严格模式，则不会报错：var myObject = Object('abc'); Object.getOwnPropertyDescriptor(myObject, '0'); // { // value: 'a', // writable: false, // 注意这里 // enumerable: true, // configurable: false // } myObject[0] = 'd'; // 'd' myObject[0]; // 'a' 这里并没有报错，原因在于 js 对于不可写的属性值的修改静默失败，只有在严格模式下才会提示错误。为了实现正常的报错，我们必须在内部使用严格模式。为什么要用 Object.prototype.hasOwnProperty.call()？通过 for...in.. 得到的是源对象自身及其原型链上的可枚举属性，但浅拷贝只需要拷贝自身可枚举属性，所以需要用 hasOwnProperty() 筛选，但是直接调用这个方法是不行的。一方面，我们需要考虑到源对象可能重写了这个方法而导致其无法正常调用，另一方面还要考虑到源对象可能是基于 Object.create(null) 创建的，而这种方法创建的对象由于不具有与 Object 原型链的联系，因此不具有 hasOwnProperty() 方法，在调用的时候会报错。var myObject = Object.create( null ); myObject.b = 2; myObject.hasOwnProperty( "b" ); // TypeError: myObject.hasOwnProperty is not a function 所以，这里采用 Object.prototype.hasOwnProperty.call()，将 hasOwnProperty() 内部的 this 绑定到源对象上，也可以达到同样的效果。var myObject = Object.create( null ); myObject.b = 2; Object.prototype.hasOwnProperty.call(myObject, "b"); // true 参考：https://github.com/yygmind/blog/issues/25https://github.com/yygmind/blog/issues/26https://juejin.im/post/59ac1c4ef265da248e75892b#heading-13]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[大一下学期：The End]]></title>
    <url>%2F2019%2F06%2F30%2FT-%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End%2F</url>
    <content type="text"><![CDATA[本来应该是在年底做一些总结，然后写下明年的目标，但是我感觉这一年 —— 准确地说是这一学期过得太快，以至于给我一种好像 2019 年就要结束了的错觉。加上最近算是完成了一个阶段的学习，所以我想还是记录一下这个学期的事情。1.计划中的事完成得怎么样？之前规划了这学期要做的事，所以先来看这些事情对应的完成度和满意度：计划完成度满意度全国大英竞赛100%不满意信息素养比赛100%很满意四级考试的准备90%还行前端进阶系列文章40%还行阅读《JavaScript 高级程序设计》33%挺满意阅读《ES6 标准入门》30%还行找一个小项目做100%很满意完成 HTML5 和 CSS3 的学习90%挺满意阅读两本历史相关书籍0%不满意通关《巫师 3》100%很满意2.有什么想法和感受？其实这学期做的事情并不止上面那些。这里挑一些重要的说一下：比赛/考试： 大英竞赛是在上学期报的名，不过我并没有腾出时间做好充分的准备，所以最终的结果 —— 只是去打了一下酱油，没有获得任何奖项。这件事情让我觉得，对待一件事我应该更加慎重地做出选择。回想起来，我确实有很多次贸然地做出一些不合适的选择，而其中大部分仅是因为单纯的喜欢和一时的头脑发热，实际上很难确保自己可以百分百投入这件事。打酱油证书 信息素养比赛的体验很棒，多亏了给力的队友，合作过程很愉快。其实也是上学期的比赛了，那时候是初赛，天真的我们后来才意识到决赛需要找文献资料、需要做 PPT、需要演讲……我记得那段时间忙得不可开交，因为可供准备的时间真的不多。不过幸运的是，我们每个人各司其职，尽了自己最大的努力。本来想的是可以拿个三等奖就很棒了，最后拿了二等奖，所以还是蛮开心的（虽然奖金至今没有到账）。很多事情用心去做了，也许结果会比你想象的好很多。拿了二等奖，还不错 四级考试的准备过程基本就是刷真题，不过也确实是太久没做题了，第一次做的时候手感很生疏。现在让我像高三那样两周刷 25 套题基本办不到了。成绩 8 月份出来，预测不会太高，毕竟作文和听力真挺悬的。前端： 学习内容：这学期主要学 HTML5 和 CSS3（包括补充以前学习时遗漏的重点），同时继续钻研原生 JS 中的重难点（主要看前端进阶系列文章）以及 ES6 的新特性。这一块也确实不好啃，很多时候一个难点需要钻研几天，除了反复翻看国内外的博客，还需要向社区上的各位前辈请教，然后自己慢慢去理解和消化。虽然很耗时间，但我觉得这是值得的，因为学习本来就是要刨根问底，而不是浮于表面。 社区：在学习上得到了不少帮助，除了社区上的人，还有群里的小伙伴，真的很感谢他们。如果受助者能够反过来去帮助他人，那么就有可能形成一个良性循环，所以我选择加入了掘金翻译团队，并在平台（掘金/思否）上发布了一些译文。可能这些文章对于大佬们来说过于简单了，不过我依然希望能够帮到一些人，就像我之前从其他人的博客那里得到的帮助一样。事实上，翻译带给我的好处远比想象得多。除了提高英文阅读能力（因为我发现我越来越能够理解那些作者想要表达的东西），还能够知道对于同样的概念和知识，老外是以什么样的方式去理解和阐述的，不同的思维值得我们去学习和借鉴。另外，通过翻译还有机会接触到新的东西，例如之前译的一篇关于 AST 的文章，其实对于抽象语法树我只停留在“听过”的阶段，但是翻译过后，自己也多多少少有了一些概念，我想这是一件好事。掘金社区的氛围超棒虽然，也不乏一些冷嘲热讽的人：这让我想起了一年前给论坛汉化游戏的时候，底下也有评论说：“你汉化的这个东西辣鸡，没人用的，别浪费时间了”。在我看来，这都是一类人，他们看不惯一些东西，但是又没有能力去给作者提意见，所以只能就近找个分享者乱喷一通。但是仔细一看他们的话，其实漏洞百出，没有任何站得住脚的地方。而类似的事情在国外社区却从来没有遇到过（我只是说没遇到过，不是说没有），不管是在游戏领域还是在技术领域，很多老外都足够热心，尤其是那些领域的大牛，他们真的要谦逊多了。 项目：这学期最开心的事情就是终于有了自己的第一个开源项目，hexo-theme-PureBlue，也就是现在这个博客的主题。刚 release 的时候其实只能算是个雏形，不过，经过几个月的不断打磨和修改（github 上 74 次 commit 和 3 次 release）之后，无论是外观还是功能都完善了不少。这回也算是体验了从 0 到 1 慢慢打磨一个作品的过程（因为这个主题不是魔改的），最重要的是学到了不少知识，因此这个项目带给我的意义很大。比较成熟的 2.0 版本大部分的 contributions 来自于主题，也包括掘金翻译计划虽然只有一个 issue，但是自己做的东西有人用了，还是很开心（图中问题已修复hh）需要反思的地方是，我花费太多时间去修缮博客了。我发现群里很多人也有这种情况 —— 花了很多时间去打造皮囊，但是忽略了最重要的内容。所以，这里重要的事情说三遍： 不要忘记写博客的目的 不要忘记写博客的目的 不要忘记写博客的目的下半年会减少花费在这上面的时间，腾出更多时间学习新知识。后面有时间再考虑两件事：一是 vue 学得差不多之后移植到 vuepress 上；二是重构整个主题的代码，之前写得实在是太烂了，命名、结构、复用性等问题一大堆，现在维护很吃力，都和这些问题有关。阅读： 这学期读的书实在不多，仔细阅读过的就两本：高程 3 和 ES6，而且都还没看完。不过后来想了一下，或许看技术书籍的时候放慢速度也不是坏事，再加上中间各种各样的事情打断了阅读，所以这个结果也还能接受。高程 3 阅读起来还是很带劲的，因为作者思路很清晰，加上之前深入理解过一些难点，所以读的时候也少了很多迷茫；另一本是阮一峰老师的《ES6 标准入门》，ES6 多了很多新东西，虽然是语法糖，但是也有一定的学习成本。图书馆有这本书，不过只能续借两个月（还是三个月，忘了），而且不能批注，看起来实在不方便，所以后面会考虑买一本。 寒假的时候看了《以色列》这本书，对以色列这个国家有了和从前不一样的看法。我认为这是历史的一个作用，历史帮助我们去理解一个国家的行为，以及这个国家现在发生的事情。之后做了一份中东历史相关书单，本来打算这学期读一两本，但是心静不下来，于是作罢。至于说为什么心静不下来呢…这可能和我的焦虑有关。我大部分时候会脚踏实地地去学习，但依然会对前端知识体系的庞大和迭代速度之快（就像今年又出现了 Flutter 这个新东西）感到恐惧，这让我觉得每一分钟都很宝贵，不学则退。但是这种焦虑是好是坏呢？很难说。娱乐：这学期通关了三个游戏： 第一个是《巫师 3》。精彩的故事 + 饱满的人物 + 高度的游戏性，就连 dlc 也是经过精心打磨的，这是我心目中的满分神作无疑了。而且和其它游戏不同的是，主角不是真正意义上的救世主，游戏的世界观设定里有很多远比他更强大的存在，很多时候玩家可以深刻感受到主角的无力。dlc《血与酒》的最后，杰洛特和雷吉斯在篝火旁畅饮，聊过去、谈人生，玩家的旅途也就此画上了圆满的句号。 第二个是《刺客信条：大革命》。剧情其实早就知道，这次游玩单纯是为了回忆和弥补遗憾（之前由于电脑带不动，所以一直没玩），有很长一段时间没有接触这个系列了。玩下来觉得还可以，巴黎真的挺美的，跑酷也很爽，但是剧情中规中矩，没有让人眼前一亮。还有就是联机体验真心差，和几个基友玩的时候基本是连不上的。想起来还真的是很怀念二代和四代，那时候游戏里的一幕幕至今依然印象深刻。 最后一个是《耻辱 2》，打折的时候入的。这个系列吸引我的就是其独特的蒸汽朋克风格和巧妙的关卡设计，真的很赞。作为一个潜入游戏，采用第一人称视角而且还做得这么成功的的确是只此一家。关卡设计在本作达到了巅峰：一个是[机关宅邸]，整座房子都是机动的，而玩家需要在其中周旋、寻找目标；另一个是[石板上的裂缝]，虽然身处相同的空间，但是却可以游走于不同的时间，通过回到过去清除障碍物，可以开辟现在的道路，甚至在被过去的敌人追杀时还可以选择回到现在躲避，这种巧妙的设计真的出现在游戏里时，不得不说很惊喜。剧情就是：上位 =&gt; 篡位 =&gt; 上位，是有点老套没错，不过不影响它是神作。另外感觉这个游戏塑造的世界真的挺叫人绝望的，第一部是鼠疫，这一部又是飞蝇，而且周围看起来一片民不聊生，可以说比巫师 3 的世界还惨了。不过，我也能很明显地感到自己对游戏的热情没有以前那么大了。以前玩游戏没有节制，但是现在能够很轻松地脱身；以前会去折腾游戏汉化，钻研游戏玩法，甚至因为别人吐槽自己喜欢的游戏而撕逼一场，但现在真的没心思弄这些了，因为累，因为网络上大部分的交流没有任何意义（当然，不包括编程方面的）；偶尔还会关注有什么新游戏或者打折优惠，但说实在的，玩的欲望不大。原本我以为对游戏的热爱会持续很久，不过现在看来并不是这样。大概随着人的成长，曾经热爱的事物反而会带来疲倦感吧。3.下半年要做什么？按照惯例，写下下半年的计划：3.1.输入： 前端：熟练掌握各种效果的实现（CSS，JavaScript）重点学习 vue 框架跟着前端进阶系列，每周攻破一个 JavaScript 重难点学习 Bootstrap学习 stylus（可能会考虑翻译一下官方文档） 技术书籍：《JavaScript 高级程序设计》+ 读书笔记《ES6 标准入门》《你不知道的 JavaScript》上下卷（考虑英文版）《深入理解 ES6》 计算机基础：数据结构以及深入理解计算机系统。这两块说实话我一直是挺畏惧的，因为很难。但有一位大佬曾经说过：“当一个程序员对英语和底层感到恐惧的时候，他的生涯就已经到了尽头。”我对英语并不恐惧，所以我希望我也能成为一个对底层不恐惧的人，哪怕这是一个艰巨的挑战，但我想要去克服它。 更加广泛的涉猎：阅读产品、历史以及个人软技能提高的相关书籍3.2.输出： 翻译： 每周保质保量，至少输出 1~2 篇翻译。输入源：国外博客网站以及 RSS；输出源：个人博客、掘金、SegmentFault。 项目和比赛：开发一个小程序，不需要太复杂，只做练手希望可以和小伙伴们参加一些比赛（感觉大一错失了很多机会） 培训： 培训下一届的小伙伴们，希望可以找到真心热爱前端的人。4.喜欢的事就坚持下去吧喜欢的事就是你愿意投入 100% 精力去做的事，对于我来说就是前端。学习前端一年了，和很多这时候早已经学习了框架的人比较，我确实是在慢慢前行。“到底哪一种比较好？是快速上手，还是即使耗时耗力也不放过每一个疑惑的知识点？”这个问题我无数次地问过自己和别人，但是每一次都没有确切的答案。这是因为，这个问题只有提问者能够回答，而且需要在自学的过程中慢慢去寻找答案。我现在可以告诉自己：没有孰优孰劣，只有合不合适。很多人学东西很快，甚至什么都学，不管是天赋使然，还是浮躁使然，我都不喜欢这种方式。对我来说，最舒服的方式是彻底弄懂一个知识点，即使辗转反侧，但是这个过程充满探索性，充满各种求问和佐证，我很享受。而这些显然是速成和培训班不能带来的。所以一句话：对于喜欢的事，不要顾虑太多，不要陷入浮躁，有个明确的学习方向，然后脚踏实地坚持下去就可以了。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「译」编写更好的 JavaScript 条件式和匹配条件的技巧]]></title>
    <url>%2F2019%2F06%2F24%2FTrs-%E6%9B%B4%E5%A5%BD%E7%9A%84JavaScript%E6%9D%A1%E4%BB%B6%E5%BC%8F%E5%92%8C%E5%8C%B9%E9%85%8D%E6%A0%87%E5%87%86%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[原文地址：Tips and Tricks for Better JavaScript Conditionals and Match Criteria原文作者：Milos Protic译者：Chor介绍如果你像我一样乐于见到整洁的代码，那么你会尽可能地减少代码中的条件语句。通常情况下，面向对象编程让我们得以避免条件式，并代之以继承和多态。我认为我们应当尽可能地遵循这些原则。正如我在另一篇文章 JavaScript 整洁代码的最佳实践里提到的，你写的代码不单单是给机器看的，还是给“未来的自己”以及“其他人”看的。从另一方面来说，由于各式各样的原因，可能我们的代码最终还是会有条件式。也许是修复 bug 的时间很紧，也许是不使用条件语句会对我们的代码库造成大的改动，等等。本文将会解决这些问题，同时帮助你组织所用的条件语句。技巧以下是关于如何构造 if...else 语句以及如何用更少的代码实现更多功能的技巧。阅读愉快！1. 要事第一。小细节，但很重要不要使用否定条件式（这可能会让人感到疑惑）。同时，使用条件式简写来表示 boolean 值。这个无须再强调了，尤其是否定条件式，这不符合正常的思维方式。不好的：const isEmailNotVerified = (email) => { // 实现 } if (!isEmailNotVerified(email)) { // 做一些事... } if (isVerified === true) { // 做一些事... } 好的：const isEmailVerified = (email) => { // 实现 } if (isEmailVerified(email)) { // 做一些事... } if (isVerified) { // 做一些事... } 现在，理清了上面的事情后，我们就可以开始了。2. 对于多个条件，使用 Array.includes假设我们想要在函数中检查汽车模型是 renault 还是 peugeot。那么代码可能是这样的：const checkCarModel = (model) => { if(model === 'renault' || model === 'peugeot') { console.log('model valid'); } } checkCarModel('renault'); // 输出 'model valid' 考虑到我们只有两个模型，这么做似乎也还能接受，但如果我们还想要检查另一个或者是几个模型呢？如果我们增加更多 or 语句，那么代码将变得难以维护，且不够整洁。为了让它更加简洁，我们可以像这样重写函数：const checkCarModel = (model) => { if(['peugeot', 'renault'].includes(model)) { console.log('model valid'); } } checkCarModel('renault'); // 输出 'model valid' 上面的代码看起来已经很漂亮了。为了更进一步改善它，我们可以创建一个变量来存放汽车模型：const checkCarModel = (model) => { const models = ['peugeot', 'renault']; if(models.includes(model)) { console.log('model valid'); } } checkCarModel('renault'); // 输出 'model valid' 现在，如果我们想要检查更多模型，只需要添加一个新的数组元素即可。此外，如果它很重要的话，我们还可以将 models 变量定义在函数作用域外，并在需要的地方重用。这种方式可以让我们集中管理，并使维护变得轻而易举，因为我们只需在代码中更改一个位置。3. 匹配所有条件，使用 Array.every 或者 Array.find在本例中，我们想要检查每个汽车模型是否都是传入函数的那一个。为了以更加命令式的方式实现，我们会这么做：const cars = [ { model: 'renault', year: 1956 }, { model: 'peugeot', year: 1968 }, { model: 'ford', year: 1977 } ]; const checkEveryModel = (model) => { let isValid = true; for (let car of cars) { if (!isValid) { break; } isValid = car.model === model; } return isValid; } console.log(checkEveryModel('renault')); // 输出 false 如果你更喜欢以命令式的风格行事，上面的代码或许还不错。另一方面，如果你不关心其背后发生了什么，那么你可以重写上面的函数并使用 Array.every 或者 Array.find 来达到相同的结果。const checkEveryModel = (model) => { return cars.every(car => car.model === model); } console.log(checkEveryModel('renault')); // 输出 false 通过使用 Array.find 并做轻微的调整，我们可以达到相同的结果。两者的表现是一致的，因为两个函数都为数组中的每一个元素执行了回调，并且在找到一个 falsy 项时立即返回 false。const checkEveryModel = (model) => { return cars.find(car => car.model !== model) === undefined; } console.log(checkEveryModel('renault')); // 输出 false 4. 匹配部分条件，使用 Array.someArray.every 匹配所有条件， Array.some 则可以轻松地检查我们的数组是否包含某一个或某几个元素。为此，我们需要提供一个回调并基于条件返回一个布尔值。我们可以通过编写一个类似的 for...loop 语句来实现相同的结果，就像之前写的一样。但幸运的是，有很酷的 JavaScript 函数可以来帮助我们完成这件事。const cars = [ { model: 'renault', year: 1956 }, { model: 'peugeot', year: 1968 }, { model: 'ford', year: 1977 } ]; const checkForAnyModel = (model) => { return cars.some(car => car.model === model); } console.log(checkForAnyModel('renault')); // 输出 true 5. 提前返回而不是使用 if...else 分支当我还是学生的时候，就有人教过我：一个函数应该只有一个返回语句，并且只从一个地方返回。如果细心处理，这个方法倒也还好。我这么说也就意味着，我们应该意识到它在某些情况下可能会引起条件式嵌套地狱。如果不受控制，多个分支和 if...else 嵌套将会让我们感到很痛苦。另一方面，如果代码库很大且包含很多行代码，位于深层的一个返回语句可能会带来问题。现在我们都实行关注点分离和 SOLID 原则，因此，代码行过多这种情况挺罕见的。举例来解释这个问题。假设我们想要显示所给车辆的模型和生产年份：const checkModel = (car) => { let result; // 首先，定义一个 result 变量 // 检查是否有车 if(car) { // 检查是否有车的模型 if (car.model) { // 检查是否有车的年份 if(car.year) { result = `Car model: ${car.model}; Manufacturing year: ${car.year};`; } else { result = 'No car year'; } } else { result = 'No car model' } } else { result = 'No car'; } return result; // 我们的单独的返回语句 } console.log(checkModel()); // 输出 'No car' console.log(checkModel({ year: 1988 })); // 输出 'No car model' console.log(checkModel({ model: 'ford' })); // 输出 'No car year' console.log(checkModel({ model: 'ford', year: 1988 })); // 输出 'Car model: ford; Manufacturing year: 1988;' 正如你所看到的，即使本例的问题很简单，上面的代码也实在太长了。可以想象一下，如果我们有更加复杂的逻辑会发生什么事。大量的 if...else 语句。我们可以重构上面的函数，分解成多个步骤并稍做改善。例如，使用三元操作符，包括 &amp;&amp; 条件式等。不过，这里我直接跳到最后，向你展示借助现代 JavaScript 特性和多个返回语句，代码可以有多简洁。const checkModel = ({model, year} = {}) => { if(!model &amp;&amp; !year) return 'No car'; if(!model) return 'No car model'; if(!year) return 'No car year'; // 这里可以任意操作模型或年份 // 确保它们存在 // 无需更多检查 // doSomething(model); // doSomethingElse(year); return `Car model: ${model}; Manufacturing year: ${year};`; } console.log(checkModel()); // 输出 'No car' console.log(checkModel({ year: 1988 })); // 输出 'No car model' console.log(checkModel({ model: 'ford' })); // 输出 'No car year' console.log(checkModel({ model: 'ford', year: 1988 })); // 输出 'Car model: ford; Manufacturing year: 1988;' 在重构版本中，我们包含了解构和默认参数。默认参数确保我们在传入 undefined 时有可用于解构的值。注意，如果传入 null ，函数将会抛出错误。这也是之前那个方法的优点所在，因为那个方法在传入 null 的时候会输出 &#39;No car&#39;。对象解构确保函数只取所需。例如，如果我们在给定车辆对象中包含额外属性，则该属性在我们的函数中是无法获取的。根据偏好，开发者会选择其中一种方式。实践中，编写的代码通常介于两者之间。很多人觉得 if...else 语句更容易理解，并且有助于他们更为轻松地遵循程序流程。6. 使用索引或者映射，而不是 switch 语句假设我们想要基于给定的国家获取汽车模型。const getCarsByState = (state) => { switch (state) { case 'usa': return ['Ford', 'Dodge']; case 'france': return ['Renault', 'Peugeot']; case 'italy': return ['Fiat']; default: return []; } } console.log(getCarsByState()); // 输出 [] console.log(getCarsByState('usa')); // 输出 ['Ford', 'Dodge'] console.log(getCarsByState('italy')); // 输出 ['Fiat'] 上诉代码可以重构，完全去除 switch 语句。const cars = new Map() .set('usa', ['Ford', 'Dodge']) .set('france', ['Renault', 'Peugeot']) .set('italy', ['Fiat']); const getCarsByState = (state) => { return cars.get(state) || []; } console.log(getCarsByState()); // 输出 [] console.log(getCarsByState('usa')); //输出 ['Ford', 'Dodge'] console.log(getCarsByState('italy')); // 输出 ['Fiat'] 或者，我们还可以为包含可用汽车列表的每个国家创建一个类，并在需要的时候使用。不过这个就是题外话了，本文的主题是关于条件句的。更恰当的修改是使用对象字面量。const carState = { usa: ['Ford', 'Dodge'], france: ['Renault', 'Peugeot'], italy: ['Fiat'] }; const getCarsByState = (state) => { return carState[state] || []; } console.log(getCarsByState()); // 输出 [] console.log(getCarsByState('usa')); // 输出 ['Ford', 'Dodge'] console.log(getCarsByState('france')); // 输出 ['Renault', 'Peugeot'] 7. 使用自判断链接（optional-chaining）和空合并（nullish-coalescing）到了这一小节，我终于可以说“最后”了。在我看来，这两个功能对于 JavaScript 语言来说是非常有用的。作为一个来自 C# 世界的人，可以说我经常使用它们。在写这篇文章的时候，这些还没有得到完全的支持。因此，对于以这种方式编写的代码，你需要使用 Babel 进行编译。你可以在自判断链接这里以及在空合并这里查阅。自判断链接允许我们在没有显式检查中间节点是否存在的时候处理树形结构，空合并可以确保节点不存在时会有一个默认值，配合自判断链接使用会有不错的效果。让我们用一些例子来支撑上面的结论。一开始，我们还是用以前的老方法：const car = { model: 'Fiesta', manufacturer: { name: 'Ford', address: { street: 'Some Street Name', number: '5555', state: 'USA' } } } // 获取汽车模型 const model = car &amp;&amp; car.model || 'default model'; // 获取厂商地址 const street = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.address.street || 'default street'; // 请求一个不存在的属性 const phoneNumber = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.phoneNumber; console.log(model) // 输出 'Fiesta' console.log(street) // 输出 'Some Street Name' console.log(phoneNumber) // 输出 undefined 因此，如果我们想要知道厂商是否来自 USA 并将结果打印，那么代码是这样的：const checkCarManufacturerState = () => { if(car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; car.manufacturer.address.state === 'USA') { console.log('Is from USA'); } } checkCarManufacturerState() // 输出 'Is from USA' 我无需再赘述如果对象结构更加复杂的话，代码会多么混乱了。许多库，例如 lodash，有自己的函数作为替代方案。不过这不是我们想要的，我们想要的是在原生 js 中也能做同样的事。我们来看一下新的方法： // 获取汽车模型 const model = car?.model ?? 'default model'; // 获取厂商地址 const street = car?.manufacturer?.address?.street ?? 'default street'; // 检查汽车厂商是否来自 USA const checkCarManufacturerState = () => { if(car?.manufacturer?.address?.state === 'USA') { console.log('Is from USA'); } } 这看起来更加漂亮和简洁，对我来说，非常符合逻辑。如果你想知道为什么应该使用 ?? 而不是 || ，只需想一想什么值会被当做 true 或者 false 从而得到意料之外的输出。顺便说句题外话。自判断链接同样支持 DOM API，这非常酷，意味着你可以这么做：const value = document.querySelector('input#user-name')?.value; 结论好了，这就是全部内容了。如果你喜欢这篇文章的话，可以送一杯咖啡给我，让我提提神，还可以订阅文章或者在 twitter 上关注我。感谢阅读，下篇文章见。译者注：关于最后一个例子的空合并为什么使用 ?? 而不是 ||，作者可能解释得不是很清楚，这里摘抄一下 tc39:proposal-nullish-coalescing 的例子：const headerText = response.settings?.headerText || 'Hello, world!'; // '' 会被当作 false，输出： 'Hello, world!' const animationDuration = response.settings?.animationDuration || 300; // 0 会被当作 false，输出： 300 const showSplashScreen = response.settings?.showSplashScreen || true; // False 会被当作 false，输出： true 照理来说，使用 || 是可以的，但是在上面代码中会有点小问题。比如我们想要获取的 animationDuration 的值为 0，那么由于 0 被当作 false，导致我们最后得到的是默认值 300，这显然不是我们想要的结果。而 ?? 就是用来解决这个问题的。目前 optional-chaining 和 nullish-coalescing 还在 ecma 标准草案的 stage2 阶段，不过 babel 针对前者已有相关插件实现，更多相关文章可以看：https://segmentfault.com/a/1190000013409955https://zhuanlan.zhihu.com/p/29296692https://www.npmjs.com/package/babel-plugin-transform-optional-chaining]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「译」前端项目中常见的 CSS 问题]]></title>
    <url>%2F2019%2F06%2F18%2FTrs-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%20CSS%20%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原文地址：Common CSS Issues For Front-End Projects原文作者：Ahmad Shadeed译者：Chor快速摘要：近年来，跨浏览器的渲染和交互已经愈加一致。不过，它仍然没有达到完全一致，有很多小问题会让你出错。除了这些问题之外，还有不同的屏幕尺寸、语言偏好和明显的人为错误等不确定因素，我们从中发现了许多会让开发者出错的小问题。在浏览器中实现用户界面时，最好是尽可能地减小这些差异和问题，以便 UI 呈现出预测的样子。记住所有的这些差异是很困难的，所以我列举了一系列常见问题以及解决方案。当你在做一个新项目的时候，可以将其作为一份方便的参考指南。我们开始吧。1. 重置 button 和 input 元素的背景添加按钮时，重置它的背景，否则在跨浏览器时它的呈现会有所不同。下面的例子分别展示了 Chrome 和 Safari 中的同一个按钮，后者默认会有一个灰色背景。(大图预览)重置背景可以解决这个问题：button { appearance: none; background: transparent; /* 其它样式 */ } 查看 Ahmad Shadeed（@shadeed）在 Codepen 上的代码 按钮和输入框。2. Overflow: scroll 和 auto为了限制一个元素的高度并允许用户在其中滚动，添加 overflow: scroll-y。在 macOS 下的 Chrome 中，这看起来不错，但是在 Windows 下的 Chrome 中，滚动条始终存在（即使内容很短）。这是因为 scroll-y 会无视内容，一直显示滚动条。而 overflow: auto 只在需要的时候才会显示滚动条。左边：macOS 下的 Chrome。右边：Windows 下的 Chrome (大图预览).element { height: 300px; overflow-y: auto; } 查看 Ahmad Shadeed（@shadeed）在 Codepen 上的代码 overflow-y。3. 添加 flex-wrap要想让一个元素表现得像弹性容器那样，只需添加 display: flex。但是，如果没有添加 flex-wrap ，那么当屏幕尺寸缩小的时候，将会出现水平滚动条。&lt;div class="wrapper"> &lt;div class="item">&lt;/div> &lt;div class="item">&lt;/div> &lt;div class="item">&lt;/div> &lt;div class="item">&lt;/div> &lt;div class="item">&lt;/div> &lt;div class="item">&lt;/div> &lt;/div> .wrapper { display: flex; } .item { flex: 0 0 120px; height: 100px; } 上面的例子在大屏幕下表现正常。在移动端下，浏览器将会出现水平滚动条。左边：出现水平滚动条，并且项目没有换行。右边：项目换行，呈两行显示 (大图预览)解决方法很简单。wrapper 应该在空间不足时让项目换行。.wrapper { display: flex; flex-wrap: wrap; } 查看 Ahmad Shadeed（@shadeed）在 Codepen 上的代码 flex-wrap。4. 当弹性项目数量不定时，不要使用 justify-content: space-between对一个弹性容器应用 justify-content: space-between 时，它会为元素分配空间，使它们互相之间的距离相等。我们的例子中有 8 个卡片项目，看起来没什么问题。如果由于某种原因，项目的数量是 7 呢？第二行的元素看起来将会与第一行的不同。包含 8 个项目的 wrapper (大图预览)包含 7 个项目的 wrapper (大图预览)查看 Ahmad Shadeed（@shadeed）在 Codepen 上的代码 flex-wrap。在这种情况下，使用 CSS 网格将会更加合适。5. 长词和链接在手机屏幕上浏览文章的时候，一个长词或者内联链接可能会导致页面出现水平滚动条。使用 CSS 的 word-break 可以防止这个问题。(大图预览).article-content p { word-break: break-all; } (大图预览)详情查看 CSS-Tricks 。6. 透明渐变当使用透明起点和终点添加渐变的时候，在 Safari 下会呈现一片漆黑。这是因为 Safari 无法识别关键字 transparent。通过使用 rgba(0, 0, 0, 0) 来替代它，我们可以达到预期的效果。注意下面的截图：顶部： Chrome 70.底部：Safari 12(大图预览).section-hero { background: linear-gradient(transparent, #d7e0ef), #527ee0; /* 其它样式 */ } 应该替换为：.section-hero { background: linear-gradient(rgba(0, 0, 0,0), #d7e0ef), #527ee0; /* 其它样式 */ } 7. CSS 网格布局中关于 auto-fit 和 auto-fill 差异的误解在 CSS 网格布局中，repeat 函数可以在不使用媒体查询的情况下创建响应式列布局。为此，可以使用 auto-fill 或者 auto-fit。.wrapper { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); } (大图预览)简而言之，auto-fill 将会在不扩展列宽度的情况下对它们进行排列，而auto-fit 则会在存在空列的时候使其宽度塌陷为 0。Sara Soueidan 写了一篇不错的文章讨论过这个问题。8. 当视窗高度不足时将元素固定在屏幕顶部如果你在视窗不够高的时候将一个元素固定在屏幕顶部，会发生什么事呢？很简单：它将占用屏幕空间，最终导致可供用户浏览网站的垂直区域变得很小、很不舒服，影响他们的体验。@media (min-height: 500px) { .site-header { position: sticky; top: 0; /* 其它样式 */ } } 上面的代码中，我们让浏览器只在视窗高度等于或大于 500 像素的时候才固定顶部。还有一点很重要：使用 position: sticky 的时候，除非指定 top 属性，否则它不会生效。(大图预览)查看 Ahmad Shadeed（@shadeed）在 Codepen 上的代码 垂直媒体查询：固定顶部。9. 为图片设置 max-width添加图片时，定义 max-width: 100%，这样图片会在屏幕较小的时候改变大小。否则浏览器将会显示水平滚动条。img { max-width: 100%; } 10. 使用 CSS 网格定义 main 和 aside 元素CSS 网格可用于定义布局中的 main 部分和 aside 部分，这是 CSS 网格的绝佳用途。问题是，即使 aside 是空的，它的高度也会和 main 的高度相等。要修复这个问题，可以让 aside 元素与其父元素的起点对齐，这样它的高度就不会扩展了。.wrapper { display: grid; grid-template-columns: repeat(12, minmax(0, 1fr)); grid-gap: 20px; } // align-self 将会让 aside 元素与其父元素的起点对齐。 aside { grid-column: 1 / 4; grid-row: 1; align-self: start; } main { grid-column: 4 / 13; } (大图预览)查看 Ahmad Shadeed（@shadeed）在 Codepen 上的代码 main 和 aside。11. 给一个 SVG 添加 fill使用 SVG 时，如果在 SVG 内部添加 fill，有时候它可能不会如预期的那样生效。要修复这个问题，要么移除 SVG 自身的 fill 属性，要么覆盖 fill: color。举个例子：.some-icon { fill: #137cbf; } 如果 SVG 有一个内联 fill 的话，这段代码将不会生效。应该替换为：.some-icon path { fill: #137cbf; } 12. 使用伪元素无论何时，我都很喜欢使用伪元素。伪元素为我们提供了一种创建假元素的方法，主要用来装饰，同时又无需将其添加到 HTML 中。使用它们的时候，开发者可能会忘记做下面的事情：添加 content: &quot;&quot; 属性，在没有定义 display 属性的情况下设置它们的 width 和 height下面的例子中，我们有一个标题，其标记是一个伪元素。必须给元素添加 content: &quot;&quot; 属性，同时还要为它设置 display: inline-block ，以使 width 和 height 像预期的那样生效。(大图预览)13. 使用 display: inline-block 时奇怪的空隙给两个或两个以上的元素设置 display: inline-block 或者 display: inline ，将会导致它们之间产生一个微小的空隙。原因是浏览器会将元素当作字词去解释，从而给每个元素之间添加一个字符的空隙。下面的例子中，每个项目的右侧都有一个 8px 的空隙，但是使用 display: inline-block 而产生的小空隙将会使其变为 12px，这不是我们想要的效果。li:not(:last-child) { margin-right: 8px; } (大图预览)通过给父元素设置 font-size: 0 可以简单地解决这个问题。ul { font-size: 0; } li { font-size: 16px; /* 应该在这里重新设置字体大小，因为它会从父元素继承 `font-size: 0`。*/ } (大图预览)查看 Ahmad Shadeed（@shadeed）在 Codepen 上的代码 内联块状空隙。14. 分配一个标签元素给一个输入框时，添加 for=&quot;ID&quot;使用表单元素时，确保所有的 label 元素都分配到了一个 ID。这将提高它们的可访问性，点击的时候，相关的输入框将获得焦点。&lt;label for="emailAddress">Email address:&lt;/label> &lt;input type="email" id="emailAddress"> (大图预览)15. 交互式 HTML 元素的字体不生效给整个文档设置字体的时候，字体并不会应用于诸如 input， button select 和 textarea 这些元素上。默认情况下，它们并不会继承文档字体，因为浏览器给它们应用了系统字体。要修复这个问题，直接设置字体属性：input, button, select, textarea { font-family: your-awesome-font-name; } 16. 水平滚动条有些元素的宽度可能会导致出现一个水平滚动条。要找到问题的根源，最简单的方法就是使用 CSS outline。Addy Osmani 写了一个方便的脚本 。将其添加到浏览器的控制台，页面上所有元素的轮廓都会显示出来。[].forEach.call($$("*"), function(a) { a.style.outline = "1px solid #" + (~~(Math.random() * (1 &lt;&lt; 24))).toString(16); }); (大图预览)17. 压缩或拉伸图片用 CSS 调整一张图片的大小时，如果纵横比与图片的宽高不一致，则图片会被压缩或拉伸。解决方法很简单：使用 CSS 的 object-fit。它的功能和给背景图片设置 background-size: cover 类似。img { object-fit: cover; } (大图预览)object-fit 并非百试百灵。一些图片必须在不裁剪或者不调整大小的情况下显示，并且某些平台会强制用户以特定的尺寸裁剪或上传图片。例如，Dribbble 规定上传的缩略图尺寸为 800 x 600 像素。18. 为 input 添加正确的 type为 input 使用正确的 type。这将改善移动端的用户体验，并使用户更容易访问。这是部分 HTML：&lt;form action=""> &lt;p> &lt;label for="name">Full name&lt;/label> &lt;input type="text" id="name"> &lt;/p> &lt;p> &lt;label for="email">Email&lt;/label> &lt;input type="email" id="email"> &lt;/p> &lt;p> &lt;label for="phone">Phone&lt;/label> &lt;input type="tel" id="phone"> &lt;/p> &lt;/form> 每个输入框分别获取焦点时，看起来是这样的：(大图预览)19. RTL 布局中的手机号码在一个从右到左的布局中添加诸如 + 972-123555777 的手机号码时，加号将会位于号码末尾。要修复这个问题，可以重新指定手机号码的方向。p { direction: ltr; } (大图预览)结论这里提到的所有问题都是我在前端开发工作中最常遇到的。我的目标是在开发 web 项目时定期检查这份清单。你在 CSS 中有没有经常遇到什么问题呢？欢迎在评论区分享！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「译」什么是抽象语法树]]></title>
    <url>%2F2019%2F06%2F15%2FTrs-%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%2F</url>
    <content type="text"><![CDATA[原文地址：What is an Abstract Syntax Tree原文作者：Chidume Nnamdi译者：ChorAST 是抽象语法树的缩写词，表示编程语言的语句和表达式中生成的 token。有了 AST，解释器或编译器就可以生成机器码或者对一条指令求值。小贴士: 通过使用 Bit，你可以将任意的 JS 代码转换为一个可在项目和应用中共享、使用和同步的 API，从而更快地构建并重用更多代码。试一下吧。假设我们有下面这条简单的表达式：1 + 2 用 AST 来表示的话，它是这样的：+ BinaryExpression - type: + - left_value: LiteralExpr: value: 1 - right_vaue: LiteralExpr: value: 2 诸如 if 的语句则可以像下面这样表示：if(2 > 6) { var d = 90 console.log(d) } IfStatement - condition + BinaryExpression - type: > - left_value: 2 - right_value: 6 - body [ - Assign - left: 'd'; - right: LiteralExpr: - value: 90 - MethodCall: - instanceName: console - methodName: log - args: [ ] ] 这告诉解释器如何解释语句，同时告诉编译器如何生成语句对应的代码。看看这条表达式： 1 + 2。我们的大脑判定这是一个将左值和右值相加的加法运算。现在，为了让计算机像我们的大脑那样工作，我们必须以类似于大脑看待它的形式来表示它。我们用一个类来表示，其中的属性告诉解释器运算的全部内容、左值和右值。因为一个二元运算涉及两个值，所以我们给这个类命名为 Binary：class Binary { constructor(left, operator, right) { this.left = left this.operator = operator this.right = right } } 实例化期间，我们将会把 1 传给第一个属性，把 ADD 传给第二个属性，把 2 传给第三个属性：new Binary('1', 'ADD', '2') 当我们把它传递给解释器的时候，解释器认为这是一个二元运算，接着检查操作符，认为这是一个加法运算，紧接着继续请求实例中的 left 值和 right 值，并将二者相加：const binExpr = new Binary('1', 'ADD', '2') if(binExpr.operator == 'ADD') { return binExpr.left + binExpr.right } // 返回 `3` 看，AST 可以像大脑那样执行表达式和语句。单数字、字符串、布尔值等都是表达式，它们可以在 AST 中表示并求值。23343 false true "nnamdi" 拿 1 举例：1我们在 AST 的 Literal（字面量） 类中来表示它。一个字面量就是一个单词或者数字，Literal 类用一个属性来保存它：class Literal { constructor(value) { this.value = value } } 我们可以像下面这样表示 Literal 中的 1：new Literal(1)当解释器对它求值时，它会请求 Literal 实例中 value 属性的值：const oneLit = new Literal(1) oneLit.value // `1` 在我们的二元表达式中，我们直接传递了值new Binary(&#39;1&#39;, &#39;ADD&#39;, &#39;2&#39;)这其实并不合理。因为正如我们在上面看到的，1 和 2 都是一条表达式，一条基本的表达式。作为字面量，它们同样需要被求值，并且用 Literal 类来表示。const oneLit = new Literal('1') const twoLit = new Literal('2') 因此，二元表达式会将 oneLit 和 twoLit 分别作为左属性和右属性。// ... new Binary(oneLit, 'ADD', twoLit) 在求值阶段，左属性和右属性同样需要进行求值，以获得各自的值：const oneLit = new Literal('1') const twoLit = new Literal('2') const binExpr = new Binary(oneLit, 'ADD', twoLit) if(binExpr.operator == 'ADD') { return binExpr.left.value + binExpr.right.value } // 返回 `3` 其它语句在 AST 中也大多是用二元来表示的，例如 if 语句。我们知道，在 if 语句中，只有条件为真的时候代码块才会执行。if(9 > 7) { log('Yay!!') } 上面的 if 语句中，代码块执行的条件是 9 必须大于 7，之后我们可以在终端上看到输出 Yay!!。为了让解释器或者编译器这样执行，我们将会在一个包含 condition、 body 属性的类中来表示它。condition 保存着解析后必须为真的条件，body 则是一个数组，它包含着 if 代码块中的所有语句。解释器将会遍历该数组并执行里面的语句。class IfStmt { constructor(condition, body) { this.condition = condition this.body = body } } 现在，让我们在 IfStmt 类中表示下面的语句if(9 > 7) { log('Yay!!') } 条件是一个二元运算，这将表示为：const cond = new Binary(new Literal(9), "GREATER", new Literal(7)) 就像之前一样，但愿你还记得？这回是一个 GREATER 运算。if 语句的代码块只有一条语句：一个函数调用。函数调用同样可以在一个类中表示，它包含的属性有：用于指代所调用函数的 name 以及用于表示传递的参数的 args：class FuncCall { constructor(name, args) { this.name = name this.args = args } } 因此，log(“Yay!!”) 调用可以表示为：const logFuncCall = new FuncCall('log', []) 现在，把这些组合在一起，我们的 if 语句就可以表示为：const cond = new Binary(new Literal(9), "GREATER", new Literal(7)); const logFuncCall = new FuncCall('log', []); const ifStmt = new IfStmt(cond, [ logFuncCall ]) 解释器可以像下面这样解释 if 语句：const ifStmt = new IfStmt(cond, [ logFuncCall ]) function interpretIfStatement(ifStmt) { if(evalExpr(ifStmt.conditon)) { for(const stmt of ifStmt.body) { evalStmt(stmt) } } } interpretIfStatement(ifStmt) 输出：Yay!!因为 9 &gt; 7 :)我们通过检查 condition 解析后是否为真来解释 if 语句。如果为真，我们遍历 body 数组并执行里面的语句。执行 AST使用访问者模式对 AST 进行求值。访问者模式是设计模式的一种，允许一组对象的算法在一个地方实现。ASTs，Literal，Binary，IfStmnt 是一组相关的类，每一个类都需要携带方法以使解释器获得它们的值或者对它们求值。访问者模式让我们能够创建单个类，并在类中编写 AST 的实现，将类提供给 AST。每个 AST 都有一个公有的方法，解释器会通过实现类实例对其进行调用，之后 AST 类将在传入的实现类中调用相应的方法，从而计算其 AST。class Literal { constructor(value) { this.value = value } visit(visitor) { return visitor.visitLiteral(this) } } class Binary { constructor(left, operator, right) { this.left = left this.operator = operator this.right = right } visit(visitor) { return visitor.visitBinary(this) } } 看，AST Literal 和 Binary 都有访问方法，但是在方法里面，它们调用访问者实例的方法来对自身求值。Literal 调用 visitLiteral，Binary 则调用 visitBinary。现在，将 Vistor 作为实现类，它将实现 visitLiteral 和 visitBinary 方法：class Visitor { visitBinary(binExpr) { // ... log('not yet implemented') } visitLiteral(litExpr) { // ... log('not yet implemented') } } visitBinary 和 visitLiteral 在 Vistor 类中将会有自己的实现。因此，当一个解释器想要解释一个二元表达式时，它将调用二元表达式的访问方法，并传递 Vistor 类的实例：const binExpr = new Binary(...) const visitor = new Visitor() binExpr.visit(visitor) 访问方法将调用访问者的 visitBinary，并将其传递给方法，之后打印 not yet implemented。这称为双重分派。调用 Binary 的访问方法。它 (Binary) 反过来调用 Visitor 实例的visitBinary。我们把 visitLiteral 的完整代码写一下。由于 Literal 实例的 value 属性保存着值，所以这里只需返回这个值就好：class Visitor { visitBinary(binExpr) { // ... log('not yet implemented') } visitLiteral(litExpr) { return litExpr.value } } 对于 visitBinary，我们知道 Binary 类有操作符、左属性和右属性。操作符表示将对左右属性进行的操作。我们可以编写实现如下：class Visitor { visitBinary(binExpr) { switch(binExpr.operator) { case 'ADD': // ... } } visitLiteral(litExpr) { return litExpr.value } } 注意，左值和右值都是表达式，可能是字面量表达式、二元表达式、调用表达式或者其它的表达式。我们并不能确保二元运算的左右两边总是字面量。每一个表达式必须有一个用于对表达式求值的访问方法，因此在上面的 visitBinary 方法中，我们通过调用各自对应的 visit 方法对 Binary 的左属性和右属性进行求值：class Visitor { visitBinary(binExpr) { switch(binExpr.operator) { case 'ADD': return binExpr.left.visit(this) + binExpr.right.visit(this) } } visitLiteral(litExpr) { return litExpr.value } } 因此，无论左值和右值保存的是哪一种表达式，最后都可以进行传递。因此，如果我们有下面这些语句:const oneLit = new Literal('1') const twoLit = new Literal('2') const binExpr = new Binary(oneLit, 'ADD', twoLit) const visitor = new Visitor() binExpr.visit(visitor) 在这种情况下，二元运算保存的是字面量。访问者的 visitBinary 将会被调用，同时将 binExpr 传入，在 Vistor 类中，visitBinary 将 oneLit 作为左值，将 twoLit 作为右值。由于 oneLit 和 twoLit 都是 Literal 的实例，因此它们的访问方法会被调用，同时将 Visitor 类传入。对于 oneLit，其 Literal 类内部又会调用 Vistor 类的 visitLiteral 方法，并将 oneLit 传入，而 Vistor 中的 visitLiteral 方法返回 Literal 类的 value 属性，也就是 1。同理，对于 twoLit 来说，返回的是 2。因为执行了 switch 语句中的 case &#39;ADD&#39;，所以返回的值会相加，最后返回 3。如果我们将 binExpr.visit(visitor) 传给 console.log，它将会打印 3console.log(binExpr.visit(visitor)) // 3 如下，我们传递一个 3 分支的二元运算：1 + 2 + 3 首先，我们选择 1 + 2，那么其结果将作为左值，即 + 3。上述可以用 Binary 类表示为：new Binary (new Literal(1), 'ADD', new Binary(new Literal(2), 'ADD', new Literal(3))) 可以看到，右值不是字面量，而是一个二元表达式。所以在执行加法运算之前，它必须先对这个二元表达式求值，并将其结果作为最终求值时的右值。const oneLit = new Literal(1) const threeLit =new Literal(3) const twoLit = new Literal(2) const binExpr2 = new Binary(twoLit, 'ADD', threeLit) const binExpr1 = new Binary (oneLit, 'ADD', binExpr2) const visitor = new Visitor() log(binExpr1.visit(visitor)) 6 添加 if 语句将 if 语句带到等式中。为了对一个 if 语句求值，我们将会给 IfStmt 类添加一个 visit 方法，之后它将调用 visitIfStmt 方法：class IfStmt { constructor(condition, body) { this.condition = condition this.body = body } visit(visitor) { return visitor.visitIfStmt(this) } } 见识到访问者模式的威力了吗？我们向一些类中新增了一个类，对应地只需要添加相同的访问方法即可，而这将调用它位于 Vistor 类中的对应方法。这种方式将不会破坏或者影响到其它的相关类，访问者模式让我们遵循了开闭原则。因此，我们在 Vistor 类中实现 visitIfStmt：class Visitor { // ... visitIfStmt(ifStmt) { if(ifStmt.condition.visit(this)) { for(const stmt of ifStmt.body) { stmt.visit(this) } } } } 因为条件是一个表达式，所以我们调用它的访问方法对其进行求值。我们使用 JS 中的 if 语句检查返回值，如果为真，则遍历语句的代码块 ifStmt.body，通过调用 visit 方法并传入 Vistor，对数组中每一条语句进行求值。因此我们可以翻译出这条语句：if(67 > 90) 添加函数调用和函数声明接着来添加一个函数调用。我们已经有一个对应的类了：class FuncCall { constructor(name, args) { this.name = name this.args = args } } 添加一个访问方法：class FuncCall { constructor(name, args) { this.name = name this.args = args } visit(visitor) { return visitor.visitFuncCall(this) } } 给 Visitor 类添加 visitFuncCall 方法：class Visitor { // ... visitFuncCall(funcCall) { const funcName = funcCall.name const args = [] for(const expr of funcCall.args) args.push(expr.visit(this)) // ... } } 这里有一个问题。除了内置函数之外，还有自定义函数，我们需要为后者创建一个“容器”，并在里面通过函数名保存和引用该函数。const FuncStore = ( class FuncStore { constructor() { this.map = new Map() } setFunc(name, body) { this.map.set(name, body) } getFunc(name) { return this.map.get(name) } } return new FuncStore() )() FuncStore 保存着函数，并从一个 Map 实例中取回这些函数。class Visitor { // ... visitFuncCall(funcCall) { const funcName = funcCall.name const args = [] for(const expr of funcCall.args) args.push(expr.visit(this)) if(funcName == "log") console.log(...args) if(FuncStore.getFunc(funcName)) FuncStore.getFunc(funcName).forEach(stmt => stmt.visit(this)) } } 看下我们做了什么。如果函数名 funcName（记住，FuncCall 类将函数名保存在 name 属性中）为 log，则运行 JS console.log(...)，并传参给它。如果我们在函数保存中找到了函数，那么就对该函数体进行遍历，依次访问并执行。现在看看怎么把我们的函数声明放进函数保存中。函数声明以 fucntion 开头。一般的函数结构是这样的：function function_name(params) { // function body } 因此，我们可以在一个类中用属性表示一个函数声明：name 保存函数函数名，body 则是一个数组，保存函数体中的语句：class FunctionDeclaration { constructor(name, body) { this.name = name this.body = body } } 我们添加一个访问方法，该方法在 Vistor 中被称为 visitFunctionDeclaration：class FunctionDeclaration { constructor(name, body) { this.name = name this.body = body } visit(visitor) { return visitor.visitFunctionDeclaration(this) } } 在 Visitor 中：class Visitor { // ... visitFunctionDeclaration(funcDecl) { FuncStore.setFunc(funcDecl.name, funcDecl.body) } } 将函数名作为键即可保存函数。现在，假设我们有下面这个函数：function addNumbers(a, b) { log(a + b) } function logNumbers() { log(5) log(6) } 它可以表示为：const funcDecl = new FunctionDeclaration('logNumbers', [ new FuncCall('log', [new Literal(5)]), new FuncCall('log', [new Literal(6)]) ]) visitor.visitFunctionDeclaration(funcDecl) 现在，我们来调用函数 logNumbers：const funcCall = new FuncCall('logNumbers', []) visitor.visitFuncCall(funcCall) 控制台将会打印：5 6 结论理解 AST 的过程是令人望而生畏并且非常消耗脑力的。即使是编写最简单的解析器也需要大量的代码。注意，我们并没有介绍扫描仪和解析器，而是先行解释了 ASTs 以展示它们的工作过程。如果你能够深入理解 AST 以及它所需要的内容，那么在你开始编写自己的编程语言时，自然就事半功倍了。熟能生巧，你可以继续添加其它的编程语言特性，例如：类和对象方法调用封装和继承for-of 语句while 语句for-in 语句其它任何你能想到的有趣特性如果你对此有任何疑问，或者是任何我需要添加、修改、删减的内容，欢迎评论和致邮。感谢 ！！！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「译」Flexbox 基本原理]]></title>
    <url>%2F2019%2F06%2F07%2FTrs-FlexBox%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[原文地址：Flexbox Fundamentals原文作者：Marina-ferreira译文地址：「译」Flexbox 基本原理译者：Chor整理自 MDN web docs 的笔记，同时参考了 Web Bos 上的什么是 Flexbox系列视频。介绍Flexbox 是 Flexible Box Module 的缩写。 它是一种布局模型，允许我们方便地控制 html 元素之间的空间分布和对齐 [2]。Flexbox 一次只能控制一个维度的定位（行或者列）。二维定位的控制需要依靠网格布局 [2]。给出以下模板：&lt;body> &lt;div class="container"> &lt;div class="box box-1">1&lt;/div> &lt;div class="box box-2">2&lt;/div> &lt;div class="box box-3">3&lt;/div> &lt;div class="box box-4">4&lt;/div> &lt;div class="box box-5">5&lt;/div> &lt;div class="box box-6">6&lt;/div> &lt;div class="box box-7">7&lt;/div> &lt;div class="box box-8">8&lt;/div> &lt;div class="box box-9">9&lt;/div> &lt;div class="box box-10">10&lt;/div> &lt;/div> &lt;/body> 上面 div 的行为默认遵循正常的 html 文档流，因此从上到下、从左到右进行渲染，并且会占据整个 body 的宽度，因为它们的 display 属性默认是 block。弹性项目当为 .containerdiv 设置 display: flex 时，所有的直接子 div 将成为弹性项目，并且获得新的行为 [2]：由于 flex-direction 默认值为 row，因此它们会呈一行排列它们将会从左到右排列项目不会依靠伸展来适应整个宽度（主轴），相反，它们采用收缩的方式项目将会伸展以适应交叉轴（在这个例子中是高度）。如果各个项目的高度不同，它们将会伸展至与最高的那个项目等高。flex-basis 默认值为 auto(项目宽度将取决于其自身的内容)flex-wrap 默认值为 nowrap（如果容器的宽度不足以囊括所有的项目，则项目不会换行，只会溢出）出于可视化的目的，我们拉伸容器以占据整个高度。弹性容器display: flex 使容器拓展整个可用宽度；与之相对的，display: inline-flex 使容器宽度塌陷至与内容宽度相等。弹性方向一旦声明为弹性容器，我们就可以将元素看作位于两条轴中。一条是由 flex-direction 定义的主轴，一条是与前者垂直的交叉轴 [2]。flex-direction 属性有四个值: row, row-reverse, column 和 column-reverse.默认值是 row，它将主轴设置为从左到右的水平方向，而交叉轴从上到下与之垂直相交。同理，column 将主轴设置为从上到下的垂直方向，而交叉轴则是从左到右。对这两个值添加 reverse ，则主轴将反转 180°，而交叉轴保持不变 [1][2]。可以通过下图观察这些值对应的弹性项目行为：弹性换行当容器空间不足以容纳全部弹性项目时，利用 flex-wrap 属性处理弹性项目 [3]。flex-wrap 的默认值为 nowrap，这意味着如果容器不能在保留项目原始宽度的同时将它们排列成一行的话，项目将会收缩以进行适应。如果由于某些原因无法收缩，则项目会溢出容器外 [1][3]。通过给项目设置 300px 的宽度，nowrap 选项输出下面这个结果：其中，每个项目收缩到大约 70px 以适应容器。当属性值更新为 wrap 时，项目的宽度将等于原先的值，300px。当第一行的宽度不足以容纳 300px 时，项目不再溢出容器外，而是会换行 [3]。每一行都应该被视为是一个独立的弹性容器，任何一个容器内的空间分布均不会影响与之相邻的其他容器 [2]。但是为什么弹性项目会占据整个屏幕的高度呢？在第一部分，容器高度被设置为 100vh，因此可用空间被这四行平分以适应 300px 的项目。假如我们没有设置 100vh，则容器高度将等于项目内容的高度，如下图所示 [1]：另一个选项是 wrap-reverse，它将会反转交叉轴。通过属性 flex-direction 设置的从上到下的方向会被 wrap-reverse 转化为从下到上 [1]。通过 flex-direction: column 反转主轴，容纳不下的元素将会换行至另一列，同时剩余空间会被平分 [1]。wrap-reverse 选项与 column 方向搭配使用，则将反转交叉轴的方向为从右到左，产生如下输出：弹性布局是一维布局，虽然在反转换行的时候，项目会从下到上排列（在方向为 row 的情况下），但是依然保持着从左到右的结构。改变的只有交叉轴。弹性流flex-direction 和 flex-wrap 可以在一个单属性中进行声明： flex-flow: [direction] [wrap] [2]。.flex-container { flex-flow : column wrap; } 项目之间的空隙回到主轴方向为 row 且进行换行的情况。通过给项目设置 width: 33.3333%，容器能够完全被填满。但是当你让子 div 之间有空隙时，它们将不会像预期的那样进行换行：可以通过使用 CSS 函数 calc() 解决这个问题 [1]：.flex-item { width: calc(33.33333% - 40px); margin: 20px; } 为了消除容器边缘的空间，这里对容器设置负外边距 [3]：.flex-container { margin: -20px; } 顺序order 属性允许修改项目的呈现顺序。顺序是以组为单位进行分配的。默认情况下所有的弹性项目都设置为 order：0 ，这意味着所有的项目位于同一组，并且它们会按照原始顺序进行定位。如果有两个或者两个以上的组，那么各组将会相对于它们的整数值进行排序 [4]。在下面的例子中，有三个顺序组， -1， 0 和 1，它们按照如下顺序排列。.box-3 { order: 1; } .box-7 { order: 1; } .box-8 { order: -1; } 表面上，这个属性重新分配了项目，但在诸如使用 tab 键对它们进行遍历的交互中则依然保留它们的原始位置。如果项目顺序与可访问性有关的话，这一点是需要考虑的。同理， flex-direction 也是这样 [4]。对齐在弹性布局中，沿着轴的项目对齐和空间分布可以通过四个属性控制 [5]：justify-content：将所有项目在主轴上对齐align-items ：将所有项目在交叉轴上对齐align-self：将单个项目在主轴上对齐align-content：控制交叉轴上各条线之间的空间justify-contentjustify-content 是一个在主轴上处理项目的容器属性。最常用的 6 个值是： flex-start， flex-end， center， space-around， space-between， space-evenly。其中，默认值为 flex-start。align-itemsalign-items 同样是一个容器属性，它在交叉轴上处理项目的对齐。 默认值是 stretch ，其他值是 flex-start， flex-end， center 和 baseline [5]。如果设置了容器高度，则 stretch 属性值会使所有的项目伸展至与容器等高；如果没有设置，则所有项目与最高的项目等高 [5]。上面第一张图片中容器高度设置为 100vh，第二张图片则没有设置高度。align-contentalign-content 是第四个也是最后一个容器属性，它在交叉轴上分配各条线之间的空间。作为最后一个属性，它的初始值为 stretch ，并且和 justify-content 一样接受以下几个属性值：flex-start， flex-end， center， space-around， space-between， space-evenly [5]。align-selfalign-items 属性实际上是通过给容器内的所有项目设置 align-self 而生效的。通过单独设置 align-self，可以覆盖先前设置的总的属性值。该属性和 align-items 拥有相同的可选值，但是还多了一个 ‘auto’ [5]。auto 会重置 align-self 的值，使之重新等于通过 align-items 给容器全局定义的值 [5]。弹性项目大小项目的大小和弹性可以通过三个属性控制：flex-grow，flex-shrink 和 flex-basis。这些属性都在主轴上发挥作用 [2]。flex-grow：如果有额外空间，每个项目应该如何伸展flex-shrink：如果空间不足，每个项目应该如何收缩flex-basis：在设置以上两个属性之前项目的大小flex-grow该属性设置的是弹性增长系数，这是一个用于处理项目之间相对大小的比率 [7]。默认值是 0，这意味着如果有剩余空间，就把这个空间放在最后一个项目的后面 [1]。在上面的例子中，direction 设置为 row，每个弹性项目的宽度是 60px。由于容器的宽度是 980px ，因此有 680px 的可用空间，这个空间称为 正向自由空间 [7]。通过将 flex-grow 设置为 1，正向自由空间将会被弹性项目平分。每个项目的宽度都会增加 136px，总的宽度是 196px [7]。通过给第三个项目设置 flex-grow: 2 ，它获得的可用正向自由空间是其他项目的两倍，即比起其他项目的 173px ，它的总宽度为 286px [7]。下图中，项目的 flex-grow 属性设置为自身的内容值。flex-shrink当容器没有足够空间来容纳所有项目时，使用 flex-shrink 处理项目大小。因此，它通过收缩项目来处理它们的负向自由空间 [7]。如下图所示，980px 的容器存放着 5 个 300px 宽度的容器。由于没有足够空间来容纳所需要的 1500px，默认的弹性收缩系数 1 会使每个项目收缩至 196px。通过给第三个项目设置 2 的比率，它会比其它项目小两倍。下图中，每个项目以自身内容值作为弹性收缩比率。flex-basisflex-basis 属性会在实际设置可用空间之前检查每个项目应该具有的大小。默认值是 auto，项目宽度要么通过 width 显式设置，要么等于内容宽度。它同样也接受像素值 [7]。下面的 gif 展示了一个 800px 宽度的容器和 5 个设置了 flex-basis: 160px 的弹性项目。这告诉浏览器：理想情况下有足够的空间放置所有的项目，项目的 160px 宽度将会得到保留，并且没有正向/负向自由空间。如果没有足够的空间，由于 flex-shrink 默认为 1，所有的项目会均匀地收缩。如果有剩余的空间，由于 flex-grow 默认为 0，剩余空间会放置在最后一个项目的后面。下面的 gif 中，项目 1 设置为 flex-shrink: 10，项目 4 设置为 flex-grow: 10。对于负向自由空间，项目 1 减小的宽度是其它项目减小宽度的 10 倍；对于正向自由空间，项目 4 增加的宽度是其它项目增加宽度的 10 倍。flex-basis 还可以接受值 content。此时，无论有没有设置 width，自由空间计算都只会基于项目内容去计算宽度。如果你不打算在计算时考虑项目宽度，则将其设置为 0。flexflex 是 flex-grow， flex-shrink 和 flex-basis 的简写属性 [2]。它接受下面的预定于值：initial：重置为弹性布局的默认值，与 flex: 0 1 auto 效果一样auto：弹性项目可以根据需要伸展/收缩，与 flex: 1 1 auto 效果一样none：使项目失去弹性，与 flex: 0 0 auto 效果一样flex: 1：弹性项目可以伸展/收缩，并且 flex-basis 设置为 0 ，与 flex: 1 1 0 效果一样Autoprefixer考虑到跨浏览器兼容性，给属性加上所有必要的前缀很重要，这可以确保提供全面的支持 [1]。手动给每个属性添加前缀是一项非常繁琐的任务，并且还会徒增样式维护的难度。作为替代方法，Gulp 可以自动化地完成这些任务。要使用 Gulp，我们需要将其作为依赖项添加到项目中。这是通过 package.json 文件完成的，它负责跟踪依赖项及其版本。通过终端创建文件类型 [1]： 🌹 npm init 在提示下输入信息，点击回车键进行确认。输出文件大概类似下面这样： { "name": "project-name", "version": "1.0.0", "description": "Project description", "main": "index.js", "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" }, "author": "Author Name", "license": "ISC" } 全局安装 gulp ： 🌹 npm install gulp -g 安装 gulp 和 gulp-autoprefixer 作为项目的依赖性： 🌹 npm install gulp --save-dev 🌹 npm install gulp-autoprefixer --save-dev 它们会出现在 package.json 文件的 devDependencies 键下。创建一个 gulpfile.js 文件： 🌹 touch gulpfile.js 添加下面内容 [9]：//gulpfile.js var gulp = require('gulp'); var autoprefixer = require('gulp-autoprefixer'); gulp.task('styles', function() { return gulp.src('./styles.css') .pipe(autoprefixer({ browsers: ['last 2 versions'], cascade: false })) .pipe(gulp.dest('build')); }); gulp 从 styles.css 中提取内容并通过 gulp-autoprefixer 进行传递。输出文件保留在 build 文件夹下。引用[1] What the Flexbox Course[2] Basic concepts of flexbox - 25/03/2018[3] Mastering Wrapping of Flex Items - 26/03/2018[4] Ordering Flex Items - 26/03/2018[5] Aligning Items in a Flex Container - 26/03/2018[6] StackOverflow - 27/03/2018[7] Controlling Ratios of Flex Items Along the Main Axis - 28/03/2018[8] Gulp[9] Gulp Autoprefixer译者注：弹性项目：Flex Items弹性容器：Flex Container弹性方向：Flex Direction弹性换行：Flex Wrap弹性流：Flex Flow弹性项目大小：Flexbox Sizing关于一级标题翻不翻译的问题拿捏了很久，最后决定翻译。如果有条件的话推荐阅读英文原文，因为翻译肯定是比不上原汁原味的文章。我觉得这篇博客的亮点在于：给出了大量图片和示例（其中不少是动图），对于理解很有帮助；每一个引用的地方都带有注释，给读者追溯文章信息的源头提供了机会（这一点是第一次看到，值得学习）；涉及到了一些细节，比如交叉轴的确定。一些文章说和顺时针、逆时针有关，其实这是错的。从文章中我们也知道了，交叉轴确实由主轴确定，但是它不一定就是由主轴按照一个方向旋转得到的]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础系列：flex 布局]]></title>
    <url>%2F2019%2F06%2F06%2FF-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1.布局演变史1）初代：table 布局在网页布局没有进入 CSS 的时代，排版几乎是通过 table 元素实现的。虽然它可以很方便地实现水平和垂直对齐，但是缺点也很明显：代码臃肿；不利于SEO；不够语义化；后期难以修改2）第二代：div+css 布局随着 Web 语义化的流行，CSS 标准为我们提供了 3 种布局方式：标准文档流、浮动布局和定位布局。这几种方式的搭配使用可以轻松搞定 PC 端页面的常见需求。然而，这些写法也存在一些缺陷：缺少语义并且不够灵活。3）第三代：flex 布局flex 布局属于一维布局，适合用于局部组件。目前在移动端布局日渐成为主流，也是本文重点。4）第四代：grid布局grid 布局属于二维布局，适合用于页面框架。目前兼容性不是很好，尚未完全普及。2.flex 布局Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。利用Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持。要使用 flex 布局，只需给元素设置 display:flex 或者 display:inline-flex 。前者会将元素作为块状弹性容器，若没有指定宽度，默认撑满一整行；后者会将元素作为内联弹性容器，若没有指定宽度，默认由内容撑开。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。2.1 基本概念1）父容器和子项目设置了 display:flex 或者 display:inline-flex 的元素将成为父容器 (flex container) ，其内部所有子元素成为子项目 (flex item)。2）主轴和交叉轴如下图所示：父容器存在两条轴，主轴（main axis）和交叉轴（cross axis）。主轴的开始位置叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。主轴默认情况下水平向右，我们可以通过 flex-direction 指定它的方向，主轴方向确定后，我们进而可以得到交叉轴的方向。子项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。3）6 大容器属性以下 6 个属性设置在父容器上：flex-directionjustify-contentalign-itemsflex-wrapflex-flowalign-contentflex-direction 属性定义主轴的方向，进而决定子项目的排列方向row:默认值。主轴水平向右，同时交叉轴垂直向下row-reverse：主轴水平向左，同时交叉轴垂直向下column：主轴垂直向下，同时交叉轴水平向右column-reverse：主轴垂直向上，同时交叉轴水平向右注意：只要主轴是 row，交叉轴就一定是向下的；而只要主轴是 column，交叉轴就一定是向右的。和所谓的逆时针、顺时针没关系。详细的解释另一篇博客有说明。justify-content 属性定义子项目沿着主轴方向具体如何排列flex-start:起始端对齐flex-end：末尾端对齐center: 居中对齐（用于实现水平居中）space-around: 子项目沿主轴均匀分布，位于首尾两端的子项目到父容器的距离是子项目间距的一半（注意 around 的意思）space-between: 子项目沿主轴均匀分布，位于首尾两端的子项目与父容器相切align-items 属性定义子项目沿着交叉轴方向具体如何排列flex-start: 起始端对齐flex-end: 末尾端对齐center：居中对齐（用于实现垂直居中）baseline: 基线对齐。以一开始是起始端对齐为例，cross-strat 到各个子项目基线的距离可能各不相同，一旦设置了基线对齐，则：距离最大的那个子项目保持与 corss-start 相切，其他子项目的基线均向该项目的基线对齐stretch：子项目沿着交叉轴方向拉伸至与父容器尺寸一样flex-wrap 属性定义子项目是否换行、如何换行nowrap:不换行（默认）。也就是说父容器尺寸不够时，会为了达到不换行的效果而压缩子项目的尺寸wrap：正常换行wrap-reverse：逆序换行。即沿着交叉轴的反方向换行，如下图：确定换行方向，也可以采用以下方法：首先确定正常换行情况下的排列方式保持第一行不动，将其他行沿着与主轴垂直的方向翻转flex-flow 属性定义子项目如何流动，以及流动到终点是否换行。简单地说，它是 flex-direction 和 flex-wrap 属性的结合。它的取值可以是：row nowraprowwrap等等。align-content 属性定义子项目存在多行时，行与行之间的对齐方式flex-start：起始端对齐flex-end：末尾端对齐center：居中对齐space-around：各行沿交叉轴均匀分布，位于首尾两端的行到父容器的距离是行与行距离的一半space-between: 各行沿交叉轴均匀分布，位于首尾两端的行到父容器相切stretch：拉伸对齐4) 6 大项目属性以下 6 个属性设置在子项目上：orderflex-growflex-shrinkflex-basisflexalign-selforder 属性定义子项目的排列顺序，它会覆盖 HTML 结构中的顺序。默认值为 0 ，即遵循 HTML 结构排列；可以是负值，数值越小越靠前。flex-grow 属性定义了父容器还有剩余空间时，子项目如何瓜分这些剩余空间。其值为一个权重（扩张因子），子项目将按照设定的这个权重去瓜分父容器的剩余空间。如果为 0（默认）：即使有剩余空间，子项目也不会去瓜分如果为整数，举个例子：父容器宽度 500px，三个子项目的 width 分别为 100px，150px，100px。于是剩余空间为 150px三个项目的 flex-grow 分别是 1，2，3，于是三个项目所得到的多余空间分别是：150 1 / 6 = 25px150 2 / 6 = 50px150 * 3 / 6 = 75px于是三个项目最终的宽度分别为：100px + 25px = 125px150px + 50px = 200px100px + 75px = 175px如果为小数，那么将不会计算权重之和作为权重率的分母，而是直接取 1 作为分母。在这个基础上，若权重之和小于 1 .则剩余空间不会全部分配给子项目。比如改一下上面的例子：三个项目的 flex-grow 改为 0.1，0.2，0.3，那么计算公式将变成下面这样：150 0.1 / 1 = 15px150 0.2 / 1 = 30px150 * 0.3 / 1 = 45px150px - 15px - 30px - 45px = 60px，可见还有 60px 没有分配给任何子项目。三个项目的最终宽度分别为：100px + 15px = 115px150px + 30px = 180px100px + 45px = 145px注意：flex-grow 还会受到 max-width 的影响。如果最终 grow 后的结果大于 max-width 指定的值，则 max-width 的值将会优先使用。同样会导致父容器有部分剩余空间没有分配。flex-shrink 属性定义了父容器空间不足时子项目如何收缩以适应有限的空间该属性与 flex-grow 相对，不同的是其值的计算还与自身宽度有关。举个例子：父容器 500px，三个子项目宽度分别为 150px，200px，300px，flex-shrink 分别为 1，2，3。首先，计算子元素溢出多少：150 + 200 + 300 - 500 = -150px。那么这 -150px 将由三个元素的分别收缩一定的量来弥补。具体的计算方式为：每个元素收缩的权重为其 flex-shrink 乘以其宽度。所以总权重为 1 150 + 2 200 + 3 * 300 = 1450三个元素分别收缩：150 1(flex-shrink) 150(width) / 1450 = -15.5150 2(flex-shrink) 200(width) / 1450 = -41.4150 3(flex-shrink) 300(width) / 1450 = -93.1三个元素的最终宽度分别为：150 - 15.5 = 134.5200 - 41.4 = 158.6300 - 93.1 = 206.9同样，当所有元素的 flex-shrink 之和小于 1 时，计算方式也会有所不同：此时，并不会收缩所有的空间，而只会收缩 flex-shrink 之和相对于 1 的比例的空间。还是上面的例子，但是 flex-shrink 分别改为 0.1，0.2，0.3。于是总权重为 145（正好缩小 10 倍，略去计算公式）。三个元素收缩总和并不是 150px，而是只会收缩 150px 的 (0.1 + 0.2 + 0.3) / 1 即 60% 的空间：90px。每个元素收缩的空间为：90 0.1(flex-shrink) 150(width) / 145 = 9.3190 0.2(flex-shrink) 200(width) / 145 = 24.8390 0.3(flex-shrink) 300(width) / 145 = 55.86三个元素的最终宽度分别为：150 - 9.31 = 140.69200 - 24.83 = 175.17300 - 55.86 = 244.14当然，flex-shrink 也会受到 min-width 的影响。flex-basis 属性定义了子项目在不伸缩（即没有以上两个属性影响）时的原始尺寸，主轴水平时表示宽度，主轴垂直时表示高度。默认值为 auto。以主轴水平为例，说一下子项目宽度如何决定：简单地说，应用规则是：content –&gt; width –&gt; flex-basis (limted by max|min-width)也就是说，在显式指定 flex-basis 时，flex-basis 即为该值，width 被忽略；在没有显式指定 flex-basis 时，flex-basis 为 auto，即采用 width 的值；在没有设置 width 的值时， flex-basis 采用项目内容的大小flex-basis 始终无法小于指定的最小宽度，无法大于指定的最大宽度flex是一个复合属性，值只有一个时等同于 flex-grow,值为三个时，等同于设置了 flex-grow,flex-shrink,flex-basis虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求align-self 属性单独定义了一个子项目在交叉轴方向上如何排列，它的可选值与 align-items 的可选值完全一致，两者同时设置时将优先考虑 align-self。2.2 历史版本flex 在演化过程有三个版本：2009 旧版本： display:box | inline-box2011 混合版本： display:flexbox | inline-flexbox2016 新版本： display: flex | inline-flex旧版相对于新版的主要区别：flex项目必须是block，没有换行设置，没有反向设置，主轴没有space-around，顺序值从1开始。当然，我们只了解新版 flex 就可以。2.3 浏览器兼容性2.4 总结最后放一张属性总结的思维导图：参考：详解 flex-grow 与 flex-shrink一劳永逸的搞定 flex 布局Flex 布局教程：语法篇flex basis 与 width 的区别Flexbox Fundamentals]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「译」创建一个Hexo主题-Part3 :评论、分析和小部件]]></title>
    <url>%2F2019%2F06%2F05%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart3%2F</url>
    <content type="text"><![CDATA[原文地址：Create an Hexo Theme - Part 3: Comments, Analytics and Widgets原文作者：Jonathan Klughertz译者：Chor在这个系列教程中，你将学习怎么从零开始制作一个 Hexo 主题。在 part1 和 part2 中，我们已经创建了博客的所有页面。在这篇文章中，我们将给博客添加 Disqus 评论系统，实现 谷歌分析以及完成侧边栏的小部件。其它文章的链接：创建一个Hexo主题-Part1:首页创建一个Hexo主题-Part2:其他页面创建一个Hexo主题-Part3:评论、分析和小部件Disqus 评论系统我已经写了一篇关于如何在 Hexo 中使用 Disqus 评论系统的文章。请前往查看以了解更多信息，这里我只简单介绍一下怎么使用：第一步是获取 Disqus UID 来测试评论功能，可以利用你的账号在这里获取：接下来需要完成三个部分：主题文件的 disqus 配置、评论占位区、Disqus 脚本。事不宜迟，我们开始吧。主题配置我们希望 Disqus UID 是可以配置的，因此给主题的 config.yml 文件添加一个条目：# Disqus Comments Shortname disqus_shortname: klugjoTest 评论占位区接下来我们给页面和文章详情页添加评论系统。和之前一样，创建一个局部视图文件 layout/_partial/comments.ejs，之后打开 layout/_partial/article-full.ejs 文件，把它插入到末尾。/* layout/_partial/comments.ejs */ &lt;div class="blog-post"> [...] &lt;!-- Comments --> &lt;%- partial('comments') %> &lt;/div> Disqus 需要 ID 为 disqus_thread 的 div 元素，因此我们这里复制官方文档提供的代码：&lt;div id="disqus_thread"> &lt;noscript>Please enable JavaScript to view the &lt;a href="//disqus.com/?ref_noscript">comments powered by Disqus.&lt;/a>&lt;/noscript> &lt;/div> 将上面的代码合并到 comments 文件中：/* layout/_partial/comments.ejs */ &lt;% if(page.comments &amp;&amp; theme.disqus_shortname){ %> &lt;div class="blog-post-comments"> &lt;h3>Comments:&lt;/h3> &lt;div id="disqus_thread"> &lt;noscript>Please enable JavaScript to view the &lt;a href="//disqus.com/?ref_noscript">comments powered by Disqus.&lt;/a>&lt;/noscript> &lt;/div> &lt;/div> &lt;% } %> 首先我们检查是否开启了评论功能和设置了 disqus UID，之后将 Disqus 标记代码放到容器里。以下是容器的 CSS 样式代码：/* source/css/blog.css */ .blog-post-comments { margin-top: 50px; } Disqus 脚本在测试之前，我们还需要添加 Disqus 的脚本，这是一切生效的关键。将它和其他脚本一起放在 layout/_partial/after-footer.ejs 的末尾/* layout/_partial/after-footer.ejs */ &lt;!-- Disqus Comments --> &lt;% if (theme.disqus_shortname){ %> &lt;script type="text/javascript"> var disqus_shortname = '&lt;%= theme.disqus_shortname %>'; (function(){ var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/&lt;% if (page.comments){ %>embed.js&lt;% } else { %>count.js&lt;% } %>'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); }()); &lt;/script> &lt;% } %> 脚本来自于官方文档,并且我们在这里将 Disqus UID 参数化。接着就可以测试一切是否正常工作了。谷歌分析谷歌分析的实现和 Disqus 差不多，所以这里我只简单提一下。具体步骤可以看我的另一篇博客。在主题配置文件中设置 tracking ID从你的账号中获取谷歌分析的 tracking ID，之后再配置文件中新增条目。# Google Analytics Tracking ID google_analytics: UA-83746351-2 创建一个新的局部文件创建一个新的局部视图文件 layout/_partial/google-analytic.ejs/* layout/_partial/google-analytic.ejs */ &lt;% if (theme.google_analytics){ %> &lt;script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', '&lt;%= theme.google_analytics %>', 'auto'); ga('send', 'pageview'); &lt;/script> &lt;% } %> 这是从谷歌分析跟踪代码复制粘贴过来的，其中包括一个参数化的 ID。合并到局部文件中我们希望可以在任何页面中获取到跟踪代码，而页面上又没有合适的位置来存放，因此我们选择把它添加到 &lt;head&gt;&lt;/head&gt; 的末尾：/* layout/_partial/head.ejs */ &lt;head> &lt;meta charset="utf-8"> &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"> &lt;meta name="viewport" content="width=device-width, initial-scale=1"> [...] &lt;!-- Google Analytics --> &lt;%- partial('google-analytics') %> &lt;/head> 大功告成！小部件此时，sidebar.ejs 文件中的小部件还只是一堆采用硬编码的静态 HTML。我们来修复这个问题。配置先从配置开始吧。我们准备创建两个小部件，一个是“关于”，一个是“标签”。相关配置如果以 JavaScript 对象的形式来书写，大概是下面这样：{ widgets: { about: "Here goes the about text", tags: true // Or any additional configuration the widget needs } } 这是它在我们的主题配置文件中转换成 YML 的形式：# Widgets List widgets: about: This blog is based off the official bootstrap blog template. Checkout the corresponding tutorial at &lt;a href="http://www.codeblocq.com">http://www.codeblocq.com&lt;/a tags: true 侧边栏代码作为所有小部件的占位区，我们的侧边栏需要遍历配置文件中的所有小部件并将其渲染出来：侧边栏的 EJS 模板如下：/* layout/_partial/sidebar.ejs */ &lt;% for(var widget in theme.widgets){ %> &lt;%- partial('widget/' + widget) %> &lt;% }; %> 第一个小部件：“关于”新建一个局部文件 layout/_partial/widget/about.ejs，之后在里面创建第一个小部件。代码是从原先的 bootstrap 模板中复制过来的，文本则来自于配置文件。/* layout/_partial/widget/about.ejs */ &lt;% if(theme.widgets.about){ %> &lt;div class="sidebar-module sidebar-module-inset"> &lt;h4>About&lt;/h4> &lt;p>&lt;%- theme.widgets.about %>&lt;/p> &lt;/div> &lt;% } %> 第二个小部件：“标签”我们给这个部件做一些略微高级的改动。设置一个段落用于存放博客中用过的所有标签。它们互相之间用空格隔开，并且字体大小与标签使用次数成比例。这是 layout/_partial/widget/tags.ejs 的代码：/* layout/_partial/widget/tags.ejs */ &lt;% if (theme.widgets.tags &amp;&amp; site.tags.length){ %> &lt;div class="sidebar-module"> &lt;h4>Tags&lt;/h4> &lt;p> &lt;% site.tags.sort('name').each(function(item){ %> &lt;a href="&lt;%- config.root %>&lt;%- item.path %>" style="font-size: &lt;%- Math.min(item.posts.length * 2 + 13, 30) %>px">&lt;%= item.name %>&lt;/a> &lt;% }); %> &lt;/p> &lt;/div> &lt;% } %> site.tags 让我们可以获取所有标签site.tags.sort(&#39;name) 按照字母表的顺序对所有标签进行排序item.path 对应标签归档页的相对 URLitem.posts.length 表示标签的使用次数item.name 是标签的名字我这里选择 13+（标签使用次数 *2）px 作为字体大小的计算方式，并且最大不超过 30px。当然，你可以根据自己的喜好来。最后教程到这里就结束了，我希望你从中可以学到不少有趣的东西。如果你想进一步打磨主题，可以考虑下面这些事情：通过参数化 &lt;title&gt; 和所有 Open Graph 属性完善 head 部分添加更多小部件，例如搜索小部件 或者是一个 近期文章小部件将你的主题提交到 Hexo官方主题站点查看我的其他 Hexo 教程来改进你的博客查看hexo-theme-bootstrap-blog,这个主题同样是基于 bootstrap 模板实现的从零开始打造你自己的主题感谢阅读！欢迎在评论区留下你的评论、指正和意见。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>hexo theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础系列：常见布局方式]]></title>
    <url>%2F2019%2F05%2F31%2FF-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.单列布局常见的单列布局有两种：header、content、footer等宽header、footer 等宽，content 略窄 对于第一种：给 header、content、footer 设置相同的 width 或者 max-width（显示的宽度都一样，但是前者内容过长会溢出，后者会换行），再设置 margin 达到水平居中。代码示例：&lt;div class="header">&lt;/div> &lt;div class="content">&lt;/div> &lt;div class="footer">&lt;/div> .header{ margin:0 auto; max-width: 960px; height:100px; background-color: blue; } .content{ margin: 0 auto; max-width: 960px; height: 400px; background-color: aquamarine; } .footer{ margin: 0 auto; max-width: 960px; height: 100px; background-color: aqua; } 对于第二种：首先给 header 和 footer 共同的宽度（不设置宽度时默认撑满整个屏幕），之后给 content 和 header 子元素（比如头部的导航条）、footer 子元素一个共同的宽度。最后通过 margin 设置水平居中。代码示例：&lt;div class="header"> &lt;div class="nav">&lt;/div> &lt;/div> &lt;div class="content">&lt;/div> &lt;div class="footer">&lt;/div> .header{ margin:0 auto; max-width: 960px; height:100px; background-color: blue; } .nav{ margin: 0 auto; max-width: 800px; background-color: darkgray; height: 50px; } .content{ margin: 0 auto; max-width: 800px; height: 400px; background-color: aquamarine; } .footer{ margin: 0 auto; max-width: 960px; height: 100px; background-color: aqua; } 2.两列自适应布局两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式。有三种常用方式可以达到两列自适应布局 float + BFC：左元素在没有固定宽度的情况下设置浮动，因此宽度由内容撑开；右元素激活 BFC（这里采用 overflow:hidden）后，可以防止被浮动元素盖住，且正是为了防止被盖住，右元素宽度才会由默认的撑满屏幕变为撑满剩余部分。这里还要注意一个点是：浮动元素的 margin 是相对于与自己同级的浮动兄弟元素来说的。代码示例：&lt;div class="parent" style="background-color: lightgrey;"> &lt;div class="left" style="background-color: lightblue;"> &lt;p>left&lt;/p> &lt;/div> &lt;div class="right" style="background-color: lightgreen;"> &lt;p>right&lt;/p> &lt;p>right&lt;/p> &lt;/div> &lt;/div> .left { float: left; margin-right: 20px; } .right { overflow: hidden; zoom: 1; /* 兼容 IE */ } flex 布局：设置父盒子为弹性盒后，子元素默认成一行显示，之后设置右元素 flex:1。该属性默认为 0，表示即使该行有额外空间也不会占满，设置为 1 表示右元素占满额外空间。代码示例：/* html部分同上 */ .parent { display:flex; } .right { margin-left:20px; flex:1; } grid 布局：代码示例：/* html部分同上 */ .parent { display:grid; grid-template-columns:auto 1fr; grid-gap:20px } 3.三栏布局即中间列自适应宽度，旁边两侧固定宽度的布局方式，最典型的是圣杯布局和双飞翼布局。 3.1 圣杯布局：3.1.1 代码示例：&lt;article class="container"> &lt;div class="center">&lt;/div> &lt;div class="left">&lt;/div> &lt;div class="right">&lt;/div> &lt;/article> .body{ min-width: 600px; } .container { padding-left: 220px; padding-right: 220px; } .left { float: left; width: 200px; height: 400px; background: red; margin-left: -100%; position: relative; left: -220px; } .center { float: left; width: 100%; height: 500px; background: yellow; } .right { float: left; width: 200px; height: 400px; background: blue; margin-left: -200px; position: relative; right: -220px; } 3.1.2 实现步骤：首先我们想要优先加载 center 部分的内容，所以 dom 结构上先写 center为了让三者共在一行，给它们设置浮动；为了让 center 自适应，给它设置宽度 100%。此时布局是这样的：这里要注意的点：块级元素在不显式设置宽度的情况下确实撑满整个屏幕，从这个角度来看，width 设置为 100% 似乎没有必要。但不要忘记了我们给它设置了浮动 —— 浮动元素具有包裹性，在不显式设置宽度的情况下由内容撑开。这里如果不设置 100% 宽度，且里面没有足够的内容，那么会导致布局崩坏。设置 left 和 right 的 margin-left 为负值，让它们回到与 center 同一行。此时布局是这样的：这里要注意的点：所有浮动元素可以看作位于同一个浮动流，利用负边距可以让某个元素在这个流中移动，并且会叠加到相应元素的上面。对于 left 来说，它需要左移父元素的总宽度，对于 right 来说，它需要左移自身宽度。设置父容器的左右 padding，使内部内容向中间挤压，从而使左右留白。此时布局是这样的：给 left 和 right 设置绝对定位，让它们占据父元素的留白空间。最终得到的布局是这样的：给页面设置 min-width: 600px这里要注意的点：由于左右两列宽度固定，因此我们至少要给页面一个最小宽度，但这个最小宽度并不是简单的左右两列宽度之和 —— 别忘了，之前的 left 位于 center，left 是 relative 定位，所以在 center 上占据过的空间不会消失。所以页面最小宽度是 left-width * 2 + right-width。3.1.3 缺点；如果其中一列内容高度拉长，其他两列的背景并不会自动填充（后面介绍的等高布局可以解决这个问题） 3.2 双飞翼布局：双飞翼布局在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。3.2.1 代码示例&lt;div class="center"> &lt;div class="inner">双飞翼布局&lt;/div> &lt;/div> &lt;div class="left">&lt;/div> &lt;div class="right">&lt;/div> .body { min-width: 600px; } .left { float: left; width: 200px; height: 400px; background: red; margin-left: -100%; } .center { float: left; width: 100%; height: 500px; background: yellow; } .center .inner { margin: 0 200px; /* 主要区别 */ } .right { float: left; width: 200px; height: 400px; background: blue; margin-left: -200px; } 3.2.2 实现步骤前两步与圣杯布局一样：三个部分都设定为左浮动，然后设置 center 的宽度为 100%，此时，left 和 right 部分会跳到下一行；通过设置负 margin 让 left 和 right 部分回到与 center 部分同一行；这里开始有所不同：center 部分增加一个内层div，并设margin: 0 200px；同样要给页面设置最小宽度，这里没有用定位，所以最小宽度可以直接等于左右两列宽度之和3.2.3 缺点：多加一层 dom 树节点，增加渲染树生成的计算量。 两种布局的对比：优先加载主列。三列浮动，配合负外边距形成三列布局两种布局方式的主要区别在于如何处理主列，从而让其内容不被覆盖。对于圣杯布局，它是利用父盒子的左右 padding 确保将主列内容挤到中间，在效果上表现为三个独立列；对于双飞翼布局，它是在主列里放置一个子盒子，利用子盒子的左右 margin 确保内容位于中间，在效果上表现为左右两列在主列上面。 3.3 flex 布局：flex 布局是最简便的，而且在移动端应用广泛。3.3.1 代码示例：&lt;div class="container"> &lt;div class="center">&lt;/div> &lt;div class="left">&lt;/div> &lt;div class="right">&lt;/div> &lt;/div> .container{ display: flex; } .center{ height:500px; background-color: blue; flex: 1; } .left{ height: 200px; background-color:gray; order: -1; flex:0 1 100px; } .right{ height: 200px; background-color: red; flex: 0 1 100px; } 3.3.2 实现步骤：只说几个注意的点在不优先加载主列的情况下，dom 结构可以按照左中右顺序书写，这样不需要额外设置 order；因为我们这里要优先加载主列，所以 dom 结构还是先写主列，之后通过降低左列的 order 恢复顺序。flex 只有一个值时，设置的是 flex-grow，代表弹性子元素对父元素剩余空间的分配，因为不设置的时候默认是 0，所以这里只有设置了 1 的主列参与分配剩余空间，从而实现宽度自适应。flex 有三个值时，设置的是 flex-grow，flex-shrink，flex-basis。这里左右两列的 flex-basis 都是 100px，实际上为它们设置了固定宽度。4.等高布局等高布局是指多个子元素在父元素中高度相等的布局方式。 4.1 正 padding + 负 margin：该方法可以解决圣杯布局各子元素高度不等的缺点。给各个子元素设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并给总的父盒子设置 overflow:hidden，把溢出背景切掉。假设某一列高度最大，则父盒子的高度会等于这一列高度，而其他列本来的留白部分由带背景色的 padding 补偿。基本代码与圣杯布局一样，新增代码如下：/* 注意是三个都设置 */ .center, .left, .right { padding-bottom: 10000px; margin-bottom: -10000px; } .container { padding-left: 220px; padding-right: 220px; overflow: hidden; } 关于原理，我暂时是这么理解的，不一定正确：可以看作 margin 负值是向内收缩至与 padding 高度相等处，虽然 padding 还在（所以有背景颜色），但是丧失了在空间上撑开父盒子的能力（因为此时被 margin 取代，margin 撑不开高度），即父盒子由最高列撑开，其他两列不足高度的部分由 padding 填充。 4.2 利用背景图片：这种方法是我们实现等高列最早使用的一种方法，就是使用背景图片，在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的css样式就可以轻松实现,但此方法不适合流体布局等高列的布局。在制作样式之前需要一张类似下面的背景图：代码示例：&lt;div class=”container clearfix”> &lt;div class=”left”>&lt;/div> &lt;div class=”content”>&lt;/div> &lt;div class=”right”>&lt;/div> &lt;/div> .container { background: url("column.png") repeat-y; width: 960px; margin: 0 auto; } .left { float: left; width: 220px; } .content { float: left; width: 480px; } .right { float: left; width: 220px; } 4.3 利用表格布局：这是一种非常简单，易于实现的方法。不过兼容性不好，低版本 IE 无法正常运行。&lt;div class="container table"> &lt;div class="containerInner tableRow"> /* 左列 */ &lt;div class="column tableCell cell1"> &lt;div class="left aside"> .... &lt;/div> &lt;/div> /* 主列 */ &lt;div class="column tableCell cell2"> &lt;div class="content section"> ... &lt;/div> &lt;/div> /* 右列 */ &lt;div class="column tableCell cell3"> &lt;div class="right aside"> ... &lt;/div> &lt;/div> &lt;/div> &lt;/div> .table { width: auto; min-width: 1000px; margin: 0 auto; padding: 0; display: table; } .tableRow { display: table-row; } .tableCell { display: table-cell; width: 33%; } .cell1 { background: #f00; height: 800px; } .cell2 { background: #0f0; } .cell3 { background: #00f; } 4.4 使用边框和定位：这种方法是使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。代码示例：&lt;div id="wrapper"> &lt;div id="mainContent">...&lt;/div> &lt;div id="sidebar">...&lt;/div> &lt;/div> #wrapper { width: 960px; margin: 0 auto; } #mainContent { border-right: 220px solid #dfdfdf; position: absolute; width: 740px; height: 800px; background: green; } #sidebar { background: #dfdfdf; margin-left: 740px; position: absolute; height: 800px; width: 220px; } 4.5 利用 flex 布局：最简单的方法就是直接设置父盒子为弹性盒。此时弹性子元素的 align-items 属性默认值是 stretch，也就是在 y 轴上将所有子元素拉伸为同一高度，从而达到等高布局。5.粘连布局内容区 main 高度足够长的时候，footer 紧跟在 main后面；内容区 main 高度不够长的时候，footer 粘连在屏幕的底部5.1 代码示例：&lt;div id="wrap"> &lt;div class="main"> main &lt;br /> main &lt;br /> main &lt;br /> &lt;/div> &lt;/div> &lt;div id="footer">footer&lt;/div> * { margin: 0; padding: 0; } html, body { height: 100%;/* 高度一层层继承下来 */ } #wrap { min-height: 100%; background: pink; text-align: center; overflow: hidden; } #wrap .main { padding-bottom: 50px; } #footer { height: 50px; line-height: 50px; background: deeppink; text-align: center; margin-top: -50px; } 5.2 实现步骤footer 必须是一个独立的结构，与 wrap 没有任何嵌套关系wrap 区域的高度通过设置 min-height，变为视口高度footer 要使用 margin 为负来确定自己的位置在 main 区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。参考：https://juejin.im/post/5bbcd7ff5188255c80668028#heading-19]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM 和 BOM 中的各种宽高属性]]></title>
    <url>%2F2019%2F05%2F30%2FF-DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[先区分一下 window 对象和 document 对象：window 对象表示浏览器中打开的窗口，而 document 对象表示整个 html 文档，它是 window 对象的一部分。原生 JavaScript1.与 window 相关的宽高1.1 与窗口相关window.innerHeight/window.innerWidth:返回表示窗口的内部高度/宽度的数字。不包括开发者工具、顶部栏、侧边栏、滚动条、边框等不由 HTML 控制的部分window.outerHeight/window.outerWidth：返回表示窗口的外部高度/宽度的数字。包括开发者工具、顶部栏、侧边栏、滚动条、边框等不由 HTML 控制的部分1.2 与屏幕相关window.screen.width/window.screen.height：返回表示屏幕的宽度/高度的数字。包括可能位于任意一侧的任务栏。这两个属性不受浏览器窗口位置的影响。window.screen.availHeight/window.screen.availWidth：返回表示屏幕的可用宽度/可用高度的数字。不包括可能位于任意一侧的任务栏。这两个属性不受浏览器窗口位置的影响window.screenLeft/window.screenTop:返回表示窗口到屏幕距离的数字。无视任务栏。注意：IE 和 Opera 下表示的是窗口文档区到屏幕的距离，这意味着窗口最大化时，screenTop 返回的是窗口顶部栏的高度而不是 0。兼容性：主流浏览器均支持，FireFox 浏览器在 v64 之后才支持window.screenY/window.screenX:返回表示窗口到屏幕距离的数字。兼容性：主流浏览器均支持2.与 document 相关的宽高2.1 client 系列element.clientHeight/element.clientWidth：返回元素的可视部分的高度/宽度，且不包括滚动条。即clientHeight = height + padding - scrollBarclientWidth = width + padding - scrollBarelement.clientTop/element.clientLeft：返回元素的上边框/左边框厚度。即clientTop = borderTopclientLeft = borderLeft2.2 offset 系列element.offsetWidth/element.offsetHeight：返回元素的总高度/总宽度，包括滚动条和边框。即offsetWidth = width + padding + borderoffsetHeight = height + padding + border其实这里可以看出来，以 offsetWidth 为例，可以得出：offsetWidth = clientWidth + scrollBar + borderelement.offsetTop/element.offsetLeft首先了解什么是 offsetParent: 它是距离 element 最近的设置了定位的父元素，如果 element 的所有父元素都没有设置定位，则 offsetParent 为 body 元素。element.offsetTop = offsetParent.marginTop + offsetParent.borderTop + offsetParent.paddingTop + element.marginTop element.offsetLeft = offsetParent.marginLeft + offsetParent.borderLeft + offsetParent.paddingLeft + element.marginLeft 2.3 scroll 系列scrollWidth/scrollHeight：对于 body 元素，在没有滚动条的情况下：body.scrollWidth = window.innerWidth - scrollBarbody.scrollHeight = window.innerHeight - scrollBar在有滚动条的情况下：body.scrollWidth = width + padding + border + marginbody.scrollHeight = height + padding + border + margin对于其他元素，在没有滚动条的情况下：element.scrollWidth = element.clientWidthelement.scrollHeight = element.clientHeight在有滚动条的情况下跟 body 元素是一样的。element.scrollTop/element.scrollLeft：返回元素在垂直方向或者水平方向上已滚动的距离。例如，上图中的红框是固定的屏幕可视区，而网页视为可以上下拖动的文档，当滚动条下拉的时候，实际上是文档向上拖动，而这个拖动的距离就是 element.scrollTop2.4 返回对象系列element.style.property/element.getBoundingClientRect().property;：对于一个 dom 元素，它的 style 属性返回的是一个属性可读写的对象，且属性值常常是带有单位的。注意：这种方式只能够获取元素的行内样式，而并不能获取到元素的最终样式 —— 要获取计算好的样式，使用 element.currentstyle（IE 浏览器）或者 element.getComputedStyle(IE 之外的浏览器)。对于一个 dom 元素，它的 getBoundingClientRect() 方法返回的是该元素对应的矩形对象，通过 top，bottom，left，right 可以分别获得该对象各边相对于窗口上边或者左边的距离。如下图：可以看出，假如元素在页面滚动条的拖动下向上移动，则元素的 top 会是负值。3.与 event 相关的宽高event 对象同样存在着很多位置属性，这些位置属性的参照物都不同。ev.clientX/ev.clientY：事件发生时，鼠标点击位置相对于浏览器可视区（不包括滚动条和工具栏）左上角（该点为原点）的坐标。ev.screenX/ev.screenY：事件发生时，鼠标点击位置相对于设备屏幕左上角（该点为原点）的坐标ev.offsetX/ev.offsetY：事件发生时，鼠标点击位置相对于事件源左上角（该点为原点）的坐标。FireFox 不支持ev.layerX/ev.layerY：事件发生时，鼠标点击位置相对于 document 或者设置了定位的事件源左上角（该点为原点）的坐标。仅 FireFox 支持，要想使 layerX 与 offsetX 相等，必须给事件源设置定位。ev.pageX/ev.pageY事件发生时，鼠标点击位置相对于页面左上角（该点为原点）的坐标。窗口无滚动条时，该属性与 ev.clientX/ev.clientY 等价；窗口出现滚动条时，该属性的值将更大，因为它针对的是整个页面，即包含已滚动的区域。jQuerywidth()/height()：无参时返回元素的 content 的宽度/高度，传参时（数字或者函数）设置元素的 content 的宽度/高度。对于 window.document 传参无效，即只支持读不支持写innerWidth()/innerHeight()：基本同上，不同的是额外包含了元素的 padding，另外不推荐对 window.document 使用这个方法。outerWidth()/outerHeight()：基本同上，不同的是额外包含了元素的 border，如果传参 true，则还会包含 margin。同样不推荐对 window.document 使用这个方法。scrollLeft()/scrollTop()：水平方向上或者垂直方向上，滑块相对于整个滚动条的位置。对于某个元素，滑块处于初始位置或者无滚动条时，该方法返回 0。offset()返回元素相对于 document (左上角为原点)的当前坐标值，因此即使页面向上拖动，坐标值也不变。position():返回元素相对于其 offsetParent（(左上角为原点)） 的当前坐标值两者区别看下图：参考：https://juejin.im/entry/583a9d4961ff4b007ecbfaffhttps://segmentfault.com/a/1190000007515034https://www.jianshu.com/p/60332df38393]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「译」JavaScript 究竟是如何工作的？（第二部分）]]></title>
    <url>%2F2019%2F05%2F27%2FTrs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原文地址：How Does JavaScript Really Work? (Part 2)原文作者：Priyesh Patel译文地址：[译] JavaScript 究竟是如何工作的？（第二部分）译者：Chor照片来源于 Unsplash 上的 Samuel Zeller在这篇文章的第一部分，我简要概述了编程语言的一般工作机制，并深入探讨了 V8 引擎的管道。第二部分将介绍一些更重要的概念，这些概念是每一个 JavaScript 程序员都必须了解的，并且不仅仅和 V8 引擎有关。对于任何一个程序员来说，最关注的两个问题无非就是：时间复杂度和空间复杂度。第一部分介绍了 V8 为改进 JavaScript 执行时间所做的速度提升和优化，第二部分则将着重介绍内存管理方面的知识。内存堆Orinoco 的 logo：V8 的垃圾回收器每当你在 JavaScript 程序中定义了一个变量、常量或者对象时，你都需要一个地方来存储它。这个地方就是内存堆。当遇到语句 var a = 10 的时候，内存会分配一个位置用于存储 a 的值可用内存是有限的，而复杂的程序可能有很多变量和嵌套对象，因此合理地使用可用内存非常重要。和诸如 C 这种需要显式分配和释放内存的语言不同，JavaScript 提供了自动垃圾回收机制。一旦对象/变量离开了上下文并且不再使用，它的内存就会被回收并返还到可用内存池中。在 V8 中，垃圾回收器的名字叫做 Orinoco，它的处理过程非常高效。这篇文章有相关解释。标记与清除算法标记和清除算法我们通常会使用这种简单有效的算法来判定可以从内存堆中安全清除的对象。算法的工作方式正如其名：将对象标记为可获得/不可获得，并将不可获得的对象清除。垃圾回收器周期性地从根部或者全局对象开始，移向被它们引用的对象，接着再移向被这些对象引用的对象，以此类推。所有不可获得的对象会在之后被清除。内存泄漏虽然垃圾回收器很高效，但是开发者不应该就此将内存管理的问题束之高阁。管理内存是一个很复杂的过程，哪一块内存不再需要并不是单凭一个算法就能决定的。内存泄漏指的是，程序之前需要用到部分内存，而这部分内存在用完之后并没有返回到内存池。下面是一些会导致你的程序出现内存泄漏的常见错误：全局变量：如果你不断地创建全局变量，不管有没有用到它们，它们都将滞留在程序的整个执行过程中。如果这些变量是深层嵌套对象，将会浪费大量内存。var a = { ... } var b = { ... } function hello() { c = a; // 这是一个你没有意识到的全局变量 } 如果你试图访问一个此前没有声明过的变量，那么将在全局作用域中创建一个变量。在上面的例子中，c 是没有使用 var 关键字显式创建的变量/对象。事件监听器：为了增强网站的交互性或者是制作一些浮华的动画，你可能会创建大量的事件监听器。而用户在你的单页面应用中移向其他页面时，你又忘记移除这些监听器，那么也可能会导致内存泄漏。当用户在这些页面来回移动的时候，这些监听器会不断增加。var element = document.getElementById('button'); element.addEventListener('click', onClick) Intervals 和 Timeouts：当在这些闭包中引用对象时，除非闭包本身被清除，否则不会清除相关对象。setInterval(() => { // 引用对象 } // 这时候忘记清除计时器 // 那么将导致内存泄漏！ 移除 DOM 元素：这个问题很常见，类似于全局变量导致的内存泄漏。DOM 元素存在于对象图内存和 DOM 树中。用例子来解释可能会更好：var terminator = document.getElementById('terminate'); var badElem = document.getElementById('toDelete'); terminator.addEventListener('click', function() {memory badElem.remove(); }); 在你通过 id = ‘terminate’ 点击了按钮之后，toDelete 会从 DOM 中移除。不过，由于它仍然被监听器引用，为这个对象分配的内存并不会被释放。var terminator = document.getElementById('terminate'); terminator.addEventListener('click', function() { var badElem = document.getElementById('toDelete'); badElem.remove(); }); badElem 是局部变量，在移除操作完成之后，内存将会被垃圾回收器回收。调用栈栈是一种遵循 LIFO（先进后出）规则的数据结构，用于存储和获取数据。JavaScript 引擎通过栈来记住一个函数中最后执行的语句所在的位置。function multiplyByTwo(x) { return x*2; } function calculate() { const sum = 4 + 2; return multiplyByTwo(sum); } calculate() var hello = "some more code follows" 1.引擎了解到我们的程序中有两个函数2.运行 calculate() 函数3.将 calculate 压栈并计算两数之和4.运行 multiplyByTwo() 函数5.将 multiplyByTwo 函数压栈并执行算术计算 x*26.在返回结果的同时，将 multiplyByTwo() 从栈中弹出，之后回到 calculate() 函数7.在 calculate() 函数返回结果的同时，将 calculate() 从栈中弹出，继续执行后面的代码栈溢出在不对栈执行弹出的情况下，可连续压栈的数目取决于栈的大小。如果超过了这个界限之后还不断地压栈，最终会导致栈溢出。chrome 浏览器将会抛出一个错误以及被称为栈帧的栈快照。递归：递归指的是函数调用自身。递归可以大幅度地减少执行算法所花费的时间（时间复杂度），不过它的理解和实施较为复杂。下面的例子中，基本事件永远不会执行，lonley 函数在没有返回值的情况下不断地调用自身，最终会导致栈溢出。function lonely() { if (false) { return 1; // 基本事件 } lonely(); // 递归调用 } 为什么 JavaScript 是单线程的？一个线程代表着在同一时间段内可以单独执行的程序部分的数目。要想查看一门语言是单线程的还是多线程的，最简单的方式就是了解它有多少个调用栈。JS 只有一个，所以它是单线程语言。这样不是会阻碍程序运行吗？如果我运行多个耗时的阻塞操作，例如 HTTP 请求，那么程序必须得在每一个操作得到响应之后才能执行后面的代码。为了解决这个问题，我们需要找到一种可以在单线程下异步完成任务的办法。事件循环就是用来发挥这个作用的。事件循环到现在为止，我们谈到的内容大多包含在 V8 里面，但是如果你去查看 V8 的代码库，你会发现它并不包含例如 setTimeout 或者 DOM 的实现。事实上，除了运行引擎之外，JS 还包括浏览器提供的 Web API，这些 API 用于拓展 JS。关于事件循环的概念，菲利普·罗伯茨讲得比我更好，可以看下面这段视频。结论关于制作一门编程语言，其实还有很多内容，并且语言的实现在这些年也是不断变化的。我希望这两篇博客可以帮助你成为一名更好的 JS 程序员，并且接受 JS 中那些晦涩难懂的内容 。对于诸如“V8”，“事件循环”，“调用栈”这样的术语，你现在应该熟悉了。大部分的学生（比如我）是从一个新的框架起步，之后再去学习原生 JS。现在他们应该熟悉代码背后发生的事情了，反过来，这将帮助他们写出更好的代码。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础系列：水平垂直居中方案]]></title>
    <url>%2F2019%2F05%2F25%2FF-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[比较全面的水平垂直居中方案。水平垂直居中问题大体分为两类，一类目标元素是行内元素，一类目标元素是块级元素(其中，块级元素又包括定宽高和不定宽高）。1.水平居中方案1.1 行内元素水平居中把该行内元素包裹在一个块级父元素中，之后设置父元素:.parent{ text-align:center } 1.2 块级元素水平居中设置该元素：div{ width: 100px; /* 注意宽度一定要给出 */ margin: 0 auto; /* auto 是必须的 */ } 1.3 多个块级元素水平居中转换为行内元素。设置目标块级元素 display:inline-block，之后设置父元素：.parent{ text-align:center } 利用弹性盒子。设置父元素：.parent{ display:flex; justify-content: center; } 2.垂直居中方案2.1 单行行内元素垂直居中设置块级父元素：.parent{ /* 设置父元素的高度等于行高 */ height:100px; line-height:100px; } Tip)：这里的 line-height 最终是通过继承作用在子元素上的，所以也可以直接设置子元素为 line-height:100px。2.2 多行行内元素垂直居中设置父元素：.parent{ display:table-cell; vertical-align:middle; } Tip): 注意父元素得有高度，否则默认高度由子元素撑起，就没有垂直居中的说法了。2.3 已知高度的块级元素垂直居中设置父元素：.parent{ position:relative; } 设置子块级元素：div{ position:absolute; top: 50%; height: 100px; margin-top: -50px; } Tip): 原理是绝对定位。top:50% 确保了子元素位于父元素 1/2 分割线以下，margin-top: -50px代表子元素在这个基础上上移自身的一半高度，此时子元素与父元素中线重合，实现垂直居中。2.4 未知高度的块级元素垂直居中核心代码与上面一样，不过因为我们不知道子元素高度，也就不知道要在 top:50% 的基础上上移多少距离，因此把 margin-top:-50px 改为 transform: translateY(-50%);3. 水平垂直居中方案3.1 已知高度和宽度的元素方法一：设置父元素：.parent{ position: relative; } 设置目标元素：div{ position:absolute; width:100px; height: 100px; margin:auto; top:0; bottom:0; left:0; right:0; } Tip):这段代码比较优美和灵活。原理其实是：子元素依然相对于父元素定位，但是由于 top:0 和 bottom:0 无法同时满足，且该元素的 margin 又是自适应，因此最终变成了由上下外边距平分尺寸，从而达到垂直居中。至于水平居中，原理也是一样。方法二：设置父元素：.parent{ position: relative; } 设置目标元素：div{ position:absolute; width:100px; height: 50px; top: 50%; left:50%; margin-top: -25px; margin-left: -50px; } Tip)：原理和 2.3 其实一样，只是现在多了一个水平方向的居中。看下图：3.2 未知高度和宽度的元素设置父元素：.parent{ position: relative; } 设置目标元素：div{ position:absolute; width:100px; height: 50px; top: 50%; left:50%; transform: translate(-50%,-50%); } Tip): 原理和 2.4 一样，不同的是我们现在不知道子元素高度和宽度，也就不知道要在 top:50% 和 left:50% 的基础上再移动多少距离，因此把 margin-top:-25px 和 margin-left:-50px 对应改为 transform: translateY(50%，50%);3.3 任意元素3.3.1 利用弹性布局一设置父元素：.parent{ display:flex; justify-content: center; align-items: center; } 3.3.2 利用弹性布局二设置父元素：.parent{ display: flex; } 设置子元素：div{ margin: auto; } 3.3.3 利用网格布局一设置父元素：.parent{ display: grid; } 设置子元素：div{ justify-self:center; align-self:center; } 3.3.4 利用网格布局二设置父元素：.parent{ display: grid; } 设置子元素：div{ margin: auto; } 3.3.5 利用伪元素设置父元素.parent { font-size: 0; /* 消除空隙 */ text-align: center; /* 实现水平居中*/ &amp;::before { content: ""; display: inline-block; width: 0; height: 100%; vertical-align: middle; } } 设置子元素div{ display: inline-block; vertical-align: middle; } 参考：https://segmentfault.com/a/1190000003761600https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
      <tags>
        <tag>居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础系列： at 规则总结]]></title>
    <url>%2F2019%2F05%2F25%2FF-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aat%20%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CSS 的顶层样式表包括两种规则，一种是 qualified rule，也就是常见的普通规则，由选择器和属性指定构成；一种是 at-rule，也就是 at 规则。An at-rule is a CSS statement that instructs CSS how to behaveat 规则由一个 @ 关键字和后续的一个区块组成，如果没有区块，则以分号结束。该规则包括常规规则和嵌套规则。1.常规规则常规规则的语法为：@[KEYWORD](RULE)1.1 @charset@charset &quot;utf-8&quot;;定义 CSS 文件使用的字符编码方式，它如果被使用，必须出现在最前面。实际开发用的不多，因为&lt;meta charset=&quot;utf-8&quot;&gt;会将其覆盖。1.2 @viewport用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。1.3 @import@import &quot;index.css&quot;;@import url(&quot;index.css&quot;);导入其他 CSS 样式文件。适合用作本地的 CSS 模块化开发，实际上线的时候不建议使用，因为有多请求、阻塞加载的问题。1.4 @namespace/ XHTML命名空间 /@namespace url(http://www.w3.org/1999/xhtml);/ 内嵌在XHTML的SVG的命名空间 /@namespace svg url(http://www.w3.org/2000/svg);用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。此规则应用到 XML HTML(XHTML)上特别有用，因为这样的话 XHTML 元素可以作为选择器在 CSS 中使用。2.嵌套规则嵌套规则的语法为：@[KEYWORD]{ ...... }2.1 @document@document /* 页面 url 必须是 */ url(http://www.zhangxinxu.com/), /* 页面 url 的开头必须是... */ url-prefix(www.zhangxinxu.com/wordpress/), /* 该域上的所有页面 */ domain(zhangxinxu.com), /* 所有 https 协议页面 */ regexp("https:.*") { /* 开始样式 */ body { font-family: Comic Sans; } } CSS 4.0 新增，规定了文档满足某个条件时应用的样式。普及度不高，不建议使用。2.2 @keyframes@keyframes mymove { from {top:0px;} to {top:200px;} } @keyframes mymove { 0% {top:0px;} 50% {top:100px;} 100% {top:0px;} } 用于定义元素动画的关键帧，从一个样式过渡到另一个样式2.3 @media@media screen and (min-width:960px){ /* 宽度大于 960px 时的样式*/ } 媒体查询，用于响应式布局。2.4 @page用于打印文档时修改一些 CSS 属性2.5 @supports@supports {display:flex}{ .module {display:flex;} } 是否支持某 CSS 属性声明参考链接：https://www.cnblogs.com/theWayToAce/p/5291734.htmlhttps://segmentfault.com/a/1190000019117364]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6 参数默认值引起的中间作用域]]></title>
    <url>%2F2019%2F05%2F24%2FF-ES6%20%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[ES6 参数默认值的问题，其实之前在这篇文章中已经有涉及，之所以再谈起这个问题，是在阅读《ES6 标准入门》时产生的一个疑惑。阮老师的代码是：var x = 1; function foo(x, y = function() { x = 2; }) { var x = 3; y(); console.log(x); } foo(); // 3 x // 1 怎么解释输出？首先需要明确的是，参数默认值确实会引起一个额外的参数作用域，不信看一下标准：If the function’s formal parameters do not include any default value initializers then the body declarations are instantiated in the same Environment Record as the parameters. If default value parameter initializers exist, a second Environment Record is created for the body declarations. Formal parameters and functions are initialized as part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.（注意这里的 default value parameter initializers exist，也就是说声明了默认参数值不一定会产生这个作用域，只有初始化了、确实用到了这个默认值，作用域才会产生。）第二个需要明确的地方是：上面代码中，存在全局作用域、参数作用域、函数作用域，并且这三者的关系如图：明确这两点之后开始来分析结果。实际上这段代码中存在着三个不同的 x，分别是全局的 x，参数作用域的 x 以及函数体内重新声明的 x。调用 foo 执行到 y 函数的时候，将值赋给 x，那么这是哪个 x 呢？对于 y 函数，x 不是在其体内声明的，所以这个 x 对它来说是自由变量，根据作用域链查找的规则，此时会查找到参数作用域中的 x ，并赋值为 2。之后打印 x，首先会在 foo 函数对应的变量对象中查找 x 的声明，确实 foo 函数里面有这个声明，所以就把它打印出来，为 3。后面在全局访问 x 时也同理，因为全局已经有这个 x 的声明，所以就把它打印出来，为 1。事情到这里其实问题不大，直到后面遇到了两段代码，对于输出无法理解。其一先说第一个 snippet ：function f1 ( x = 2, f = function () { x=3; } ){ let x = 5; f(); console.log(x); } f1(); 这段代码会报错：Identifier ‘x’ has already been declared。如果在同一作用域中用 let 重复声明一个变量，则确实会报错，但是根据上面的分析，这里其实是不同的两个作用域，按道理说不应该报错。为什么会报错呢？首先从标准来回答这个问题：4.1.2 Static Semantics:Early ErrorsIt is a Syntax Error if any element of the BoundNames of FormalParameters also occurs in the LexicallyDeclaredNames of FunctionBody意思是说，如果参数名和函数体内的变量名相同，将会报 Syntax Error，而且注意这是一个 Early Errors，也就是说，在解析阶段就会报错 ——— 由此看出，这里的参数 x 和函数体内 x 其实是一起解析的，并在解析时报错。那么为什么要这么设计呢？根据 @紫云飞 老师的说法，这其实是出于合理情况的考虑 —— 这里就应该报错。因为如果不报错，让开发者重复声明了一个变量，那么在函数体作用域内，实参将难以获取（事实上我们依然可以通过参数作用域里的函数返回这个实参，但这不是我们希望的访问方式）。因此这里的报错是一种合理的设计。到这里，这个问题就算解释清楚了，接下来说第二个问题。其二这是第二个 snippetfunction f1 ( x = 2, f = function () { x = 3; } ){ var x; f(); console.log(x); } f1(); // 2 奇怪，上面不是说重复声明会有 Syntax Error 吗？为何这里又不报错了？说实话，这个问题我暂时没有找到比较好的解释，只能说可能是由于上面的 Error 是针对 let 声明这种情况来说的，因为 ES5 中 var 的重复声明确实不会报错，在这里也一样不报错。那么回到问题，为什么这里会输出 2？先按照正常思路分析，执行 f 函数时，为 x 赋值 3，这个 x 按照之前的解释，应该是参数 x 而不是函数体内的 x 。所以，函数体的 x 依然是 undefined（只声明，没赋值），不过我们知道，结果打印的是 2，与预想相反。可以肯定的是，这里访问的一定是函数体的 x，那么它为何会有值 2 呢，难道它默认会有一个值吗？确实如此，我们再来看标准：NOTE vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.意思是说，与参数同名的 var 变量在初始的时候会具有一个与对应的参数相同的值。在这个例子中，函数体中的 x 的值将会和参数默认值一样，为 2。我们可以打下断点：那么这样设计的目的是什么呢？前面我们说过，我们期望的合理行为是：可以在函数体内成功访问到实参，或者更准确地说，访问到实参的值。虽然这里我们无法轻易访问到实参，但是通过设置同名变量的值与实参相同，达到了类似的期望效果。到这里问题算是解决了。这次问题的解决主要从三个方面入手：自主搜索、平台提问、阅读规范。网上有很多文章讲到参数默认值，但是提及参数作用域的文章数量很有限，所以最后也基本是依靠知乎上两位老师的回答以及自己的琢磨得出了结论。对我来说，阅读规范的难度还是太大了，很难定位到重点，所以本篇文章极有可能有表述错误的地方，如果你在阅读之后有任何的想法，欢迎在底下评论区留言。这里附上一些相关的文章链接：https://juejin.im/post/5c7350c7f265da2dde06f3aahttps://segmentfault.com/a/1190000007537913#articleHeader0https://segmentfault.com/q/1010000015237136/a-1020000015242350https://code.wileam.com/default-value-n-params-env/]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「译」利用 JavaScript 复制文本到剪贴板]]></title>
    <url>%2F2019%2F05%2F23%2FTrs-%E5%88%A9%E7%94%A8JavaScript%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[一个小小的诀窍。实现主题的复制代码功能时，思路刚好和这篇文章差不多，不过这篇文章的代码要更加合理。原文地址：Copying text to clipboard with JavaScript原文作者：Angelos Chalaris译者：Chor本文将会深入介绍 30 秒代码 中 copyToClipboard 代码块的工作原理。你可以在项目仓库中找到它的源代码以及更多其他的实用方法。30 秒代码：可以在 30 秒或更短时间内理解的 JavaScript 代码块核心功能搭建网站时经常会遇到一个需求，那就是在用户没有选中或者使用键盘组合键的情况下，复制文本到剪贴板。JavaScript 可以用短短五步轻松解决这个问题：1.创建一个稍后将插入到文档中的 &lt;textarea&gt; 元素。将我们想要复制到剪贴板的字符串设置为它的 value 。2.将上诉 &lt;textarea&gt; 元素插入到当前的 HTML 文档中。3.使用 HTMLInputElement.select() 选中 &lt;textarea&gt; 元素的内容。4.使用 Document.execCommand(&#39;copy&#39;) 复制 &lt;textarea&gt; 元素的内容到剪贴板。5.从文档中移除 &lt;textarea&gt; 元素。这个方法的最简版本大概如下：const copyToClipboard = str => { const el = document.createElement('textarea'); el.value = str; document.body.appendChild(el); el.select(); document.execCommand('copy'); document.body.removeChild(el); }; copyToClipboard 方法的基本实现记住，这个方法不是在任何情况下都可以使用的。因为 Document.execCommand() 的工作方式，它必须作为用户操作的响应结果。让插入的元素不可见如果你试用了上面的方法，你可能会在 &lt;textarea&gt; 元素插入或者移除时看到闪烁。这对使用屏幕阅读器的人来说很糟糕，因为它会导致一些非常烦人的问题。因此，下一步合理的操作就是使用 CSS 让元素不可见，同时设置只读，以防止用户的试图干扰。const copyToClipboard = str => { const el = document.createElement('textarea'); el.value = str; el.setAttribute('readonly', ''); el.style.position = 'absolute'; el.style.left = '-9999px'; document.body.appendChild(el); el.select(); document.execCommand('copy'); document.body.removeChild(el); }; 隐藏文本域的 copyToClipboard 实现保存和恢复原先的文档选中最后需要考虑的问题是，用户可能已经在 HTML 文档中选中了一些内容，明智之举是不移除他们选中的这些内容。幸运的是，我们可以使用诸如 DocumentOrShadowRoot.getSelection(),Selection.rangeCount, Selection.getRangeAt(), Selection.removeAllRanges() 和 Selection.addRange() 等现成的 JavaScript 方法和属性来保存和恢复原先的文档选中。这是最终的带注释的改良代码：const copyToClipboard = str => { const el = document.createElement('textarea'); // 创建一个 &lt;textarea> 元素 el.value = str; // 设置它的值为你想复制的字符串 el.setAttribute('readonly', ''); // 设置为只读以防止干扰 el.style.position = 'absolute'; el.style.left = '-9999px'; // 移出屏幕外以使其不可见 document.body.appendChild(el); // 插入 &lt;textarea> 元素到 HTML 文档中 const selected = document.getSelection().rangeCount > 0 // 检查是否之前曾选中过内容 ? document.getSelection().getRangeAt(0) // 如果找到，则保存选中 : false; // 标记为 false 以表示不存在之前选中的内容 el.select(); // 选中 &lt;textarea> 的内容 document.execCommand('copy'); // 复制 - 仅当作为用户操作的响应结果时才可以工作(比如，点击事件) document.body.removeChild(el); // 移除 &lt;textarea> 元素 if (selected) { // 如果在复制前已存在选中的内容 document.getSelection().removeAllRanges(); // 取消 HTML 文档中所有的选中部分 document.getSelection().addRange(selected); // 恢复原来的选中 } }; 最终形式的 copyToClipboard，可以保存选中这就是全部的内容。仅用了不到 20 行代码，我们已经创建了前端开发中最常用的方法之一。如果喜欢这篇文章，给一个 clap（或者 fifty）。记得查看 30 秒代码 ，为你的 JavaScript 项目找到更多实用的代码块！]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>30 seconds of code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习知识体系]]></title>
    <url>%2F2019%2F05%2F22%2FT-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[原文地址：一名【合格】前端工程师的自检清单原文作者：ConardLi原文题目是《一名合格前端工程师的自检清单》，我目前的水平离前端工程师还很遥远，所以更愿意把这篇文章当作是对知识体系或者学习路线的总结。同时也是对自己的一个警醒，做好长期学习的准备。PS： 表示自己增加的部分一、JavaScript变量和类型1.JavaScript 规定了几种数据类型2.JavaScript 对象的底层数据结构是什么3.Symbol 类型在实际开发中的应用、可手动实现一个简单的 Symbol4.基本类型对应的内置对象，以及他们之间的装箱拆箱操作5.理解值类型和引用类型6.赋值、浅拷贝、深拷贝的区别7.null 和 undefined 的区别8.至少可以说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用10.出现小数精度丢失的原因， JavaScript 可以存储的最大数字、最大安全数字， JavaScript 处理大数字的方法、避免精度丢失的方法原型和原型链1.理解原型设计模式以及 JavaScript中的原型规则2.instanceof的底层实现原理，手动实现一个 instanceof3.实现继承的几种方式以及他们的优缺点4.至少说出一种开源项目(如 Node)中应用原型继承的案例5.可以描述 new一个对象的详细过程，手动实现一个 new操作符6.理解 es6class构造以及继承的底层实现原理作用域和闭包1.理解词法作用域和动态作用域2.理解 JavaScript 的作用域和作用域链3.理解 JavaScript 的执行上下文栈和变量对象，可以应用堆栈信息快速定位问题4.this 的绑定，call、apply、bind 的原理5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用6.如何处理循环的异步操作7.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理内存机制内存空间，堆栈存储理解堆栈溢出、内存泄漏的原理，如何防止，如何进行垃圾回收执行机制1.为何 try 里面放 return， finally 还会执行，理解其内部机制2.JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制3.宏任务和微任务分别有哪些4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法5.使用 Promise 实现串行6.Node 与浏览器 EventLoop 的差异7.如何在保证页面运行流畅的情况下处理海量数据语法和API1.理解 ECMAScript 和 JavaScript 的关系2.熟练运用 es5、 es6 提供的语法规范，尤其是掌握 es6 的 let、解构、箭头函数、Promise、Async、Await、Class 等3.熟练掌握 JavaScript提供的全局对象、全局函数、全局属性4.熟练应用 map、 reduce、 filter 等高阶函数解决问题5.setInterval 需要注意的点，使用 settimeout 实现 setInterval6.JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、 URL 解析、去重等）解决常见问题7.JavaScript 异常处理的方式，统一的异常处理方案jQuery1.熟练掌握选择器，样式操作，dom 操作，事件绑定2.链式编程（方法链），动画3.常用组件，通过源代码了解封装原理二、HTML和CSSHTML1.从规范的角度理解 HTML，从分类和语义的角度使用标签2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式3.元信息类标签( head、 title、 meta)的使用目的和配置方法4.HTML5离线缓存原理5.可以使用 CanvasAPI、 SVG 等绘制高性能的动画CSS1.CSS 盒模型，在不同浏览器的差异（w3c 盒模型，IE 盒模型）2.CSS 所有选择器及其优先级、使用场景，哪些属性可以继承，如何运用 at规则3.CSS 伪类和伪元素有哪些，它们的区别和实际应用4.HTML 文档流的排版规则， CSS 几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理5.水平垂直居中的方案、可以实现 6 种以上并对比它们的优缺点6.BFC 实现原理，可以解决的问题，如何创建 BFC，如何清除浮动7.了解布局方案的发展历史（table、div+css、一维 flex、二维 grid）。熟悉 flex 布局的六大容器属性和项目属性7.可使用 CSS 函数复用代码，实现特殊效果8.PostCSS、 Sass、 Less 的异同，以及使用配置，至少掌握一种9.CSS 模块化方案、如何配置按需加载、如何防止 CSS 阻塞渲染10.CSS 浏览器兼容性写法，了解不同 API 在不同浏览器下的兼容性情况11.掌握多套完整的响应式布局方案手写1.手写瀑布流、轮播图、焦点图、弹出层、手风琴菜单、返回顶部、导航定位 2.使用 CSS 绘制几何图形（圆形、三角形、扇形、菱形等）3.使用纯 CSS 实现曲线运动（贝塞尔曲线）4.使用 CSS 实现常见动画，如渐变、移动、旋转、缩放等等4.实现常用布局效果（二列、三列、圣杯、双飞翼、吸顶、移动吸顶），可以说出多种方式并理解其优缺点框架bootstrap 的组件应用、常用模板、删格系统 三、计算机基础关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要编译原理1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序2.正则表达式的匹配原理和性能优化3.如何将 JavaScript代码解析成抽象语法树( AST)base64的编码原理5.几种进制的相互转换计算方法，在 JavaScript中如何表示和转换网络协议1.理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用2.三次握手和四次挥手详细原理，为什么要使用这种机制3.有哪些协议是可靠， TCP 有哪些手段保证可靠交付4.DNS 的作用、 DNS 解析的详细过程， DNS 优化原理5.CDN 的作用和原理6.HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么7.HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题8.HTTP1.1、 HTTP2.0 带来的改变9.HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求10.理解 WebSocket 协议的底层原理、与 HTTP 的区别设计模式1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等2.发布订阅模式和观察者模式的异同以及实际应用3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用四、数据结构和算法JavaScript编码能力1.多种方式实现数组去重、扁平化、对比优缺点2.多种方式实现深拷贝、对比优缺点3.手写函数柯里化工具函数、并理解其应用场景和优势4.手写防抖和节流工具函数、并理解其内部原理和应用场景5.实现一个 sleep 函数手动实现前端轮子1.手动实现 call、apply、bind2.手动实现符合 Promise/A+ 规范的 Promise、手动实现 asyncawait3.手写一个 EventEmitter 实现事件发布、订阅4.可以说出两种实现双向绑定的方案、可以手动实现5.手写 JSON.stringify、JSON.parse6.手写一个模版引擎，并能解释其中原理7.手写懒加载、下拉刷新、上拉加载、预加载等效果数据结构1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点2.理解数组、字符串的存储原理，并熟练应用他们解决问题3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题4.了解图、堆的基本结构和使用场景算法1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗2.至少理解五种排序算法的实现原理、应用场景、优缺点,可快速说出时间、空间复杂度3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题5.前端处理海量数据的算法方案五、运行环境我们需要理清语言和环境的关系：ECMAScript描述了 JavaScript语言的语法和基本对象规范浏览器作为 JavaScript的一种运行环境，为它提供了：文档对象模型（ DOM），描述处理网页内容的方法和接口、浏览器对象模型（ BOM），描述与浏览器进行交互的方法和接口Node也是 JavaScript的一种运行环境，为它提供了操作 I/O、网络等 API浏览器 API1.浏览器提供的符合 W3C标准的 DOM 操作 API、浏览器差异、兼容性2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局 API、浏览器差异、兼容性3.大量 DOM 操作、海量数据的性能优化(合并操作、Diff、 requestAnimationFrame 等)4.浏览器海量数据存储、操作性能优化DOM 事件流的具体实现机制、不同浏览器的差异、事件代理6.前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、 fetch、可以熟练使用第三方库7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型8.浏览器跨域解决方案9.浏览器提供的几种存储机制、优缺点、开发中正确的选择10.浏览器跨标签通信浏览器原理1.各浏览器使用的 JavaScript 引擎以及它们的异同点、如何在代码中进行区分2.请求数据到请求结束与服务器进行了几次交互3.可详细描述浏览器从输入 URL 到页面展现的详细过程4.浏览器解析 HTML 代码的原理，以及构建 DOM 树的流程5.浏览器如何解析 CSS 规则，并将其应用到 DOM 树上6.浏览器如何将解析好的带有样式的 DOM 树进行绘制7.浏览器的运行机制，如何配置资源异步同步加载8.浏览器回流与重绘的底层原理，引发原因，如何有效避免9.浏览器的垃圾回收机制，如何避免内存泄漏10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案AJAX 1.Ajax 简介、异步的概念、Ajax 框架的封装、XMLHttpRequest 对象、兼容性处理方法、Ajax 缓存问题、XML 介绍和使用2.JSON 和 JSON 解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和 lazy-load 技术、JQuery 框架中的 AjaxAPINode1.理解 Node 在应用程序中的作用，可以使用 Node 搭建前端运行环境、使用 Node 操作文件、操作数据库等等2.掌握一种 Node 开发框架，如 Express， Express 和 Koa的区别3.熟练使用 Node 提供的 API 如 Path、 Http、 ChildProcess 等并理解其实现原理4.Node 的底层运行原理、和浏览器的异同5.Node 事件驱动、非阻塞机制的实现原理六、框架和类库轮子层出不穷，从原理上理解才是正道TypeScript1.理解泛型、接口等面向对象的相关概念，TypeScript 对面向对象理念的实现2.理解使用 TypeScript 的好处，掌握 TypeScript 基础语法3.TypeScript 的规则检测原理4.可以在 React、 Vue 等框架中使用 TypeScript 进行开发Vue1.熟练使用 Vue 的 API、生命周期、钩子函数2.MVVM 框架设计理念3.Vue 双向绑定实现原理、Diff 算法的内部实现4.Vue 的事件机制5.从 template 转换成真实 DOM 的实现机制多端开发1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发 SPA的方案2.理解 Viewport、em、rem 的原理和用法，分辨率、 px、 ppi、 dpi、 dp的区别和实际应用3.移动端页面适配解决方案、不同机型适配方案，移动端测试和调试4.掌握一种 JavaScript移动客户端开发技术，如 ReactNative：可以搭建 ReactNative 开发环境，熟练进行开发，可理解 ReactNative 的运作原理，不同端适配5.掌握一种 JavaScript PC客户端开发技术，如 Electron：可搭建 Electron 开发环境，熟练进行开发，可理解 Electron 的运作原理6.掌握一种小程序开发框架或原生小程序开发7.理解多端框架的内部实现原理，至少了解一个多端框架的使用数据流管理1.掌握 React 和 Vue 传统的跨组件通信方案，对比采用数据流管理框架的异同2.熟练使用 Redux 管理数据流，并理解其实现原理，中间件实现原理3.熟练使用 Mobx 管理数据流，并理解其实现原理，相比 Redux 有什么优势4.熟练使用 Vuex 管理数据流，并理解其实现原理5.以上数据流方案的异同和优缺点，不情况下的技术选型实用库1.至少掌握一种 UI 组件框架，如 antd design，理解其设计理念、底层实现2.掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表3.掌握一种 GIS 开发框架，如百度地图 API4.掌握一种可视化开发框架，如 Three.js、 D35.工具函数库，如 lodash、 underscore、 moment 等，理解使用的工具类或工具函数的具体实现原理开发和调试1.熟练使用各浏览器提供的调试工具2.熟练使用一种代理工具实现请求代理、抓包，如 charls3.可以使用 Android、 IOS模拟器进行调试，并掌握一种真机调试方案4.了解 Vue、 React等框架调试工具的使用七、前端工程前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度项目构建1.理解 npm、 yarn依赖包管理的原理，两者的区别2.可以使用 npm运行自定义脚本3.理解 Babel、 ESLint、 webpack等工具在项目中承担的作用4.ESLint规则检测原理，常用的 ESLint配置5.Babel的核心原理，可以自己编写一个 Babel插件6.可以配置一种前端代码兼容方案，如 Polyfill7.Webpack的编译原理、构建流程、热更新原理， chunk、 bundle和 module的区别和应用8.可熟练配置已有的 loaders和 plugins解决问题，可以自己编写 loaders和 pluginsnginx1.正向代理与反向代理的特点和实例2.可手动搭建一个简单的 nginx服务器、3.熟练应用常用的 nginx内置变量，掌握常用的匹配规则写法4.可以用 nginx实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理开发提速1.熟练掌握一种接口管理、接口 mock工具的使用，如 yapi2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题3.理解 TDD与 BDD模式，至少会使用一种前端单元测试框架版本控制1.理解 Git的核心原理、工作流程、和 SVN的区别2.熟练使用常规的 Git命令、 git rebase、 git stash等进阶命令3.可以快速解决 线上分支回滚、 线上分支错误合并等复杂问题4.熟练使用Github平台持续集成1.理解 CI/CD技术的意义，至少熟练掌握一种 CI/CD工具的使用，如 Jenkins2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括 Web应用、移动客户端应用、 PC客户端应用、小程序、 H5等等）八、项目和业务后端技能1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库性能优化1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案2.了解常见的 Web、 App性能优化方案3.SEO排名规则、 SEO优化方案、前后端分离的 SEO4.SSR实现方案、优缺点、及其性能优化5.Webpack的性能优化方案6.Canvas性能优化方案7.React、 Vue等框架使用性能优化方案前端安全1.XSS攻击的原理、分类、具体案例，前端如何防御2.CSRF攻击的原理、具体案例，前端如何防御3.HTTP劫持、页面劫持的原理、防御措施业务相关1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性九、学习提升 1.博客：持续更新博客，定期总结知识，不断完善自己的知识体系2.英语：参与社区翻译，在阅读资料上逐渐往官方文档和英文博客靠拢3.人际：保持好奇心，保持解疑的热情，保持理性交流4.知识管理：RSS/书籍/社区 —— 印象笔记 —— 博客]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础系列：从清除浮动和margin塌陷问题谈BFC]]></title>
    <url>%2F2019%2F05%2F17%2FF-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC%2F</url>
    <content type="text"><![CDATA[1.清除浮动浮动的元素会影响其兄弟元素的位置，并可能导致父元素的高度塌陷（假如父元素没设置高度），因此需要清除浮动（带来的影响）。1.1 方法常用方法有：给浮动元素的父元素一个固定高度（不推荐）给浮动元素新增一个空的 div 兄弟元素，设置 clear:both给浮动元素新增一个 &lt;br&gt; 兄弟元素，设置 clear 属性为 all给浮动元素的父元素新增一个 after 伪类，设置该伪类和父元素：div{ zoom:1; } div:after{ content:""; display:block; clear:both; } 给浮动元素的父元素设置 display: table（触发BFC）给浮动元素的父元素也设置浮动（触发 BFC。不推荐）给浮动元素的父元素设置 overflow: hidden（触发 BFC）1.2 原理这里主要说下 clear:both。clear:both 意思是说，设置了该属性的元素，其左边和右边不允许存在浮动元素。父元素高度塌陷的情况：子元素浮动后脱离了文档流，未设置高度的父元素在形式上表现为 0 高度，设置了 clear:both 的元素为了满足其左右两边没有浮动元素的这个条件，只能自身下移，从而带动了父元素高度的撑开。兄弟元素覆盖的情况：同理，比如A由于浮动覆盖了 C，我们在 AC 之间新增一个 B 元素，则 BC 位于同一文档流，B 为了满足其左右两边没有浮动元素的这个条件，只能自身下移，从而带动了 C 元素向下移动直到没有被 A 覆盖。那么为什么除了 clear:both 之外，其他方法也能清除浮动呢？因为那些方法大都触发了 BFC，而 BFC 是可以清除浮动的，这个后面再介绍。2.margin 塌陷文档流内，块级元素与块级元素在垂直方向上的 margin 有时会合并（塌陷）为单个 margin，这样的现象称之为 margin 塌陷（margin collapse）。具体包括三种情况：相邻的兄弟元素之间：原因：相邻的兄弟元素默认位于同一个块级上下文中计算规则：正正取大值，正负值相加，负负最小值父元素与第一个/最后一个子元素之间：原因：a.margin-top 重叠父元素非块状格式化上下文元素父元素没有border-top设置父元素没有padding-top值父元素和第一个子元素之间没有inline元素分隔b.margin-bottom 重叠父元素非块状格式化上下文设置父元素没有 border-bottom 设置父元素没有 padding-bottom 值父元素和第一个子元素之间没有inline元素分隔父元素没有 height，min-height，max-height计算规则：子元素和父元素上边界重叠，并且以子元素的 margin-top 作为父元素的 margin-top 整体移动。对于 margin-bottom 同理。空的block元素:原因：元素没有 border 设置元素没有 padding 值里面没有 inline 元素没有 height 或者min-height那么怎么解决 margin 塌陷问题呢？同样是利用接下来要讲到的 BFC。3.BFC3.1 什么是 BFC？BFC 即 Block formatting context，译为块级格式化上下文。简单来说，它是一种属性，这种属性影响着元素的定位以及与其兄弟元素之间的相互作用。因为是属性，所以我们通常说“元素具有 BFC”、“元素触发了 BFC”，而不说“元素是 BFC”。从样式上看，具有 BFC 的元素与普通的容器没有什么区别；但是从功能上，具有 BFC 的元素可以看作是隔离了的独立容器，容器里面的子元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性。3.2 如何触发 BFC？CSS 规定满足下列 CSS 声明之一的元素便会生成 BFC：根元素或其它包含它的元素；float 的值不为 none；overflow 的值不为 visible；position 的值为 absolute 或 fixed；display 的值为 inline-block、table-cell、table-caption、table、flex、inline-flex、flow-roottable 本身不生成 BFC，而是 table 默认生成的匿名 table-cell 会生成 BFC3.3 BFC 的特性从整体上看，BFC 是隔离了的容器，这个具体可以表现为三个特性：3.3.1 BFC 会阻止 margin 塌陷前面我们说过 BFC 可以用于解决 margin 塌陷问题。因为相邻兄弟元素默认位于同一个 BFC 是导致 margin 塌陷的原因，所以我们只需要设法隔离它们两者即可 ———— 假设有兄弟元素 A 和 B，可以使 A 的父元素触发 BFC，此时，触发了 BFC 的父元素里面的 A 子元素不会在布局上影响到 B，也自然不会有 margin 的叠加。同样地，如果是父子嵌套的 margin 塌陷问题，只需要触发父元素的 BFC 即可。3.3.2 BFC 可以包含浮动的元素前面说过，父元素没有设置高度时，子元素的浮动会导致父元素表现为 0 高度，也就是说正常情况下父元素无法包含浮动的子元素。如图：.Fa{ border: 2px solid red; width: 300px; } .son{ width:180px; height:180px; background-color:yellow; float:left; } 但是触发了父元素的 BFC 后，父元素将可以包含浮动的子元素。如图：.Fa{ border: 2px solid red; width: 300px; overflow:hidden; /* 随便一个 BFC 的触发条件 */ } .son{ width:180px; height:180px; background-color:yellow; float:left; } 3.3.3 BFC 可以阻止元素被浮动元素覆盖前面说过浮动元素会影响兄弟元素的位置，具体地说就是浮动之后脱离了文档流，使得兄弟元素上移填补空缺，而这会使得它被浮动元素覆盖。如图：但是触发了兄弟元素的 BFC 后，兄元素将不会被浮动的元素覆盖 ———— 不会被覆盖，意味着兄弟元素出现在浮动元素的旁边或者下面，具体取决于父元素的宽度。如果父元素的宽度足以包含这两个子元素的宽度之和，则子兄弟元素和子浮动元素并排。如图：如果父元素的宽度不足以包含这两个子元素的宽度之和，则子兄弟元素会出现在子浮动元素的下面。如图：4.可视化格式模型让我们进一步拓展一下可视化格式模型的一些概念，由于比较复杂，所以只做了解即可。可视化格式模型规定了客户端（浏览器）如何在媒介（显示器）中渲染文档树(document tree)。如下图，每个节点、元素都有属于自己的可见或不可见、有名或匿名的盒模型，可视化格式模型即规定了这些盒、框框如何整齐地排列在页面中，还有盒子之间的相互作用。可视化格式模型的体系包括：1.包含块 CB(Containing block)2.控制框：块框、行框3.FC(Formatting Context, 格式化上下文)BFC(Block Formatting Context, 块级格式化上下文)IFC(Inline Formatting Context, 行内格式上下文)GFC(Grid Formatting Context, 网格布局格式化上下文)FFC(Flex formatting contexts, 自适应格式上下文)4.定位体系/方案(普通流、定位流、浮动流)5.浮动体系这里只说 FC 和定位体系。4.1 FCFC 即 Formatting context，译为格式化上下文。这是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系、相互作用。除了最常见的 CSS2.1 中的 BFC 和 IFC 之外，CSS3 中还增加了 GFC 和 FFC。4.1.1 BFC：前面已经说过了。4.1.2 IFC：IFC 的 line box 高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。IFC 的line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 IFC 下的多个 line box 高度会不同。IFC 中是不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。那么IFC一般有什么用呢？水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。4.1.3 GFC：当为一个元素设置 display:grid 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么 GFC 有什么用呢，和 table 又有什么区别呢？首先同样是一个二维的表格，但 GridLayout 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。4.1.4 FFC：display:flex 或者 display:inline-flex 的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少 safari 和 chrome 还是 OK 的，毕竟这俩在移动端才是王道。Flex box 由伸缩容器和伸缩项目组成。通过设置元素display:flex 或者 display:inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flex box 定义了伸缩容器内伸缩项目该如何布局。4.2 定位方案在定位的时候，浏览器会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。在 CSS2.1 中，有三种定位方案 ———— 普通流、浮动和绝对定位，下面分别对这三种布局简略说明一下：普通流(Normal flow)在普通流中，盒一个接着一个排列;在块级格式化上下文里面，它们竖着排列；在行内格式化上下文里面，它们横着排列;通常情况下， position 为 static 或 relative，并且 float 为 none ，因而会触发普通流；position 为 static 时，盒的位置是常规流布局里的位置；position 为 relative 时，盒偏移位置由 top，bottom，left 和 right 定义。即使有偏移，仍然保留原有的位置，其它普通流不能占用这个位置。浮动 (Floats)元素脱离普通流，并且影响普通流的布局 ———— 导致普通流环绕在它的周边，除非设置 clear 属性；盒称为浮动盒(floating boxes)；它位于当前行的开头或末尾；绝对定位 (Absolute positioning)元素脱离普通流，并且不影响普通流的布局它的定位相对于它的包含块，相关CSS属性：top，bottom，left 和 right；如果元素为 position:absolute 或 position:fixed，它是绝对定位元素；对于 position: absolute，元素将相对最近的一个非 static 定位的父元素进行定位，如果没有则相对于 body；参考：学习 BFC (Block Formatting Context)CSS-可视化格式模型]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
      <tags>
        <tag>BFC</tag>
        <tag>浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「译」JavaScript 究竟是如何工作的？（第一部分）]]></title>
    <url>%2F2019%2F05%2F10%2FTrs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原文地址：How Does JavaScript Really Work? (Part 1)原文作者：Priyesh Patel译文地址：[译] JavaScript 究竟是如何工作的？（第一部分）译者：Chor如果你是一个 JS 开发者或者是正在学习这门语言的学生，很大概率上你会遇到双字母词”V8”。在这篇文章中，我将会为你简述不同的 JS 引擎并深入探究 V8 引擎的工作机制。文章的第二部分涵盖了内存管理的概念，不久后将发布。这篇文章是由 Bit (GitHub) 带来的。作为一个共享组件的平台，Bit 帮助每个人构建模块化的 JavaScript 应用程序，在项目和团队之间轻松地共享组件，同时实现更好&amp;更快的构建。试试看。1.编程语言是如何工作的？在开始讲解 JavaScript 之前，我们首先要理解任意一门编程语言的基本工作方式。电脑是由微处理器构成的，我们通过书写代码来命令这台小巧但功能强大的机器。但是微处理器能理解什么语言？它们无法理解 Java，Python 等语言，而只懂机器码。用机器语言或汇编语言编写企业级代码是不可行的，因此我们需要像 Java，Python 这样配带一个解释器或者编译器用于将其转换为机器码的高级语言。1.1编译器和解释器编译器/解释器可以用它处理的语言或任何其他语言来编写。解释器： 一行一行地快速读取和翻译文件。这就是 JavaScript 最初的工作原理。编译器： 编译器提前运行并创建一个文件，其中包含了输入文件的机器码转换。有两种途径可以将 JavaScript 代码转换为机器码。编译代码时，机器对代码开始运行前将要发生的事情有更好的理解，这将加快稍后的执行速度。不过，在这个过程之前需要花费时间。另一方面，解释代码时，执行是立即的，因此要更快，但是缺乏优化导致它在大型应用程序下运行缓慢。创建 ECMAScript 引擎的人很聪明，他们集二者之长开发了 JIT(Just-in-time) 编译器。JavaScript 同时被编译和解释，但实际实现和顺序取决于引擎。我们将会看到 V8 团队采用的是什么策略。2.从 JavaScript 到机器码就 JavaScript 而言，有一个引擎将其转换为机器码。和其他语言类似，引擎可以用任何语言来开发，因此这样的引擎不止一个。V8 是谷歌针对 Chorme 浏览器的引擎实现。SpiderMonkey 是第一个引擎，针对网景浏览器开发，现用于驱动 FireFox。JavaScriptCore 是苹果针对 Safari 浏览器使用的引擎。还有很多，如果你想知道 Internet Explorer 背后的引擎，查看这个维基百科页面.2.1 ECMAScript面对这么多的引擎，你可能会问：我可以开发自己的引擎吗？可以，只要遵循 ECMAScript 标准。如果我们打算做一个翻译器，那么就必须知道这两门语言的有效字。我们已经知道机器语言中什么是有效的了，但是对于 JavaScript，这是需要进行标准化的。JavaScript 的标准化工作是由 Ecma 国际组织负责的，相关规范被称为 ECMAScript 或者 ES。因此，当你看到一篇文章/视频提到“ES7 有什么新特性？”时，你就知道它代表的是 ECMAScript 标准中新增的 JS 特性。3.V8 引擎3.1 部分历史谷歌针对浏览器开发了谷歌地图，而这对浏览器的处理能力提出了很高的要求。那时的 JavaScript 实现尚不足以快速地运行地图。谷歌想要吸引更多的用户使用这项服务，从而进行广告销售并牟利。基于这个原因，这项服务必须快速且稳定。因此谷歌自己用 C++ 开发了 V8 引擎并在 2008 年启用，它的速度很快，或者就像一些人说的，它的速度是最快的。3.2 解析和构建树JavaScript 文件进入引擎后，解析器进行词法解析，它将代码分解成 token 以确定它们的含义。这些 token 组成了AST(抽象语法树)。编译器在语义分析中验证语言元素和关键词的正确用法，而 ASTs 在这个过程中扮演着重要的角色。之后，ASTs 被用于生成实际的字节码或者机器码。3.3 引擎的核心我们之前谈到，JavaScript 是由 Ignition 这个解释器解释的，同时由 TurboFan 这个 JIT 优化编译器进行编译。首先，前面步骤生成的 ASTs 传递给解释器，该解释器迅速生成未经过优化的机器码，并且其执行是无延迟的。Profiler 在代码运行时进行观察，找出可以进行优化的地方。例如，一个‘for’循环跑了 100 次，但是每次迭代产生的结果都是一样的。使用这个分析器后，任何未优化的代码都将传递给编译器以进行优化，同时生成机器码，它最终会替换掉之前由解释器生成的未优化代码中的对应部分。随着分析器和编译器不断地更改字节码，JavaScript 的执行性能逐渐提高。3.4 更多历史在V8 的 5.9 版本推出之前，它使用两个优化编译器和一个基线编译器。基线编译器 full-codegen 迅速生成未优化的机器码。两个优化编译器 Crankshaft 和 TurboFan 用于优化代码。JavaScript 增加了新的特性后，架构的复杂度上升，维护相同的管道对 V8 团队来说变得更加困难了。如果你想阅读更多相关的旧方法以及转向新管道的原因，可以访问他们的网站。3.5 放眼未来随着更多进一步提升性能的研究的进行，V8 引擎的工作机制在未来还可能发生变化。此外，随着 Webassembly 逐渐成形，可能会向管道添加额外步骤。4.结论ECMAScript 引擎的实现有很多，其中以谷歌的 V8 最为出名。希望这篇文章的简述不仅可以帮助你理解 JavaScript 的工作原理，还能从大体上了解一门编程语言的工作原理。如果你想了解 V8 团队的未来计划或者引擎的细节，这里有一篇很不错的博客。本文的第二部分将会在不久后发布，其中将谈到内存堆，栈，事件循环以及更多与 JavaScript 代码执行相关的概念。敬请关注！如果你不清楚 Node.js 在其中的作用，我这里碰巧写了一篇不错的文章：What exactly is Node.js?]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻译术语表]]></title>
    <url>%2F2019%2F05%2F03%2FTrs-%E7%BF%BB%E8%AF%91%E6%9C%AF%E8%AF%AD%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[翻译技术文章时积累的术语，可用于阅读，也可用于规范提问。English中文English中文arity参数个数argument实参assignment赋值array of arrays多维数组block scope块级作用域build-in内置的currying柯里化class-based基于类的classical inheritance类式继承closure闭包coexist共存declarative声明式dynamic动态的duplicate重复；副本execution context执行上下文event handler事件处理器event driven事件驱动的function signature函数声明free variable自由变量getter-only只读global scope全局作用域global variable全局变量hoist提升invoke调用identifier标识符iterate遍历iterator迭代器non-extensible不可拓展Object-oriented面向对象的prototypal inheritance原型式继承private property私有属性prototype chain原型链parameter形参scope chain作用域链strict mode严格模式semantics语义statement语句silentl failure静默失败syntactical sugar语法糖throw an exception抛出异常library库framework框架LexicalEnvironment词法环境programming patterns and paradigms编程范式heap堆stack栈sync同步async异步instance实例encapsulation封装implicit隐式explicit显式call by value按值调用call by reference按引用调用override覆盖binding绑定Immediately Invoked Function Expression立即执行函数表达式Named Function Expression具名函数表达式single thread单线程recursive递归snippet代码片段resolve解析LIFO（Last-In-First-Out）先进后出FIFO（First-In-First-Out）先进先出loop循环backward compatibility向下（向后）兼容destructuring assignment解构赋值enumerated可枚举的distributed version control system（VCS）分布式版本控制系统roll back回滚cross-platform跨平台的pseudocode伪代码]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「译」ES6：参数默认值的实现细节]]></title>
    <url>%2F2019%2F05%2F02%2FTrs-ES6%EF%BC%9A%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%2F</url>
    <content type="text"><![CDATA[原文地址：ES6: Default values of parameters原文作者：Dmitry Soshnikov译者：Chor在这篇文章中我们会介绍另一个 ES6 的特性，带默认值的函数参数。正如我们将看到的，有一些微妙的案例。1.ES5 及更低版本的手动默认值以前的默认参数值是通过以下几种可选方式手动处理的：function log(message, level) { level = level || 'warning'; console.log(level, ': ', message); } log('low memory'); // warning: low memory log('out of memory', 'error'); // error: out of memory 为了避免参数未传递的情况，通常可以看到 typeof 检查：if (typeof level == 'undefined') { level = 'warning'; } 有时，你也可以检查 arguments.length :if (arguments.length == 1) { level = 'warning'; } 所有这些方法都行之有效，但是，它们太偏向手动了，并且不够抽象。ES6 标准化了一种句法结构，在函数头直接定义了参数默认值。2.ES6 默认值：基本实例许多语言都存在默认参数值，所以大多数开发人员应该熟悉它的基本形式：function log(message, level = 'warning') { console.log(level, ': ', message); } log('low memory'); // warning: low memory log('out of memory', 'error'); // error: out of memory 这种默认参数用法相当随意，但是却很方便。让我们深入实现细节来理清默认参数可能带来的困惑。3.实现细节以下是一些关于 ES6 函数默认参数值的实现细节。3.1 执行阶段的重新计值一些其他语言（例如 Python）会在定义阶段对默认参数进行一次计值，相比之下，ECMAScript 则会在执行阶段计算默认参数值 —— 每次函数调用的时候。采用这种设计是为了避免与作为默认值的复杂对象混淆。思考下面的 Python 例子：def foo(x = []): x.append(1) return x # 我们可以看到默认值在函数定义时 # 只创建了一次，并且保存于 # 函数对象的属性中 print(foo.__defaults__) # ([],) foo() # [1] foo() # [1, 1] foo() # [1, 1, 1] # 正如我们所说的，原因是： print(foo.__defaults__) # ([1, 1, 1],) 为了避免这种情况，Python 开发者习惯将默认值定义为 None，并且显式检查这个值：def foo(x = None): if x is None: x = [] x.append(1) print(x) print(foo.__defaults__) # (None,) foo() # [1] foo() # [1] foo() # [1] print(foo.__defaults__) # ([None],) 但是，这与手动处理实际默认值的方式是一样不方便的，并且最初的案例让人感到疑惑。因此，为了避免这种情况，ECMAScript 会在每次函数执行时计算默认值：function foo(x = []) { x.push(1); console.log(x); } foo(); // [1] foo(); // [1] foo(); // [1] 一切都很好，很直观。接下来你会发现，如果我们不了解默认值的工作机制，ES 语义可能会让我们感到困惑。3.2 外部作用域的遮蔽思考下面的例子：var x = 1; function foo(x, y = x) { console.log(y); } foo(2); // 2，不是 1！ 正如我们看到的，上面的例子输出的 y 是 2 ，不是 1 。 原因是参数中的 x 与全局的 x 不是同一个。由于执行阶段会计算默认值，在赋值 = x 发生的时候， x 已经在内部作用域被解析了，并且指向了 x 参数自身。具有相同名称的参数 x 遮蔽了全局变量，使得对来自默认值的 x 的所有访问都指向参数。3.3 参数的 TDZ（暂时性死区）ES6 提到了所谓的 TDZ（表示暂时性死区）—— 这是程序的一部分，在这个区域内变量或者参数在初始化（即接受一个值）之前将无法访问。就参数而言，一个参数不能以自身作为默认值：var x = 1; function foo(x = x) { // 抛出错误！ ... } 我们上面提到的赋值 = x 在参数作用域中解析 x ，遮蔽了全局 x 。 但是，参数 x 位于 TDZ 内，在初始化之前无法访问。因此，它无法初始化为自身。注意，上面带有 y 的例子是有效的，因为 x 已经初始化（为隐式默认值 undefined ）了。我们再来看一下：function foo(x, y = x) { // 可行 ... } 之所以可行，是因为 ECMAScript 中的参数是按照从左到右的顺序初始化的，我们已经有可供使用的 x 了。我们提到参数已经与“内部作用域”相关联了，在 ES5 中我们可以假定是函数体的作用域。但是，它实际上更加复杂：它可能是一个函数的作用域，或者是一个为了存储参数绑定而特别创建的中间作用域。我们来思考一下。3.4 特定的参数中间作用域事实上，如果一些（至少有一个）参数具有默认值，ES6 会定义一个中间作用域用于存储参数，并且这个作用域与函数体的作用域不共享。这是与 ES5 存在主要区别的一个方面。我们用例子来证明：var x = 1; function foo(x, y = function() { x = 2; }) { var x = 3; y(); // `x` 被共用了吗？ console.log(x); // 没有，依然是 3，不是 2 } foo(); // 并且外部的 `x` 也不受影响 console.log(x); // 1 在这个例子中，我们有三个作用域：全局环境，参数环境，以及函数环境：: {x: 3} // 内部 -> {x: undefined, y: function() { x = 2; }} // 参数 -> {x: 1} // 全局 我们可以看到，当函数 y 执行时，它在最近的环境（即参数环境）中解析 x ，函数作用域对其并不可见。3.4.1 转译为 ES5如果我们要将 ES6 代码编译为 ES5，并看看这个中间作用域是怎样的，我们会得到下面的结果：// ES6 function foo(x, y = function() { x = 2; }) { var x = 3; y(); // `x` 被共用了吗？ console.log(x); // 没有，依然是 3，不是 2 } // 编译为 ES5 function foo(x, y) { // 设置默认值。 if (typeof y == 'undefined') { y = function() { x = 2; }; // 现在可以清楚地看到，它更新了参数 `x` } return function() { var x = 3; // 现在可以清楚地看到，这个 `x` 来自内部作用域 y(); console.log(x); }.apply(this, arguments); } 3.4.2 参数作用域的源由但是，设置这个参数作用域的确切目的是什么？为什么我们不能像 ES5 那样与函数体共享参数？理由是：函数体中的同名变量不应该因为名字相同而影响到闭包绑定中的捕获行为。我们用下面的例子展示：var x = 1; function foo(y = function() { return x; }) { // 捕获 `x` var x = 2; return y(); } foo(); // 是 1，不是 2 如果我们在函数体的作用域中创建函数 y，它将会捕获内部的 x ,也即 2。但显而易见，它应该捕获的是外部的 x，也即 1(除非它被同名参数遮蔽)。同时，我们无法在外部作用域中创建函数，这意味着我们无法从这样的函数中访问参数。我们可以这样做：var x = 1; function foo(y, z = function() { return x + y; }) { // 可以看到 `x` 和 `y` var x = 3; return z(); } foo(1); // 2，不是 4 3.4.3 何时不会创建参数作用域上述的语义与默认值的手动实现是完全不同的：var x = 1; function foo(x, y) { if (typeof y == 'undefined') { y = function() { x = 2; }; } var x = 3; y(); // `x` 被共用了吗？ console.log(x); // 是的！ 2 } foo(); // 外部的 `x` 依然不受影响 console.log(x); // 1 现在有一个有趣的事实：如果一个函数没有默认值，它就不会创建这个中间作用域，并且会与一个函数环境中的参数绑定共享，即以 ES5 模式运行。为什么要这么复杂呢？为什么不总是创建参数作用域呢？这仅仅和优化有关吗？并非如此。确切地说，这是为了向下兼容 ES5：上述手动实现默认值的代码应该更新函数体中的 x（也就是参数自身，且位于相同作用域中）。同时还要注意，那些重复声明只适用于 var 和函数。用 let 或者 const 重复声明参数是不行的：function foo(x = 5) { let x = 1; // 错误 const x = 2; // 错误 } 3.5 undefined 检查还要注意另一个有趣的事实，是否应用默认值，取决于对参数初始值（其赋值发生在一进入上下文时）的检查结果是否为值 undefined 。我们来证明一下：function foo(x, y = 2) { console.log(x, y); } foo(); // undefined, 2 foo(1); // 1, 2 foo(undefined, undefined); // undefined, 2 foo(1, undefined); // 1, 2 通常，在编程语言中带默认值的参数在必需参数之后，但是，上述事实允许我们在 JavaScript 中使用如下结构：function foo(x = 2, y) { console.log(x, y); } foo(1); // 1, undefined foo(undefined, 1); // 2, 1 3.6 解构组件的默认值涉及默认值的另一个地方是解构组件的默认值。本文不会涉及解构赋值的主题，不过我们会展示一些小例子。不管是在函数参数中使用解构，还是上述的使用简单默认值，处理默认值的方式都是一样的：即在需要的时候创建两个作用域。function foo({x, y = 5}) { console.log(x, y); } foo({}); // undefined, 5 foo({x: 1}); // 1, 5 foo({x: 1, y: 2}); // 1, 2 尽管解构的默认值更加通用，不仅仅用于函数中：var {x, y = 5} = {x: 1}; console.log(x, y); // 1, 5 4 结论希望这篇简短的笔记可以帮助解释 ES6 中默认值的细节。注意，在本文撰写的那一天（2014 年 8 月 21 日），默认值还没有得到真正的实现（它们都只是创建了一个与函数体共享的作用域），因为这个“第二作用域”是在最近才添加到标准草案里的。默认值一定会是一个很有用的特性，它将使我们的代码更加优雅和整洁。另外，你也可以在掘金翻译计划找到本篇译文。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[译文排版规范]]></title>
    <url>%2F2019%2F05%2F01%2FTrs-%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言：这是之前还在论坛当版主的时候，给自己定下的汉化规矩：1.按照固定格式来排版；2.能力有限不是机翻和偷工减料的借口；3.尽量得到原作者的转载授权虽然不再参与汉化工作了，但是有一些好的习惯值得继续保持。统一中文文案、排版的相关用法，降低沟通成本，增强译文的规范性和气质，使其更加易读。空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。与大家共勉之。」——vinta/paranoid-auto-spacing中英文之间需要增加空格正确：在 LeanCloud 上，数据存储是围绕 AVObject 进行的。错误：在LeanCloud上，数据存储是围绕AVObject进行的。在 LeanCloud上，数据存储是围绕AVObject 进行的。完整的正确用法：在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。中文与数字之间需要增加空格正确：今天出去买菜花了 5000 元。错误：今天出去买菜花了 5000元。今天出去买菜花了5000元。数字与单位之间需要增加空格正确：我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。错误：我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。例外：度／百分比与数字之间不需要增加空格：正确：今天是 233° 的高温。新 MacBook Pro 有 15% 的 CPU 性能提升。错误：今天是 233 ° 的高温。新 MacBook Pro 有 15 % 的 CPU 性能提升。全角标点与其他字符之间不加空格正确：刚刚买了一部 iPhone，好开心！错误：刚刚买了一部 iPhone ，好开心！标点符号不重复使用标点符号正确：德国队竟然战胜了巴西队！她竟然对你说「喵」？！错误：德国队竟然战胜了巴西队！！德国队竟然战胜了巴西队！！！！！！！！她竟然对你说「喵」？？！！她竟然对你说「喵」？！？！？？！！破折号前后需要增加一个空格正确：你好，我是破折号 —— 一个不苟言笑的符号。错误：你好，我是破折号——一个不苟言笑的符号。全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。使用全角中文标点正确：嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！核磁共振成像（NMRI）是什么原理都不知道？JFGI！错误：嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎!嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎!核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!核磁共振成像(NMRI)是什么原理都不知道?JFGI!数字使用半角字符正确：这件蛋糕只卖 1000 元。错误：这件蛋糕只卖 １０００ 元。例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。遇到完整的英文整句、特殊名词，其內容使用半角标点正确：乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。错误：乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。正确：使用 GitHub 登录我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。错误：使用 github 登录使用 GITHUB 登录使用 Github 登录使用 gitHub 登录使用 gｲんĤЦ8 登录我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。不要使用不地道的缩写正确：我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。错误：我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。排版斜体文字使用加粗样式代替正确：斜体本身是为西文文字所设计，为了保持良好的阅读效果，在中文排版时不应出现斜体，因此统一使用加粗样式代替。错误：斜体本身是为西文文字所设计，为了保持良好的阅读效果，在中文排版时不应出现斜体，因此统一使用加粗样式代替。如果文章中有脚注怎么办英文原文中经常会出现脚注的情况，我们在译者 LeopPro 的推荐下，选择如下的方案：这里是修改后的脚注显示方案 &lt;sup>&lt;a href="#note1">[1]&lt;/a>&lt;/sup> 1. &lt;a name="note1">&lt;/a> [how-to-add-footnotes-to-github-flavoured-markdown](http://stackoverflow.com/questions/25579868/how-to-add-footnotes-to-github-flavoured-markdown) 预览效果如下：这里是修改后的脚注显示方案 [1] how-to-add-footnotes-to-github-flavoured-markdown详见译者 LeopPro 提的 Issue：https://github.com/xitu/gold-miner/issues/3153争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的，但同一篇文章风格要保持一致。链接之间增加空格用法：请 提交一个 issue 并分配给相关同事。访问我们网站的最新动态，请 点击这里 进行订阅！对比用法：请提交一个 issue 并分配给相关同事。访问我们网站的最新动态，请点击这里进行订阅！简体中文使用直角引号用法：「老师，『有条不紊』的『紊』是什么意思？」对比用法：“老师，‘有条不紊’的‘紊’是什么意思？”工具仓库语言vinta/paranoid-auto-spacingJavaScripthuei90/pangu.nodeNode.jshuacnlee/auto-correctRubysparanoid/space-loverPHP (WordPress)nauxliu/auto-correctPHPhotoo/pangu.vimVimsparanoid/grunt-auto-spacingNode.js (Grunt)hjiang/scripts/add-space-between-latin-and-cjkPython参考Chinese Copywriting Guidelines掘金翻译计划译文排版指北]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分享一些实用工具和平台]]></title>
    <url>%2F2019%2F04%2F23%2FTo-%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[这个帖子用来不定期更新网上收集的一些实用工具和平台，运用得好还是可以提高学习或工作效率的。PS：部分资源国内无法访问，这个问题自己想办法解决。社区和博客 ：StackOverflow ——&gt; 最棒的编程问答社区SegmentFault ——&gt; 国内编程问答社区，得到高质量回答的机率很高掘金 ——&gt; 文章质量很高，社区氛围很好Bits and pieces ——&gt; 不错的技术博客网站（好像和Medium有关系？）CSDN ——&gt; 不建议去博客园 ——&gt; 优秀文章和大牛聚集地FreeCodeCamp ——&gt; FreeCodeCamp 中文社区文件编辑类：Online converter ——&gt; 文件格式转换PDF To Word ——&gt; pdf 转 wordOnline PDF to EPUB converter ——&gt; pdf 转 epubTable Convert Online ——&gt; 表格转换Compress images / Tinypng / Shrinkme——&gt; 图片压缩Smart Resize ——&gt; 图片修改Syntax-highlight-word ——&gt; 可以在 word 中使用代码高亮tool.lu ——&gt; 在线编写 markdown 以及 html 和 md 转换长链接压缩 ——&gt; 链接太长不好看？用这个就对了Bigjpg ——&gt; AI 图片无损放大电子书：GitHub coding books online reading ——&gt; Github编程相关书籍分享itbook.download ——&gt; 编程相关书籍免费下载Jiumo Search ——&gt; 目前用过最棒的电子书搜索网站Ebookee ——&gt; 编程相关书籍免费下载（外文）搜索引擎：chongbuluo search ——&gt; 集成搜索网站DuckDuckGo ——&gt; 搜索引擎素材：SM.MS Picture ——&gt; 免费图床Font Awesome ——&gt; 图标库Iconfont ——&gt; 图标网站free icons ——&gt; 图标网站fontke ——&gt; 字体网站asciiflow ——&gt; 在线生成字符码图Picular ——&gt; 根据关键词检索与之相关的色彩Clippy — CSS clip-path maker ——&gt; CSS3 clip 工具Bestvist ——&gt; CSS3 颜色渐变工具前端相关：MDN Web Doc ——&gt; MDN文档ECMAScript International ——&gt; ECMAScript 标准CSS速查总表 ——&gt; 速查属性Caniuse ——&gt; 前端兼容性自查compile javascript online / GDB online Debugger ——&gt; 在线编译Codepen ——&gt; 代码托管和分享，可以嵌入 md 文章中ScreenDump ——&gt; 响应式效果测试JavaScript Visualizer ——&gt; 可视化JavaScript执行过程（仅ES6之前）Loupe ——&gt; 可视化事件循环 （Philps Roberts大神的作品）RegExr / Regulex ——&gt; 可视化正则表达式Javascript-ast Visualizer ——&gt; 可视化抽象语法树cubic-bezier ——&gt; 可视化贝塞尔曲线其它Moakt ——&gt; 临时邮箱]]></content>
      <categories>
        <category>Tool</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解this绑定]]></title>
    <url>%2F2019%2F04%2F17%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[最近在阅读《你不知道的JavaScript》，再次补充了一下之前不熟悉的this绑定问题，在这里做一下阅读笔记。（很多晦涩的概念包括闭包、作用域链等都和js中的调用栈有关，所以也得另外找个时间系统学一下了）1.调用位置js中的词法作用域是静态的，需要关注的往往是函数的声明位置而不是调用位置—–例如闭包引用自由变量时，应该注意闭包函数的声明位置；而this却在某种程度上类似于动态作用域，this到底绑定的是谁，要看函数的调用位置（或者说调用方法），只有在函数调用的时候this的指向才能被确定。确定当前执行函数的调用位置，有两种方法：1.1 分析调用栈调用栈即：为了到达当前执行位置所调用的所有函数。而当前执行函数的调用位置就在该函数的前一个调用中。function baz() { //当前调用栈是:baz // 因此，当前调用位置是全局作用域 console.log("baz"); bar(); // bar的调用位置 } function bar() { // 当前调用栈是baz -> bar // 因此，当前调用位置在baz中 console.log("bar"); foo(); // foo的调用位置 } function foo() { // 当前调用栈是baz -> bar -> foo // 因此，当前调用位置在bar中 console.log("foo"); } baz(); // &lt;-- baz的调用位置 如上代码，例如当前执行函数为bar，bar函数的调用位置即bar函数的前一个调用，分析调用栈baz -&gt; bar可知，是baz。1.2 设置断点或debugger上面的方法将调用栈当作了函数调用链，这种方法比较麻烦，且容易出错，所以我们采取设置断点或debugger的方法寻找调用位置。我们在上面代码的foo函数中的第一行插入debugger;，那么运行代码时（当前执行函数是foo），调试器会在那个位置暂停，右侧的call stack展示了当前位置的函数调用列表，即调用栈。而调用位置就是栈中的第二个元素。2.绑定规则2.1 默认绑定可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。独立函数调用（如代码中的foo函数，它是直接使用不带任何修饰的函数引用进行调用的）应用的就是默认绑定规则。function foo(){ console.log(this.a); } var a = 2; foo(); //2 但是，函数运行在严格模式下时，this的默认绑定将无法绑定全局对象，而是绑定到undefined。function foo() { "use strict"; // 函数运行在严格模式下 console.log( this.a ); } var a = 2; foo(); // TypeError: Cannot read property 'a' of undefined 同时，函数在严格模式下调用时，默认绑定不受影响。function foo() { console.log( this.a ); } var a = 2; (function() { "use strict"; //函数在严格模式下调用 foo(); // 2 })(); 2.2 隐式绑定当函数引用有上下文对象时（或者说被某个对象“包含”/“拥有”），隐式绑定规则会把函数中的this绑定到这个上下文对象。function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 对象属性引用链中只有上一层或者说最后一层在调用中起作用。function foo() { console.log( this.a ); } var obj1 = { a: 2, obj2: obj2 }; var obj2={ a: 42 foo: foo } obj1.obj2.foo(); // 42 2.2.1 隐式丢失隐式绑定在一些情况下会丢失绑定对象，应用默认绑定，使this指向全局对象或者undefined。以下情况会发生隐式丢失：将绑定上下文对象的函数的引用赋值给变量并调用function foo(){ console.log(this.a); } var obj = { a:2, foo: foo } var a = 3； var bar = obj.foo; bar(); 虽然bar是obj.foo的一个引用，但实际上是直接引用了foo函数本身，此时的bar()是不带任何修饰的函数调用，因此使用了默认绑定传入回调函数function foo(){ console.log(this.a); } function bar(fn){ fn(); } var obj = { a:2, foo: foo } var a = 3; bar(obj.foo); 传参其实是隐式赋值，即把实参（这里是绑定上下文对象的函数的引用）赋值给形参变量，该变量也是直接引用了foo函数本身，和上面的情况其实是一样的。这也解释了为什么传参给setTimeout函数时会发生隐式丢失：function foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; var a = 3; setTimeout(obj.foo, 100); // 3 因为上面的代码实际上相当于：(function setTimeout(fn,100){ // 100...... fn(); })(obj.foo); 2.3 显式绑定2.3.1 call() 和 apply()call() 或者 apply() 方法接受一个 thisArg，将函数的 this 绑定到该 thisArg。thisArg 的取值有以下四种情况：不传，或者传null,undefined：函数中的 this 指向 window 对象传递另一个函数的函数名：函数中的 this 指向这个函数的引用传递字符串、数值或布尔类型等基本类型：函数中的 this 指向其对应的包装对象，如 String、Number、Boolean传递一个对象：函数中的 this 指向这个对象function foo() { console.log(this.a); } var obj = { a: 2 }; foo.call(obj); // 2 2.3.2 硬绑定 bind()但是这两种方法依然无法解决绑定丢失的问题，所以有了硬绑定:function foo() { console.log( this.a); } var obj = { a: 2 }; var bar = function() { foo.call(obj); }; bar(); // 2 setTimeout(bar, 100); // 2 bar.call(window); //无效，硬绑定之后的this不可再更改 硬绑定新创建了一个函数，并在该函数内部完成了this的绑定，之后不管怎么调用新建的这个函数，this的绑定都不会丢失。典型应用场景是1.创建一个包裹函数，负责接收参数并返回值。function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a: 2 }; var bar = function() { return foo.apply( obj, arguments ); }; var b = bar( 3 ); // 2 3 console.log( b ); // 5 2.创建一个可以重复使用的辅助函数。function foo(something) { console.log( this.a, something ); return this.a + something; } // 简单的辅助绑定函数 function bind(fn, obj) { return function() { return fn.apply( obj, arguments ); } } var obj = { a: 2 }; var bar = bind( foo, obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 ES5提供了内置方法Function.prototype.bind，对上面这种辅助函数进行了封装：function foo(something) { console.log(this.a, something); return this.a + something; } var obj = { a: 2 }; var bar = foo.bind(obj); var b = bar(3); // 2 3 console.log(b); // 5 bind()方法将返回一个完成硬绑定的新函数。2.3.3 API调用的“上下文”同样可以解决绑定丢失的问题。JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。var obj = { id: "awesome" } var myArray = [1, 2, 3] // 调用foo(..)时把this绑定到obj myArray.forEach( function foo(el) { console.log( el, this.id ); }, obj ); // 1 awesome 2 awesome 3 awesome 2.4 new 绑定在这篇文章中，其实已经谈到了new的内部原理，在这里再做一下总结—–使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：1.创建一个新对象2.为该对象执行[[prototype]]链接3.将该对象绑定到构造函数的this4.如果函数没有显式返回对象，则new操作最终将返回步骤1中创建的新对象基于这些步骤，我们就可以手写实现new了，具体过程依然可以参考上面链接的文章。有时候会将硬绑定与new一起使用，目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数（柯里化）function foo(p1, p2) { this.val = p1 + p2; } // 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么 // 反正使用new时this会被修改 var bar = foo.bind( null, "p1" ); var baz = new bar( "p2" ); baz.val; // p1p2 3. this的判断现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条this绑定规则。可以按照下面的顺序来进行判断：函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。var bar = new foo()函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。var bar = foo.call(obj2)函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。var bar = obj1.foo()如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定 到全局对象。var bar = foo()4.绑定例外4.1 被忽略的this把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认规则。下面两种情况下会传入null:使用apply(..)来“展开”一个数组，并当作参数传入一个函数bind(..)可以对参数进行柯里化（预先设置一些参数）function foo(a, b) { console.log( "a:" + a + "，b:" + b ); } // 把数组”展开“成参数 foo.apply( null, [2, 3] ); // a:2，b:3 // 使用bind(..)进行柯里化 var bar = foo.bind( null, 2 ); bar( 3 ); // a:2，b:3 总是传入null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。更安全的做法:传入一个空对象，把this绑定到这个对象不会对你的程序产生任何副作用。function foo(a, b) { console.log( "a:" + a + "，b:" + b ); } // 我们的空对象 var ø = Object.create( null ); // 把数组”展开“成参数 foo.apply( ø, [2, 3] ); // a:2，b:3 // 使用bind(..)进行柯里化 var bar = foo.bind( ø, 2 ); bar( 3 ); // a:2，b:3 4.2 间接引用你可能会有意无意地创建一个函数的间接引用，尤其是在赋值的时候// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo() function foo() { console.log( this.a ); } var a = 2; var o = { a: 3, foo: foo }; var p = { a: 4}; o.foo(); // 3 (p.foo = o.foo)(); // 2 4.3 软绑定硬绑定可以把this强制绑定到指定的对象（new除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this。如果给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。// 默认绑定规则，优先级排最后 // 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this if(!Function.prototype.softBind) { Function.prototype.softBind = function(obj) { var fn = this; // 捕获所有curried参数 var curried = [].slice.call( arguments, 1 ); var bound = function() { return fn.apply( (!this || this === (window || global)) ? obj : this, curried.concat.apply( curried, arguments ) ); }; bound.prototype = Object.create( fn.prototype ); return bound; }; } 使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。function foo() { console.log("name:" + this.name); } var obj = { name: "obj" }, obj2 = { name: "obj2" }, obj3 = { name: "obj3" }; // 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj var fooOBJ = foo.softBind( obj ); fooOBJ(); // name: obj // 隐式绑定规则 obj2.foo = foo.softBind( obj ); obj2.foo(); // name: obj2 &lt;---- 看！！！ // 显式绑定规则 fooOBJ.call( obj3 ); // name: obj3 &lt;---- 看！！！ // 绑定丢失，应用软绑定 setTimeout( obj2.foo, 10 ); // name: obj 5 this词法5.1 箭头函数ES6新增了箭头函数，上述四条规则对这种函数是不生效的。箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。拿下面的代码举例，箭头函数在词法层面的上一层是foo()，所以它的this和foo()的this是一样的。由于foo()的this绑定到obj1，所以bar(引用箭头函数)的this也会绑定到obj1。需要注意的是，箭头函数的绑定无法被修改 —— 因为箭头函数没有自己的 this，所以是不能对它使用 call，apply，bind 的，new也不行。function foo() { // 返回一个箭头函数 return (a) => { // this继承自foo() console.log( this.a ); }; } var obj1 = { a: 2 }; var obj2 = { a: 3 } // 绑定foo()的this为obj var bar = foo.call( obj1 ); bar.call( obj2 ); // 2，不是3！ 箭头函数常用于回调函数中，例如事件处理器或者定时器。function foo() { setTimeout(() => { // 这里的this在词法上继承自foo() console.log( this.a ); },100); } var obj = { a:2 }; foo.call( obj ); // 2 5.2 self = this与箭头函数this在通常情况下都是动态作用域的，而箭头函数很明显是静态（词法）作用域。实际上，在ES6之前，也有类似于箭头函数的模式—–self = this，采用的正是词法作用域：function foo() { var self = this; // lexical capture of this setTimeout( function() { console.log( self.a ); // self只是继承了foo()函数的this绑定 }, 100 ); } var obj = { a: 2 }; foo.call(obj); // 2 5.3 代码风格统一如果你经常编写this风格的代码，但是绝大部分时候都会使用self = this或者箭头函数来否定this机制，那你或许应当：只使用词法作用域并完全抛弃错误 this 风格的代码；完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>调用栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由一道题引发的思考]]></title>
    <url>%2F2019%2F04%2F13%2FT-%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[“不惧怕争论，也不要带情绪，保持理性争论才能获得提升。有时候一直以来以为正确的，说不好真实不一定就是你想的那样。”昨天，A群有个人问了一道题：var obj = { say: function() { console.log(obj); // 为什么输出undefined }() }; obj.say(); 先说结果。其实这道题是很简单的，只要注意在自执行函数执行过程中，obj变量尚未完成赋值就行了—–所以这时候打印的是执行上下文创建阶段的obj的值（undefined）；如果是let声明，那就是打印未初始化的变量obj，将在一开始就报错。如果非要用执行上下文来解释的话，详细的过程看下图：但是问题就在于，我坚信A群的看法是正确的，并且把这个问题带到了B群，引发了一场激烈的讨论（幸亏最后没有撕起来），我在那时是完全听不进B群的解释的。虽然下午争论的时候不了了之，但是晚上的时候我还是放不下这道题，于是选择到StackOverflow提问，之后又结合 Javascript visualizer 看到了代码执行的可视化过程，这时候我才明白自己的想法是错误的，B群的解释才是正确的。为什么我会在一开始那么相信A群的说法？我开始思考这个问题。首先是因为我没有从完全空白的状态去独立思考这道题，而是依附别人的看法去建立对这道题的认知；其次是因为我太相信那些看上去很权威的人，A群在我眼中是大佬云集的群，所以我很笃信他们的看法，但是大佬就一定是对的吗？就像那些传播很广的转载和翻译的文章，为什么要在没有任何根据的情况下去相信这些文字？换句话说，为什么不回到信息源头确认一下，打消自己的疑虑？在我看来，这根本不是钻牛角尖，我想表达的意思是：如果你不确定，你就想办法去确定，不要带着连自己都怀疑的东西继续自己的学习；对于A群的过度相信还和对B群的不信任有关，我向来是很讨厌扯高嗓子显得自己最有道理的那类人的，所以当B群的群友（有点激动地）发表自己的意见时，我并没有把他的话太放在心上，而结果却证明他说的才是正确的。另一个值得思考的地方是，如何在交流中保持自己的理性。B群有个群友说了一段话，我觉得很在理，这里拿出来分享一下，共勉：不惧怕争论，也不要带情绪，保持理性争论才能获得提升。有时候一直以来以为正确的，说不好真实不一定就是你想的那样。网络世界中，交谈起来往往是无所顾忌的，这种无所顾忌让撕逼变成了一种常态（我自己加了很多社群，所以清楚不过了）。那么如何做到理性的交流？第一点，找那些值得交流的人。如果你发现一个人在交流中带有太多的个人情绪、对人不对事，那么请不要继续和他浪费口舌。有没有个人情绪看他说话方式和内容就知道了，尤其是不断加各种感叹号以示强调的人，早点远离为好。值得交流的人，是那种即使打心眼里无法认同你的看法，也能安静地听你陈述的人，大有一种“我不赞同你的观点，但我誓死捍卫你说话的权利”的感觉。想一想，能做到这样的人真的多吗？第二点，清楚自己的目的。争论也好，交流也好，不要偏离自己的目的。很多情况下，你不仅仅是为了一个答案，还想要寻求自我认知修正的机会。确实，我们一直以来认为正确的不一定就是我们想的那样，正因为我们的认知有可能是错误的，所以才要在交流中试图找出这个错误，从而获得提升。知识不是一成不变的，所以请随时做好推翻自己想法的准备。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解变量对象、作用域链和闭包]]></title>
    <url>%2F2019%2F04%2F10%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[执行上下文、执行栈、作用域链、闭包，这其实是一整套相关的东西，之前转载的文章也有讲到这些。下面两篇文章会更加详细地解释这些概念。深入理解执行上下文和执行栈深入理解变量对象、作用域链和闭包1.前言首先引用下winter大的原话：在ES3中，执行上下文包含三个部分:1.scope: 作用域，也常常被叫做作用域链。2.variable object:变量对象，用于存储变量的对象。3.this value: this值。在ES5中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子:1.lexical environment:词法环境，当获取变量时使用。2.variable environment:变量环境，当声明变量时使用。3.this value: this值。在ES2018中，this值被归入lexical environment,同时增加了不少内容：1.lexical environment:词法环境，当获取变量或者this值时使用。2.variable environment:变量环境，当声明变量时使用。3…….我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的ES2018中规定的术语定义。所以，你会看到本文讲解的部分与另一篇文章有出入（例如变量对象VS环境记录），只需要知道是不同时期的不同规范就行了，没必要深究。2.执行上下文每个执行上下文都有三个重要的属性：变量对象、作用域链、this。在执行上下文压栈后，将进行初始化，这个过程具体来说就是：创建变量对象创建作用域链确定this指向用代码表示如下：ExecutionContext = { VO: {...}, // 或者 AO this: thisValue, Scope: [ // 所用域链 // 所有变量对象的列表 // 用于标识符查询 ] }; 下面我们针对这三个东西一一进行解释。3.变量对象3.1 定义变量对象即Variable object/VO，它是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。在全局执行上下文中，变量对象即全局对象（在浏览器中是window对象），它是可以访问的。在函数执行上下文中，变量对象是不能直接访问的，此时由活动对象(Activation Object/AO)扮演变量对象的角色，也就是所谓的VO–&gt;AO。总而言之，变量对象和活动对象的区别就是：1、变量对象是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。2、当进入到一个函数执行上下文后，这个变量对象才会被激活，成为活动对象，这时候活动对象上的各种属性才能被访问。3.2 从执行上下文看变量对象首先，执行上下文分为两个阶段：1.进入执行上下文2.代码执行3.2.1 进入执行上下文很明显，这个时候还没有执行代码。此时的变量对象将包含（按照如下顺序初始化）：1.一个指向arguments对象的arguments变量（如果是函数执行上下文）：具体地说，在变量对象内部将创建局部变量arguments和arguments对象，并使该变量指向该对象。arguments对象包括下列属性：callee：指向当前函数的引用length： 真正传递的参数的个数properties-indexes：就是函数的参数值(按参数列表从左到右排列)2.函数的所有形参（如果是函数执行上下文）：有实参则赋值，无实参则为undefined。3.函数声明：如果声明的函数跟已经声明的形参在名称上是相同的，则完全替换这个形参变量。4.变量声明：如果声明的变量跟已经声明的形参/函数在名称上是相同的，则变量声明不会干扰它们，仅赋值部分是生效的。同时明确，变量对象将不包含：函数表达式（与函数声明相对）没有使用var声明的变量（这属于“全局式”的声明方式，只是给全局添加了一个属性，并不在变量对象中）拿下面代码作为例子：function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1); 在调用函数foo后，将进入其对应的函数执行上下文，此时的变量对象（实际上是活动对象）根据上面的说法，应为：AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 可以从arguments对象的properties-indexes属性或者a看出，形参此时已经赋值了，但是变量仍是undefined。3.2.2 代码执行这个阶段会顺序执行代码，修改变量对象的值，执行完成后变量对象如下：AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression "d" } 前面说过，函数表达式和没有使用var声明的变量将不会包含在变量对象里，所以如果添加如下代码：(function x() {}); e = 1； 变量对象是不会变的4.作用域链4.1 定义作用域链其实就是所有执行上下文的变量对象的列表。我们可以将其看作数组，并表示为：var Scope = [VO1, VO2, ..., VOn]; 具体来说，函数执行上下文的作用域链包括该上下文的活动对象和该上下文对应函数的内部[[Scope]]属性。表示为：Scope = AO + [[Scope]] 4.2 作用：作用域链的作用是：在处理标识符的时候进行变量查询。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。4.3 Scope和[[Scope]]：前面我们说的Scope是执行上下文的属性，而[[Scope]]是函数的属性。具体来说，[[Scope]]是一个包含了所有上层变量对象的分层链，它属于当前函数执行上下文，在函数创建伊始就存在了，并保存在函数中。这里要注意的很重要的一点是：[[Scope]]是在函数创建的时候保存起来的——静态的（不变的），只有一次并且一直都存在——直到函数销毁。 比方说，哪怕函数永远都不能被调用到，[[Scope]]属性也已经保存在函数对象上了。4.4 从执行上下文看作用域链：下面用具体的例子回顾一下在执行上下文中，变量对象和作用域链的创建过程var x = 10; function foo() { var y = 20; function bar() { var z = 30; alert(x + y + z); } bar(); } foo(); // 60 首先进入全局执行上下文，创建变量对象（全局对象window）globalContext.VO === Global = { x: undefined foo: &lt;reference to function> }; 之后开始执行代码，变量对象变为：globalContext.VO === Global = { x: 10 foo: &lt;reference to function> }; 其中，在创建foo函数时，确认它的[[Scope]]属性：foo.[[Scope]] = [ globalContext.VO ]; 之后，调用foo函数，进入其对应的函数执行上下文，此时函数的变量对象激活为活动对象：fooContext.AO = { y: undefined, bar: &lt;reference to function> }; 同时确认了foo函数执行上下文的作用域链：fooContext.Scope = fooContext.AO + foo.[[Scope]] // i.e.: fooContext.Scope = [ fooContext.AO, globalContext.VO ]; 之后开始执行代码，变量对象变为：fooContext.AO = { y: 20, bar: &lt;reference to function> }; 其中，在创建bar函数时，确认它的[[Scope]]属性：bar.[[Scope]] = [ fooContext.AO, globalContext.VO ]; 之后，调用bar函数，进入bar函数对应的函数执行上下文，此时函数的变量对象激活为活动对象：barContext.AO = { z: undefined }; 同时确认了bar函数执行上下文的作用域链：barContext.Scope = barContext.AO + bar.[[Scope]] // i.e.: barContext.Scope = [ barContext.AO, fooContext.AO, globalContext.VO ]; 之后开始执行代码，变量对象变为：barContext.AO = { z: 30 }; 在运行alert(x + y + z);这一语句的时候，开始进行变量（或者说标识符）查询：- "x" -- barContext.AO // not found -- fooContext.AO // not found -- globalContext.VO // found - 10 - "y" -- barContext.AO // not found -- fooContext.AO // found - 20 - "z" -- barContext.AO // found - 30 这里需要注意，由于确认执行上下文的作用域链时，总会将当前上下文的变量对象/活动对象推至作用域链的顶端( Scope=当前活动对象+所有上层对象 )，所以变量查询也将从该变量对象开始，而全局对象则一直处于末端，是最后被查询的。bar执行完毕，出栈—&gt;foo执行完毕，出栈—&gt;回到全局执行上下文5.闭包5.1 从向下Funarg问题谈静态作用域“Funarg”即函数式参数，指的是值为函数的参数。如：function exampleFunc(funArg) { funArg(); } 首先看下这段代码：let x = 10; function foo() { console.log(x); } function bar(funArg) { let x = 20; funArg(); // 10, 而不是20! } // 将 `foo` 作为实参传给 `bar`。 bar(foo); 对于函数foo，变量x就是自由变量。当foo函数被调用时，它在哪里解析x绑定呢？是从创建函数的外层作用域，还是从调用函数的外层作用域？这就是所谓的向下funarg问题(downwards funarg problem)，即在判断绑定的环境时的歧义性：它应该是创建时的环境，还是调用时的环境？这是通过达成约定使用静态作用域来解决的。静态作用域也就是词法作用域（这也是词法环境这个名称的由来），它是通过捕获函数创建所在的环境来实现的，因而会到函数创建时保存起来的静态作用域链中进行变量查询。如果一个语言只通过查找源代码，就可以判断绑定在哪个环境中解析，那么该语言就实现了静态作用域。与静态作用域相对的是动态作用域。动态作用域是在当前活跃的动态链（而不是在函数创建时保存起来的静态作用域链）中进行变量查询的。对于上面的代码，如果是动态作用域，将输出20而不是10。5.2 从向上Funarg问题谈闭包另一种Funarg问题是向上funarg问题(upwards funarg problem)。function foo() { let x = 10; // 闭包，捕获`foo`的环境。 function bar() { return x; } // 向上funarg。 return bar; } let x = 20; // 调用`foo`来返回`bar`闭包。 let bar = foo(); bar(); // 10，而不是20! 除了判断绑定环境的歧义性，向上funarg问题面临的另一个问题是：如果JavaScript是面向堆栈的，那么foo函数在调用结束后，其执行上下文将带着变量对象销毁，这样一来，在我们调用bar函数时将发生错误（因为bar函数需要用到自由变量x，而该变量已经随着foo函数变量对象的销毁而消失了）。而且，在面向堆栈实现模型中，要想将bar函数返回根本是不可能的，因为它也是foo函数变量对象的一部分，也会随之销毁。也就是说我们面临两个问题：绑定环境的歧义性被引用的自由变量在上下文销毁后无法得到保留为了解决这两类问题，引入了闭包的概念。5.3 闭包5.3.1 定义ECMAScript中，闭包指的是：从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。从实践角度：以下函数才算是闭包：1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）2.在代码中引用了自由变量JavaScript显然是支持词法作用域的（除了this），所以解决了向下Funarg问题；同时由于闭包的存在，即使创建闭包的执行上下文出栈后被销毁，其变量对象也依然存在，所以闭包函数依然有办法访问到该对象，这就解决了向上Funarg问题。这个过程具体来说就是：通过某种方式（通常是返回值）调用闭包后，创建闭包对应的执行上下文并压栈，该上下文的属性Scope包括了闭包本身的变量对象和闭包的[[Scope]]属性，后者使得闭包执行时有机会访问到自由变量，因为[[Scope]]在闭包的词法创建阶段便已确定，并在那时候保存了其上层变量对象（上层，也就是闭包的父函数）。5.3.2 注意不过这里需要注意，仅变量对象里被引用的自由变量依然存在，不需要用到的变量会被垃圾清除机制清除。可以用下面的代码做个测试：var bar = function() { var hello = "world"; var unused = "nope"; return function(s) { console.log(hello); debugger; return s; }; } var g = bar(); g(1); debugger查看closure，发现只有hello变量，而找不到unused变量:在控制台打印unused变量时，报错：另外一个需要注意的地方是：同一个上下文中可能存在多个闭包，而这些闭包是共用同一个[[Scope]]属性的。也就是说，某个闭包对其中的变量做修改会影响到其他闭包对该变量的读取：var firstClosure; var secondClosure; function foo() { var x = 1; firstClosure = function () { return ++x; }; secondClosure = function () { return --x; }; x = 2; // 对AO["x"]产生了影响, 其值在两个闭包的[[Scope]]中 alert(firstClosure()); // 3, 通过 firstClosure.[[Scope]] } foo(); alert(firstClosure()); // 4 alert(secondClosure()); // 3 这也可以解释经典的for循环问题：var data = []; for (var k = 0; k &lt; 3; k++) { data[k] = function () { alert(k); }; } data[0](); // 3, 而不是 0 data[1](); // 3, 而不是 1 data[2](); // 3, 而不是 2 每一个函数都是一个闭包，拥有同一个[[Scope]]属性，这个属性包含了全局对象，而全局对象包含了变量k，这个k在循环跑完后变成了3，所以闭包调用的时候统一输出3。5.3.3 闭包的运用实际使用的时候，闭包可以创建出非常优雅的设计，允许对funarg上定义的多种计算方式进行定制。 如下就是数组排序的例子，它接受一个排序条件函数作为参数：[1, 2, 3].sort(function (a, b) { ... // 排序条件 }); 同样的例子还有，数组的map方法（并非所有的实现都支持数组map方法，SpiderMonkey从1.6版本开始有支持），该方法根据函数中定义的条件将原数组映射到一个新的数组中：[1, 2, 3].map(function (element) { return element * 2; }); // [2, 4, 6] 使用函数式参数，可以很方便的实现一个搜索方法，并且可以支持无穷多的搜索条件：someCollection.find(function (element) { return element.someProperty == 'searchCondition'; }); 还有应用函数，比如常见的forEach方法，将funarg应用到每个数组元素：[1, 2, 3].forEach(function (element) { if (element % 2 != 0) { alert(element); } }); // 1, 3 顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）：(function () { alert([].join.call(arguments, ';')); // 1;2;3 }).apply(this, [1, 2, 3]); 闭包还有另外一个非常重要的应用 —— 延迟调用：var a = 10; setTimeout(function () { alert(a); // 10, 一秒钟后 }, 1000); 也可以用于回调函数：... var x = 10; // only for example xmlHttpRequestObject.onreadystatechange = function () { // 当数据就绪的时候，才会调用; // 这里，不论是在哪个上下文中创建，变量“x”的值已经存在了 alert(x); // 10 }; .. 还可以用于封装作用域来隐藏辅助对象：var foo = {}; // initialization (function (object) { var x = 10; object.getX = function _getX() { return x; }; })(foo); alert(foo.getX()); // get closured "x" – 10 参考：http://dmitrysoshnikov.com/ecmascripthttp://goddyzhao.tumblr.com/post/11311499651/closures]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>变量对象</tag>
        <tag>作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解执行上下文和执行栈]]></title>
    <url>%2F2019%2F04%2F08%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[执行上下文、执行栈、作用域链、闭包，这其实是一整套相关的东西，之前转载的文章也有讲到这些。下面两篇文章会更加详细地解释这些概念。深入理解执行上下文和执行栈深入理解变量对象、作用域链和闭包1.执行上下文1.1 定义执行上下文（execution context）是当前 JavaScript 代码被解析和执行时所在环境的抽象概念，1.2 类型全局执行上下文只有一个。它创建了一个全局对象（浏览器中是window对象），并将this指向该对象。函数执行上下文无数个。每次调用函数时，都会为该函数创建一个新的执行上下文。eval函数执行上下文运行在 eval 函数中的代码也获得了自己的执行上下文，eval函数不常用，所以这里不讨论2.执行栈执行栈（execution stack），也即调用栈（call stack），具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。当 JavaScript 引擎首次读取脚本时，它会创建一个全局执行上下文并将其push到当前的执行栈。每当调用函数的时候，都会为该函数创建一个新的执行上下文并将其push到栈顶；在函数执行完毕后，对应的执行上下文将会从栈顶pop出，上下文控制权将移到当前执行栈的下一个执行上下文。let a = 'Hello World!'; function first() { console.log('Inside first function'); second(); console.log('Again inside first function'); } function second() { console.log('Inside second function'); } first(); console.log('Inside Global Execution Context'); // Inside first function // Inside second function // Again inside first function // Inside Global Execution Context 3.执行上下文的创建执行上下文分两个阶段创建：1）创建阶段（The Creation Phase）； 2）执行阶段（The Execution Phase）3.1 创建阶段词法环境组件被创建变量环境组件被创建用伪代码表示就是：ExecutionContext = { LexicalEnvironment = { ... }, // 词法环境 VariableEnvironment = { ... }, // 变量环境 } 3.1.1 词法环境词法环境（Lexical environment）是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用）词法环境有三个组成部分：环境记录：存储变量和函数声明的实际位置对外部环境的引用：可以访问其外部词法环境this绑定：确定this的指向词法环境有两种类型：全局环境：全局执行上下文的词法环境。函数环境：函数执行上下文的词法环境。3.1.1.1 环境记录：根据词法环境的两种类型，环境记录（Environment record）同样也有两种类型：对象环境记录（Object environment record）：全局环境的环境记录类型。存储全局变量和函数声明、全局对象（window 对象）和关联的属性/方法。声明性环境记录（Declarative environment record）：函数环境的环境记录类型。存储局部变量和函数声明、arguments对象。arguments对象包含了索引与参数之间的映射，以及传给函数的参数的个数。function foo(a, b) { var c = a + b; } foo(2, 3); // argument object Arguments: {0: 2, 1: 3, length: 2}, 3.1.1.2 外部环境引用：外部环境引用（Reference to the outer environment）表明当前词法环境能够访问外部词法环境。这意味着如果JavaScript引擎未在当前词法环境找到变量，它将向外部词法环境寻找（这有点类似原型链中的属性查找）全局环境没有外部环境，其外部环境引用为 null。函数环境有外部环境，其外部环境引用可以是全局环境，也可以是包含内部函数的外部函数环境。3.1.1.3 this绑定：全局执行上下文中，this绑定（this binding）到全局对象（对于浏览器，该对象为window）；函数执行上下文中，this绑定到谁将取决于函数的调用位置（或者说调用方法）。我会在另一篇文章总结this的绑定机制，所以这里不再展开。讲完了词法环境的三个组成部分，最后再配合伪代码理解一下：// 全局执行上下文 GlobalExectionContext = { LexicalEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 } outer: &lt;null>, this: &lt;global object> } } // 函数执行上下文 FunctionExectionContext = { LexicalEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 } outer: &lt;Global or outer function environment reference>, this: &lt;depends on how function is called> } } 3.1.2 变量环境变量环境（Variable environment）同样也是词法环境，因此它具有上面定义的词法环境的所有特征。这两者的区别主要在于：在 ES6 中，词法环境用于存储函数声明和变量（let和const）绑定，而变量环境仅用于存储变量（var）绑定。3.2 执行阶段在执行阶段，完成对所有变量的分配，最后执行代码。3.3 举例说明通过一个例子来了解执行上下文的整个创建和执行过程。以下面的代码为例let a = 20; const b = 30; var c; function multiply(e, f) { var g = 20; return e * f * g; } c = multiply(20, 30); 在开始读取代码后，JavaScript引擎创建全局执行上下文并压栈，全局执行上下文的创建阶段的伪代码如下：GlobalExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 a: &lt; uninitialized >, b: &lt; uninitialized >, multiply: &lt; func > } outer: &lt;null>, ThisBinding: &lt;Global Object> }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 c: undefined, } outer: &lt;null>, ThisBinding: &lt;Global Object> } } 之后进入全局执行上下文的执行阶段，开始进行变量分配/赋值，伪代码如下：GlobalExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 a: 20, b: 30, multiply: &lt; func > } outer: &lt;null>, ThisBinding: &lt;Global Object> }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 c: undefined, } outer: &lt;null>, ThisBinding: &lt;Global Object> } } 随着执行阶段的进行，我们遇到了multiply(20, 30)，这是一个函数调用语句，所以此时创建了该函数对应的函数执行上下文并压栈，函数执行上下文的创建阶段的伪代码如下：FunctionExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 Arguments: {0: 20, 1: 30, length: 2}, }, outer: &lt;GlobalLexicalEnvironment>, ThisBinding: &lt;Global Object or undefined>, }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 g: undefined }, outer: &lt;GlobalLexicalEnvironment>, ThisBinding: &lt;Global Object or undefined> } } 之后进入函数执行上下文的执行阶段，开始进行函数内的变量的分配/赋值，伪代码如下：FunctionExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 Arguments: {0: 20, 1: 30, length: 2}, }, outer: &lt;GlobalLexicalEnvironment>, ThisBinding: &lt;Global Object or undefined>, }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 g: 20 }, outer: &lt;GlobalLexicalEnvironment>, ThisBinding: &lt;Global Object or undefined> } } 函数执行完毕，函数执行上下文出栈，此时的执行上下文是全局执行上下文。由于函数的返回值被赋给变量c，此时全局执行上下文对应的全局词法环境得到更新，伪代码如下：GlobalExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 a: 20, b: 30, multiply: &lt; func > } outer: &lt;null>, ThisBinding: &lt;Global Object> }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 c: 12000, } outer: &lt;null>, ThisBinding: &lt;Global Object> } } 全局执行上下文的执行阶段结束，程序结束。补充：在全局执行上下文创建阶段的伪代码中我们可以看到，let和const定义的变量没有任何与之关联的值，但var定义的变量设置为undefined。这是因为在创建阶段，JavaScript引擎会扫描一遍代码并解析所有的变量和函数声明，其中函数声明被存储在环境记录中，而变量的情况则比较特殊：var声明的变量将被设置为undefined，let和const声明的变量将保持未初始化。因此，我们可以在声明之前就访问var定义的变量（尽管是undefined ），但如果在声明之前访问let和const定义的变量则会提示引用错误（因为在执行阶段之前其始终是未初始化的）。这就是我们所谓的变量提升。注： 在执行阶段，如果Javascript引擎在源代码中声明的实际位置找不到 let变量的值，那么将为其分配undefined值。注意：如果你发现译文和原文的说法存在出入，例如：在原文中：The execution context is created during the creation phase. Following things happen during the creation phase:1.LexicalEnvironment component is created.2.VariableEnvironment component is created.Each Lexical Environment has three components:1.Environment Record2.Reference to the outer environment,3.This binding在译文中：在任何 JavaScript 代码执行之前，执行环境经历了创建阶段，创建阶段包含以下三个事：1.this 的值确定，也被称为 This Binding.2.Lexical Environment 被创建。3.Variable Environment 被创建。在词法环境中，有两种组件：(1) environment record(2) reference to the outer environment.这是因为（请看这幅图）：总而言之是由于ECAMAScript的标准变更导致的。原文最初是基于ES5编写的，this绑定的确是执行上下文创建阶段的一环，但是在ES2015 ES2018 的规范中，this绑定被并入词法环境的环境记录，所以原作者后来进行了更改，只是各种翻译和转载没有改过来就是了。关于具体内容，可以参考：ES5规范ES6规范上图的文章本文参考：原文译文]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>执行上下文</tag>
        <tag>词法环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PureBlue 主题更新记录]]></title>
    <url>%2F2019%2F04%2F04%2FP-PureBlue%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[strong{font-size:18px} 2019.6.3： 修复文章目录过长覆盖 footer 的问题 本来想集成 Alogolia 搜索，无奈问题一个接着一个，只好放弃 2019.5.29： 完成部分移动端适配工作是的，终于填了一点坑了。用的是媒体查询，虽说没有适配全部尺寸的手机，但是大部分已经可以正常显示了，第一次看到博客在手机上正常显示还是很开心的哈哈哈。总的来说最近更新比较频繁，两天三头就改一些地方，是时候 release 一下了。 2019.5.27： 修改导航栏布局 修复代码块与顶部条宽度不一致的 bug。本来代码块和顶部条在同一个父元素里的话是很好控制宽度一致的，无奈插件是直接暴露代码块在外面。而我又不想用jq来给它们嵌套一个父元素，所以最后采用了计算代码块宽度再赋值给顶部条的方法。 2019.5.21： 改进代码块样式，增加复制功能。代码高亮还是用现成的插件实现的，但是在样式上借鉴了 Carbon，最主要的是在右上角添加了复制代码功能（有 ZeroClipboard 插件可以用，但是不知怎地用不了，所以自己写了一个。怎么实现的就不说了，因为代码比较丑）。现在代码高亮效果是这样的：function fun(){ ..... } 2019.5.19： 修改了配色基调 添加站内搜索，现在可以搜索文章了 2019.5.14： 一直觉得banner光秃秃的，所以换上了随机的背景图 利用媒体查询对手机端的样式做了部分调整（虽然还是没有达到想要的效果）。感觉是个大工程，还是以后再来弄吧。 2019.5.10： 一点小改动。翻译文章时突然发现一件事，有的文章标题下是有类似subtitle的东西的，但不是hexo的内置变量，所以自己定义了一个（说实话之前没考虑到这个问题）。 2019.4.2： 优化了部分代码 (总算)引入分享插件，只需要在主题的config.yml文件配置即可。之前以为没法在script标签里写ejs，所以采用了在js里拼接字符串的方法，想想真是又笨又奇葩。 2019.4.1：几个优化阅读体验的小变动 引入了font-awesome库，增加了一些图标 现在TOC目录中的标题会随着屏幕滚动而对应高亮。为了醒目，暂时采用了我比较喜欢的荧光黄采用红色 取消纯黑字体，现在阅读文章不会那么晃眼了 修复代码块背景显示不正常的问题 增加文章字数统计和阅读时长统计，可配置 2019.3.31:发布 Version 1.0最近确实还是挺忙的。虽说主题做出来了，但是一些大大小小的毛病或者 bug 总是让我心里不太舒服，所以花了一些功夫进行了修复，并终于发布了第一个版本。现在看起来已经好很多了（也已经与初版完全不同了）。至于响应式布局，目前没打算做，因为我还是习惯用 PC 端浏览。 整体布局：比较直观的感受应该就是布局上的调整。为了让整体更加趋向扁平化，我去除了初版中所有圆润的元素，尤其是那个巨丑的导航栏。还有一个就是稍微美化了一下滑动条，现在和主题更加搭配了。 配色：虽然主题叫做PureBlue，但并不是所有人都能接受默认的颜色，所以在以蓝色为主配色的前提下，我提供了其他的几种方案可供选择，只要修改配置文件即可。这个也算是给我的一个tip：为了提高主题的可配置性，应该避免在一些地方采用硬编码，而是代之以变量（stylus本身是支持书写变量的）。 阅读体验优化：之前比较尴尬的两个问题，一个是图片无法放大查看（= =无法放大的图片要你何用），一个是没有文章目录（阅读长文非常痛苦）。图片问题我是用fancybox插件解决的，同时支持放大、下载和分享。这里有一点比较关键:因为md文件引用的图片默认是放在&lt;p&gt;&lt;/p&gt;中的，而插件针对的图片必须有&lt;a&gt;&lt;/a&gt;嵌套，所以需要用js给所有的img嵌套上&lt;a&gt;&lt;/a&gt;；至于文章目录，可以用TOC函数生成，之后再编写样式就行。当然，目录是类似侧边栏的存在，所以必须用js做一些判断，之后进行适当的定位。 浏览体验优化：首先是修复了分类页无法正常进入的问题（之前的分类点击之后会走archive页面的布局，所以我暂时给了个空链接）；然后是重写了分页器，说到这个，之前的分页器可以说是丑到无以复加，而且非常不人性化，只提供上一页和下一页的选择简直是不像话有木有！好在这个问题解决了，而且也简化了一些不必要的代码；再者一个是导航栏，导航栏条目可以根据当前所在页面的类型对应高亮。 第三方插件支持：目前引入了valine评论插件，用起来还是很舒服的。后面看情况可能会增加对gittalk的支持；分享插件，我个人使用的是Addthis，之所以只有个人使用= =，因为这个插件必须要到它的官网去配置，而我要的效果是用户可以通过主题文件进行配置。所以虽然好用，但不会考虑作为主题的分享插件 增加了对Addthis的支持，现在用户可以通过配置pubid使用这个插件了。说到插件，以后也许会增加Algolia站内搜索，现在看搜索功能还是比较鸡肋的，毕竟标签和分类其实已经足够发挥索引功能了增加了本地搜索，用起来感觉还蛮不错。 其他小改动：显示标签数、分类数和文章数，至于文章阅读时长和字数的统计可以以后再说；还有就是在after-footer.ejs中统一引用所有的js文件，没有之前那么乱糟糟的了；标签云的标签，之前鼠标移入的时候会“鬼畜”，这个问题也得到了修复。总而言之改动还是挺大的，不过随着越来越多第三方插件的使用，以后实现去jq化也可能比较麻烦。]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>PureBlue</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解原型和继承]]></title>
    <url>%2F2019%2F03%2F31%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[这几天在掘金上阅读到了一篇关于原型的文章，角度较之前看到的几篇博客都不一样，顿时感觉我对于原型的知识点还没有完全吃透。鉴于本篇文章很可能会进行不定期的修订和拓展，故在此附上更新日志，以简单记录我在学习上的认知更新。2019.2.24js继承的几种实现方式2019.2.19完善关于constructor属性的介绍比对new和Object.create()的本质区别纠正隐式原型的错误写法（之前没看仔细，一直写错，今天报错才发现）1.创建对象的方法在了解原型链之前，首先先了解一下创建对象的几种方式，为后面做个铺垫。介绍以下三种。代码： &lt;script type="text/javascript"> // 第一种方式：字面量 var o1 = {name: 'o1'} var o2 = new Object({name: 'o2'}) // 第二种方式：构造函数 var M = function (name) { this.name = name; } var o3 = new M('o3') // 第三种方式：Object.create var p = {name: 'p'} var o4 = Object.create(p) console.log(o1) console.log(o2) console.log(o3) console.log(o4) &lt;/script> 打印结果：2.构造函数、实例、原型、原型链先来一张图简单了解一下2.1 原型、实例、构造函数首先是代码 var M = function (name) { this.name = name; } var o3 = new M('o3') 实例就是通过new一个构造函数生成的对象。在本例中o3就是实例，M就是构造函数。每个函数都有prorotype属性，每个对象都有proto 属性（隐式原型,读作dunder prototype）从上图中可以知道，实例的protpo指向原型对象。从上图中可以知道，实例的构造函数的prototype也是指向原型对象。原型对象的construor指向构造函数。再来通过下面这个图来理解一下2.2 原型链简单理解就是原型组成的链，实例的proto就是原型，而原型也是一个对象，也有proto属性，它会指向另一个原型…………就这样可以一直通过proto向上找，这就是原型链，当向上找找到Object这个构造函数的原型（即null）时，这条原型链就算到头了。也就是说，原型链的尽头是null 。2.3 原型的作用原型的存在是为了帮助实现继承。我们先来思考一个问题：假如现在通过一个构造函数创建了多个实例，想要给它们添加同一个方法，该怎么做呢？1.给每个实例去添加。太过麻烦，并不是一个明智的选择；2.在构造函数的内部添加方法。这样做的话在每次用构造函数创建实例时都会大量产生方法的副本，这些方法副本功能一样，实际却是不同的。这会影响性能，且不利于代码复用；3.这时，就该用上原型了。只要给构造函数的原型添加一个方法，那么构造函数的所有实例便都有了这个方法。接着上面的例子继续演示： function M(name) {this.name = name;} var o3 = new M('o3') var o5 = new M('o5') M.prototype.say=furnction(){ console.log('hello world')} o3.say() o5.say() console.log(o3.say()==o5.say()); // true 打印结果按照JS引擎的分析方式，在访问一个实例的方法时，首先在实例本身中找，如果找到了就说明其构造函数先前是有定义这个方法的(this)；如果没找到就去实例的原型中找，还没找到就再沿着原型链往上找，直到找到。当然，不止方法，属性也是可以继承自原型的。那么怎么判断属性是实例本身具有的还是继承的？对实例用 hasOwnProperty( )方法即可。那么实例为何有这个方法？同样是继承来的。 由于所有的对象的原型链都会找到追溯到Object.prototype，因此所有的对象都会有Object.prototype的方法，其中就包括 hasOwnProperty( )方法 。2.4 访问原型可以用obj.prototype，obj.__proto__，或者obj.getPrototypeOf()。这里重点说后面两个。__proto__属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，更不推荐通过这种方式修改实例的原型，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用 Object.getPrototypeOf()。2.5 原型、构造函数、实例、Function、Object的关系前面我们给出了一幅图简单梳理了一下关系，但想追本溯源，光靠那张图是不够的。下面我们给出另一张更详细的图。请先记住，Function和Object 是特殊的构造函数。首先从构造函数Foo（或任意一个普通构造函数）出发，它创建了实例f1和f2等，而实例的__proto__指向了Foo.prototype这个原型，该原型的__proto__向上再次指向其他构造函数的原型，一直向上，最终指向Object这个构造函数的原型，即Object.prototype。而Object.prototype的 __proto__指向了null，这时我们说到达了原型链的终点null。回过头看，该原型又被Object构造函数的实例的__proto__指向，而函数的实例就是我们通常通过字面量创建的那些对象，也即是图中的o1，o2。那么，普通构造函数（这里指Foo）和特殊构造函数Object又来自于哪里？答案是，来自于另一个特殊构造函数Function。实际上，所有的函数都是由Function函数创建的实例，而构造函数当然也是函数，所以也来自于Function。从图中可以看到，实例Foo的__proto__和实例Object的__proto__ 都指向了 Function的prototype，即Function.prototype 。既然所有的函数都是由Function函数创建的实例，那么Function又是怎么来的？答案是，Function自己创造了自己。它既作为创造其他实例函数的构造函数而存在，也作为实例函数而存在，所以可以在图上看到作为实例的Function的__proto__ 指向了作为构造函数的Function的prototype,即Function.__proto__ ===Function.prototype正如我们前面所说的，Function.prototype的__proto__也像其他构造函数.prototype的__proto__一样，最终指向Object.porototype，而Object.porototype的__proto__最终指向null，原型链结束。可以发现，经过简单梳理，这几者的关系没有我们想象的那么复杂。一句话，看懂这幅图就够了。3.instanceof的原理instanceof 沿着 实例—&gt; proto —&gt; …….. 这条线来找，同时沿着 实例的构造函数的prototype—&gt;proto —&gt; …….. 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。如下图，很显然 f1 instanceof Object 成立注意：正因为 instanceof 的原理如上所述，因此实例的instanceof在比较的时候，与原型链上向上找的的构造函数相比都是true。继续上面的代码那怎么判断实例是由哪个构造函数生成的呢？这时候就要用到constructor了。实例的原型的构造函数， obj.proto.constructor4.constructor属性4.1 定义：构造函数的prototype属性指向它的原型对象，在原型对象中有一个constructor属性，指向该构造函数。值类型（除了null和undefined，这两者不具有这个属性）的constructor是只读的，不可修改，引用类型的constructor是可修改的，例如5.2提到的修复指向。4.2 修复constructor的指向：为了实现从父类到子类方法的继承，一般会重写构造函数的原型，如：function Person(){ ......... } function Student(){ ......... } Student.prototype = new Person() var student = new Obj() 这将使得实例student具有构造函数Person的方法，但同时也会导致constructor的指向出现问题，造成继承链的紊乱，因此为了修复这个错误指向，需要显式指定obj.prototype.constructor = obj 。拿下面例子说明：未重写原型对象之前，实例化了一个dog；第6行重写了原型对象，使其指向另一个实例（等式右边是字面量，因此可以看作是由Object构造函数实例化出来的一个对象），之后实例化了一个cat。查看dog和cat的constructor： console.log(dog.constructor); //function Animal() console.log(cat.constructor); //function Object() dog.say(); //wan cat.say(); //miao 首先，构造函数没有constructor属性，这导致了它构造的实例也没有constructor属性，所以，实例将沿着原型链(注意，构造函数不算在原型链里)向上追溯对应的原型对象的constructor属性。dog.constructor可以指向原来的构造函数，说明原来的原型对象还存在；而cat.constructor 指向另一个构造函数，是因为Animal( )的原型被重写，并且作为Object( )构造函数的一个实例而存在，那么由cat实例出发，向上进行constructor属性追溯的时候，最终会找到Object( ) 构造函数。同样的，正因为原型重写前后创建的实例分别对应了初始原型和新的原型，所以我们可以对旧实例调用初始原型的方法、对新实例调用新的原型的方法，放在本例子中，就表现为dog依然可以调用say( )方法发出wan，而cat也可以调用say( )方法发出miao 。总结：重写原型对象之后，会切断构造函数与最初原型之间的连接，使新构造的实例对象的原型指向重写的原型，而先前构造的实例对象的原型还是指向最初原型。在这种情况下，先前的实例对象可以使用最初原型的方法，新的实例对象可以使用重写的原型的方法。5. new 和 Object.create()：这里，让我们回到文章开头提到的创建对象的三种方式。重点介绍后两种。5.1 newnew一个构造函数时，实际发生的过程是：var o={}; o.__proto__=M.prototype M.call(o) 第一步，创建一个空对象o；第二步，令空对象的proto指向构造函数M的prototype；第三步，令构造函数M中的this指针指向o，使得o具有M的属性或方法，如果M无返回值或返回的不是对象，则最后会返回o 。在这里要注意下面这个坑：var Base = function(){ this.a = 2; }; console.log(Base.a); 构造函数就好比印钞机，而它创建的实例就好比钞票。构造函数中的this.xxxx都是为了实例而准备的属性和方法，这些this在构造函数内，但并不指向构造函数，而是在new构造函数执行的时候转而指向新实例。构造函数自身没有这些属性和方法，像上面那样调用Base的a属性是会报错的，Base根本没有a属性。手动实现new（方法一）：下面根据new的工作原理通过代码手动实现一下new运算符 var new2 = function (func) { //创建一个空对象，并链接到原型 var o = Object.create(func.prototype); //改变func中的this指向，把func的结果赋给k var k = func.call(o); //判断func是否显式返回对象 return typeof k === 'object' ? k : o; 验证不难看出，我们手动编写的new2和new运算符的作用是一样的。手动实现new（方法二）：考虑到构造函数本身需要传参，这里提供第二种手写new的方法function new3(){ // 获得构造函数func（arguments的第一个参数） var func = [].shift.call(arguments); // 创建一个空对象，并链接到原型 var o = Object.create(func.prototype); // 改变func中的this指向，把func的结果赋给k var k = func.call(o,arguments); // 判断func是否显式返回对象 return k instanceof Object ? k : o; }; function M(){....} // 使用内置new var m = new M(....) // 使用手写new var m = new3(M,.....) 这里要注意数组的shift()方法，它可以删去数组的第一个元素并返回该元素。但是arguments是类数组的对象，无法直接使用这个方法，所以我们使用[].shift.call(arguments),意思是从参数列表（包括构造函数、构造函数的参数）中删去并返回第一个参数（构造函数），将其赋给func，之后的arguments将只包含构造函数func的参数。5.2 Object.create()Object.create()方法创建一个新对象（实例），并使用现有的对象(参数)作为新创建的对象的proto 也就是说，这个方法可以起到指定原型的作用。执行Object.create() 时，实际发生的过程是：Object.create = function (o) { var F = function () {}; F.prototype = o; return new F(); }; 第一步，创建空的构造函数；第二步，令构造函数的prototype指向传入的对象；实际上也相当于 令新实例的proto指向传入的对象第三步，实例化一个对象并返回这里，如果Object.create()接受的参数是null，即var obj = Object.create(null),则obj是真正意义上的空对象，不具有hasOwnProperty(),toString()等方法或属性。6 继承的7种方式6.1.原型链继承核心：重写子类原型，代之以父类的实例function Person(){ this.age=[6,12,24]; } function Worker(){} Worker.prototype = new Person(); 缺点：创建子类实例时，无法向父类构造函数传参；对一个子类实例的引用类型属性的操作将会影响其他子类实例，即引用属性共享var worker1 = new Worker() var worker2 = new Worker() worker1.age.push(48) alert(worker1.age) //[6,12,24,48] alert(worker2.age) //[6,12,24,48] 6.2.借用构造函数继承又称为冒充继承、经典继承、伪造对象继承核心：使用父类的构造函数来增强子类实例，等同于复制父类的实例属性给子类（不使用原型）function Person(name){ this.age=[6,12,24]; this.name=name; } function Worker(name){ Person.call(this,name); } var worker1 = new Worker() var worker2 = new Worker() worker1.age.push(48) alert(worker1.age) //[6,12,24,48] alert(worker2.age) //[6,12,24] 缺点：虽然消除了原型链继承的缺点，但是不利于实现函数复用，每个子类都有父类实例函数的副本，影响性能。6.3.组合继承核心：原型链继承+借用构造函数继承。即使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.function Person(){ this.age=[6,12,24]; } Person.prototype.shout=function(){ alert("Ahhhhhh"); } function Worker(){ Person.call(this); ...其余新增属性。。。 } Worker.prototype=new Person() Worker.prototype.constructor=Worker //别忘记修正constructor的指向 var worker1 = new Worker() 缺点：很常用的继承方式，但也有缺点，就是代码第11、13行合计调用了两次父类函数，造成了不必要的消耗。6.4.原型式继承用到了object()，规范化之后即为Object.create()核心：利用Object.create()对传入其中的对象进行浅拷贝var Person = { age: [6,12,24] } var worker1 = Object.create(Person) var worker2 = Object.create(Person) 缺点：和原型链继承一样，存在引用属性共享的问题。worker1.age.push(48) alert(worker1.age) //[6,12,24,48] alert(worker2.age) //[6,12,24,48] 原因很好解释，因为worker1无age属性，因此向它的原型查找，它的原型恰好就是Person对象。因此实际上是在改动Person的age属性。6.5.寄生继承核心：创建一个函数用于封装继承的过程，在函数内部增强对象，最后将其返回var Person = { age: [6,12,24] } function createAnother(Person){ var worker0 = Object.create(Person); worker0.shout = function(){ alert("Ahhhhh"); }; return worker0; } var worker1 = createAnother(Person) worker1.shout() 缺点：和原型链继承一样，存在引用属性共享的问题;和经典继承一样，无法实现函数复用6.6.寄生组合继承核心：结合寄生式继承和组合继承的优点，避免为了指定子类的原型而二次调用父类的构造函数//封装函数。功能：在避免二次调用父类函数的前提下令子类原型指向父类实例 function inheritPrototype(subType, superType){ var obj = Object.create(superType.prototype); subType.prototype = obj; subType.prototype.constructor = subType; //修正constructor的指向 } // 父类初始化实例属性和原型属性 function Person(){ this.age=[6,12,24] } Person.prototype.shout = function(){ alert("Ahhhhhh"); }; // 借用构造函数传递增强子类实例属性（支持传参和避免篡改） function Worker(){ Person.call(this); } // 调用函数，令子类原型指向父类实例 inheritPrototype(Worker, Person); 优点：基本完美的继承方式，无任何缺点，也是目前库实现的方式。6.7.extends类继承// 父类 class Person { constructor(name,age) { this.name = name; this.age = age; } shout() { alert("Ahhhhhh"); } } //子类继承父类 class Worker extends Person{ constructor(name,age,job){ super(name,age); this.job = job; } work() { alert("I am working"); } } 解释：可以看作是ES6新增的语法糖，使得js中继承的写法更趋向于传统的面向对象语言。super是关键字，代表父类构造函数，只有在子类的构造函数中调用super()函数，才能让父类构造出this给子类去丰富。参考：http://www.cnblogs.com/wangfupeng1988/p/3978131.htmlhttps://www.cnblogs.com/chengzp/p/prototype.htmlhttps://juejin.im/post/5c6a9c10f265da2db87b98f3https://www.cnblogs.com/94pm/p/9113434.htmlhttps://segmentfault.com/a/1190000016891009]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>原型</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾博客系列之发布自己的主题：PureBlue]]></title>
    <url>%2F2019%2F03%2F28%2FT-%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue%2F</url>
    <content type="text"><![CDATA[这篇文章用来记录自己开发 PureBlue 主题过程中的感想。先立一个 Flag博客内容固然是最重要的，但是抛开内容不讲，博客本身也应该带有自己的Tag，而不是光会用别人的轮子。最早接触的博客平台是 CSDN 和博客园，在上面学习到了很多网友的经验，于是萌发了想要创建自己博客的念头，在写了几篇文章后又觉得：为何不自己搭建一个博客平台呢？因此在今年一月份的寒假捣鼓了 hexo 和 github pages，包括下载各种漂亮的主题、添加各种有意思的插件，一时乐在其中。平静下来之后，我开始进行知识迁移的工作，把以前存放在印象笔记中的东西重新修改并整合，转移到个人博客里，于是内容慢慢充实起来。直到十几天前，我用的还是 Next 主题，这的确是一个相当成熟和漂亮的主题，我特别喜欢它的简洁。直到某天看到一句话：当你看到你用的主题出现在两个以上的博客时，那你就要考虑自己写一个了。别说两个了，Next 主题的用户数应该是目前所有主题中最多的，而博客外观的雷同很显然是一件非常尴尬的事情。正好在那时我也陷入了一个纠结，就是我一直处于知识输入的状态却鲜有项目上的输出，简单地说就是学的多、做的少—-这是很要命的事，毕竟“纸上得来终觉浅”。也就是说我面临两个问题：缺少项目实践博客主题缺少个性化这两个问题恰巧有共同的答案，那就是自己制作一个主题。当时想的是这学期能做出来都算好的了，于是立了一个 flag：不过很欣慰的是，我赶在月底之前把它完成了，前后大约花了14天。（大概是这个 flag 给我的动力）这是项目地址。体会和感想虽然是一个小项目，而且代码也写得比较乱，但是收获颇丰——接触到了两个新的技术，一是模板引擎ejs，二个是css预处理器stylus，还有就是对hexo的原理有了更为深入的理解，至少知道了我写的markdown文件是怎么在网页上渲染出来的，而不是光会用却不知道原理。万事开头难，前期准备工作的时候真的是一头雾水。首先是Hexo的官方文档，写得很不友好，所以读起来云里雾里；其次是不同主题使用的模板引擎和css预编译都不同，主题文件的结构也不同，这大大提高了阅读源码的难度和花在上面的时间成本。虽然经过“搜刮”，我找到了几篇教程，但是大部分还是讲的不够浅显易懂，越看越晕。这时候我意识到两个重要的问题：这些东西不是给纯新手准备的，我需要先了解基础的概念善用搜索引擎，不要将视野局限在国内平台所以我开始去youtube上寻找相关的视频，幸运的是我的确找到了纯新手向的主题制作教程。每集只有几分钟，但是对于理解一些基础概念来说已经足够。不用担心听不懂，因为自带字幕，再配合up主的操作演示，还是很好理解的。之后我又谷歌了相关的文章，成功找到了这个系列教程，这是目前找到的最详细的教程，真真正正的从零开始教你怎么做一个主题，所以说实话真的很感谢这位老外。为了加深对主题制作的理解以及方便其他有需求的人，我将这个系列翻译了过来，可以在我的博客里找到，当然也可以去Segment Fault。目前我只翻译了两篇，第三篇会另外找个时间搞定。教程看下来，发现难点主要集中在两个地方：一是理清项目结构，进行合理的组织，二个是设计样式并具体实现。准备工作差不多之后，就可以开始动工了，不需要太着急，每天完成一部分就行。印象比较深的难点就是垂直时间轴的制作，也就是下面这个东西：一个是要做出样式，主要涉及伪元素的使用，以及考虑怎么让垂直轴随着页面高度增加而延长；二个是逻辑，遍历所有文章并根据年份进行划分，这里需要使用ejs的语法，对Hexo的内置变量也要熟悉。踩了哪些坑当然，做这个主题的时候也踩了很多坑，这里做一下踩坑记录：路径问题。为了使代码更容易管理，通常制作主题都是采用模块化的方式，因此存在着大量的文件引用。而A文件引用B文件时，不一定是使用B相对于A的路径，而要看最终A文件被谁引用。某篇文章中出现了一行很长的代码，因为没有对它进行换行和溢出处理，导致图片尺寸无法正常设置，同时所有的文本内容都被挤出div。在本地测试的时候某些文章无法显示全文内容，并且底部div消失。这个问题比较奇葩，而且至今无解。猜想应该是渲染出错还是什么= =。写stylus文件时混用了空格和tab，git报错。（这个是真的坑，开了sublime的提示才看出来的）第三方插件失效。返回顶部按钮是用的第三方jq插件，坑的地方就在于，作者引用jq库时是用的http链接，被浏览器阻止了，导致插件失效。一开始以为是缓存问题导致的样式无法修改，在反复修改和刷新了一个半小时后才想到去控制台看报错信息：所以，为了保险一点还是在项目中放jq文件比较好，当然更好的做法应该是直接用原生js来写。改动不生效的问题。比较常见的状况，在本地预览一切正常，通过域名访问的时候改动却迟迟没有生效，而且通常的清除浏览器缓存或者hexo clean还不一定有效。只能说改动的同步还是需要时间的= =page页面共用。这个严格来说不算坑，而是应该留意的一个地方。Hexo中并没有专门的展示所有标签或者所有类别的页面，拿我用的ejs来说，layout文件夹下的tag.ejs实际指的是单一标签下的所有文章，同理categories.ejs指的是单一类别下的所有文章。而我们需要的展示页面实际上是统一放在page.ejs中，再根据条件判断生成对应页面。不过我实际操作的时候发现分类页走的是归档页的布局。所以目前这个主题的分类页无法正常工作，也许之后会找到原因吧问题已解决，目前分类页可以正常工作。在 js 中引用 hexo 的内置变量。做导航栏时需要区分不同类型的页面。这个其实也很好解决，因为页面链接和导航栏条目是一一对应的（比如archive页面的链接是/archive，导航栏条目是archive），所以做一个判断就好。然而尴尬的是，首页压根就没有这种链接，首页就是一个/，尽管有 is_home() 函数可以用，不过 js 里是用不了的。所以这个时候我想到了直接通过配置文件拿到首页的 url，之后再做判断，但是又有一个问题 —— 这是hexo的内置变量，只能在ejs中使用，在js里是不识别的。考虑到ejs会生成dom元素，所以解决的思路是：将内置变量存放在dom元素里并生成，之后在js中获取它的值，并设置该元素不可见 直接作为dom元素的data-*属性即可。后面的 TOC 文本也是用的这个办法。总结主题基本的东西都做好了，剩下的就是上传到 github，并且向 Hexo 官方站点发起 PR—-这些对于我这个菜鸟来说还很陌生，所以不得不去b站找了 github 和 git 使用的相关教程。本来应该一切顺利了，但是本地这边一直报错，原来是没有先 pull 远程仓库进行同步。当然，git 和 github 是每个技术人的必备技能，所以之后我会另外找个时间系统学习一下这两者的使用。最后当然就是编写说明文档了，这很像以前做汉化时写的使用说明。感触比较深的两点：一个是注意阅读源码。如果实在没有思路，可以先参考别人是怎么写的，一开始制作主题的时候很难理清项目结构，所以我选择了先看看别人是怎么写的；二个是英语的重要性——1/5的答案在百度，4/5的答案在谷歌，学会英语就意味着你找到了解决问题的另一条途径，而且无疑是更加宽广的途径。比如 Hexo 主题的制作，国内是没有人真的会去为这个而做系列视频的，但是国外有；同样地，提问题时也可以考虑选择国外平台，如果你注意了提问礼仪，很大几率问题会得到秒回。到这里差不多就告一段落了，之后的时间我会慢慢完善和更新这个主题。目前来说用户只有我自己，所以也算是为我自己而去努力地塑造它吧。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>PureBlue</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「译」创建一个Hexo主题-Part2:其他页面]]></title>
    <url>%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2%2F</url>
    <content type="text"><![CDATA[原文地址：Create an Hexo Theme-Part2: Other Pages原文作者：Jonathan Klughertz译者：Chor在这个系列教程中，你将学习怎么从零开始制作一个 Hexo 主题。在 part1 中，我们已经着手动工并创建了首页。在这篇文章中，我们将运用所学完成剩余的页面。其它文章的链接：创建一个Hexo主题-Part1:首页创建一个Hexo主题-Part2:其他页面创建一个Hexo主题-Part3:评论、分析和小部件文章详情页让我们继续完成 part1 中的剩余工作并创建文章详情页。正如我们看到的，为了生成详情页，Hexo将会在/layout/文件夹中寻找一个post.ejs文件。这是我的post.ejs文件：// layout/post.ejs &lt;%- partial('_partial/article-full', {item: page}) %> 为了让代码更加有序，我们会将实际代码放在_partial/article-full.ejs中。现在先来创建这个文件：// layout/_partial/article-full.ejs &lt;div class="blog-post"> &lt;!-- Title --> &lt;h2 class="blog-post-title"> &lt;a href="&lt;%- config.root %>&lt;%- item.path %>"> &lt;%- item.title || item.link%> &lt;/a> &lt;/h2> &lt;!-- Date and Author --> &lt;p class="blog-post-meta"> &lt;%= item.date.format(config.date_format) %> &lt;% if(item.author) { %> by &lt;%- item.author %> &lt;% } %> &lt;/p> &lt;!-- Content --> &lt;%- item.content %> &lt;hr /> &lt;!-- Tags and Categories links --> &lt;%- partial('article-tags', {item: item}) %> &lt;%- partial('article-categories', {item: item}) %> &lt;/div> 这个模板几乎和_partial/article-excerpt.ejs`一样，除了：我们使用&lt;%- item.content %&gt;展示全文内容而不是摘要在底部新增两个部分，分别是标签部分和分类部分。接下来分别创建它们。文章标签文章标签部分将生成一篇文章对应的所有标签：layout/_partial/article-tags.ejs我们想要创建的是一系列的标签和链接，每个链接都将导向对应的标签页面，而标签页面会显示该标签的所有文章。// layout/_partial/article-tags.ejs &lt;% if (item.tags &amp;&amp; item.tags.length){ %> &lt;% var tags = []; item.tags.forEach(function(tag){ tags.push('&lt;a href="' + config.root + tag.path + '">#' + tag.name + '&lt;/a>'); }); %> &lt;div class="blog-tags-container"> &lt;span class="glyphicon glyphicon-tags">&lt;/span> &lt;%- tags.join(' ') %> &lt;/div> &lt;% } %> 很简单，我们通过post.tags遍历文章的所有标签并让这些标签一个接一个地显示。我在每个标签前面加了一个#号，并且在列表前面额外加了一个图标。文章分类layout/_partial/article-categories.ejs的内容和上面很相似// layout/_partial/article-categories.ejs &lt;% if (item.categories &amp;&amp; item.categories.length){ %> &lt;% var categories = []; item.categories.forEach(function(category){ categories.push('&lt;a href="' + config.root + category.path + '">' + category.name + '&lt;/a>'); }); %> &lt;div class="blog-categories-container"> &lt;span class="glyphicon glyphicon-folder-open">&lt;/span> &lt;%- categories.join(' / ') %> &lt;/div> &lt;% } %> 这里不再赘述。文章样式可能有人注意到了，我们分别给了标签部分和分类部分一个类名，这是为了方便给它们设置样式。这是相关代码，将它们添加进blog.css中：// source/css/blog.css .blog-tags-container, .blog-categories-container { margin-top: 30px; font-size: 20px; } .blog-tags-container span.glyphicon, .blog-categories-container span.glyphicon { margin-right: 20px; } 页面类型模板的详情页这个很简单。“页面类型模板”和“文章类型模板”相差无几。就当做练习自定义一下就好，这是我的设置：// layout/page.ejs &lt;%- partial('_partial/article-full', {item: page}) %> 归档页归档页和首页一样会显示文章列表，只是它要更加简略—尽管基础结构和首页是差不多的：// layout/archive.ejs &lt;% page.posts.each(function(item){ %> &lt;%- partial('_partial/article-archive', {item: item}) %> &lt;% }); %> &lt;%- partial('_partial/pagination') %> 文章归档页部分和前面一样，实际的工作是由article-archive.ejs完成的。我使用article-excerpt作为基础结构，做了适当删减，只保留标题、日期和作者。// layout/_partial/article-archive.ejs &lt;div class="blog-post"> &lt;!-- Title --> &lt;h2 class="blog-post-title-archive"> &lt;a href="&lt;%- config.root %>&lt;%- item.path %>"> &lt;%- item.title || item.link%> &lt;/a> &lt;/h2> &lt;!-- Date and Author --> &lt;p class="blog-post-meta"> &lt;%= item.date.format(config.date_format) %> &lt;% if(item.author) { %> by &lt;%- item.author %> &lt;% } %> &lt;/p> &lt;/div> 细心的人可能注意到，我为标题创建了一个新的类名（它们太大了，我不喜欢）：// source/css/blog.css .blog-post-title-archive { margin-bottom: 5px; font-size: 25px; } 标签页和分类页最后我们还需要创建两个页面。标签页将包括某个标签对应的全部文章，分类页同理。如果你还记得的话：| 模板 | 备用模板 | 页面描述 ||—–|—–|—-|| archive | index | 这是归档页。它将显示我们博客中所有文章的标题和详情页链接|| category | archive | 这是分类页。与归档页类似，但是会根据类别进行筛选|| tag | archive | 这是标签页。与分类页类似，但是会根据标签进行筛选|tag.ejs和’category.ejs’的回退页是archive.ejs。我认为这三个页面并无太大区别，我们仅仅是在使用archive.ejs的回退页而已。好处就是代码量减少、提高代码可复用性和可维护性。不过为了区分这三个页面，我们还是给归档页加上标题吧：// layout/archive.ejs &lt;% var title = ''; if (page.category) title = page.category; if (page.tag) title = page.tag; if (page.archive){ if (page.year) title = page.year + (page.month ? '/' + page.month : ''); else title = "Archives"; } %> &lt;% if(title) { %> &lt;h2 class="blog-archive-title">&lt;%- title %>&lt;/h2> &lt;% } %> &lt;% page.posts.each(function(item){ %> &lt;%- partial('_partial/article-archive', {item: item}) %> &lt;% }); %> &lt;%- partial('_partial/pagination') %> 现在我们有了一个漂亮的标题用以描述了归档页的类型。这是对应的CSS样式：// source/css/blog.css .blog-archive-title { margin-bottom: 50px; } 本教程的第二篇文章非常简单，你只需要清楚第一篇文章中提及的概念即可。我强烈推荐你根据自己的口味尝试修改主题。在第三篇文章中，我们将添加评论部分、统计部分、装饰部件并做一些改进。期待与你再次相见！目前可以找到的比较完备的 Hexo 主题制作教程，我自己从中受益良多。有打算自己撸一个主题的都可以参考下，真的写得很不错。如果发现译文存在错误或其他需要改进的地方，欢迎在下面评论指出。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>hexo theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「译」创建一个Hexo主题-Part1:首页]]></title>
    <url>%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1%2F</url>
    <content type="text"><![CDATA[原文地址：Create an Hexo Theme-Part1: Index原文作者：Jonathan Klughertz译者：Chor在这个系列教程中，你将学习怎么从零开始制作一个 Hexo 主题。我很喜欢 Hexo ，并且每天都在使用，不幸的是，直到今天关于主题制作的文档还是相当稀缺。所以我打算弥补这个空缺。其它文章的链接：创建一个Hexo主题-Part1:首页创建一个Hexo主题-Part2:其他页面创建一个Hexo主题-Part3:评论、分析和小部件预先准备Hexo 博客的基础使用。如果你是第一次接触，请前往官网阅读教程了解 Bootstrap了解 Javascript 模板引擎（我们将使用 EJS ）项目描述这个项目旨在制作一个 Hexo 主题并详细了解 Hexo 引擎的工作方式。我不想在 HTML 和 CSS 上花费太多时间，所以我们将重置下面这个Hexo主题：https://getbootstrap.com/docs/3.4/examples/blog/ 。它是 Bootstrap 文档中的一个标准初始模板样例。我们将一步步地重用 CSS 、复制粘贴 HTML ，直到最后实现想要的效果。如果你感到困惑或者只对它的代码感兴趣，请前往 github 。项目结构创建一个新的 hexo 博客让我们从搭建一个全新的 hexo 博客开始吧// Create a new folder mkdir hexo-theme-creation cd hexo-theme-creation // Initialise Hexo hexo init 创建主题文件夹// Enter the theme folder cd themes // bootstrap-blog-hexo is also going to be the name of our theme mkdir bootstrap-blog-hexo 注意：如果你想在 git 中保存主题的话（你也应该这么做），请在/themes/bootstrap-blog-hexo/中初始化 git 。文件夹结构这是我们开始工作所需要的文件和文件夹：|-- layout // .ejs templates |-- source // source files (CSS, scripts) |-- _config.yml 创建以下两个文件夹和 _config.yml 文件。/layout/ 将包含我们所有的 EJS 模板/source/ 将包含我们所有的资源（ CSS 文件、外部脚本和库）_config.yml 包含我们的主题配置。现在暂且不写入任何内容。复制 bootstrap blog 资源从 bootstrap blog template 复制所有我们需要的资源并放在 source 文件夹里。你可以选择通过浏览器查看资源并复制下来，或者是下载该压缩包，之后解压到 source 文件夹里。|-- layout |-- source |-- bootstrap // Copy the boostrap library files here |-- css // Copy the blog's css file here |-- favicon |-- favicon.ico // Your choice of favicon |-- js // Copy the blog's js file here |-- _config.yml Hexo 的基本要素在我们开始写第一个模板文件之前，先来看看 Hexo 博客生成过程的基本要素。页面类型我们能够在主题中定义 6 种页面类型，与之相对应地，在 public 文件夹生成的每一个单独的 HTML 页面都属于下面模板中的其中一个：模板回退页面描述index无这是博客的首页，也是网站的主要入口。本教程中我们将让其显示文章摘要列表postindex这是文章的详情页。我们将展示一篇完整的文章以及一个评论区pageindex这是页面的详情页，与 post 一样，但是是 page 类型的 postarchiveindex这是归档页。它将显示我们博客中所有文章的标题和详情页链接categoryarchive这是分类页。与归档页类似，但是会根据类别进行筛选tagarchive这是标签页。与分类页类似，但是会根据标签进行筛选在本篇教程中我们将创建 index 模板。在页面生成过程中， Hexo 将会搜索名字为 index.ejs, post.ejs , page.ejs 等的文件，这些模板之后用于创建静态 HTML 页面。公共布局Hexo 支持使用 公共的布局文件 ，上面的模板都将使用到该文件。该文件命名为 layout.ejs 。不同页面类型的模板会创建一些内容，而这个文件就好比这些内容的“外壳”。在我们的主题中，公共布局将包括：&lt;html&gt;标签、&lt;head&gt;标签、头部、菜单、底部和侧边栏。基本上是所有类型的页面都具备的元素。不同的页面模板将只负责创建实际内容，这些内容将放在我们的主体部位。变量在所有的模板中，我们都可以使用 hexo 引擎提供的内置变量。以下是部分变量：Site：site包含了网站的信息。例如，我们可以通过site.posts访问博客中的所有文章。当我们想要显示统计数据的时候，这将派上用场。Page：page是主要变量，包含了许多与当前页面相关的信息，包括所有的文章标题、日期、内容等。Config：config是一个指向站点_config.yml文件的 JavaScript 对象Theme：theme是一个指向主题_config.yml文件的 JavaScript 对象主题的布局创建上面提及了/layout/layout.ejs文件，现在我们开始来创建它。顶部标签首先创建 layout.ejs 文件并插入&lt;html&gt;&lt;/html&gt;标签//layout/layout.ejs &lt;html> &lt;!-- Head tag --> &lt;%- partial('_partial/head') %> &lt;/html> 这里我们将所有&lt;head&gt;标签里的代码提取出来并放在局部视图中，这有助于实现关注点分离和代码重用。语法是partial(&#39;path&#39; [, arguments])在创建layout/_partial/head.ejs文件后，从 bootstrap 源码中复制 head 标签里的代码：// layout/_partial/head.ejs &lt;head> &lt;meta charset="utf-8"> &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"> &lt;meta name="viewport" content="width=device-width, initial-scale=1"> &lt;meta name="description" content=""> &lt;meta name="author" content=""> &lt;link rel="icon" href="favicon/favicon.ico"> &lt;title>Blog Template for Bootstrap&lt;/title> &lt;!-- Bootstrap core CSS --> &lt;%- css('bootstrap/css/bootstrap.min.css') %> &lt;!-- IE10 viewport hack for Surface/desktop Windows 8 bug --> &lt;%- css('css/ie10-viewport-bug-workaround.css') %> &lt;!-- Custom styles for this template --> &lt;%- css('css/blog.css') %> &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --> &lt;!--[if lt IE 9]> &lt;script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js">&lt;/script> &lt;script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js">&lt;/script> &lt;![endif]--> &lt;/head> 这很简单，我们只需使用 CSS helper 插入样式表。source 文件夹中的文件将会被复制到站点根目录下，所以不要在路径中包含source/我们将让&lt;title&gt;和&lt;meta&gt;标签保持动态，不过现在先暂且不管它们。底部标签底部标签位于&lt;/body&gt;之前。我们将在这个局部视图中包含所有脚本。先修改一下布局：// layout/layout.ejs &lt;html> &lt;!-- Head tag --> &lt;%- partial('_partial/head') %> &lt;body> &lt;!-- After footer scripts --> &lt;%- partial('_partial/after-footer') %> &lt;/body> &lt;/html> 然后创建layout/_partial/after-footer.ejs的内容：// layout/_partial/after-footer.ejs &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js">&lt;/script> &lt;%- js('bootstrap/js/bootstrap.min.js') %> &lt;!-- IE10 viewport hack for Surface/desktop Windows 8 bug --> &lt;%- js('js/ie10-viewport-bug-workaround.js') %> 注意 JS helper function 的使用，它将引用本地 js 文件。顶部菜单类似地，在&lt;body&gt;标签后创建顶部菜单。// layout/layout.ejs // [...] &lt;body> &lt;!-- Menu --> &lt;%- partial('_partial/menu') %> // [...] layout/_partial/menu.ejs的内容：// layout/_partial/menu.ejs &lt;div class="blog-masthead"> &lt;div class="container"> &lt;nav class="blog-nav"> &lt;% for (var i in theme.menu){ %> &lt;a class="blog-nav-item" href="&lt;%- url_for(theme.menu[i]) %>">&lt;%= i %>&lt;/a> &lt;% } %> &lt;/nav> &lt;/div> &lt;/div> 注意theme全局变量的使用,它指向的是主题的_config.yml文件。为了可以在主题配置中配置菜单，我们需要在_config.yml文件中添加配置：_config.yml # Header menu: Home: / Archives: /archives 在menu.ejs中我们遍历了配置文件中所有的菜单项目并创建对应的链接。顶部顶部将位于顶部菜单下面，它包含了博客标题和子标题：// layout/_partial/header.ejs &lt;div class="blog-header"> &lt;h1 class="blog-title">&lt;%= config.title %>&lt;/h1> &lt;p class="lead blog-description">&lt;% if (config.subtitle){ %>&lt;%= config.subtitle %>&lt;% } %>&lt;/p> &lt;/div> 这里我们使用了指向站点_config.yml文件的config变量，它包含了可供配置的标题和子标题属性。注意在布局的&lt;div class=&quot;container&quot;&gt;&lt;div&gt;中嵌套顶部：// layout/layout.ejs &lt;html> &lt;!-- Head tag --> &lt;%- partial('_partial/head') %> &lt;body> &lt;!-- Menu --> &lt;%- partial('_partial/menu') %> &lt;div class="container"> &lt;!-- Blog Header: title and subtitle --> &lt;%- partial('_partial/header') %> &lt;/div> // [...] 底部底部现在是完全静态的，内容如下：// layout/_partial/footer.ejs &lt;footer class="blog-footer"> &lt;p>Blog template built for &lt;a href="http://getbootstrap.com">Bootstrap&lt;/a> by &lt;a href="https://twitter.com/mdo">@mdo&lt;/a>.&lt;/p> &lt;p>Adapted to Hexo by &lt;a href="http://www.codeblocq.com/">klugjo&lt;/a>.&lt;/p> &lt;p>&lt;a href="#">Back to top&lt;/a>&lt;/p> &lt;/footer> 主要内容和侧边栏此时，我们再加上主要内容和侧边栏，基本就差不多了。下面是最终的layout.ejs：// layout/layout.ejs &lt;html> &lt;!-- Head tag --> &lt;%- partial('_partial/head') %> &lt;body> &lt;!-- Menu --> &lt;%- partial('_partial/menu') %> &lt;div class="container"> &lt;!-- Blog Header: title and subtitle --> &lt;%- partial('_partial/header') %> &lt;div class="row"> &lt;!-- Main Content --> &lt;div class="col-sm-8 blog-main"> &lt;%- body %> &lt;/div> &lt;!-- Sidebar --> &lt;div class="col-sm-3 col-sm-offset-1 blog-sidebar"> &lt;%- partial('_partial/sidebar') %> &lt;/div> &lt;/div> &lt;/div> &lt;!-- Footer --> &lt;%- partial('_partial/footer') %> &lt;!-- After footer scripts --> &lt;%- partial('_partial/after-footer') %> &lt;/body> &lt;/html> body变量对应了不同页面类型模板创建的内容（参见上面）。至于侧边栏，我们现在暂且使用来自 bootstrap 模板的硬编码：// layout/_partial/sidebar.ejs &lt;div class="sidebar-module sidebar-module-inset"> &lt;h4>About&lt;/h4> &lt;p>Etiam porta &lt;em>sem malesuada magna&lt;/em> mollis euismod. Cras mattis consectetur purus sit amet fermentum. Aenean lacinia bibendum nulla sed consectetur.&lt;/p> &lt;/div> &lt;div class="sidebar-module"> &lt;h4>Archives&lt;/h4> &lt;ol class="list-unstyled"> &lt;li>&lt;a href="#">March 2014&lt;/a>&lt;/li> &lt;li>&lt;a href="#">February 2014&lt;/a>&lt;/li> &lt;li>&lt;a href="#">January 2014&lt;/a>&lt;/li> &lt;li>&lt;a href="#">December 2013&lt;/a>&lt;/li> &lt;li>&lt;a href="#">November 2013&lt;/a>&lt;/li> &lt;/ol> &lt;/div> &lt;div class="sidebar-module"> &lt;h4>Elsewhere&lt;/h4> &lt;ol class="list-unstyled"> &lt;li>&lt;a href="#">GitHub&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Twitter&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Facebook&lt;/a>&lt;/li> &lt;/ol> &lt;/div> 首页文件布局到位后，我们就可以开始创建第一个页面类型模板 inde.ejs 了。这是比较简陋的第一个版本：// layout/index.ejs &lt;span>Content&lt;/span> 别小瞧它，我们可以用这个在浏览器中测试主题：# Verify that everything is alright hexo generate # Start hexo server hexo server 访问 http://localhost:4000/ 。哇！注意：不要忘记在站点的 config 文件中更新主题：_config.yml # Extensions ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: bootstrap-blog-hexo 遍历博客文章我们想要在首页显示各篇文章的摘要。首先，在我们的 index.ejs 文件中遍历文章：// layout.index.ejs &lt;% page.posts.each(function(item){ %> &lt;%- partial('_partial/article-excerpt', {item: item}) %> &lt;% }); %> 通过page.posts获取该页面的所有文章通过&lt;%- partial(&#39;name&#39;, args) %&gt;给 partial 传参文章布局创建article-excerpt.ejs文件，添加适合主题的代码。这是我的布局：// layout/_partial/article-excerpt.ejs &lt;div class="blog-post"> &lt;!-- Title --> &lt;h2 class="blog-post-title"> &lt;a href="&lt;%- config.root %>&lt;%- item.path %>"> &lt;%- item.title %> &lt;/a> &lt;/h2> &lt;!-- Date and Author --> &lt;p class="blog-post-meta"> &lt;%= item.date.format(config.date_format) %> &lt;% if(item.author) { %> by &lt;%- item.author %> &lt;% } %> &lt;/p> &lt;!-- Content --> &lt;%- item.excerpt || item.content %> &lt;!-- Only display the Read More link if we are displaying an excerpt --> &lt;% if(item.excerpt) { %> &lt;p> &lt;a href="&lt;%- config.root %>&lt;%- item.path %>"> &lt;%= theme.excerpt_link %> &lt;/a> &lt;/p> &lt;% } %> &lt;/div> 全文链接全文链接是由config.root（配置选项，相当于/）和item.path(相对路径或者绝对路径，指向全文)连接组成的。文章作者默认情况下， Hexo 没有关于作者属性的的文章变量。不过我们可以在 front matter 中添加任意自己想要的变量。如果你想要在文章中显示作者名字，那么文章的 front matter 应该类似如下进行设置：title: Hello World author: Klughertz Jonathan --- Item excerpt 和 Item content当用 Hexo 编辑文章时，你可以用&lt;!-- more --&gt;标签从文章内容中截取摘要。在本教程中，因为我们展示的是文章列表，所以选择显示摘要。之后用户可以通过点击文章标题或者“阅读更多”的链接浏览全文。“阅读更多”文本别忘了，你需要像我这样在主题的配置文件中添加一个新的属性：_config.yml # Read More text excerpt_link: Read More 希望接下来的代码容易理解。现在，我建议你写一些除了默认的 Hello World 之外的文章并享受这个结果。分页器在本篇文章中，我们最后需要处理的是首页的分页器。在index.ejs文件中增加一个分页器的 partial ：// layout/index.ejs &lt;% page.posts.each(function(item){ %> &lt;%- partial('_partial/article-excerpt', {item: item}) %> &lt;% }); %> &lt;%- partial('_partial/pagination') %> 之后开始创建分页器的内容，layout/_partial/pagination.ejs:// layout/_partial/pagination.ejs &lt;nav> &lt;ul class="pager"> &lt;% if (page.prev){ %> &lt;li>&lt;a href="&lt;%- config.root %>&lt;%- page.prev_link %>">Previous&lt;/a>&lt;/li> &lt;% } %> &lt;% if (page.next){ %> &lt;li>&lt;a href="&lt;%- config.root %>&lt;%- page.next_link %>">Next&lt;/a>&lt;/li> &lt;% } %> &lt;/ul> &lt;/nav> page.prev：上一页的页码。如果当前页是第一页，则为0page.next：下一页的页码。如果当前页是最后一页，则为0page.next_link和page.prev_link是什么就不用多说了。如果你没有足够的文章用来查看分页器的工作效果，可以在主配置文件中（per_page属性）调整每一页的文章数。这就是今天的内容，在下一篇教程中，我们将完成博客剩下的所有页面。目前可以找到的比较完备的 Hexo 主题制作教程，我自己从中受益良多。有打算自己撸一个主题的都可以参考下，真的写得很不错。如果发现译文存在错误或其他需要改进的地方，欢迎在下面评论指出。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>hexo theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础系列：inline-blcok和float]]></title>
    <url>%2F2019%2F03%2F27%2FF-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Ainline-block%E5%92%8Cfloat%2F</url>
    <content type="text"><![CDATA[1.比对：简单比对一下div+css布局中的inline-block和float的特点，同时附上使用inline-block之后元素之间产生空隙的解决方法。虽然设置浮动跟设置inline-block有些特征类似，但两者的区别还是非常明显的:文档流（Document flow）:浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。水平位置（Horizontal position）：很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。垂直对齐（Vertical alignment）：在两个div的高度不同时，两种方式的对齐效果也不相同：图一：display:inlne-block属性修饰的元素没有脱离文档流，当然会与在正常的文档流中的元素一样采取的底端对齐方式。图二： float属性修饰的元素在一定程度上脱离了普通文档流的限制，只用考虑向某个方向浮动，所以会产生如图的效果。区别来了！！！如果是使用display:inlne-block，则我们可以通过vertical-align来控制两个元素的对齐方式：我们为两个div分别添加一个属性：vertical-align:middle&lt;div class="myContainer"> &lt;div class="div1" style="display: inline-block;vertical-align: middle"> &lt;/div> &lt;div class="div2" style="display: inline-block;vertical-align: middle"> &lt;/div> &lt;/div> 查看一下运行效果：如图，div1出现在了div2的居中位置。假如使用的是float，我们是没办法使div1位于div2的中间位置的。空隙（Whitespace）：inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空隙。而浮动元素会忽略空白节点，互相紧贴。2.总结：什么时候使用inline-block、什么时候使用float，这取决于你的设计稿跟解决方法。通常来说，当你需要控制元素的垂直对齐跟水平排列时，使用inline-block；当你需要让元素环绕某一个元素时，或者需要支持旧版本ie，或者不想处理inline-block带来的空隙问题时，使用浮动。3.如何消除inline-block带来的空隙;3.1 思路一：元素间的间隙出现的原因是元素标签之间的空格，把空格去掉间隙自然就会消失。来看以下几种写法：写法一/不建议使用：&lt;div class="demo"> &lt;span>我是一个span&lt;/span>&lt;span>我是一个span&lt;/span>&lt;span>我是一个span&lt;/span>&lt;span>我是一个span&lt;/span> &lt;/div> 写法二：&lt;div class="demo"> &lt;span>我是一个span &lt;/span>&lt;span>我是一个span &lt;/span>&lt;span>我是一个span &lt;/span>&lt;span>我是一个span&lt;/span> &lt;/div> 写法三：&lt;div class="demo"> &lt;span>我是一个span&lt;/span>&lt;!-- -->&lt;span>我是一个span&lt;/span>&lt;!-- -->&lt;span>我是一个span&lt;/span>&lt;!-- -->&lt;span>我是一个span&lt;/span> &lt;/div> 3.2 思路二：取消span的结束标签，这样间隙就没有了。为了兼容IE6/IE7，最后一个标签需要闭合。&lt;div class="demo"> &lt;span>我是一个span &lt;span>我是一个span &lt;span>我是一个span &lt;span>我是一个span&lt;/span> &lt;/div> .demo span{ background:#ddd; display: inline-block; } 3.3 思路三：不管是思路一还是思路二，都只适用于写静态页面的时候，一旦HTML是后台生成，就不生效了。这时还有一个办法：在父容器上使用font-size:0。&lt;div class="demo"> &lt;span>我是一个span&lt;/span> &lt;span>我是一个span&lt;/span> &lt;span>我是一个span&lt;/span> &lt;span>我是一个span&lt;/span> &lt;/div> .demo {font-size: 0;} .demo span{ background:#ddd; display: inline-block; font-size: 14px; /*要设置相应的字号*/ } 原理：换行和回车会给各个span之间带来空格，而空格会被当成字符处理，因此通过给父元素设置字体大小为0，则空格字符大小也为0，相当于消除了其大小。需要注意的是，一定要额外设置span中的字体大小，否则会继承父元素的0大小字体。3.4 思路四：上面的思路其实已经很完美，但可惜不兼容Safari，以下给出终极方案,即font-size:0配合letter-space:-N px。.finally-solve { letter-spacing: -4px;/*根据不同字体字号或许需要做一定的调整*/ word-spacing: -4px; font-size: 0; } .finally-solve li { font-size: 16px; letter-spacing: normal; word-spacing: normal; display:inline-block; *display: inline; zoom:1; }]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text3插件简易使用教程]]></title>
    <url>%2F2019%2F03%2F26%2FTo-Sublime%20Text3%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[作为一款轻便的编辑器，Sublime Text3的下载和安装都比较简单，这里一并略过，只说安装插件的事情。Sublime Text3支持各种强大的插件，可以在一定程度上提高打码速度。1.安装 Package Control安装插件有两种方式，一种是直接下载插件的安装包，解压缩到编辑器的 Packages 目录中，比较麻烦，不推荐；我们通常用另一种方法，即通过 Package Control 组件来安装插件 。所以第一步，先安装 Package Control 组件 。打开编辑器，按 control + ` 打开控制台，粘贴如下代码到命令行并回车；import urllib.request,os;pf = 'Package Control.sublime-package';ipp = sublime.installed_packages_path(); urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen('http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 重启编辑器，在 Perferences -&gt;Package Settings 中看到 Package Control，则表示安装成功。当然，你有很大的概率会安装失败，遇到下面的报错弹窗：原因不便多说（你懂的），网上有比较多的解决方法，这里提供一种最有效也是最简单的方法。依次点击编辑器的 Preferences –&gt;package settings–&gt;package control–&gt;settings user,进入用户自定义配置文件，修改 channels 的值为http://www.miaoqiyuan.cn/products/proxy.php/https://packagecontrol.io/channel_v3.json 如下图所示：这样我们就可以成功安装 package controls 了 。2.安装想要的插件点击 Preferences –&gt;package control，点选 install package 选项 ，输入自己想要安装的插件的名称，即可进行安装。当然，由于**原因，安装插件的过程一般比较慢，等一会就行了。一般来说，安装成功后会弹出新标签页。3.推荐的插件3.1 汉化插件如果你看不惯英文的话，可以下一个汉化插件。点选 install package 选项后 ，搜索“ChineseLocalization”进行安装。安装完后重启编辑器即可；3.2 解决中文乱码问题的插件Sublime Text3 不支持 GB 2312和 GBK 编码，会出现中文乱码的情况，所以推荐安装“ConvertToUTF8”插件，安装方法同上；3.3 解决输入法输入框不跟随问题的插件中文状态下，我们会发现输入法的输入框无法跟随鼠标，看着非常难受，所以这里可以用 IMESupport 插件解决这个问题。这个方法绝大多数情况下是有效的，然而，如果你是 win10用户，并且用的是系统自带输入法，那么你得采取另一种方法。原文链接在此 https://blog.csdn.net/qq_24345801/article/details/79077902 ，这里粘贴一下主要内容。其实还是要用到插件 IMESupport ，只不过这个插件是国人大神自己修改的，下载地址是：https://github.com/zcodes/IMESupport由于是修改过的源码，不能通过 package control 来在线安装 ，而是需要自己手动安装（安装前请先卸载原来的插件），安装过程如下：从上面的网址下载插件，解压Preferences-&gt;Browse Packages 打开插件安装的目录将解压后的文件夹复制到上一步打开的目录中重启 sublime text 3即可3.4 自动补全代码的插件使用“Emmet”插件，可以迅速编写 HTML /CSS 代码 ，例如，只需要用html:5配合 tab 键即可迅速生成 html 的基础结构 ，还可以用诸如nav&gt;ul&gt;li的快捷方式迅速生成嵌套结构，具体其他用法可以百度“Emmet 语法 ”。3.5 语法检查插件也即 SublimeLinter 插件。但其实我们并不是直接用它进行代码检测——实际上它是一个包含了多种检测插件（sublimelinter-htmlhint，sublimelinter-csslint，sublimelinter-jshint）的“容器”。本步骤的安装会比其他插件麻烦得多，下面介绍一下具体安装过程。3.5.1 安装 node .js安装 SublimeLinter 前必须先安装 node .js 这一重要前置 。这是因为 sublimelinter -htmlhint，sublimelinter-csslint，sublimelinter-jshint 实际上分别调用的是 node.js 的 htmlhint，csslint 和 jshint。安装 node .js 比较简单 ，这里略过。3.5.2 安装 SublimeLinter打开 Sublime ，按下 Ctrl+Shift+p 进入 Command Palette;输入 install 进入 Package Control: Install Package;输入 SublimeLinter ，选择 SublimeLinter 进行安装。3.5.3 安装 sublimeLinter-contrib-htmlhint 和 xg-htmlhintSublimeLinter 的插件之一 ，用来调用 node .js 的 xg-htmlhint 进行语法检查 。前往 Releases 下载最新版本的压缩包，解压并重命名为“SublimeLinter-contrib-htmlhint”，并放入 Sublime 的 Package 目录 (菜单-&gt;Preferences-&gt;BrowsePackages)开始菜单—&gt;node.js—&gt;node.js command prompt，输入以下命令 ：npm install -g xg-htmlhint等待出现一堆数字版本号即为成功安装。3.5.4 安装 sublimeLinter-csslint 和 csslint，sublimeLinter-jshint 和 jshint打开 Sublime Text3,按住 Ctrl +Shift+P 安装SublimeLinter-csslintSublimeLinter-jshint开始菜单—&gt;node.js—&gt;node.js command prompt，输入以下命令：npm install -g jshintnpm install -g csslint之后重启编辑器，大功告成。这个插件虽然不是万能的，但是可以鉴别很多错误。3.6 热更新插件每次修改文件都要刷新一遍浏览器，会不会太麻烦？试试热更新插件吧。首先去 chrome 应用商店安装 LiveReload 扩展程序，之后设置允许访问文件网址；接着在 sublime 中按 ctrl+shift+p 打开命令面板，并选择“Add Repository”，输入https://github.com/NickWoodhams/LiveReload.Git 并回车；接着搜索 LiveReload 插件并安装，之后配置：{ "enabled_plugins": [ "SimpleReloadPlugin", "SimpleRefresh" ] } 保存并重启 sublime。正常打开文件，点击 chrome 右上角的相关插件开启热更新功能。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[折腾博客系列之博客搭建：Hexo+Github pages]]></title>
    <url>%2F2019%2F03%2F24%2FT-hexo%2Bgithub%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[初衷：之前我习惯用印象笔记进行知识的收集和整理，虽然很好用，但终归只适合输入而不适合输出。我需要的是一个更加开放的平台，在这上面可以输出： 1.学习的收获 ；2.生活的感想 ；3.有价值的分享，因此有了这个博客网站。用hexo+github pages 可以很方便地搭建一个个人博客网站，不需要购买域名和服务器，只需要按部就班操作即可。我自己大概是花了两三个小时搞定，主要是因为对git bash的使用不够熟悉，因此走了一些弯路。实际上动作快的话半个小时就可以搞定。下面是对部署过程的大概介绍，以及必须注意的事项（划重点，也就是所谓的“坑”）。由于本文参考了大量博客，所以在文末我会列出原文链接。一.Github，Github pages ，Hexo首先介绍一下这三个东西，有大概的了解、知道是什么东西就可以。GitHub是一个面向开源及私有软件项目的托管平台，而GIthub Pages则是github的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，现在大多用来开发和制作个人博客网站。它的好处在于域名和服务器都是免费提供的，并且没有网站数量的限制。而Hexo 是一个快速、简洁且高效的博客框架，它使用Markdown解析文章，在几秒内，就可以利用靓丽的主题生成静态网页。（关于Hexo的详细介绍，请看官方文档 https://hexo.io/zh-cn/docs/ ，这里就不展开了）。因此，可以说github和hexo是绝配。接下来，开始我们的工作。二. 环境和必要准备我个人的环境：win10，64bit必要准备：你需要（1）github账号 ：前往https://github.com/ 官网注册就好（2）git ： 最新版本的git（本文发表的时候是2.20.1版本），前往https://git-scm.com/ 官网下载并安装。安装完后前往git文件夹下打开git bash，运行以下命令：git config --global user.name "username" git config --global user.email "your mail" 注：将username替换为自己的github账号名，将your mail替换为自己注册github时绑定的邮箱。这一步非常重要，当时部署的时候我因为遗漏了这一步，导致后面报错.（3）node.js ： 前往 https://nodejs.org/en/ 下载并安装。这两个的安装比较简单，一路next就好，不过我推荐还是修改一下路径，尽量放在自己可以找到的位置。（4）hexo ：打开git文件夹下的git bash，运行 以下命令安装hexonpm install -g hexo-cli 依次运行以下命令进行hexo的初始化$ hexo init &lt;folder> $ cd &lt;folder> $ npm install 注：请将上面代码的&lt;folder&gt;替换成你自己想要的文件夹名字，以我为例，我想要在git文件夹下新建一个Myblog文件夹以存放站点文件，那么我这里的代码就应该是$ hexo init Myblog $ cd Myblog $ npm install 成功之后，我们会在git文件夹下看到新建的Myblog文件夹，这个就是我们的站点文件夹，网站相关文件都存放在这里。这里顺便介绍一下cd Myblog的作用，可以理解为“进入Myblog运行git bash”，你也可以在Myblog中右键运行git bash（如下图），效果是一样的。在之后介绍的操作中，凡是需要输入命令的，请确保你已经cd进自己的站点文件夹。接着上面的代码，我们继续运行：hexo server 这将在本地打开我们的网站，当提示”xxx is running at xxx“的时候，我们可以通过http://localhost:4000/ 这个网址预览我们的网站，想要切断连接，只需要在命令行窗口按下ctrl+c。至此，hexo博客已经在本地搭建好了。接下来，我们要将hexo和github进行对接。三. hexo与github 实现对接1.建立仓库还记得我们之前注册的github账号吗？现在，请进入github网站，并点击头像选择your repository，我们现在需要创建一个仓库（也就是repository）用于存放相关站点文件。按照下图顺序进行设置：其中，Repository name也即是我们的仓库名字，必须是 Github账号名称.github.io的格式。比如你的github名字是ccc，那么仓库名字必须是ccc.github.io 。2.对接github在git bash中运行以下命令，安装 hexo-deployer-git 插件。npm install hexo-deployer-git --save 运行以下命令，创建SSH key。（注：和上面一样，请将your mail替换成github邮箱地址）$ ssh-keygen -t rsa -C "your mail" 前往 C:\Users\Administrator.ssh\id_rsa.pub （注意，这只是大概位置。不同系统路径可能不同，但是大同小异）打开id_rsa.pub文件（可以用记事本打开，但是推荐用sublime text）。复制文件中的全部内容，前往 https://github.com/settings/keys ，将刚才复制的内容粘贴在New SSH key 的文本框中。前往站点目录下（例如：git/ Myblog），打开_config.yml 文件，对文件末尾进行如下修改：# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 在这里要注意，1）所有的冒号距离右边的内容之间都有一个空格，如果没有空格，则修改是无效的。2）和前面一样，将usename替换成我们自己的github用户名 。 3）repo后面的地址，在旧版本的hexo中是http地址，但在新版本的hexo用的是ssh地址，我们统一用如上所示的ssh地址。有些博客由于没有进行更新，在说明这个问题的时候依然用的是http地址，造成了一定程度上的误导。运行以下命令，对接并推送内容到github。$ hexo g $ hexo d 等待片刻，打开 https://&lt;Github账号名称&gt;.github.io （例如 https://ccc.github.io ) 即可进入你搭建好的个人博客网站了。当然，网站默认用的是landscape主题，比较难看，关于主题的美化和后期一些插件的添加，可以参考文章末尾贴出的链接。PS：这里顺便介绍一下常用的 hexo 命令：hexo clean ————————&gt;清除缓存文件和已生成的静态文件hexo g 或者 hexo generate ————————&gt;生成静态文件hexo d 或者hexo deploy ————————&gt;生成静态文件并部署到仓库hexo s 或者 hexo server —————————&gt;在本地打开网站一般来说，在对网站进行修改后，我们可以先用hexo g和hexo s 在本地预览效果，如果效果符合预期的话再用hexo d 推送到 github。当然，可能会遇到本地打开和域名打开的效果不一致，这种情况下通常是因为 1. 没有用hexo clean 清除缓存 2. 没有清除浏览器缓存（ctrl+f5 ） 3.忘记用hexo d 将本地文件推送到github 4. 本地和线上的同步本身需要时间，所以上述方法如果无效，可以尝试等几分钟，再打开网站就正常显示了。参考自：https://www.jianshu.com/p/3a05351a37dchttps://www.simon96.online/2018/10/12/hexo-tutorial/]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾博客系列之编辑工具的选择]]></title>
    <url>%2F2019%2F03%2F24%2FTo-%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[Hexo是静态博客网站，必须先在本地编辑好md文件再推送到网站上去—md文件也就是所谓的用markdown语法编写内容的文件。“工欲善其事，必先利其器”，因此我们需要一个合适的markdown编辑工具，它必须具备以下特点：1.可导出md文件到本地，并随时进行修改2.可提供分屏预览，支持同步滚动和定位3.启动时响应速度快，编辑时渲染速度快以下是一些工具在markdown编写方面的优劣比较，可酌情进行选择。（平台：windows）印象笔记印象笔记自带markdown编辑器,如下图：优点：提供分屏预览，无需直接编写md代码，只需点击按钮即可，操作方便缺点：无法导出md文件到本地，这是它的致命缺点。sublime text3优点：安装插件后可以提供分屏预览缺点：预览效果极差，超出的文本内容无法自动换行显示，而是直接隐藏。如下图红框部分Typora优点：简洁美观缺点：不提供分屏预览，md代码编辑完成后回车即自动渲染出文本来。（虽然它认为这是优点，很多人习惯的却是分屏）Atom优点：提供分屏预览，有较多可拓展插件缺点：响应速度极慢，编辑时明显感觉卡顿；软件过大，大概100多m；安装插件极其困难，失败率较高HexoEditor优点：简洁美观，提供分屏预览，图片插入方便缺点：需要用npm指令下载安装，和Atom插件安装如出一辙，很容易卡死Hexo-admin非工具。Hexo自带的博客后台管理，可以在web ui界面下进行编辑优点：提供分屏预览缺点：界面过于简陋，自定义程度较低，本地服务器必须一直开着才能使用Vscode这是这么多工具中我觉得体验最好的，本篇博客也是用vscode编写。优点：提供分屏预览、同步滚动等；较多markdown插件和主题；启动速度快，使用流畅不卡顿，渲染速度很快缺点：需要自己写md代码，不过鉴于md语法并不复杂，我觉得这个缺点完全可以忽略不计。最后是博客编写方面的一点小tip：原生markdown语法并不支持定义字体颜色和大小等样式，但是由于在hexo中，我们编写的md文件最后会生成对应的html文件，所以完全可以在编写的时候使用html语法，浏览器会自动解析并渲染文件中包含的标签等。比如，上面就可以通过将句子放在span标签中，再加上内联样式达到荧光高亮的效果。不止是样式，我们还可以用&lt;br&gt;标签实现换行,让每一段不至于太紧凑。（md中空格是会被合并的，这点和html一样）]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>编辑工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大一下学期：The Start]]></title>
    <url>%2F2019%2F03%2F23%2FT-%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20Start%2F</url>
    <content type="text"><![CDATA[1.英语准备四级考试，重点是听力和写作；2.前端2.1. JS 重难点突破：培训视频（进阶系列）SegmentFault上js进阶的相关文章。由于是js中的难点，并且在面试中出现比较多，所以慢慢来。打算是每周攻克一个或两个【进阶1期】 调用堆栈【进阶2期】 作用域闭包【进阶3期】 this全面解析【进阶4期】 深浅拷贝原理【进阶5期】 原型Prototype【进阶6期】 高阶函数【进阶7期】 事件机制【进阶8期】 Event Loop原理【进阶9期】 Promise原理【进阶10期】Async/Await原理【进阶11期】防抖/节流原理【进阶12期】模块化详解【进阶13期】ES6重难点【进阶14期】计算机网络概述【进阶15期】浏览器渲染原理2.2.《js高程》的阅读：之所以单独拎出这一点，因为这学期基本不可能读完这么厚的书。所以打算是在学习h5的时候同步阅读本书。2.3. 找一个小项目做：初步决定是面向对象的小游戏，也有可能是hexo的一个主题主题已完成，接下来可能会探索一下小程序2.4. 新东西：html5+css3，了解新特性，重点放在css动画。如果有时间，就学习ajax和jq。jq不作为重点。3.阅读看两本历史相关的书，大概是以下其中两本：中东问题：《奥斯曼帝国六百年》《穿越百年中东》《中东生死门》以色列/犹太人：《我为何放弃做犹太人》《耶路撒冷异乡人》《我的一生》《我的应许之地》《以色列123》《爱与黑暗的故事》《犹太国》《犹太复国主义史》巴勒斯坦：《最后的天空之后》伊拉克：《搅动世界的伊拉克》阿拉伯：《阿拉伯的劳伦斯》战争回忆录：《南瓜花》4.游戏可能会把巫师3+dlc打通关，当然，前提是有时间。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[游戏往事]]></title>
    <url>%2F2019%2F03%2F18%2FG-%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[之前就说过这个博客不会纯记录自己的学习心得，而是会适当地聊聊自己的一些感想，其中当然也包括游戏。游戏被称为“第九艺术”，艺术自然不止是带给人娱乐感。&gt;&gt;2012年：《刺客信条II》译：当我年少轻狂时，我曾拥有自由，但我并不明白它的意义。我曾拥有时间，但我没有意识到它的珍贵。我曾拥有爱，但我从未用心去体会。数十年的时间考验后，我终于理解了三者的真谛。现在，我已风烛残年，这种理解已经逐渐变成一种满足。爱，自由和时间，曾一度被我挥霍，而今成为了我前进的动力。而我将最特别的爱，献给最亲爱的你和我们的孩子们，以及刺客联盟的兄弟姐妹们，并献给赋予我们生命的那壮美奇妙，让人产生无限遐想的世界。此爱永恒，Mia Sofia&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ——艾吉奥·奥迪托雷最早接触的游戏之一，有七年之久了。年代久远，写不下太多感慨性的文字，但是—-游戏里的场景还是记忆犹新：耶路撒冷、佛罗伦萨、罗马、君士坦丁堡……更重要的是Ezio这个人物给我留下了深刻的印象。我现在还觉得，能够在游戏中体验一个角色完整的一生是实属难得的事情。&gt;&gt;2013年：《刺客信条IV》荡气回肠的加勒比海之旅以如此平静的方式结束。爱德华在最后摘下一朵红花送给女儿，这一幕在今天看来仍然美妙而浪漫，它带给我的视觉冲击力难以言说。“如果没有黄金，我们早就是英雄了”黑胡子的这句话也许是对那个航海时代最好的概括。爱德华最后得到了黄金、跻身上流贵族之列，然而代价之深重恐怕只有他自己清楚。大概人总会有一种错觉，以为离去的人其实还活着。在安妮最后弹唱这首《The parting glass》的时候，爱德华恍惚之间仿佛看到昔日的朋友们正在与自己举杯共饮，片刻后才回过神，他们早就不在了。“晚安，愿快乐与你们相伴”Of all the money that ere I had, I’ve spent it in good company,过去我所有的积蓄，我都已和伙伴们一同分享And of all the harm that ere I’ve done, alas was done to none but me.而我做过的所有伤人之事，唉，受伤的只是我自己And all I’ve done for want of wit, to memory now I cannot recall.我为寻求智慧所做的一切，已成了不可追的回忆So fill me the parting glass, goodnight and joy be with you all.就为我添满这杯离别酒吧，晚安，愿快乐与你们常伴Of all the comrades that ere I had, they’re sorry for my going away,我所有的战友们，都不舍我即将离去And of all the sweethearts that ere I’ve had , they wish me one more day to stay,而我所有的情人们，都希望我多留一日But since it falls unto my lot that I should rise and you should not,但因为我深感起身之时已至 诸君安坐I’ll gently rise and I’ll softly call, Goodnight and joy be with you all.我会轻轻站起并柔声祝道，晚安，愿快乐与你们常伴A man may drink and not be drunk,一位男子大可畅饮但不该喝醉A man may fight and may not be slain一位男子大可战斗但不该嗜杀A man may court a pretty girl一位男子大可追求可爱的女孩and perhaps be welcome back again.而且或许还能欣然再相见But since it has so ordered been by a time to rise可是人生注定如此 有时起And a time to fall又有时落Come fill to me the Parting glass, goodnight and joy be withyou all.为我添满这杯离别酒，晚安，愿快乐与你们常伴Come fill to me the Parting glass, goodnight and joy be with you all.为我添满这杯离别酒，晚安，愿快乐与你们常伴&gt;&gt;2019年：《巫师III》玩下来的一个感觉就是：满分佳作——-我是一个对游戏很挑剔的人，即使是玩了有5年之久的游戏，我也不会对其缺点避而不谈。但巫师这款游戏意外地推翻了我之前对于RPG游戏的固有认知，让我明白了这个世界上真的有一款RPG游戏近乎完美，从任何方面来看都无可挑剔。比起传统的美式RPG游戏，在游玩过程中深有体会的一点就是：波兰人真的很会讲故事。他们为玩家呈现的不是大量中世纪传说的意象（比如烂大街的骑士和恶龙），而是真真正正底蕴丰厚的故事。或者愤慨，或者无奈，或者悲恸，玩家的情感爆发点仿佛尽在这群鬼才开发者的掌握之中，只等剧情走向的推动去点燃那小小的火苗。用一个老外很喜欢的词来形容再适合不过了—immersive，入味，而且是余韵不绝的那种。游戏里的大部分对话选项都会影响剧情的走向和人物的最终结局，这是我非常喜欢的一点。我个人觉得，开放世界游戏的所谓“开放”，绝不仅仅局限于地图的规模和场景的互动性，更体现在剧情的丰富化。丰富多样的剧情比起单一的剧情，最大的优势就在于大幅度提高了游戏的可探索性，玩家不得不去考虑：如果我做另外一个选择，结果会是怎么样？不同的选择带来不同的后果，这种极具冒险性的尝试恰好像极了我们的现实生活。人们向来喜欢拿《巫师》和《上古卷轴5：天际》进行对比，虽然在情感上我更偏向于后者（因为它对我而言不只是一款游戏），但不得不承认的是，《巫师》的战斗系统尤其值得后者借鉴：针对不同的敌人需要采用不同的打法、角色的技能提高需要玩家做出适当的取舍以找出效果最好的组合方案、魔法和药水需要紧密结合，你几乎不可能靠着单一的技能或者装备撑过整场战斗……总的来说系统设计非常流畅和舒服，而且值得玩家花时间去钻研，这在一定程度上也提高了可玩度。]]></content>
      <categories>
        <category>Gaming</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型式继承和类式继承]]></title>
    <url>%2F2019%2F03%2F17%2FF-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF%E5%92%8C%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[Java和JavaScript都是面向对象的语言，但二者的继承方式截然不同。前者采用类式继承（classical inheritence），也是大多数面向对象语言的继承方式。而后者采用原型式继承（prototype ineritence），因此称JavaScript为基于对象更加合适。1.JavaScript的继承就JavaScript的继承来说，又可以分为es5的继承和es6的继承。参考阮一峰老师在《ES6标准入门》一书中所说的：在ES6之前，class是保留字，ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。虽然在es6中引入了类的概念，但它其实只是简化了原来需要我们自己编写的原型链代码的语法糖，从而让js更趋向于传统的面向对象语言而已。要理解这个过程，首先要明白es6中的class做了什么。1.1 class到底做了什么：首先看看class是什么东西class Person{ ...... } typeof Person // function 这里的class与java中的class不同，它并不是一个全新的数据类型，而是相当于原型继承中的构造函数。接着看看es5和es6在实现继承上的区别：es5：function Person(name){ //父类 this.name = name; } Person.prototype.showName = function(){ return this.name; }; function SubPerson(name,job){ // 子类 Person.call(this,name); // 子类继承父类的属性 需要将this指向父类中的name this.job = job; // job是子类的新增属性 } SubPerson.prototype = new Person(); // 让子类继承父类的方法 var p1 = new SubPerson('zcl'); //实例化子类对象 console.log(p1.name); // zcl（父类属性） console.log(p1.showName()); // zcl（父类方法） es6：class Person{ // 父类 constructor(name){ this.name = name; } showName(){ return this.name; } } class SubPerson extends Person{ //子类 constructor(name,job){ super(name); // 用super来调用父类的构造函数 this.job = job; // job是子类的新增属性 } showJob(){ return this.job; } } var p1 = new SubPerson('zcl','前端开发'); //实例化子类对象 console.log(p1.name); // zcl（父类属性） console.log(p1.showName()); // zcl（父类方法） console.log(p1.job); // 前端开发（子类属性） 可以看到，es6中采用class后，大大简化了组合继承的步骤。class做了什么：1.定义父类时class Person{ constructor{ /*constructor*/ } method{ /*method*/ } } // 等价于 function Person{ /*constructor*/ } Person.prototype.method{ /*method*/ } 2.子类继承父类时：class SubPerson extends Person{ onstructor{ super(...) /*constructor*/ //子类新增属性 } method{ /*method*/ } //子类新增方法 } var subperson1 = new SubPerson() // 等价于 function SubPerson{ Person.call(....) /*constructor*/ //子类新增属性 } SubPerson.prototype = new Person() SubPerson.prototype.method=function{ /*method*/ //子类新增方法 } var subperson1 = new SubPerson() 对于es6继承而言，访问实例化的子类对象的属性或者方法时，依然是沿着原型链进行追溯，并且子类实例创建后，class SubPerson中的this依然会指向该子类，可以看出，这与es5的原型继承的一模一样的。1.2 关于this：es5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.call(this)）；es6的继承机制完全不同，实质是先通过调用super方法（super指向父类的构造函数）创造父类的实例对象this，然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加。2.Java的继承首先了解java中创建对象的方式。java中，类一般包含field(变量)，constructor(构造方法)，method(其他方法)。class Person{ // 创建父类 private String name; // field public String getName(){ // method return this.name; }; public Person(String name){ // constructor this.name = name; }; } 接着实现继承class SubPerson extends Person{ // 创建子类 private int age; // field public String getAge(){ // method return this.age; }; public SubPerson(String name,int age){ // constructor super(name); // 通过super调用父类构造方法 this.age = age; }; public String getName(){ //重写父类方法，发生覆盖 return "I am not "+super.getName()+" but I am "+this.name; } } 创建测试类Public class Testclass{ public static void main(String[] args){ Person person1 = new Person("father") //通过new一个构造方法创建父类实例 SubPerson subperson1 = new SubPerson("son") // 创建子类实例 System.out.println(subperson1.getName()); //->I am not father but I am son. } } 3.JavaScript的原型式继承与Java的类式继承由上面分析可见，es6中的类式继承其实还是原型式继承。那么它与java中真正的类式继承相比，有什么区别呢？类式继承的方法都会存在父对象之中，每一次实例，都会将funciton保存在内存中，这会带来性能上的问题。类式继承是不可变的。在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法；相反，原型继承是可以通过改变原型链进而对子类进行修改的。类式继承可以实现多重继承（Java是通过接口来实现）；原型式继承一般来说是不支持多继承的（因为原型链），但可以通过Mixin变相实现多继承。4.补充：子类如何调用父类被覆盖的同名方法首先这是一个比较奇怪的需求，因为既然子类重写了父类方法，就说明父类方法无法实现我们的要求，反过来，假设父类方法可以实现要求，则没必要重写该方法。但是让我们设想一下，假定现在一定要通过子类调用父类被覆盖的那个方法，应该怎么做呢？通过上面的例子可以看到，在java中，我们只能在子类的构造方法中通过super关键字调用父类方法，而无法直接用子类的实例调用那个方法，像“子类实例.super.父类方法”，这是无效的；但是在js中，我们是可以做到的。基本思路就是：将父类实例以属性的方式进行保存，且该属性是子类构造函数的原型对象的属性。这其实和原型链有关。我们设想有父类A、子类B以及同名方法say，并且设定子类B的原型对象的superClass属性指向父类实例b。那么，子类实例a直接调用say方法，必然是调用重写之后的方法；当它想要调用被覆盖的方法时，我们只需要用a.superClass.say()即可—–对于实例a，我们知道它本身并不具备superClass属性，因此它将沿着自己的原型对象也即子类B的原型对象进行查找，刚好B的原型对象有一个指向b的superClass属性，所以我们拿来用，而b有被覆盖的say方法，所以这里顺利完成了被覆盖方法的调用。附上CSDN的参考链接]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何在Stack Overflow规范提问]]></title>
    <url>%2F2019%2F03%2F17%2FT-Stack%20Overflow%E6%8F%90%E9%97%AE%E6%8C%87%E5%8D%97%E5%92%8C%E5%BF%85%E5%A4%87%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言：最近学习js的时候看到了一段代码，思考再三之后仍然不是很理解，于是决定到尽可能多的平台进行提问，目的有二：1.最主要的，解决问题；2.借这个机会测试哪些平台可以在短时间内给予提问者反馈和援助，从而作为下次提问的首选之地。最后问题是解决了，但是关于提问这件事再次有了不一样的感想。首先从我自身出发—-在中文环境下我能够做到比较规范的提问（我认为的规范），即表诉清晰必要的答谢但是在英文环境下就显得吃力得多，暴露的缺点如下：表达不够地道清晰，误导了回答者，导致问题被认为是duplicate而被关闭编辑问题后未进行必要的核查，导致了后期的修改无法完全理解对方想要表达的意思其次从平台出发进行分析，不得不说国内的平台反馈速度和热情的确比不上国外的。知乎因为有邀请机制，所以问题还是有机会得到高手的点拨；SegmentFault本身定位就是中国的Stack Overflow，所以得到专业回答的可能性也比较大。但是类似贴吧和QQ群这些交流平台，得到有效回答的机率却实在太低。本来QQ群是实时互动的，反馈更应该迅速点，但是很多时候问题会被忽略。是什么原因我就不说了，不好直接下定论，但这无疑提示了我：如果急着解决问题，就应该避免在这些地方浪费时间—-一来速度没保障，二来质量参差不齐。理想的提问平台应该是SegmentFault或者Stack Overflow。关于如何在Stack Overflow规范提问，这里转载一篇不错的博客：规范提问指南可以问什么样的主题大家都知道 Stack Overflow是编程类的问答社区， 但还真有人把它当成通用的问答社区了， 问些完全无关的问题。 其实， Stack Overflow 是有一系列兄弟网站的（目前已经有100+)， 统称 Stack Exchange， 涵盖很多主题， 比如数学、物理、化学等科学类， 服务器管理、Latex、数据库等计算机类， 中文、俄文、日文等语言类， 详细的列表看这里， 不要让好问题问错地方哦。允许的主题包括： 具体的编程问题、软件算法相关、通常只有程序员用的软件工具相关等。有些主题是比较容易弄错的， 比如一般的电脑操作问题， 应该去Super User(热门的 Linux/Unix, 和Ubuntu还有独立的站点）， 专业的服务器问题， 应该去Server Fault。这些都不属于编程类的问题， 尽管不少程序员的日常工作也有涉及（想一想“怎么修电脑？”属于编程问题么）。 再举个例子， 同样是编辑器， Vim/Emacs/Atom相关的问题是可以的，因为基本只有程序员会用这些工具， 而 Word/记事本相关的一般就不可以。什么样的问题应该避免问编程相关还不够， Stack Overflow 要求问题必须是 「practical, answerable questions based on actual problems that you face」。这是什么意思呢？ 首先， 开放式的问题是不允许的，比如“你为什么喜欢PHP?”， 隔壁Quora会是更合适的对象。 其次， 问题应该不需要很长的篇幅来回答， 如果一个问题期待的回答足够写一本书， 那很可能会被关闭的。 各种寻求资源的问题应该避免，如 “要完成某某工作， 有什么Python的库可以用”， 或者“学习C++应该选择哪本书？”等， 因为答案会主观， 也容易吸引广告。 最后， 问题不要基于凭空的假设，要基于实际的难题。需要注意的是，你很可能见过一些违反上面规定的问题还在，而且浏览量很大， 尤其是一些寻求资源的问题， 和非编程相关的计算机问题等。 这是什么原因呢？ 原来，早期的Stack Overflow的规则还比较松，也没有Super User之类的站点。 这些问题往往是08/09年问的，大多数现在已经被关闭了。上面的规则如果遵守， 你的问题应该问对地方了。 下面继续说说内容上具体需要注意的。直入主题Stack Overflow不是论坛， 它的目标是希望成为编程类问答的一个超级数据库， 所以每个问题都不止是为了帮助提问者本人， 更重要的是希望将来能够帮助到每一个遇到同样问题的人。所以， 和问题无关的内容都被认为是一种噪音， 包括： 打招呼（比如 Hi, Hello， Good afternoon， Dear Coders等)， 表示感谢（比如 Thanks, Any help would be appreciated等)， 没必要的背景（比如 I’m a newbie in C#等)， 你的签名 等。可能有人会不理解为什么这样规定， 尤其是不要表示感谢这点。 Stack Overflow社区的理由是， 对愿意阅读并尝试解答你问题的人来说， 最好的表达感谢的方式是upvote有帮助的回答， 以及选择其中一个作为答案。 每一句和问题无关的内容都增加了额外的阅读时间， 而一个问题可能会被大量的人阅读。 更多的相关讨论可以参见这里和这里。同样道理， 当有人回答你的问题之后， 也不要去添加无用的评论， 比如单纯的表达感谢的话， “+1”， 或者闲聊等。 评论的唯一用处是用来澄清疑问。英语作为一个英语社区， 不论提问、回答还是在评论中和别人互动， 都是要用英语的。除非英语水平真的很糟糕， 语法其实并不是最需要担心的，因为并不需要做到完美。Stack Overflow是允许自由的编辑其他人的问题/回答的（编辑者如果rep不到2K，需要经过评审才会生效）。 有很多人会热情的对问题进行编辑的， 包括修复可能的语法错误。 我想说的一点是， 要尽可能的保证单词拼写是正确的。 即使对英语不够好的人来说， 这也只需要多花一点时间检查就可以做到， 但它代表着对阅读你问题的人的尊重。 甚至很多英语母语的人在拼写上也不注意， 会把I’m 写成im, 把 want to写成 wanna之类的非正式英语， 这些都会降低问题被回答的概率。内容在发问题之前， 问自己几个问题：你做过足够的研究么？ 有的人连入门指南都没读上10分钟就去提问， 问的问题能有多少价值呢？你尝试过搜索么？ 至少要试过Google和站内搜索， 很可能相同的问题已经有答案了你试过debug么？ 把你的想法或调试过程写在问题里，否则很可能会看到几条评论“Have you tried anything?”或“We don’t do your homework”之后问题就被downvote得惨不忍睹了。 因为大多数人是拒绝回答没有努力尝试的提问者的。标签： 一个问题可以加1~5个标签， 大多数问题是和某种具体的编程语言相关的， 这个语言的标签通常是必须的， 否则相关语言的关注者们很可能根本见不到问题。起一个好标题： 一般来说， 标题应该尽量用简介的语言描述具体的问题。 比如 C# number confusion就是个反例， 如果改成 Why does using float instead of int give me different results when all of my inputs are integers? 就要具体多了。提供代码对于编程类问题，的确有问题不需要代码也能表达清楚的， 但大多数问题都需要代码才能清晰的表达。“我声明了一个变量， 调用了几个函数， 然后它的值就变了， 为什么呢？” 这样的问题， 鬼才知道答案。提供代码要注意： 不要贴截图， 难道你要回答者去照着截图敲键盘复现你的问题？ 也不要只贴站外的链接， 如果站外链接能够提供一些额外的方便功能， 也要在贴代码的基础上附上该链接。对于提供什么样的代码， Stack Overflow给出了一个可参考的标准： MCVE， 即Minimal, Complete, and Verifiable exampleMinimal: 最小的， 也就是尽可能的去掉和问题无关的部分。 如果你贴了一个几百行的代码， 很少有人愿意花时间去仔细看。 构造最小化例子的过程本身也是debug的过程。Complete: 完整的， 一个简单的判断是：别人看到问题， 可以通过复制你提供的代码复现出问题吗？Verifiable: 可验证， 描述问题尽可能具体， “the code doesn’t work”这样的描述就很不好。 如果编译不过， 要加上编译错误信息； 如果运行报错， 也同样要加上具体的错误信息； 如果结果和你的预期不一致， 要说清楚你的预期结果是什么， 为什么会这样想。格式Stack Overflow的编辑器是Markdown格式的， 如果你还不熟悉， 建议去学一下， 因为Markdown真的是一个只要10分钟就可以学会的语言。大多数的格式问题都是出在贴代码的地方， 如果你发现你的代码是普通文本， 而没有语法高亮等功能， 那你很可能是格式搞错了。 最方便的方法就是选择所有代码， 然后按键盘Ctrl + K 即可。交流有可能你的问题几分钟内就会有人回答， 也有可能有人对问题有疑问， 在评论中要求你解释。 可以评论@他们解释， 如果问题确实不够清晰， 编辑你的问题吧。 最后， 如果你自己发现了解答方法， 而还没人给出， 那就自己回答自己的问题吧。 自问自答是被鼓励的行为。术语词汇另外，我认为规范提问建立在规范词汇的基础上，诚如上面所说的，这是一种对回答者应有的尊重。如何积累规范的词汇？我的计划是每周阅读1到2篇MDN上的文档，首先阅读英文并做出自己的理解，之后借助本地化团队的译文加深/修正自己的理解，这个过程既锻炼了阅读技术文档的能力，也可以顺带积累术语词汇，值得尝试。2019.5.3 更：近期找到了一个更好的平台（掘金翻译计划），它拥有完善的流程把控和工作分配，这其实正是我很久以前试图在汉化工作中寻找但是没有找到的东西。其实这是一件值得长期投资的事情：1.最主要的目的，锻炼阅读英文技术文档的能力，同时积累术语词汇；2.熟悉 github 的操作3.据说 200 积分可以换一台kindle（虽然听起来遥遥无期，但是可以作为动力哈哈哈）当然，这个工作不会很轻松，不过完事开头难是很正常的，希望我可以坚持下去吧。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[经典面试题解析]]></title>
    <url>%2F2019%2F03%2F17%2FF-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本篇博客专门用于收集各类经典面试题，并给出相关的解题思路和原理。1.考点：块级作用域和闭包先看一道很经典的面试题var a=[]; for(var i=0;i&lt;10;i++){ a[i] = function(){ console.log(i); } } console.log(a[6]); 如果你认为输出的是6，那么恭喜你答错了。正确答案是10。首先分析一下这段代码的具体执行过程。var a=[]; var i=0; /* 用var声明的变量要么在函数作用域中，要么在全局作用域中，很明显这里是在全局作用域中， 因此认为i是全局变量，直接放在全局变量中。*/ a[0]=function(){ console.log(i); /* 关键！！这里之所以i为i而不是0；是因为我们只是定义了该函数，并未调用它，所以没有进入 该函数执行环境，i当然不会沿着作用域链向上搜索找到自由变量i的值。*/ } // 由于不具备块级作用域，所以该函数暴露在全局作用域中。 var i=1; //第二次循环，这时var i=1;覆盖了前面的var i=0；即现在全局变量i为1; a[1]=function(){ console.log(i); //解释同a[0]函数。 } var i=2; // 第三次循环，这时var i=2;覆盖了前面的var i=1；即现在全局变量i为2; a[2]=function(){ console.log(i); } ......第四次循环 此时i=3 这个以及下面的i不断的覆盖前面的i，因为都在全局作用域中 ......第五次循环 此时i=4 ......第六次循环 此时i=5 ......第七次循环 此时i=6 ......第八次循环 此时i=7 ......第九次循环 此时i=8 var i=9; a[9]=function(){ console.log(i); } var i=10;// 这时i为10，因为不满足循环条件，所以停止循环。 紧接着在全局环境中继续向下执行。 a[6](); /* 这时调用a[6]函数，所以随即进入a[6]函数的执行上下文环境中，即 function(){console.log(i)}中，此时执行函数中的代码console.log(i)， 因为在当前的函数执行上下文中不存在变量i，所以i为自由变量，此时会 沿着作用域链向上寻找，进而进入了全局作用域中寻找变量i,而全局作用域 中的i在循环跑完后已经变成了10，所以a[6]的值就是10了。*/ 那么，如果我们想要输出6，应该怎么修改代码呢？两种方法。1.使用let形成块级作用域，配合闭包使用var a=[]; { //进入第一次循环 let i=0; /*注意：因为使用let使得for循环为块级作用域，此次let i=0 在这个块级作用域中，而不是在全局作用域中。*/ a[0]=function(){ console.log(i); }; /* 注意：由于是用let声明的i,所以使整个块成为块级作用域，又由于a[0]这个函数 引用到了上一级作用域中的自由变量，所以a[0]就成了一个闭包。*/ } /*声明:这里用｛｝表达并不符合语法，只是希望通过它来说明let存在时，这个for循环块 是块级作用域，而不是全局作用域。*/ 讲道理，上面这是一个块级作用域，就像函数作用域一样，执行完毕，其中的变量会被销毁， 但是因为这个块级作用域中存在一个闭包，且该闭包维持着对自由变量i的引用，所以在闭包 被调用之前也就是后续为了测试而console.log出a[..]之前，此次循环的自由变量i即0不会 被销毁. { //进入第二次循环 let i=1; /*注意：进入第二次循环即进入第二个代码块，此时处于激活状态的是let i=1。 它位于与let i=0不同的块级作用域中，所以两者不会相互影响。*/ a[1]=function(){ console.log(i); }; //同样，这个a[i]也是一个闭包 } ......进入第三次循环，此时其中let i=2; ......进入第四次循环，此时其中let i=3; ......进入第五次循环，此时其中let i=4; ......进入第六次循环，此时其中let i=5; ......进入第七次循环，此时其中let i=6; ......进入第八次循环，此时其中let i=7; ......进入第九次循环，此时其中let i=8; {//进入第十次循环 let i=9; a[i]=function(){ console.log(i); };//同样，这个a[i]也是一个闭包 } { let i=10; /*不符合条件，不再向下执行，导致此次的块级作用域中不存在闭包，导致let i=10 未像前面的i一样等待被闭包引用，故此次的i没有必要继续存在，随即被销毁。*/ } a[6](); /*调用a[6]()函数，这时执行环境随即进入下面这个代码块中的执行环境： funcion(){console.log(i)};*/ 即进入： { let i=6; a[6]=function(){ console.log(i); }; //同样，这个a[i]也是一个闭包 } a[6]函数（闭包）这个执行环境中，它会首先寻找该执行环境中是否存在 i，没有找到， 就沿着作用域链继续向上到了函数所在的块级作用域，找到了自由变量i=6,于是输出了6， 即a[6]()的结果为6。闭包既已被调用，所以整个代码块中的变量i和函数a[6]()被销毁。 2.利用自执行函数说来惭愧，本来如果明白这道题的原理，应该自然想到可以利用自执行函数达到相同的目的，但是最后还是在群里朋友的点拨下才明白的。实际很简单，前面我们说过一句很关键的话：这里之所以 i 为 i 而不是 0；是因为我们只是定义了该函数，并未调用它，所以没有进入该函数执行环境，i 当然不会沿着作用域链向上搜索找到自由变量 i 的值那么反过来想一想，假如我们在定义了函数之后即刻对其进行了调用，是否此时将会在环境中寻找 i 的值并马上替换掉 console.log(i) 中的 i 呢？是的。要立刻调用函数，用自执行函数就可以，代码如下：var a=[]; for(var i=0;i&lt;10;i++){ a[i] = (function(){ console.log(i); })() } 需要注意的是，这里每一次的循环实际上是对当前函数进行一次立即调用，所以在循环的同时对应的值就已经打印出来了，并且这些函数的返回值依次赋值给数组元素。在没有显式指定函数返回值时，默认返回 undefined，因此后续再访问数组元素时只能得到 undefined。2.考点：连等、解析和引用类型这是某大厂一道知名的面试题，表面简单但是坑很多。var a = {n:1}; var b = a; a.x = a ={n:2}; console.log(a.x); // undefined console.log(b.x); // {n:2} 我们来分析一下这段代码到底是怎么执行的，就会明白为什么结果与我们预想的完全不同，甚至可以说很怪异。var a = {n:1}; var b = a; 首先，这两句令a和b同时引用了{n:2}对象，接着的a.x = a = {n：2}是关键。尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a重定向，指向了新对象{n：2},而b依然指向的是旧对象，这点是不变的。接着的关键来了：执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。后面输出a.x的时候，又要解析a了，此时的a当然是重定向后的指向新对象的a，而这个新对象是没有x属性的，故得到undefined；而输出b.x的时候，将输出旧对象的x属性的值，即{n:2}。3.考点：异步、作用域、闭包如果无法深入到内部，从原理层面上理解代码的运行机制，那么知识只是浮在表面、浅尝辄止。“同步优先，异步靠边，回调垫底”的口诀可以帮助我们迅速判断，但是我希望用自己刚学习的事件循环机制来解释这道题。实际上这也是比较普遍的一道面试题：for (var i = 0; i &lt; 3; i++) { setTimeout(function() { console.log(i); }, 0); console.log(i); } 代码最后输出什么？ 如果不熟悉异步，很可能直截了当地回答是：0 0 1 1 2 2 。正确答案应该是 0 1 2 3 3 3根据事件循环的机制，跑循环和输出i的值都是主线程上的同步任务，既然是同步任务，当然是按照顺序执行，所以0 1 2是容易理解的。那么setTimeout怎么办呢？setTimeout是异步任务，并不在主线程上，而是在宏任务队列里，它必须等待主线程的执行栈清空，才有自己的“一席之地”，才能去执行，所以这里我们直接忽略setTimeout，将前三次循环的setTimeout都挂在任务队列里。之后，循环跑完了，主线程的同步任务结束。此时i变成了3。轮到任务队列了——&gt; 我们回过头调用setTimeout里的回调函数，进行i的输出。当然，由于i只有一个，即全局变量，所以此时输出的都是3，三次setTimeout即三次3。如果我们要输出 0 1 2 0 1 2 呢？其实这里就和第一个考点很像了。这里有三种方法，1.将var改为let改为 let 后会形成多个独立的块级作用域，这样，每个setTimeout里的回调函数的i都将对应每一次循环的i（因为是块级作用域）。接着，由于输出和循环依然是同步任务，所以输出 0 1 2；之后轮到任务队列，也是输出0 1 2。2.利用自执行函数让函数在定义之后就即刻执行，那么函数中的 i 就会指向当前循环的 i，这个 i 的值为多少在那时就已经确定了，而不再是随着跑循环而动态变化。这里又有两种自执行的方法：for (var i = 0; i &lt; 3; i++) { setTimeout((function(i) { return function() { console.log(i); }; })(i), 0); console.log(i); } 或者for (var i = 0; i &lt; 3; i++){ (function (i) { setTimeout(function () { console.log(i); }, 0) })(i); console.log(i); } 一个是将回调函数作为自执行函数，一个是将setTimeout函数作为自执行函数，效果是一样的。3.利用bind()for (var i = 0; i &lt; 3; i++) { setTimeout(function(i) { console.log(i); }.bind(null,i), 0); console.log(i); } bind() 的第一个参数是 thisArg，用来绑定 this，这里我们不管，直接传参 null，重点在于第二个参数，这个参数也就是回调函数的参数。这里要理解循环做了什么：每一次循环，实际上执行的是 setTimeout() 方法，执行完之后把每次的回调函数挂载在队列里，后续等主任务清空之后，再一一执行。这里添加了 bind() 方法后，每次循环除了挂载回调函数，其实还完成了硬绑定，这时候对应的 i 值已经存在于回调函数的词法作用域里了。所以，后面执行回调函数的时候，每个函数都能在词法作用域中找到自己对应的 i 值。4.考点：作用域、NFE的函数名只读性let b = 10; (function b(){ b=20; console.log(b); })(); console.log(b); // 代码最后输出什么？ 如果没有认识到NFE函数的函数名只读性，这道题就会做错。正确答案应该是：f { b=20; console.log(b); } 10 要理解这道题，先来看另一段代码var c=function b(){ console.log("234"); console.log(b); } console.log(b) // b is no defined 首先，这是一个具名函数表达式，即NFE。而NFE的函数名只能在函数内部访问，所以我们将该函数的引用赋给变量c之后，就只能通过c()调用该函数，而不能通过b()调用，更不能访问b。并且还要注意，函数名在函数内部类似于一个const常量，只能访问而不能对它进行修改。理解这一点之后再来看最开始的代码，这是一段IIFE—–立即执行函数表达式（因为括号是操作符，所以认为括号里的是表达式而不是声明），它同样也是具名函数表达式，自然也有上面的性质。函数自调用，遇到b=20语句时开始在函数作用域中查找b是在哪里声明的，结果发现就是函数b，然后试图对函数名进行修改，因为这种修改相当于是修改一个常量，所以是无效的（非严格模式下静默失败，严格模式下抛出Type错误）。忽略了这段语句后，等于是只输出b，也就是输出函数本身。之后，我们在全局下输出b，根据上面的说法，我们无法在NFE函数外部访问NFE的函数名，所以这里的b代表的不是函数，而是用let声明的那个变量b。let b = 10; (function b(){ var b=20; console.log(b); })(); // 20 当然，如果在函数内部用var或者let重新声明一个同名变量b并赋值，则是允许的，此时的b变量与函数b没有任何关系，仅仅是同名而已。PS：NFE 函数名为什么是只读的？规范有说吗？还真有，看下面：The productionFunctionExpression : function Identifier ( FormalParameterListopt ) { FunctionBody }is evaluated as follows:1.Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument2.Let envRec be funcEnv’s environment record.3.Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.4.Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.5.Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.6.Return closure.NOTE The Identifier in a FunctionExpression can be referenced from inside the FunctionExpression’s FunctionBody to allow the function to call itself recursively. However, unlike in a FunctionDeclaration, the Identifier in a FunctionExpression cannot be referenced from and does not affect the scope enclosing the FunctionExpression.重点就在第三和第五的 ImmutableBinding，注意这是一个不可变的绑定。关于这道题的详细解释，移步：https://segmentfault.com/q/10100000028100935. this 绑定某不知来源的面试题一道："use strict"; const a=[1,2,30]; const b=[4,5,60]; const c=[7,8,90]; a.forEach((function (){ console.log(this); }).bind(globalThis),b); // 输出什么？ 正确答案是：window window window 这道题的难点在于，forEach() 的 thisArg 指定了回调的 this，而回调本身也有一个 bind() 方法指定 this，那么应该以哪个为准呢？在这篇文章中曾经讨论过 this 绑定的问题，但是 forEach() 的 this 绑定好像并不符合文章里面的情况。不妨看一下 forEach() 的 polyfill 代码：A polyfill is a piece of code (usually JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it.也就是说，forEach() 绑定 this 实际上也是通过 call() 实现的。接下来再来看一下 bind() 的 polyfill 代码：bind() 实际上也是通过 apply() 实现的 —— 原理就是返回一个包装函数，这个函数在内部对初始函数完成了 this binding。之后不管怎么调用这个包装函数，this 都是使用 bind() 的thisArg。也就是说，即使是：func.bind(obj1).bind(obj2); func 中的 this 最后也是指向 obj1 而不是 obj2，原因在于 func.bind(obj1) 是一个返回的包装函数，内部的 this 是没有暴露出来的，看上去就像是一个没有 this 的函数，因此后面的 bind(obj2) 对其不生效。这也是为什么说 bind() 是 tight binding 的原因，一旦绑定就很难再改变。理解这一点之后，再来看上面的题就简单了。题目的代码我们可以简化为：const f0 = function () { console.log(this) } const f1 = f0.bind(globalThis) a.forEach(f1, b) f0 是初始函数，f1 是包装函数。那么在 forEach 进行迭代的时候，虽然指定了 this 是参数 b，但是由于此时的 f1 是一个内部完成了 this binding 的包装函数，因此其实已经没有 this 什么事了，自然 forEach 的 thisArg 也不生效。既然是 bind() 生效，那么结果自然是输出全局对象了。Tip: 下次思考问题的时候，polyfill 可以作为一个着手方向。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「译」如何用原生JS打造一款简易谷歌插件]]></title>
    <url>%2F2019%2F03%2F10%2FTrs-%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[原文地址：How to Build a Simple Chrome Extension in Vanilla JavaScript原文作者：Sara Wegman译者：Chor今天，我打算向你们展示如何用原生JS—-不依靠任何诸如React、Angular或者Vue框架的原生JS做一款谷歌插件。做一款谷歌插件并没有那么困难——在学习编程的第一年，我发布了两个插件，并且都是用HTML、CSS和原生JS做的。在这篇文章中，我会用几分钟的时间教你们怎么完成这件事。我将向你们展示如何从零开始打造一款简易的谷歌插件主控面板。如果你对插件有自己的想法、只是想知道应该向已有项目文件中添加什么，从而让其运行在谷歌浏览器中的话，你可以跳到自定义mainfest.json文件和图标的部分。关于谷歌插件从本质上来说，一款谷歌插件只是一些用来定制浏览体验的文件。有许多不同类型的插件，有些插件仅在某种特定条件下才会激活，比如当你在商店的结账页面的时候；有些插件仅在你点击图标后才会弹出；有些则在你每次打开新标签页的时候才会出现。我今年发布的两款插件都是“新标签页式”插件，第一款是Compliment Dash,一个可以显示to-do list并问候用户的主控面板；第二款是Liturgical.li,为牧师量身打造的工具。如果你知道如何建设一个基本的网站，那么你就可以很轻松地做出这种插件。前期准备我们打算一切从简，所以本教程只会使用HTML、CSS和基本的JS，以及下面会讲到的自定义mainfest.json文件。谷歌插件的复杂度各不相同，因此做一款插件可能很简单，也可能很难，这取决于你打算让它实现什么功能。在学习了本篇文章的基础知识后，你将可以活用技能做出更为复杂的东西。新建文件本教材中，我们将制作一款可以问候用户的简易主控面板，名字就叫Simple Greeting Dashboard好了。首先需要创建三个文件：index.html,main.css和main.js。将这些文件放在各自的文件夹中。接下来，在html文件中书写必要的声明，并引入css文件和js文件：&lt;!-- ================================= Simple Greeting Dashboard ================================= //--> &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8" /> &lt;title>Simple Greeting Dashboard&lt;/title> &lt;link rel="stylesheet" type="text/css" media="screen" href="main.css" /> &lt;/head> &lt;body> &lt;!-- My code will go here --> &lt;script src="main.js">&lt;/script> &lt;/body> &lt;/html> 定制你的mainfest.json文件仅有这些文件还不能够让你的插件项目正常运行。我们还需要一个mainfest.json文件以定制插件的基本信息。可以在Google’s developer portal下载该文件，或者复制粘贴如下代码到一个新文件中，另存为manifest.json文件。{ "name": "Getting Started Example", "version": "1.0", "description": "Build an Extension!", "manifest_version": 2 } 现在，我们修改上面文件中关于插件信息的内容。只需改变代码中的前三个值：name,version和description。填入插件名称以及相关描述，由于这是第一个版本，所以version项就不需要改了。manifest_version也不需要改动。接着，添加代码行以告诉谷歌浏览器如何操作这个插件。{ "name": "Simple Greeting Dashboard", "version": "1.0", "description": "This Chrome extension greets the user each time they open a new tab", "manifest_version": 2 "incognito": "split", "chrome_url_overrides": { "newtab": "index.html" }, "permissions": [ "activeTab" ], "icons": { "128": "icon.png" } } 代码incognito&quot;: &quot;split告诉谷歌浏览器当它处于匿名模式的时候应该如何操作该插件。“split”将允许插件运行在自己的进程中。其他选项请查阅developer documentation正如你所看到的，”chrome_url_overrides”指定浏览器打开新标签页的时候打开index.html。将值设定为“permissions”后，将弹出窗口，提示用户安装该插件将会覆盖新标签页。最后，设定我们的图标：一个名为icon的png文件，尺寸为128x128像素。创建图标现在我们还没有Simple Greeting Dash的图标文件，所以来创建一个。你可以用下面我做的图标。如果你想自己做一个的话，用PS或者Canva都可以。切记图标尺寸为128x128像素，然后另存为名称icon的png文件，与HTML文件、CSS文件、JS文件和Json文件放在同一个文件夹里。上传你的文件（如果你正在编写自己的页面）要创建你的“新标签页式”谷歌插件，只需明悉以上全部信息即可。在你定制了mainfest.json文件后，你可以用HTML、CSS和JS设计任何自己想要的新标签页，之后按照下图所示将其上传。不过，如果你想知道我怎么创建这个简易面板的话，请跳至“创建一个设置菜单”部分。一旦你设计好了新标签页，你的谷歌插件就创建完成了，随时可以上传至谷歌浏览器。手动上传，请在浏览器的地址栏输入chrome://extensions/，进入页面后在右上角启用开发者模式。刷新页面，点击“加载已解压的拓展程序”。接着，选择存放HTML、CSS、JS、mainfest.json文件和icon.png的文件夹，上传。之后每次打开新标签页的时候该插件都会运行！在创建了自己的插件并且通过测试之后，你便可以申请一个开发者账号并将该应用发布到谷歌拓展程序商店。这篇教程将指导你如何发布你的插件。如果你现在不急着创建插件，只是想看看谷歌插件能够做什么的话，下面将教你如何创建一个非常简易的问候面板。创建一个设置菜单就这个插件来说，我首先要做的第一件事就是创建一个可供用户添加自己名字的输入框。因为我不打算让它一直显示，所以我将其放在一个名为settings的div下，该div只在用户点击settings按钮的时候才会显示。&lt;button id="settings-button">Settings&lt;/button> &lt;div class="settings" id="settings"> &lt;form class="name-form" id="name-form" action="#"> &lt;input class="name-input" type="text" id="name-input" placeholder="Type your name here..."> &lt;button type="submit" class="name-button">Add&lt;/button> &lt;/form> &lt;/div> 我们的页面设置看起来大概是这样的：…因此很有必要通过CSS给它们添加一些样式。我将给settings按钮和输入框添加内边距和轮廓，之后让settings按钮和输入框之间留有一点空隙。.settings { display: flex; flex-direction: row; align-content: center; } input { padding: 5px; font-size: 12px; width: 150px; height: 20px; } button { height: 30px; width: 70px; background: none; /* This removes the default background */ color: #313131; border: 1px solid #313131; border-radius: 50px; /* This gives our button rounded edges */ font-size: 12px; cursor: pointer; } form { padding-top: 20px; } 现在看起来好多了：不过，我们必须设置一下：用户未点击settings按钮的时候输入框不显示。我将通过给settings类添加下面的代码来完成这个设置，之后输入框将从屏幕上消失：transform: translateX(-100%); transition: transform 1s; 现在创建一个名为settings-open的类，在用户点击settings按钮的时候该类名将动态添加或去除。当添加settings-open类给已经有settings类的div时，div将不会隐藏，而是在正常位置显示。.settings-open.settings { transform: none; } 接着用JS实现类名的改变。定义一个名为openSettings的函数，它的功能是实现settings-open类名的添加或去除。具体做法是通过div的ID获取到该div元素，之后调用clssLIst.toggle方法添加settings-open类名。function openSettings() { document.getElementById("settings").classList.toggle("settings-open"); } 现在添加一个事件监听器，它将会在settings按钮被点击的时候调用函数document.getElementById("settings-button").addEventListener('click', openSettings) 在你点击settings按钮后，输入框将显示或隐藏。创建一个个性化的问候语接下来，我们来创建问候信息。首先在HTML中放入一个空的h2标签，之后用JS中的innerHTML方法来给它增加内容。为方便稍后获取h2元素，我们将给它一个ID，并将其放入一个名为greeting-container的div中。&lt;div class="greeting-container"> &lt;h2 class="greeting" id="greeting">&lt;/h2> &lt;/div> 现在，我将在JS中结合用户名创建一个基本的问候信息。首先声明一个空的变量用以稍后存放用户名。var userName; 如果就这样把useName变量放在HTML的问候语句中，即使为userName变量赋了值，谷歌浏览器也是不会使用相同的名字的。为了确保浏览器记住用户，我们必须进行本地存储的工作。因此，定义一个名为saveName的函数。function saveName() { localStorage.setItem('receivedName', userName); } 函数localStorage.setItem()接受两个参数：第一个是用于稍后获取信息的关键词，第二个是它需要记住的信息，也即是useName。我将通过localStorage.setItem获取储存的信息，并用该信息来更新useName变量的值。var userName = localStorage.getItem('receivedName'); 在将这条语句添加进表单的事件监听器之前，我想要让浏览器默认指定一个用户名，以应对我没有告诉它名字的情况。我将用if语句来完成这件事。if (userName == null) { userName = "friend"; } 现在，将userName变量与表单连接起来。我们将该操作写进函数里，这样每次名字更新的时候都可以调用该函数。我们给这个函数取名changeName。function changeName() { userName = document.getElementById("name-input").value; saveName(); } 我想要让该函数在用户每次用表单提交名字的时候都被调用。这里用事件监听器，它可以调用changeName函数并防止在表单提交的时候页面默认刷新。document.getElementById("name-form").addEventListener('submit', function(e) { e.preventDefault() changeName(); }); 最后，我们来创建问候语。我将把该语句也放进一个函数中，这样，在页面刷新或者changeName()调用后，我都可以调用该函数。function getGreeting() { document.getElementById("greeting").innerHTML = `Hello, ${userName}. Enjoy your day!`; } getGreeting() 最后，自定义你的页面现在是时候收尾了。我将用flexbox使标题居中，让它变得更大。同时在CSS中给body添加一个渐变背景。为了在渐变背景中突出按钮和h2，我会把它们设置成白色的。.greeting-container { display: flex; justify-content: center; align-content: center; } .greeting { font-family: sans-serif; font-size: 60px; color: #fff; } body { background-color: #c670ca; background-image: linear-gradient(45deg, #c670ca 0%, #25a5c8 52%, #20e275 90%); } html { height: 100%; } 就这样！你的页面大概会是下面这样子：虽然内容不多，但这是你创建和定义自己的谷歌插件的基础。如果有任何疑问，请告诉我，并随时在推特上@saralaughed 联系我。纯练手的第一篇译文。如果发现译文存在错误或其他需要改进的地方，欢迎在下面评论指出。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础系列：伪类和伪元素]]></title>
    <url>%2F2019%2F03%2F10%2FF-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[1.伪类和伪元素的引入CSS introduces the concepts of pseudo-elements and pseudo-classes to permit formatting based on information that lies outside the document tree.CSS 引入伪类和伪元素的概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。2.伪类和伪元素的概念2.1 伪类：伪类用于当已有元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。例如，当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态。虽然它和普通的 CSS 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。2.2 伪元素伪元素用于创建一些不在文档树中的元素，并为其添加样式。例如，我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。3.伪类列举3.1 状态伪类状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式就会失去。状态伪类的顺序很重要，顺序错误可能会导致没有效果。通常的建议是LVFHA，即—–link，visited，focus，hover，active。选择器示例示例说明:linka:link选择所有未访问的链接:visiteda:visited选择所有访问过的链接:hovera:hover选择鼠标悬空的链接:activea:active选择正在活动的链接:focusinput:focus选择获得焦点的输入框3.2 结构化伪类结构化伪类是 CSS3 新增选择器，利用 DOM 树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少 class 和 id 属性的定义，使文档结构更简洁。选择器示例示例说明:first-childp:first-child选择符合的p元素，该p元素必须是其父元素的第一个子元素:first-of-typep:first-of-type选择符合的p元素，该p元素必须是其父元素的第一个p子元素:last-childp:last-child选择符合的p元素，该p元素必须是其父元素的最后一个子元素:last-of-typep:last-of-type选择符合的p元素，该p元素必须是其父元素的最后一个p子元素:not(selector):not(p)选择所有p以外的元素:nth-child(n)p:nth-child(2)选择符合的p元素，该p元素必须是其父元素的第2个子元素:nth-last-child(n)p:nth-last-child(2)选择符合的p元素，该p元素必须是其父元素的倒数第2个子元素:nth-last-of-type(n)p:nth-last-of-type(2)选择符合的p元素，该p元素必须是其父元素的倒数第2个p子元素:nth-of-type(n)p:nth-of-type(2)选择符合的p元素，该p元素必须是其父元素的第2个p子元素:only-of-typep:only-of-type选择符合的p元素，该p元素的父元素可以有多个子元素，但是类型为p的子元素只有一个:only-childp:only-child选择符合的p元素，该p元素的父元素只有一个子元素，就是该p元素:target#news:target选择当前活动#news元素(点击URL包含锚的名字)3.3 表单相关选择器示例示例说明:disabledinput:disabled选择所有禁用的表单元素:enabledinput:enabled选择没有设置disabled属性的表单元素:in-rangeinput:in-range选择在指定区域内的表单元素:out-of-rangeinput:out-of-range选择不在指定区域内的表单元素:validinput:valid选择条件验证正确的表单元素:invalidinput:invalid选择条件验证错误的表单元素:requiredinput:required选择设置required属性的表单元素:optionalinput:optional选择没有required属性，即设置 optional属性的表单元素:read-onlyinput:read-only选择设置只读属性的表单元素:read-writeinput:read-write选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态:checkedinput:checked匹配勾选的input元素，input元素包括 radio 和 checkbox:emptyp:empty匹配所有没有子元素的 p 元素:default匹配默认选中的元素(提交按钮总是表单的默认按钮):indeterminate当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。:scope匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。(试验阶段)3.4 语言相关选择器示例示例说明:lang(language)匹配设置了特定语言的元素设置特定语言可以是：HTML元素设置lang=” “属性，meta元素设置charset=” “属性，或者是在 http头部上设置语言属性。实际上，lang=” “ 属性不只可以在 html 标签上设置，也可以在其他的元素上设置。:dir匹配指定阅读方向的元素。当 HTML 元素中设置了 dir 属性时该伪类才能生效。现时支持的阅读方向有两种：ltr（从左往右）和 rtl（从右往左）。目前，只有火狐浏览器支持 :dir 伪类，并在火狐浏览器中使用时需要添加前缀( -moz-dir() )(试验阶段)。3.5 其他选择器示例示例说明:root匹配文档的根元素一般的 html 文件的根元素是 html 元素。:fullscreen匹配处于全屏模式下的元素全屏模式不是通过按 F11 来打开的全屏模式，而是通过 Javascript 的 Fullscreen API 来打开的，不同的浏览器有不同的 Fullscreen API。目前，:fullscreen 需要添加前缀才能使用。！！注意，伪类的名称不区分大小写。4 伪元素列举4.1 单双冒号选择器示例示例说明::before/:before在被选元素前插入内容需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。::after/:after在被选元素后插入内容用法同上::first-letter/:first-letter匹配元素中文本的首字母被修饰的字母不在首字母中::first-line/:first-line匹配元素中第一行的文本这个伪元素只能用在块元素中，不能用在内联元素中4.1 仅双冒号选择器示例示例说明::selection匹配被用户选中或者处于高亮状态的部分在FF浏览器使用时需要添加 -moz 前缀::placeholder匹配占位符的文本只有元素设置placeholder 属性时，该伪元素才能生效。该伪元素不是 CSS 的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（IE10 和 Firefox18 及其以下版本）会使用单冒号的形式::backdrop用于改变全屏模式下的背景颜色全屏模式的默认颜色为黑色。(试验阶段)5. :first-child和:first-of-type的区别:first-child选择器是css2中定义的选择器，从字面意思上来看也很好理解，就是第一个子元素。比如有段代码：p:first-child: 匹配到的是p元素,因为p元素是div的第一个子元素；h1:first-child: 匹配不到任何元素，因为在这里h1是div的第二个子元素，而不是第一个；span:first-child: 匹配不到任何元素，因为在这里两个span元素都不是div的第一个子元素；:first-child: 匹配到的是p元素,因为在这里div的第一个子元素就是p。然后，在css3中又定义了:first-of-type这个选择器，这个跟:first-child有什么区别呢？还是看那段代码：p:first-of-type: 匹配到的是p元素,因为p是div的所有为p的子元素中的第一个，事实上这里也只有一个为p的子元素；h1:first-of-type: 匹配到的是h1元素，因为h1是div的所有为h1的子元素中的第一个，事实上这里也只有一个为h1的子元素；span:first-of-type: 匹配到的是第三个子元素span。这里div有两个为span的子元素，匹配到的是第一个。:first-of-type: 匹配到的是p元素所以，通过以上两个例子可以得出结论：:first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。:first-of-type 匹配的是该类型的第一个，类型是指什么呢，就是冒号前面匹配到的东西，比如 p:first-of-type，就是指所有p元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了，当然这些元素的范围都是属于同一级的，也就是同辈的。同样类型的选择器 :last-child 和 :last-of-type、:nth-child(n) 和 :nth-of-type(n) 也可以这样去理解。]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[获取DOM节点的方法汇总]]></title>
    <url>%2F2019%2F03%2F08%2FF-%E8%8E%B7%E5%8F%96DOM%E8%8A%82%E7%82%B9%E7%9A%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1.原生获取DOM节点的方法1.1 通过顶层document节点获取：document.getElementById(&quot;ID&quot;)document.getElementsByName(&quot;Name&quot;)document.getElementsByClassName(&quot;className&quot;)document.getElementsByTagName(&quot;tagName&quot;) 注意，前两个都是document节点的专有方法，其他节点不能使用，尤其不能在ID下获取ID，这是非常愚蠢的做法。1.2 通过父节点获取：parentObj.firstChild：获取父节点下的第一个子节点（会将空格和换行计入），这个属性是可以递归使用的，即支持parentObj.firstChild.firstChild...的形式，如此就可以获得更深层次的节点。parentObj.firstElementChild：获取父节点下的第一个子元素节点parentObj.lastChild：获取父节点下的最后一个子节点（会将空格和换行计入）。与firstChild一样，它也可以递归使用。parentObj.lastElementChild：获取父节点下的最后一个子元素节点parentObj.childNodes：获取父节点下的所有直接子节点（会将空格和换行计入）parentObj.children：获取父节点下的直接子元素节点。parentObj.getElementsByTagName(&quot;tagName&quot;)parentObj.getElementsByClassName(&quot;className&quot;)1.3 通过子节点获取：childObj.parentNode : 获取子节点的直接父节点。w3c标准childObj.parentElement : 获取子节点的直接父节点。IE标准1.4 通过兄弟节点获取：neighbourObj.parentNode.children[..] :通过父节点间接获取已知节点的兄弟节点neighbourObj.previousSibling：获取已知节点的上一个兄弟节点（会将空格和换行计入）neighbourObj.previousElementSibling: 获取已知节点的上一个兄弟元素节点neighbourObj.nextSibling：获取已知节点的下一个兄弟节点（会将空格和换行计入）neighbourObj.nextElementSibling: 获取已知节点的下一个兄弟元素节点1.5 通过CSS选择器获取：采用CSS选择器的语法，即#abc，div.abc,#abc .abc等。document.querySelector(&quot;...&quot;): 返回匹配的第一个节点document.querySelectorAll(&quot;...&quot;): 返回匹配的所有节点2.jQuery 获取 DOM 节点的方法方法用途祖先$(&quot;#A&quot;).parent()获取A节点的直接父节点$(&quot;#A&quot;).parents()获取A节点的所有祖先节点$(&quot;#A&quot;).parents(&quot;.B&quot;)获取A节点的所有祖先节点中的B节点$(&quot;#A&quot;).closet(&quot;B&quot;)获取A节点的第一个为B的祖先节点后代$(&quot;#A&quot;).children()获取A节点的直接子节点$(&quot;.A&quot;).children(&quot;.B&quot;)获取A节点的所有为B的直接子节点$(&quot;#A&quot;).find(&quot;*&quot;)获取A节点的所有后代节点$(&quot;#A&quot;).find(&quot;.B&quot;)获取A节点的所有为B的后代节点同胞$(&quot;#A&quot;).prev()获取A节点的上一个兄弟节点$(&quot;#A&quot;).prevAll()获取A节点之前的所有兄弟节点$(&quot;#A&quot;).prevUntil(&quot;.B&quot;)获取A节点之前、B节点之后的所有兄弟节点$(&quot;#A&quot;).next()获取A节点的下一个兄弟节点$(&quot;#A&quot;).nextAll()获取A节点之后的所有兄弟节点$(&quot;#A&quot;).nextUntil(&quot;.B&quot;)获取A节点之后、B节点之前的所有兄弟节点$(&quot;#A&quot;).siblings()获取A节点的所有兄弟节点$(&quot;#A&quot;).siblings(&quot;.B&quot;)获取A节点的所有为B的兄弟节点过滤$(&quot;A B&quot;).first()获取第一个A节点的第一个B节点$(&quot;A B&quot;).last()获取最后一个A节点的最后一个B节点$(&quot;.A&quot;).eq(0)获取所有A节点中的第一个A节点$(&quot;A&quot;).filter(&quot;B&quot;)获取A节点中的所有B节点$(&quot;A&quot;).not(&quot;B&quot;)获取A节点中的不包括B节点的所有节点3.HTMLCollection 和 NodeList我们都知道，当获得所有节点（如：getElementsByTagName）或者获得所有子元素（如：element.childNodes）时，实际上返回的是包含一些DOM节点的集合，这个集合要么是 HTMLCollection，要么是 NodeList，两者其实都是类数组的对象。HTMLCollection和NodeList的共同点：都是类数组对象，都有length属性;都有共同的方法：item，可以通过item(index)或者item(id)来访问返回结果中的元素;一般都是实时变动的（live），document上的更改会反映到相关对象上（！！注意：document.querySelectorAll返回的NodeList不是实时的）;HTMLCollection和NodeList的不同点：NodeList可以包含任何节点类型，HTMLCollection只包含元素节点（elementNode）。HTMLCollection比NodeList多一项方法：NamedItem，可以通过传递id或name属性来获取节点信息规定返回结果：node.childNodes 结果返回类型是 NodeList，即所有子节点；node.children 结果返回类型是 HTMLCollection ，即所有子元素节点；getElementsByXXX 结果返回类型是HTMLCollection旧版本浏览器(尤其是IE)中，node.children 结果返回类型是 NodeList]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM Core 与 HTML-DOM]]></title>
    <url>%2F2019%2F03%2F08%2FF-DOM%20Core%20%E5%92%8CHTML%20DOM%2F</url>
    <content type="text"><![CDATA[1.DOMDOM（文档对象模型）是由W3C制定的一套访问和操作XML（eXtensible Markup Language）文档的标准，即API。比如DOM告诉JavaScript引擎如何在浏览器窗口中显示和操作XML创建的标记（Tag）。DOM与特定的平台、浏览器、语言无关，很多种语言都实现了DOM，比如因为JavaScript和PHP都实现了DOM，所以 JavaScript中有getElementsByTagName()方法，PHP中也有 getElementsByTagName()，getElementsByTagName()方法是DOM规定的访问XML文档的接口。2.XML、XHTML、HTMLXML与HTML相似，但两者是有区别。XML和HTML都来自于SGML，它们都含有标记，有着相似的语法，HTML和XML的最大区别在 于：HTML是一个定型的标记语言，用固定的标记来描述和显示数据，比如&lt;h1&gt;表示首行标题，有固定的尺寸；而XML没有固定的标记，只能通过自定义的标记来描述数据的形式和结构，而不能显示。HTML是将数据 和显示混在一起，而XML则是将数据和显示分开来。那为什么能使用DOM访问和操作HTML文档（即网页）呢？Web语义化的一个发展方向是将HTML逐 渐演变为更有语义、能将数据内容与现实分离的XML，但HTML不可能立即演变为XML，目前推荐使用的是一个过渡产物——XHTML。HTML与 XHTML网页形成的节点树（统称为HTML节点树）在结构上与XML节点树一样，可以看做是一个符合DOM的XML文档，因此可以使用实现了DOM的程序语言（如JavaScript、PHP等）来访问和操作HTML文档，即访问和操作那些节点。3.DOM Core和HTML-DOM由于HTML与XML的相似性及差异，JavaScript不仅实现了标准的DOM方法和属性（即由W3C制定的），而且还实现了HTML特有的 DOM方法和属性，前者称为DOM Core，并不专属于JavaScript，后者称为HTML-DOM。不管是DOM Core还是HTML-DOM，我们在使用JavaScript的时候要注意浏览器之间的兼容性，因为不同的浏览器对这两类方法和属性的支持可能不一样。常见的DOM Core方法如下：1、创建节点createElement()createTextNode()2、复制节点cloneNode()3、插入节点appendChild()insertBefore()4、删除节点removeChild()5、替换节点replaceChild()6、查找和设置节点属性setAttribute()getAttribute()7、查找节点getElementById()getElementsByTagName()hasChildNode()常见的DOM Core属性如下：node.childNodesnode.firstChildnode.lastChildnode.nextSiblingnode.previousSiblingnode.parentNode]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解事件循环]]></title>
    <url>%2F2019%2F03%2F05%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[本篇博客讲的东西偏底层，较难理解。虽然有的地方不够精准和全面，但是我觉得对于理解js中的异步来说已经够了，所以没有再深究一些概念（比如浏览器在这个过程中充当的角色）。1.单线程所谓的单线程，可以简单理解为做事情讲究先来后到，要做后面的事情，你得等前面的事情做完—–不管它需要多久。既然如此，js引擎为何还要采取这种单线程的机制呢？js主要是与用户互动，这个过程涉及到对DOM节点的操作，如果js是多线程的，一个在节点上添加内容，一个要对这个dom节点进行删除，到底是以哪个为准？所以这就是为什么js从一出现就秉承着单线程的运行机制。另外还要注意：“为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质”2.同步任务和异步任务很显然，单线程会带来一个问题：就是代码执行的阻塞。比如：排在前面的任务如果耗时长，则后面的任务不得不一直等待它。 如果说耗时长是因为计算量大、cpu一直忙着计算的话倒也还好，可事实是——大部分时间浪费在了IO上（ajax从网络上获取数据），还有其他的如鼠标点击、setTimeout等等。因此这里提出了同步任务和异步任务的概念。在js中，可以将同步和异步简单理解为执行顺序的问题。2.1同步（sync）：即上面所说的后面等待前面。同步对应了同步任务（synchronous），即可以按照正常顺序执行的任务，比如加载页面骨架等。2.2异步（async）：即把耗时长的任务挂起，先执行耗时短的，再回过头执行耗时长的。异步对应了异步任务（asynchronous），即不适合按照正常顺序执行的任务，主要包括：onclick等事件绑定—&gt; 当事件触发时，回调函数会被添加到任务队列中；setTimeout / setInterval 等计时器—&gt; (时间延迟)当浏览器完成计时，回调函数会被添加到任务队列中；AJAX请求—&gt;当网络请求完成返回时，回调函数会被添加到任务队列中3.事件循环事件循环又叫event loop，需要注意的是，事件循环不是单线程的js引擎提供的机制，而是来自于js引擎的运行环境（多线程的浏览器或node.js）。事件循环是实现异步的一种机制。一个线程中只有一个事件循环，我们将这个循环的每一次循环执行过程称之为tick。 具体每一次循环是怎么执行的，后文会讲。4.执行栈和任务队列事件循环机制离不开执行栈和任务队列的相互配合。js中将同步任务放到主线程上执行，形成“执行栈”；异步任务则放到任务队列中。任务队列的分类标准之一：一个线程可以拥有多个任务队列。每一个任务队列都对应某一任务源，并包含了一堆来自该任务源的任务。任务源是什么？像setTimeout/Promise/DOM事件/AJAX等都是任务源，来自同类任务源的任务我们称它们是同源的，比如setTimeout与setInterval就是同源的。任务队列的分类标准之二：在ES6中，我们用另一种方式对任务队列进行分类。宏任务: 即macro-task，包括整体代码script，setTimeout，setInterval、AJAX、用户I\O 等。宏任务会对应地进入宏任务队列中；微任务: 即micro-task,包括Promise，process.nextTick(callback)(可以理解为node.js版的setTimeOut)。微任务会对应地进入微任务队列中。5.事件循环的具体实现过程？总的来说，事件循环的顺序，决定了js代码执行的顺序。首先进入&lt;script&gt;包裹的整体代码(这是第一个宏任务)，标志着第一次循环开始。在整体代码的执行过程中，同步任务照旧执行，异步任务分发到对应的任务队列中；整体代码执行完，执行栈清空，开始读取任务队列；读取所有微观任务队列 -&gt; 执行 -&gt;第一次循环结束，开始第二次循环读取一个宏观任务队列 -&gt; 执行 -&gt;读取所有微观任务队列 -&gt; 执行 -&gt;第二次循环结束，开始第三次循环读取一个宏观任务队列……………..………………队列清空，执行栈清空，事件循环正式结束。PS：读取任务时，会执行这些任务指定的回调函数,并且要注意：若回调函数中又有宏任务，则该宏任务会被安排到下一轮循环中。6.事件循环的例子下面通过三个由易到难的例子来理解上面所说的过程。例1setTimeout(() => { task() },3000) sleep(10000000) 分析：跑一下代码，会发现控制台执行task()需要的时间远远超过3秒，这就说明我们有的人理解的”setTimeout的第二个参数指定了多长时间后执行回调函数”的说法是错误的。让我们来分析一下这个过程：&lt;script&gt;中的整段代码作为第一个宏任务，进入主线程。即开启第一次事件循环；首先遇到了setTimeout，将其回调函数task()进入Event Table并注册,同时浏览器开始计时；继续，遇到了sleep函数，这是同步任务，所以直接执行。但是速度很慢，非常慢，而浏览器计时仍在继续；好了，3秒终于到了，计时事件setTimeout总算完成，可以把task()放入任务队列了;但是主线程上的sleep太慢了，还没执行完，于是我们只好等着；sleep终于执行完了，执行栈清空,第一次循环的宏任务结束；读取微任务队列….不对，没有任何任务被分发到这个队列，于是第一次循环只好这样结束了；第二次循环开始，读取宏任务队列，刚好，里面有一个setTimeout对应的task()回调函数，压栈、令其进入主线程执行；执行栈清空了，任务队列也清空了，事件循环正式结束。现在，我们知道setTimeout的回调函数是一开始就注册进event table的，但是那时并未进入任务队列—-要经过一定的时间，而这个时间由第二个参数来指定。也就是说，第二个参数指定的是“多长时间后将回调函数放入到任务队列中”。另外，即使回调函数已经进入队列，也得先等主线程的执行栈清空后才有可能轮到自己。我们还经常遇到setTimeout(fn,0)(或者干脆没有指定第二个参数)这样的代码，这是不是意味着可以立即执行呢？不是。setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是注册进event table的同时就将任务放入队列中，只要主线程执行栈内的同步任务全部执行完成，且此时没有微任务队列，那么该任务就会马上压栈并执行。例2setTimeout(function() { console.log('setTimeout'); }) new Promise(function(resolve) { console.log('promise'); }).then(function() { console.log('then'); }) console.log('console'); 分析：&lt;script&gt;中的整段代码作为第一个宏任务，进入主线程。即开启第一次事件循环；遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中（第二个参数不设定时，默认延迟为0）；接下来遇到new Promise、Promise，立即执行，输出: promise 。将then函数分发到微任务队列中；遇到console.log，立即执行，输出: console整体代码作为第一个宏任务执行结束，此时去微任务队列中查看有哪些微任务，结果发现了then函数，然后将它推入主线程并执行，输出: then第一轮事件循环结束，第二轮事件循环开始；先从宏任务开始，去宏任务队列中查看有哪些宏任务，结果发现了setTimeout对应的回调函数，将它推入主线程并执行，输出：setTimeout然后去微任务队列中查看是否有事件，结果没有；此时第二轮事件循环结束；执行栈清空了，任务队列也清空了，事件循环正式结束。例3console.log('1'); setTimeout(function() { console.log('2'); process.nextTick(function() { console.log('3'); }) new Promise(function(resolve) { console.log('4'); resolve(); }).then(function() { console.log('5') }) }) process.nextTick(function() { console.log('6'); }) new Promise(function(resolve) { console.log('7'); resolve(); }).then(function() { console.log('8') }) setTimeout(function() { console.log('9'); process.nextTick(function() { console.log('10'); }) new Promise(function(resolve) { console.log('11'); resolve(); }).then(function() { console.log('12') }) }) 分析：第一轮事件循环:a) 整段`&lt;script>`代码作为第一个宏任务进入主线程，即开启第一轮事件循环 b) 遇到console.log，立即执行。输出：1 c) 遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中。 我们将其标记为setTimeout1 d) 遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务 队列中。记为process1 e) 遇到new Promise、Promise，立即执行；then回调函数放入Event table中注册，然后 被分发到微任务队列中。记为then1。 输出: 7 f) 遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中。 我们将其标记为setTimeout2 此时第一轮事件循环宏任务结束，下表是第一轮事件循环宏任务结束时各任务队列的情况可以看到第一轮事件循环宏任务结束后微任务事件队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行g)、执行process1。输出：6 h)、执行then1。输出：8 第一轮事件循环正式结束！第二轮事件循环:a）、第二轮事件循环从宏任务setTimeout1开始。遇到console.log，立即执行。输出: 2 b）、遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务 队列中。记为process2 c）、遇到new Promise，立即执行；then回调函数放入Event table中注册，然后被分发到 微任务队列中。记为then2。输出: 5 此时第二轮事件循环宏任务结束，下表是第二轮事件循环宏任务结束时各任务队列的情况可以看到第二轮事件循环宏任务结束后微任务事件队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行d)、执行process2。输出：3 e)、执行then2。输出：5 第二轮事件循环正式结束！第三轮事件循环:a)、第三轮事件循环从宏任务setTimeout2开始。遇到console.log，立即执行。输出: 9 d)、遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务 队列中。记为process3 c)、遇到new Promise，立即执行；then回调函数放入Event table中注册，然后被分发到 微任务队列中。记为then3。输出: 11 此时第三轮事件循环宏任务结束，下表是第三轮事件循环宏任务结束时各任务队列的情况可以看到第二轮事件循环宏任务结束后微任务队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行d)、执行process3。输出：10 e)、执行then3。输出：12 第二轮事件循环正式结束！执行栈清空，任务队列清空，事件循环正式结束！参考：https://segmentfault.com/a/1190000017970432http://www.ruanyifeng.com/blog/2014/10/event-loop.html]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出理解闭包]]></title>
    <url>%2F2019%2F03%2F04%2FF-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言：本篇博客转载自@王福朋 王老师的系列文章。系列文章共计18篇，主要涉及js中的两个重难点—-原型和闭包。由于原型部分我在另外一篇博客有介绍，所以这里只集合了他关于闭包的几篇讲解，包括了作用域、执行上下文等。原作者：王福朋来源：深入理解JavaScript原型和闭包转载授权:1.简述执行上下文（上）：什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：这是第一种情况。下面还有。先来个简单的。有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。下面还有。。。第三种情况。在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。好了，“准备工作”介绍完毕。我们总结一下，在“准备工作”中完成了哪些工作：变量、函数表达式——变量声明，默认赋值为undefined；this——赋值；函数声明——赋值；这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的。细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。这里解释一下为什么代码段分为这三种。所谓“代码段”就是一段文本形式的代码。首先，全局代码是一种，这个应该没有非议，本来就是手写文本到&lt;script&gt;标签里面的。其次，eval代码接收的也是一段文本形式的代码。最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。这样解释应该能理解了。最后，eval不常用，也不推荐大家用。2.简述执行上下文（下）：继续上面的内容。上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：变量、函数表达式——变量声明，默认赋值为undefined；this——赋值；函数声明——赋值；如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。另外一点不同在于，函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。全局代码的上下文环境数据内容为：如果代码段是函数体，那么在此基础上需要附加：给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。3.执行上下文栈继续上文的内容。执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。其实这是一个压栈出栈的过程——执行上下文栈。 如下图：可根据以下代码来详细介绍上下文栈的压栈、出栈过程。如上代码。在执行代码之前，首先将创建全局上下文环境。然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。执行到第13行，调用bar函数。跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。并将这个执行上下文环境压栈，设置为活动状态。执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。要说闭包，咱们还得先从自由变量和作用域说起。4.作用域提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：再比如for语句：所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——javascript除了全局作用域之外，只有函数可以创建的作用域。所以，我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。jQuery就是一个很好的示例：下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。说到这里，咱们又可以拿出jquery源码来讲讲了。jQuery源码的最外层是一个自动执行的匿名函数：为什么要这样做呢？原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。下一节将把作用域和执行上下文环境结合起来说一说。可见，要理解闭包，不是一两句话能说清楚的。5.作用域和上下文环境上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。另外，对上下文环境不了解的朋友，可以回过头看看前面。第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。结束了 ！最后我们可以把以上这几个图片连接起来看看。连接起来看，还是挺有意思的。作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。6.从自由变量到作用域链先解释一下什么是“自由变量”。在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。上面描述的只是跨一步作用域去寻找。如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。这个一步一步“跨”的路线，我们称之为——作用域链。我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；第四步，跳转到第一步。以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。7.闭包前面提到的上下文环境和作用域的知识，一方面是必须了解的知识，一方面也是理解闭包的基础。至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。闭包的作用，简而言之一句话：可以在其他的执行上下文中，访问到函数的内部变量。第一，函数作为返回值如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。第二，函数作为参数被传递如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。上一节讲到自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。咱们可以拿本文的第一段代码（稍作修改）来分析一下。第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域.。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。使用闭包会增加内容开销，现在很明显了吧！第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。正如我们所看到的，闭包和作用域、上下文环境有着密不可分的关系。另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么，因为这些BUG可能完全在你的知识范围之外。到现在闭包就简单介绍完了。8.补充：上下文环境和作用域的关系本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。在说明之前，咱们先用简单的语言来概括一下这两个的区别。8.1. 上下文环境：可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？8.2. 作用域：首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。8.3. 两者：一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。上面的文字不理解没关系，且看下面的例子。第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境。讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>执行上下文</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包和计数器]]></title>
    <url>%2F2019%2F03%2F04%2FF-%E9%97%AD%E5%8C%85%E5%92%8C%E8%AE%A1%E6%95%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[之前想不通的一道题—–主要是不知道思路怎么来的，为何会想到用闭包。本来打算就将原博客转载过来，但是刚刚重新审视这道题的时候，好像看到了以前没有发现的东西，有种恍然大悟的感觉，所以决定用自己的话来解释这道题的思路。假如我们想制作一个计数器，每点击一次就加一，代码如下：var counter = 0; //把计数器counter设置成全局变量 function add(){ return counter+=1; } add(); //1 add(); //2 add(); //此时counter=3 &gt;&gt;固然可以实现功能，但问题就在于其他语句也有可能会改动到counter，这样的计数器是不安全的。如果把counter改为外部访问不到的局部变量呢？function add(){ var counter=0; counter+=1; } add(); //counter为1 add(); //counter为1 add(); //counter为1 &gt;&gt;固然保证了counter不会被其他语句影响到，但问题就在于每次调用函数都会重置counter，无法实现计数功能。所以我们需要的counter应该满足：1.不会被重置；2.在函数内部第2点容易满足，但是由上面的例子我们知道，如果单纯把counter写在一个函数里，则每次调用都会重置，所以我们定义这样一个嵌套函数：将counter放在父函数里，子函数作为操作counter的函数，每次我们只调用子函数。但是，全局作用域是无法访问嵌套函数中的子函数的，所以我们必须将子函数作为闭包返回出来，使其暴露在全局作用域下。依照这个想法，代码如下：var add = function(){ var counter = 0; return function(){ return (++counter); } } add()(); //counter为1 add()(); //counter为1 add()(); //counter为1 &gt;&gt;意思是把add函数（父函数）执行后返回的函数（子函数）执行一次（注意这里是两次执行）。但这样的问题在于：每次调用add()()时依然执行了一次父函数，结果就是依然重置了counter。那么有没有办法让父函数只执行一次，仅在那一次初始化counter，之后每次都只通过执行子函数来操作counter呢？可以用自执行函数来解决这个问题—–也就是通过自执行函数（而不是通过add()）来调用父函数，在这一次调用初始化counter，之后将返回的子函数赋给add，通过调用add()来操作counter。var add = (function(){ var counter = 0; return function(){ return(++counter); } })(); //这里add已经是父函数的执行结果了，即add已经是返回的那个子函数了 add(); //counter为1 console.log(counter) //undefined add(); //counter为2 console.log(counter) //undefined add(); //counter为3 console.log(counter) //undefined 接下来就是闭包的知识了：在每次调用闭包add——-即function(){return(++counter)时，由于add中存在自由变量counter，所以它必须到定义该函数时所在的那个作用域中去寻找该变量，也就是到父函数中去寻找。恰好父函数中有一个为0的counter可以被引用，所以这时候完成加一操作，counter变成1。注意，接下来我们尝试调用了console.log(counter)，但是输出的是undefined，这说明了即使add函数执行后返回了值为1的counter，但是该返回值并不是返回到全局作用域中（不然不会输出undefined），而是覆盖了父函数中原来定义的counter，使counter变为1；第二次调用add函数依然同上，只是此时引用counter时，引用的是为1的counter，加1后变为2；同理第三次，引用的是为2的counter，加1后变为3。基于这道题，我们不难看出使用闭包函数的好处：1、缓存：最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量作为相对于闭包函数的自由变量，在闭包函数里直接使用它。因此该自由变量只初始化一次，但却可以通过多次调用闭包函数来使用。这比起我们直接在闭包函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是上面例子中的—–实现计数功能。2、实现封装：自由变量只能被闭包函数本身或者其子函数访问，而不能被闭包函数之外的函数访问。这就实现了面向对象的封装性，更安全更可靠。参考：http://www.cnblogs.com/haidaojiege/p/7070560.htmlhttps://www.cnblogs.com/leoin2012/p/3978979.html]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解line-height]]></title>
    <url>%2F2019%2F02%2F20%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height%2F</url>
    <content type="text"><![CDATA[1.相关概念普及：1.1 顶线，中线，基线和底线 ：直接见下图。inline-block和inline都可以有这四种线。其中，我们重点研究基线，即base line。基线并不是汉字文字的下端沿，而是英文字母“x”的下端沿。1.2 行高：即line-height，是指同一个元素中，两个文本行基线间的垂直距离。&lt;div style="width:170px;"> &lt;span style="font-size:16px;line-height:20px;background:red;"> I'm the first line &lt;/span> &lt;span style="font-size:16px; line-height:40px;background:green;"> I'm the second line &lt;/span> &lt;/div> 比如上图或者下图中两条红线之间的距离。1.3 行距：上行的底线和下一行的顶线之间的距离就是行距，行距的一半称为半行距1.4 字体大小：即font-size，是指同一行的顶线和底线之间的距离从上图我们就可以看出，行距、font-size与行高之间的关系满足行距 = （行高 - font-size）当font-size等于行高时，行距 = 0，如下图而当font-size大于行高时，行距为负值，则两行重叠，如下图：1.5 CSS boxes的四种类型（containing boxes、inline boxes、line boxes、content area)1.5.1 content area （内容区）：内容区是包围着文字的一种box，无法显示出来。在没有其他因素 (比如padding) 的影响时，内容区的高度即为font-size。1.5.2 inline box (行内框) ：每个行内元素会生成一个行内框，行内框是一个浏览器渲染模型中的一个概念，无法显示出来。在没有其他因素 (比如padding) 的影响时，行内框的高度即为内容区的高度；设定line-height后，实际改变的是行距，行内框的高度将由 内容区 变为 内容区＋行距。因此，此时会有行内框高度=行高。1.5.3 3.line box（行框） ：行框是指本行的一个虚拟的矩形框，由该行中一个个行内框组成。行框也是浏览器渲染模式中的一个概念，无法显示出来。行框高度等于本行中所有行内框高度的最大值。当有多行内容时，每一行都有自己的行框。1.5.4 containing box（包含框）：包裹着上述三种box的box2. line-height的取值方法与继承一般而言，line-height只影响行内元素( 包括行内替换元素和行内非替换元素，如img和span )，并不能直接应用于块级元素。但是line-height 具有可继承性，块级元素的子元素会继承该特性，并且在行内元素上生效。一般情况下，浏览器默认的line-height为1.2。可以自定义 line-height 覆盖这个初始值，那么该怎样设置line-height呢？有以下5种方式：line-height是个可继承属性，它的继承规则比较复杂。需要提前说明的是：line-height的大小与font-size息息相关，除了指定line-height为多少px，剩下的设置方式都是基于font-size算出来的。 下面一一解释。inherit ：继承父元素line-height的值，所以父元素的是多少就是多少。 如果其后代元素不设置line-height 的话，也会是这个值。数字＋px： 假设设置 line-height 为20px，那么该行的行高就是20px，与 font-size 无关，不会随着 font-size 做相应比例的缩放。 这个长度值（20px）会被后代元素继承，所有的后代元素会使用这个相同的、继承的 line-height (20px)，除非后代元素设定 line-height 。数字＋％ ：假设自身的 font-size 为16px，line-height 设为120%。那么其行高为：16 * 120% = 19.2px。即 line-height 是根据自身的 font-size 计算出来的。 子元素会继承父元素的line-height，它继承的不是百分比而是父元素line-height计算后的最终值。normal ：假设设置line-height 为 normal ，则会根据浏览器的解析情况给元素分配一个倍数，一般是1.2，即line-height为字体的1.2倍。与上一个不同的是，其子元素不再继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~可见，子元素随着自身 font-size 的大小而做相应比例的缩放。纯数字/缩放因子 ：如果既想要 normal 的灵活，又想设置一个自定义的值，那就要用 纯数字 。纯数字方式与 normal 唯一的不同，在于数值的大小不一定是1.2，而是完全由你自己决定。同样地，其子元素不是继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~总结如下：那么，哪一种是最好的方式呢？ 一般来数，设置行高的值为纯数字是最推荐的方式，因为其会随着对应的 font-size 而缩放。3 line-height实现垂直居中的原理通常情况下，div中的a标签包含文本，文本将默认出现在div的顶端，如果想要垂直居中，可以设置div的高度等于行高，由于行高不直接作用于块状元素且行高可以继承，所以实际上等效于设置a的行高等于div的高度。a的行高即a的行内框高度，即 内容区＋行距。行高默认是浏览器分配的1.2，由于此时重新设置了行高☞☞所以行距跟着改变☞☞所以内容区上下往外延伸☞☞即行内框整体延伸。但是，文字始终在行内框里垂直居中，行内框延伸的终点是div的高度，也就是延伸至行内框高度等于div高度。此时，文本自然会在div中垂直居中。]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery AJAX load()方法中代码执行顺序的问题]]></title>
    <url>%2F2019%2F02%2F18%2FF-jQuery%20AJAX%20load()%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题来源于菜鸟教程介绍 jQuery load() 方法时用的一个实例：JS：$("button").click(function(){ $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr){ if(statusTxt=="success") alert("外部内容加载成功!"); if(statusTxt=="error") alert("Error: "+xhr.status+": "+xhr.statusText); }); }); HTML：&lt;div id="div1">&lt;h2>使用 jQuery AJAX 修改该文本&lt;/h2>&lt;/div> &lt;button>获取外部内容&lt;/button> 这里作为load方法参数的函数是一个回调函数。什么是回调函数呢？我们先来看看回调的英文定义：A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。字面上的理解，回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。那么根据这个解释，这段代码应该是先执行 load(&quot;demo_test.txt&quot;) 加载外部内容，之后再执行回调函数弹出 alert。但是实际运行后发现和预想的不一样：方法中代码执行顺序的问题-1.png)方法中代码执行顺序的问题-2.png)从结果来看，是先弹出 alert 再改变文本内容。那么，为什么会这样呢？难道上面的说法有误？为了进一步验证，修改代码如下：$("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr){ alert(responseTxt); if(statusTxt=="success"){ 运行：方法中代码执行顺序的问题-3.png)很明显文本内容已经改变，说明前面关于回调函数最后执行的说法是没问题的。接着猜想，之所以先弹出 alert 再改变文本内容，可能是因为必须等回调函数执行完后才能把文本渲染到浏览器上。为了进一步验证，修改代码如下：$("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr){ if(statusTxt=="success"){ debugger； console.log("1"); } 运行：方法中代码执行顺序的问题-4.png)控制台中没有打印出1，且程序中断，说明此时回调函数还在执行当中，但是文本内容却已经改变了。这说明上面的猜想错误—–即文本渲染到浏览器上不需要等到回调函数执行结束。但是，那只是一般情况！！问题就在于，alert是可以阻塞浏览器的渲染工作的！重新运行最初的代码，可以看到还是先弹出 alert，文本没变，但是这时候点开控制台的 elements，可以看到图中红框显示这时候文本的内容其实已经改变了。方法中代码执行顺序的问题-5.png)虽然文本内容看上去不变——但是实际情况是文本内容已经改变了，也就是 load() 方法已经生效了，只是 alert 阻塞了浏览器将它渲染出来。在这里还要注意，alert 可以阻塞浏览器的渲染，而 debugger 是没办法的。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AJAX</tag>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提问的智慧]]></title>
    <url>%2F2019%2F02%2F18%2FT-%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7%2F</url>
    <content type="text"><![CDATA[提问领域的“圣经”，虽然很难严格按照里面的标准规范自己的行为，但是可以作为一个提醒的方式。译文应该是很长时间没维护了，因为bug被直接翻译为“臭虫”的情况屡见不鲜，但是总体上还是可以把英文原文要表达的意思说明白的。之所以放在博客，一是阅读体验，因为博客的TOC自动生成目录会使得阅读本文更加轻松；二是迁移，这类长文我认为不适合放在笔记里。主要是个人需要，所以悄悄地copy下来了，没有去要授权。原文：http://doc.zengrong.net/smart-questions/cn.html?from=singlemessage下面是正文提问前在通过电邮、新闻组或论坛提技术问题以前，做以下事情：1.尝试在你准备提问论坛的历史文档中搜索答案2.尝试搜索互联网以找到答案3.尝试阅读手册以找到答案4.尝试阅读“常见问题文档”（FAQ）以找到答案5.尝试自己检查或试验以找到答案6.尝试请教懂行的朋友以找到答案如果你是程序员，尝试阅读源代码以找到答案提问时，请先表明你已做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中 学到的东西 ，我们喜欢回答那些表现出能从答案中学习的人。运用某些策略，比如用谷歌（Google）搜索你遇到的各种错误提示（既搜索 谷歌论坛，也搜索网页）， 这样很可能直接就找到了解决问题的文档或邮件列表线索。 即使没有结果，在邮件列表或新闻组寻求帮助时提一句“我在谷歌中搜过下列句子但没有找到什么有用的东西” 也是件好事，至少它表明了搜索引擎不能提供哪些帮助。将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。别着急，不要指望几秒钟的谷歌搜索就能解决一个复杂的问题。读一下常见问题文档。在向专家提问之前，先向后靠靠放松一下，再思考一下问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑抛出，只因你的第一次搜索没有结果（或者结果太多）。认真地思考，准备好你的问题。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想 “愚蠢的问题……”，一边按将错就错的答案回复你，并且希望这种只是得到你自己“问的问题”而非真正所需的解答，给你一个教训。永远不要假设你 有资格 得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社区贡献经验，而不仅仅是消极地要求从别人那获取知识的问题，你将“挣到”答案。另一方面，表明你有能力也乐意参与问题的解决是个很好的开端。“有没有人能指个方向？”，我这还差点什么？”，“我应该查哪个网站？”，通常要比 “请给出我可以用的完整步骤”更容易得到回复，因为你表明了只要有人能指个方向，你就很乐意完成剩下的过程。提问时1.仔细挑选论坛要对在哪提问留心，如果你做了下述事情，多半会被一笔勾销或被看成“失败者”：张贴与论坛主题无关的问题在面向高级技术问题的论坛上张贴肤浅的问题，或者反之。在太多不同的新闻组同时张贴给既非熟人也没有义务解决你问题的人发送你私人的电邮为保护通信的渠道不被无关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想让这种事落到自己头上的。因此，第一步是找对论坛。谷歌和其它搜索引擎还是你的朋友，可以用它们搜索你遇到困难的软硬件问题最相关的项目网站。那里通常都有项目的常见问题（FAQ）、邮件列表及文档的链接。如果你的努力（包括 阅读 FAQ）都没有结果，这些邮件列表就是最后能取得帮助的地方。项目的网站也许还有报告bug的流程或链接，如果是这样，去看看。向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个内容丰富的网页的作者想充当你的免费顾问，不要对你的问题是否会受到欢迎做太乐观的估计──如果你不确定，向别处发或者压根别发。在选择论坛、新闻组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以明确你的问题是否切题。发贴前先翻翻已有的帖子，这样可以让你感受一下那里行事的方式。事实上，张贴前在新闻组或邮件列表的历史文档中搜索与你问题相关的关键词是个极好的主意，也许就找到答案了。即使没有，也能帮助你归纳出更好的问题。别象机关枪似的一次性“扫射”所有的帮助渠道，这就象大喊大叫一样会令人不快，温柔地一个一个来。弄懂主题！最典型的错误之一是在某种致立于跨平台可移植的语言、库或工具的论坛中提关于 Unix 或 Windows 操作系统程序接口的问题。如果你不明白为什么这是大错，最好在搞清楚概念前什么也别问。一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回答。有几个道理支持这点，一是看潜在的回复者有多少，二是看论坛的参与者有多少，黑客更愿回答能启发多数人的问题。可以理解，老练的黑客和一些流行软件的作者正在承受过多的不当消息。就象那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端──已经好几次了，一些流行软件的作者退出了对自己软件的支持，因为伴随而来的涌入其私人邮箱的垃圾邮件变得无法忍受。2.面向新手的论坛和互联网中继聊天（IRC）通常响应最快本地的用户组织或者你所用的 Linux 发行版也许正在宣传新手取得帮助的论坛或 IRC 通道（在一些非英语国家，新手论坛很可能还是邮件列表），这些地方是开始提问的好去处，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 通道是公开邀请提问的地方，通常可以得到实时的回复。事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的项目论坛或邮件列表，（否则）该项目的黑客可能仅仅回复“用 我们的 代码”。在任何论坛发贴以前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。通过论坛或 IRC 通道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发者保留。所以先在论坛或 IRC 中寻求与该项目相关的帮助。3.第二步，使用项目的邮件列表当某个项目存在开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文档和主页，找到项目的邮件列表并使用它。采用这种办法有几个很好的理由：向个别开发者提的问题（如果）足够好，也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为骚扰个别开发者的理由。向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导）也许太忙以至于没法回答你的问题。大多数邮件列表都要存档，那些存档将被搜索引擎索引，如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。如果一个项目既有 “用户” 也有“开发者”（或 “黑客”）邮件列表或论坛，而你又不摆弄那些代码，向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会遭受你的噪音干扰。然而，如果你 确信 你的问题不一般，而且在“用户” 列表或论坛中几天都没有回复，可以试试“开发者”列表或论坛。建议你在张贴前最好先暗暗地观察几天,至少看看最近几天保存的帖子,以了解那的行事方式（事实上这是参与任何私有或半私有列表的好主意）如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。4.使用有意义且明确的主题在邮件列表、新闻组或论坛中，主题是你在五十个或更少的字以内吸引有资格专家注意的黄金机会，不要用诸如 “请帮我” （更别提大写的 “请帮我！！！！”，这种主题的消息会被条件反射式地删掉）之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题描述。使用主题的好惯例是“对象──偏差”（式的描述），许多技术支持组织就是这样做的。在“对象”部分指明是哪一个或哪一组东西有问题，在“偏差”部分则描述与期望的行为不一致的地方。愚蠢：救命啊！我的笔记本视频工作不正常！明智：X.org 6.8.1 扭曲鼠标光标，MV1005 型号的某显卡芯片组更明智：使用 MV1005 型号的某显卡芯片组在 X.org 6.8.1 的鼠标光标被扭曲编写 “对象──偏差”式描述的过程有助于你组织对问题的细致思考。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在 X.org 中出现？或只是在其 6.8.1 版中？是针对某显卡芯片组？或者只是其中的 MV1005 型号？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。更一般地，想象一下在一个只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接就找到答案的线索，而不用再次发贴提问。如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象 “Re: 测试” 或者 “Re: 新bug”的消息不太可能引起足够的注意。同时，将回复中与新主题不甚相关的引用内容尽量删除。对于列表消息，不要直接点击回复（按钮）来开始一个全新的线索，这将限制你的观众。有些邮件阅读程序，比如 mutt，允许用户按线索排序并通过折叠线索来隐藏消息，这样做的人永远看不到你发的消息。仅仅改变主题还不够。mutt 和其它一些邮件阅读程序还要检查邮件头主题以外的其它信息，以便为其指定线索，所以宁可发一个全新的邮件。在论坛，因为消息与特定的线索紧密结合，并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧。不是所有论坛都允许在回复中出现分离的主题，而且这样做了基本上没有人会去看。不过，通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该线索的人读到。所以，除非你 只想 在该线索当前活跃的人群中提问，还是另起炉灶比较好。5.使问题容易回复以“请向……回复”来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，换个好点的；如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。在论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是敏感的（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如“留意本线索”、“有回复发送邮件”等功能。6.用清晰、语法、拼写正确的语句书写经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程（我敢打赌）。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将时间花在其它地方。清楚、良好地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意（你的问题）麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它 必须 很准确，而且有迹象表明你是在思考和关注问题。正确地拼写、使用标点和大小写，不要将“its”混淆为“it’s”，“loose”搞成“lose”或者将“discrete”弄成 “discreet”。不要全部用大写，这会被视为无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox [注：著名黑客，Linux 内核的重要参与者] 也许可以这样做，但你不行。）一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。也不要使用即时通讯中的简写，如将“you”简化为“u”会使你看起来象一个为了节约二次击键的半文盲式的傻子。更糟的是，如果象个小孩似地鬼画桃符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。如果在非母语论坛提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍（是的，我们通常看得出其中的差别）。同时，除非你知道回复者使用的语言，请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被阅读就被直接删除的可能性降到最低。如果你用英语书写但它是你的第二语言，最好提醒潜在的回复者语言上可能的困难以便绕过这个问题，比如：英语不是我的母语，请谅解拼写错误。如果您使用某某语言，请电邮/私聊我，也许我需要您的协助翻译我的问题。对于这个技术术语本身我很熟悉，但对于它的一些俚语或习惯表达方式就不太明白了。我已经同时用某某语及英语提问，如果您使用两者之一回复，我很乐意翻译。7.使用易于读取且标准的文件格式发送问题如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：使用纯文本而不是 HTML（超文本标注语言）（ 关闭HTML 并不难）使用 MIME（多用途互联网邮件扩展）附件通常没有问题，前提是真正有内容（譬如附带的源文件或补丁），而不仅仅是邮件客户端程序生成的模板（譬如只是消息内容的拷贝）。不要发送整段只是单行句子但多次折回的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的文本终端阅读邮件，设置你的行折回点小于 80 列。但是，也 不要 用任何固定列折回数据（譬如日志文件拷贝或会话记录）。数据应该原样包含，使回复者确信他们看到的是与你看到的一样的东西。在英语论坛中，不要使用’Quoted-Printable’ MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持。当它们分断时，那些文本中四处散布的 “=20”符号既难看也分散注意力，甚至有可能破坏内容的语意。永远 不要 指望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就象有人将还在冒热气的猪粪倒在你门口时你的反应一样。即使他们能够处理，也很厌恶这么做。如果你从使用视窗的电脑发送电子邮件，关闭问题颇多的微软“聪明引用”功能（在“工具” -&gt; “自动纠正选项”的“输入时自动格式化”下去掉聪明引用的选框），以免在你的邮件中到处散布垃圾字符。在论坛，勿滥用“表情符号”和“HTML”功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。如果你使用图形用户界面的邮件客户端程序(如网景公司的 Messenger、微软公司的 Outlook 或者其它类似的)，注意它们的缺省配置不一定满足这些要求。大多数这类程序有基于菜单的“查看源码”命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。8.描述问题应准确且有内容仔细、清楚地描述问题的症状描述问题发生的环境(主机、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：“Fedora Core 7”、“Slackware 9.1”等）描述提问前做过的研究及其理解。描述提问前为确定问题而采取的诊断步骤。描述最近对计算机或软件配置的任何相关改变。如果可能，提供在可控环境下重现问题的方法。尽最大努力预测黑客会提到的问题，并提前备好答案。如果你认为是代码有问题，向黑客提供在可控环境下重现问题的方法尤其重要。当你这么做时，得到有用且及时回复的可能性将大大增加。西蒙.泰瑟姆（Simon Tatham）写过一篇 如何有效报告bug的文章，我强烈推荐各位阅读。9.量不在多，精炼则灵你应该（写得）精炼且有内容，简单地将一大堆代码或数据罗列在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝试将其裁剪得越小越好。至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到 有用的 回复。第三，在提纯bug报告的过程中，你可能自己就找到了解决办法或权宜之计。别急于宣称找到bug当你在一个软件中遇到问题，除非你 非常、非常 的有根据，不要动辄声称找到了bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你（声称）发现了文档的“bug”，你应该能提供相应位置的替代文本。记住，还有许多其它用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时就应该发现了（你在报怨前已经做了这些，是吧 ？）。这也意味着很有可能是你弄错了而不是软件本身有问题。编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了bug，也就置疑了他们的能力，即使你是对的，也有可能会使其中的部分人感到不快。（此外，）在主题中嚷嚷“bug”也是特别不老练的。提问时，即使你私下非常确信已经发现一个真正的bug，最好写得像是你做错了什么。如果真的有bug，你会在回复中看到这点。这样做的话，如果真的有bug，维护者就会向你道歉，这总比你弄砸了然后欠别人一个道歉要强。10.低声下气代替不了做自己的家庭作业有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端：“我知道我只是个可怜的新丁，一个失败者，但……”。这既使人困扰，也没有用，当伴随着对实际问题含糊的描述时还特别令人反感。别用低级灵长类动物的办法浪费你我的时间，相反，尽可能清楚地描述背景情况和你的问题，这比低声下气更好地摆正了你的位置。有时，论坛设有单独的初学者提问版面，如果你真的认为遇到了肤浅的问题，到那去就是了，但一样别低声下气。11.描述问题症状而不是猜测告诉黑客是什么导致了问题是没用的（如果你的诊断理论是了不起的东西，你还会向别人咨询求助吗？）。所以，确保只是告诉他们问题的原始症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述自己的猜测很重要，应清楚地说明这只是你的猜测并描述为什么它们不起作用。愚蠢：我在编译内核时接连遇到 SIG11 错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？明智：我组装的电脑（K6/233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机 20 分钟左右、做内核编译时频繁地报 SIG11 错，但在头 20 分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问题，相关的典型编译会话日志附后。由于以上这点许多人似乎难以掌握，这里有句话可以提醒你：“所有的诊断专家都来自密苏里州”。美国国务院的官方座右铭则是“让我看看”（出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：“我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。”）针对诊断者而言，这并不是怀疑，而只是一种真实而有用的需求，以便让他们看到与你看到的原始证据尽可能一致的东西，而不是你的猜测与总结。（所以，）让我们看看。12.按时间先后罗列问题症状刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你、电脑和软件在崩溃前都做了什么。在命令行处理的情况下，有会话日志（如运行脚本工具生成的）并引用相关的若干（如20）行记录会非常有帮助。如果崩溃的程序有诊断选项（如-v详述开关），试着选择这些能在记录中增加排错信息的选项。记住，“多”不等于“好”。试着选取适当的排错级别以便提供有用的信息而不是将阅读者淹没在垃圾中。如果你的记录很长（如超过四段），在开头简述问题随后按时间先后罗列详细过程也许更有用。这样，黑客在读你的记录时就知道该注意哪些内容了。13.描述目标而不是过程如果你想弄清楚如何做某事（而不是报告一个bug），在开头就描述你的目标，然后才陈述遇到问题的特定步骤。经常出现这种情况，寻求技术帮助的人在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身有问题，结果要费很大的劲才能通过。愚蠢：我怎样才能让某图形程序的颜色拾取器取得十六进制的 RGB 值？明智：我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的 RGB 值。第二种提法是明智的，它使得建议采用更合适的工具以完成任务的回复成为可能。14.别要求私下回复电邮黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为回复者也因为能力和学识被其它同行看到而得到某种回报。当你要求私下回复时，此过程和回报都被中止。别这样做，让 回复者 来决定是否私下回答──如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人毫无意义。对这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么“向我发电邮，我将为论坛归纳这些回复”将是神奇的句子。试着将邮件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你必须信守诺言。15.提问应明确漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人（假如只是因为他们承担了太多工作的话），这些人对于没有止境的时间无底洞极其敏感，所以他们也倾向于讨厌那些漫无边际的问题。如果你明确了想让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力并间接地设定了他们为帮助你需要花费的时间和精力上限，这很好。要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很忙的专家那里得到解答。所以限定你的问题以使专家回答时需要付出的时间最少──这通常与简化问题还不太一样。举个例，“请问可否指点一下哪有好一点的 X 解释？”通常要比“请解释一下 X”明智。如果你的代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。16.关于代码的问题别要求他人给你出问题的代码排错而不提及应该从何入手。张贴几百行的代码，然后说一声“它不能运行”会让你得不到理睬。只贴几十行代码，然后说一句“在第七行以后，本应该显示，但实际出现的是”非常有可能让你得到回复。最精确描述代码问题的方法是提供一个能展示问题的最小测试样例。什么是最小测试样例？它是对问题的展现，只需要刚好能够重现非预期行为的代码即可。如何生成一个最小测试样例？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样例（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源码并去除那些与问题无关的代码段。你能提供的最小测试样例越小越好（参见 量不在多，精炼则灵 ）。生成一个非常小的最小测试样例并不总是可能，但尽力去做是很好的锻练，这有可能帮助你找到需要自己解决的问题。即使你找不到，黑客们喜欢看到你努力过，这将使他们更合作。如果你只是想让别人帮忙审一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。17.别张贴家庭作业式问题黑客们善于发现“家庭作业”式的问题。我们中的大多数人已经做了自己的家庭作业，那是该 你 做的，以便从中学到东西。问一下提示没有关系，但不是要求完整的解决方案。如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户组、论坛或（作为最后一招）在项目的“用户”邮件列表或论坛中提问。尽管黑客们 会 看出来，一些老用户也许仍会给你提示。18.删除无意义的要求抵制这种诱惑，即在求助消息末尾加上诸如“有人能帮我吗？”或“有没有答案？”之类在语义上毫无意义的东西。第一，如果问题描述还不完整，这些附加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如“是的，你可以得到帮助”和“不，没有给你的帮助”。一般来说，避免提“是或否”类型的问题，除非你想得到 “是或否”类型的回答。19.不要把问题标记为“紧急”， 即使对你而言的确如此这是你的问题，不要我们的。宣称“紧急”极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关照。而且“紧急”或其它有类似含义的主题有可能触发垃圾过滤规则，潜在的回复者可能永远看不到你的问题！有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌地提到这点，人们也许会有足够的兴趣快一点回答。当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原因这样做几乎肯定不行。事实上，张贴诸如“紧急：帮我救救这个毛绒绒的小海豹！”肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄懂了再发贴也不迟。20.礼貌总是有益的礼貌一点，使用“请”和“谢谢你的关注”或者“谢谢你的关照”，让别人明白你感谢他们无偿花时间帮助你。坦率地讲，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要（同时也不能替代它们）。黑客们一般宁可读有点唐突但技术鲜明的bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价它的）然而，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。（我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的“提前谢了”，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的建议是要么先说 “提前谢了”，事后 再 对回复者表示感谢，要么换种方式表达，譬如用“谢谢你的关注”或“谢谢你的关照”）。21.问题解决后追加一条简要说明问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比较恰当。最理想的方式是向最初提问的线索回复此消息，并在主题中包含“已解决”、“已搞定”或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见线索 “问题 X”和“问题 X-已解决”的潜在回复者就明白不用再浪费时间了（除非他个人觉得“问题 X”有趣），因此可以利用此时间去解决其它问题。追加的消息用不着太长或太复杂，一句简单的“你好──是网线坏了！谢谢大家──比尔”就比什么都没有要强。事实上，除非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。对于有深度的问题，张贴排错历史的摘要是恰当的。描述问题的最终状态，说明是什么解决了问题，在此之后 才指明可以避免的弯路。应避免的弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。最后，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题叙述到最后不知所终总是令人沮丧的，黑客们痒痒地渴望它们被解决。“挠痒痒”为你挣到的信誉将对你下次再次张贴提问非常非常的有帮助。考虑一下怎样才能避免他人将来也遇到类似的问题，问问自己编一份文档或 FAQ 补丁会不会有帮助，如果是的话就将补丁发给维护者。在黑客中，这种良好的后继行动实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。如何解读回答1.“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸有一个古老而神圣的传统：如果你收到“读读该死的手册”（RTFM） 的回复，发信人认为你应该去“读读该死的手册”。他或她多半是对的，去读一下吧。“读读该死的手册”（RTFM）有个年轻一点的亲戚，如果你收到“搜搜该死的网络”（STFW）的回复，发信人认为你应该“搜搜该死的网络”。那人多半也是对的，去搜一下吧。(更温和一点的说法是“谷歌是你的朋友！”)在论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种关照，提问前应该先搜索一下文档。通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息很容易找到。第二，自已找要比别人喂到嘴里能学得更多。你不应该觉得这样就被冒犯了，按黑客的标准，回复者没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。2.如果还不明白……如果你看不懂回答，不要马上回复一个要求说明的消息，先试试那些最初提问时用过的相同工具（如手册、FAQ、网页、懂行的朋友等）试着搞懂回答。如果还是需要说明，展现你已经明白的。譬如，假如我告诉你：“看起来象是某输入项有问题，你需要清除它”，接着是个 不好 的回帖：“什么是某输入项？”。而这是一个 很好 的跟帖：“是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？”3.对待无礼很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱的人是很自然的。如果你觉得被冒犯了，试着平静地反应。如果有人真的做了过格的事，邮件列表、新闻组或论坛中的前辈多半会招呼他。如果这 没有 发生而你却光火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而 你 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外来者，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。（有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，缺少用于润滑人类社会“正常”交往所需的脑电路。这既可能是真也可能是假。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们 喜欢 现在这个样子，并且一般都对病号标记有站得住脚的怀疑。）在下一节，我们会谈到另一个问题，当 你 行为不当时会受到的“冒犯”。别像失败者那样反应在黑客社区的论坛中有那么几次你可能会搞砸──以本文描述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反，你该这样去做：熬过去，这很正常。事实上，它是有益健康与恰当的。社区的标准不会自己维持，它们是通过参与者积极而 公开 地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称“如果你不想帮助用户就闭嘴”。有思路的参与者纷纷离开的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。是夸张的“友谊”（以上述方式）还是有用？挑一个。记着：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要容易得多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃那样对你。有时候，即使你没有搞砸（或者只是别人想象你搞砸了）， 有些人也会无缘无故地攻击你本人。在这种情况下，报怨倒是 真的 会把问题搞砸。这些找茬者要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些找茬者在给自己找麻烦，这点你不用操心。也别让自己卷入口水战，大多数口水战最好不要理睬──当然，是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其中之后（这也是可能的）。提问禁忌下面是些典型的愚蠢问题和黑客不回答它们时的想法。问：我到哪可以找到某程序或 X 资源？问：我怎样用 X 做 Y？问：如何配置我的 shell 提示？问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？问：我的{程序、配置、SQL 语句}不运行了问：我的视窗电脑出问题了，你能帮忙吗？问：我的程序不运行了，我认为系统工具X有问题问：我安装 Linux 或 X 遇到困难，你能帮忙吗？问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？问：我到哪可以找到某程序或 X 资源？答：在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 谷歌 吗？问：我怎样用 X 做 Y？答：如果你想解决的是 Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对要解决的 Y 问题糊涂，还被特定形势禁锢了思维。等他们把问题弄好再说。问：如何配置我的 shell 提示？答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 “读读该死的手册”（RTFM），然后自己去找出来。问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？答：试试就知道了。如果你试过，你既知道了答案，又不用浪费我的时间了。问：我的{程序、配置、SQL 语句}不运行了答：这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下：你还有什么补充吗？噢，太糟了，希望你能搞定。这跟我究竟有什么关系？问：我的视窗电脑出问题了，你能帮忙吗？答：是的，把视窗垃圾删了，装个象 Linux 或 BSD 的开源操作系统吧。注意：如果程序有官方的视窗版或者与视窗有交互(如 Samba)，你 可以 问与视窗相关的问题，只是别对问题是由视窗操作系统而不是程序本身造成的回复感到惊讶，因为视窗一般来说太差，这种说法一般都成立。问：我的程序不运行了，我认为系统工具 X 有问题答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文档作后盾。问：我安装 Linux 或 X 遇到困难，你能帮忙吗？答：不行，我需要亲手操作你的电脑才能帮你排错，去向当地的 Linux 用户组寻求方便的帮助（你可以在 这里 找到用户组列表）注意：如果安装问题与某 Linux 发行版有关，在针对 它 的邮件列表、论坛或本地用户组织中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 “linux”和 所有 被怀疑的硬件 [作关键词] 仔细搜索。问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？答：想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。好问题与坏问题最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。愚蠢：我在哪能找到关于 Foonly Flurbamatic 设备的东西？这个问题在乞求得到 “搜搜该死的网络”（STFW） 式的回复。明智： 我用谷歌搜索过“Foonly Flurbamatic 2600”，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。愚蠢： 我不能编译某项目的源代码，它为什么这么破？提问者假设是别人搞砸了，太自大了。明智： 某项目的源代码不能在某 Linux 6.2 版下编译。我读了常见问题文档，但其中没有与某 Linux 相关的内容。这是编译时的记录，我做错了什么吗？提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，这家伙值得注意。愚蠢： 我的主板有问题，谁能帮我？某黑客对此的反应可能是：“是的，还需要帮你拍背和换尿布吗？”，然后是敲下删除键。明智： 我在 S2464 主板上试过 X、Y 和 Z，当它们都失败后，又试了 A、B 和 C。注意我试 C 时的奇怪症状，显然某某东西正在做某某事情，这不是期望的行为。通常在 Athlon MP 主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？相反地，这个人看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。在最后那个问题中，注意“给我一个回答”与“请帮我看看我还能再做点什么测试以得到启发”之间细微但重要的差别。事实上，最后那个问题基本上源于 2001 年 8 月 Linux 内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。事后，当我感谢大家并评论这次良好的经历时，一个 Linux 内核邮件列表的成员谈到，他认为我得到答案并不是因为我的名字挂在列表上，而只是因为我正确的提问方式。黑客们在某种方面是非常不留情面的精英分子。我想在这事上他是对的，如果我 表现得 象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。如果得不到回答如果得不到回答，请不要认为我们不想帮你，有时只是因为被问到的小组成员的确不知道答案。没有回复不等于不被理睬，当然必须承认从外面很难看出两者的差别。一般而言，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。有许多在线与本地的用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。还有众多大小商业公司提供签约支持服务，别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。象 Linux 这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。如何更好地回答态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 FAQ 都不知道。如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。如果帮不了忙，别妨碍。 不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。探索性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。尽管对那些懒虫报怨一声“读读该死的手册”（RTFM）是正当的，指出文档的位置（即使只是建议做个谷歌关键词搜索）会更好如果你决意回答，给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。请回答真正的问题！如果提问者已经做了自己该做的研究，并且说明尝试过X，Y，Z，A，B与C都没有得到想要的結果，那么回复“试试A或B” 或者给出一个内容为 “试一下X，Y，Z，A，B或C”的链接将极其无益！帮助你的社区从中学习。当回复一个好问题时，问问自己 “如何修改相关文件或 FAQ 文档以免再次解答同样的问题？”，接着再向文档维护者发一份补丁。如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟“授人以鱼，不如授人以渔”。补充(XY Problem)：1.What is it?The XY problem is asking about your attempted solution rather than your actual problem. This leads to enormous amounts of wasted time and energy, both on the part of people asking for help, and on the part of those providing help.User wants to do X.User doesn’t know how to do X, but thinks they can fumble their way to a solution if they can just manage to do Y.User doesn’t know how to do Y either.User asks for help with Y.Others try to help user with Y, but are confused because Y seems like a strange problem to want to solve.After much interaction and wasted time, it finally becomes clear that the user really wants help with X, and that Y wasn’t even a suitable solution for X.The problem occurs when people get stuck on what they believe is the solution and are unable step back and explain the issue in full.2.What to do about it?Always include information about a broader picture along with any attempted solution.If someone asks for more information, do provide details.If there are other solutions you’ve already ruled out, share why you’ve ruled them out. This gives more information about your requirements.Remember that if your diagnostic theories were accurate, you wouldn’t be asking for help right?]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解事件]]></title>
    <url>%2F2019%2F02%2F18%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件：事件是用户或浏览器自身执行的某种动作，如 click,load 和mouseover 都是事件的名字。响应某个事件的函数叫做事件处理函数 / 事件处理程序 / 事件句柄。如果想要绑定多个函数，则需要用到事件监听器。1. 事件绑定的几种方式javascript 给 DOM 绑定事件处理函数总的来说有2种方式：在 html 文档中绑定、在 js 代码中绑定。下面的方式1、方式2属于在 html 中绑定事件，方式3、方式4和方式5属于在js代码中绑定事件，其中，方式4和5属于事件监听，而方式5是最推荐的做法。1）在html文档中绑定方式1：&lt;input type="button" id="btn" onclick="函数名( )"> 方式2：&lt;input type="button" id="btn" onclick="直接写函数内容"> 2）在js代码中绑定方式3：document.getElementById("btn").onclick=function( ){ }; 说明：方式3也称为“DOM0级事件处理程序”。它无法绑定多个事件，当绑定多个事件的时候，只有最后一个会生效，其他皆被覆盖）方式4：[object].attachEvent(“事件类型”,”处理函数”)说明：①方式4也称为“IE事件处理程序”。这种方法不属于w3c标准，并且仅IE8及以下支持该方法；②事件类型要加on；③如下图，b中声明a函数时分配了一块内存地址 ，两个dom.attachEvent(&#39;onclick&#39;,a)中的a都指向的是下面定义的a；c中只是两个函数体一样的匿名函数，分别有各自的内存地址，故认为是两个不同的函数对象方式5：[object].addEventListener(“事件类型”,”处理函数”,”冒泡事件或捕获事件”);说明：①方式5也称为“DOM2级事件处理程序”。w3c正统标准，IE9及以上、Chrome、Firefox等支持该方法；②事件类型不加on；③第三个参数不设置的时候，默认为false即冒泡；④ 同一个事件处理函数可以绑定2次,一次用于事件捕获，一次用于事件冒泡；如果绑定的是同一个事件处理函数，并且都是事件冒泡类型或者事件捕获类型，那么只能绑定一次；⑤ 不同的事件处理函数可以重复绑定，这点与上面attachEvent是一样的2. 事件处理函数的执行顺序方式123都不能实现事件的重复绑定，所以自然也就不存在执行顺序的问题。方式4和方式5可以重复绑定特性，所以需要了解下执行顺序的问题。结论：对于addEventListener，如果给目标的同一个事件绑定多个处理函数，先绑定的先执行。 attachEvent则刚好相反，后绑定的先执行，这是因为采用attachEvent的是IE8-，而IE8-是不支持dom事件流模型的。&lt;script> window.onload = function(){ var outA=document.getElementById("outA"); outA.addEventListener('click',function(){alert(1);},false); outA.addEventListener('click',function(){alert(2);},true); outA.addEventListener('click',function(){alert(3);},true); outA.addEventListener('click',function(){alert(4);},true); }; &lt;/script> &lt;body> &lt;div id="outA"> &lt;/div> &lt;/body> 当点击outA的时候，会依次打印出1、2、3、4。这里特别需要注意：我们是同时给outA这个元素绑定了多个onclick事件处理函数，没有涉及父子元素，所以也不涉及事件冒泡和事件捕获的问题，即addEventListener的第三个参数在这种场景下，没有什么用处，直接忽略之。如果是通过事件冒泡或者是事件捕获触发outA的click事件，那么函数的执行顺序会有变化。3. 事件捕获和事件冒泡我们知道HTML中的元素是可以嵌套的，形成类似于树的层次关系。比如下面的代码：&lt;div id="outA"> &lt;div id="outB"> &lt;div id="outC">&lt;/div> &lt;/div> &lt;/div> 如果点击了最内侧的outC，那么外侧的outB和outC算不算被点击了呢？很显然算，不然就没有必要区分事件冒泡和事件捕获了，这一点各个浏览器厂家也没有什么疑义。假如outA、outB、outC都注册了click类型事件处理函数，当点击outC的时候，触发顺序是A–&gt;B–&gt;C，还是C–&gt;B–&gt;A呢？如果浏览器采用的是事件冒泡，那么触发顺序是C–&gt;B–&gt;A，由内而外，像气泡一样，从水底浮向水面；如果采用的是事件捕获，那么触发顺序是A–&gt;B–&gt;C，从上到下，像石头一样，从水面落入水底。一般来说事件冒泡机制用的更多一些，所以在IE8以及之前，IE只支持事件冒泡。IE9+/FF/Chrome这2种模型都支持，可以通过addEventListener的第三个参数来设定，false代表事件冒泡，true代表事件捕获。&lt;script> window.onload = function(){ var outA = document.getElementById("outA"); var outB = document.getElementById("outB"); var outC = document.getElementById("outC"); // 使用事件冒泡 outA.addEventListener('click',function(){alert(1);},false); outB.addEventListener('click',function(){alert(2);},false); outC.addEventListener('click',function(){alert(3);},false); }; &lt;/script> &lt;body> &lt;div id="outA"> &lt;div id="outB"> &lt;div id="outC">&lt;/div> &lt;/div> &lt;/div> &lt;/body> 使用的是事件冒泡，当点击outC的时候，打印顺序是3–&gt;2–&gt;1。如果将false改成true使用事件捕获，打印顺序是1–&gt;2–&gt;3。4. DOM事件流4.1 事件流定义：事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点与根节点之间按照特定的顺序如流水一样传播，路径所经过的所有节点都会收到该事件，这个传播过程即事件流。4.2 事件流模型：事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即由内到外捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即由外到内4.3 DOM事件流：4.3.1 dom事件流定义：DOM标准采用捕获+冒泡的DOM事件流。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。4.3.2 dom事件流包括：DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。事件捕获阶段：实际目标(&lt;div&gt;)在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。上图中为1~3.处于目标阶段：事件在&lt;div&gt;上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。冒泡阶段：事件又传播回文档。4.3.3 dom事件流与冒泡、捕获将DOM事件流看作整个过程，那么其实 useCapture=false意味着：将该事件处理函数加入到冒泡阶段，在冒泡阶段会被调用；useCapture=true意味着：将该事件处理函数加入到捕获阶段，在捕获阶段会被调用。从DOM事件流模型可以看出，捕获阶段的事件处理函数，一定比冒泡阶段的事件处理函数先执行。4.3.4 dom事件流的相关概念1） target:触发事件的某个具体对象，固定不变的。2） currentTarget:绑定事件的对象，恒等于this，可能出现在事件流的任意一个阶段中。动态变化的。控制台：点击最里面的son3后，可以看到target一直不变，而由于冒泡，导致currentTarget动态变化。3） 两者的应用场合通常情况下target和currentTarget是一致的，我们只要使用terget即可，但有一种情况必须区分这三者的关系，那就是在父子嵌套的关系中，父元素绑定了事件，单击了子元素（根据事件流，在不阻止事件流的前提下他会传递至父元素，导致父元素的事件处理函数执行），这时候currentTarget指向的是父元素，因为他是绑定事件的对象，而target指向了子元素，因为他是触发事件的那个具体对象PS：注意！！！并非所有的事件都会经过冒泡阶段 。所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。5. DOM事件流中的“事件处理函数的执行顺序”我们回头再来说事件处理函数的执行顺序。点击outC的时候，打印顺序是 :capture1–&gt;capture2–&gt;target2–&gt;target1–&gt;bubble2–&gt;bubble1。由于outC是我们触发事件的目标对象，在outC上注册的几个事件处理函数都属于DOM事件流中的目标阶段。对同一个绑定对象（这里是outC）而言，同处于目标阶段的多个函数的执行顺序：先注册的先执行，后注册的后执行。这就是上面我们说的，在目标对象（outC）上绑定的函数是采用捕获，还是采用冒泡，都没有什么关系，因为冒泡和捕获只是对父元素上的函数执行顺序有影响，对自己没有什么影响。至此我们可以给出事件函数执行顺序的结论了：捕获阶段的处理函数最先执行，其次是目标阶段的处理函数，最后是冒泡阶段的处理函数。目标阶段的处理函数如果有多个，则先注册的先执行，后注册的后执行。6. 阻止事件冒泡和捕获默认情况下，多个事件处理函数会按照DOM事件流模型中的顺序执行。如果子元素上发生某个事件，不需要执行父元素上注册的事件处理函数，那么我们可以停止捕获和冒泡，避免没有意义的函数调用。前面提到的5种事件绑定方式，都可以实现阻止事件的传播。由于第5种方式，是最推荐的做法。所以我们基于第5种方式，看看如何阻止事件的传播行为。注意：IE8以及IE8之前可以通过 window.event.cancelBubble=true阻止事件的继续传播；IE9+/FF/Chrome通过event.stopPropagation()阻止事件的继续传播。当点击outC的时候，打印出capture–&gt;target，不会打印出bubble。因为当事件传播到outC上的处理函数时，通过stopPropagation阻止了事件的继续传播，所以不会继续传播到冒泡阶段。想要在哪个节点阻止传播，就在哪个节点的事件处理函数中添加stopPropagation，记得要传参。7. 事件代理/事件委托7.1 概述：事件委托又叫事件代理。JavaScript高级程序设计上讲:事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。我们可以用取快递的例子来理解这个东西。假设：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台也会在收到寄给新员工的快递后核实并代为签收。这里其实还有2层意思的：第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；第二，新员工也是可以被前台代为签收的，即程序中新添加的dom节点也是有事件的。7.2 为什么要使用事件委托：简单来说，就是为了减少不必要的dom操作，优化性能。一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了。比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢？如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，自然性能就会更好。7.3 事件委托的原理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。7.4 事件委托如何实现：终于到了本文的核心部分了。在介绍事件委托的方法之前，我们先来看例一：需求：不管点击哪个li，都能弹出123：&lt;ul id="ul1"> &lt;li>111&lt;/li> &lt;li>222&lt;/li> &lt;li>333&lt;/li> &lt;li>444&lt;/li> &lt;/ul> window.onload = function(){ var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); for(var i=0;i&lt;aLi.length;i++){ aLi[i].onclick = function(){ alert(123); } } } 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作:首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；那么我们用事件委托的方式做又会怎么样呢？window.onload = function(){ var oUl = document.getElementById("ul1"); oUl.onclick = function(){ alert(123); } } 我们让父级ul监听点击事件，则不管是哪个li被点击————由于冒泡原理，事件最终都会冒泡到ul上，触发ul上的点击事件，弹出123。当然，这里当点击ul的时候，也是会触发的。那么问题就来了，如果我想让事件代理的效果跟直接给某个指定的节点的事件效果一样怎么办？比如说只有点击li才会触发，不怕，我们有绝招：事件本身是一个对象，即Event对象，事件发生时该对象作为参数传给回调函数。而Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称之为事件源.也就是说，target可以表示为当前的事件直接操作的那个dom。当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：window.onload = function(){ var oUl = document.getElementById("ul1"); oUl.onclick = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li'){ alert(123); alert(target.innerHTML); } } } 这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？请看例二：&lt;div id="box"> &lt;input type="button" id="add" value="添加" /> &lt;input type="button" id="remove" value="删除" /> &lt;input type="button" id="move" value="移动" /> &lt;input type="button" id="select" value="选择" /> &lt;/div> window.onload = function(){ var Add = document.getElementById("add"); var Remove = document.getElementById("remove"); var Move = document.getElementById("move"); var Select = document.getElementById("select"); Add.onclick = function(){ alert('添加'); }; Remove.onclick = function(){ alert('删除'); }; Move.onclick = function(){ alert('移动'); }; Select.onclick = function(){ alert('选择'); } } 上面实现的效果很简单，4个按钮对应4个不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？window.onload = function(){ var oBox = document.getElementById("box"); oBox.onclick = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == 'input'){ switch(target.id){ case 'add' : alert('添加'); break; case 'remove' : alert('删除'); break; case 'move' : alert('移动'); break; case 'select' : alert('选择'); break; } } } } 可见，用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？请看例三：我们的需求是是：①移入li，li变红，移出li，li变白②对于点击按钮后新增的li节点，仍然具有该效果。以下是正常的方法：&lt;input type="button" name="" id="btn" value="添加" /> &lt;ul id="ul1"> &lt;li>111&lt;/li> &lt;li>222&lt;/li> &lt;li>333&lt;/li> &lt;li>444&lt;/li> &lt;/ul> window.onload = function(){ var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++){ aLi[i].onmouseover = function(){ this.style.background = 'red'; }; aLi[i].onmouseout = function(){ this.style.background = '#fff'; } } //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); }; } 你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去——这是因为li遍历这一动作发生在新增li这一动作之前，在那个时候已经确定了li的个数是4，因此只绑定了4个li。这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环封装在一个函数里，命名为mHover，如下：window.onload = function(){ var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; function mHover () { //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++){ aLi[i].onmouseover = function(){ this.style.background = 'red'; }; aLi[i].onmouseout = function(){ this.style.background = '#fff'; } } } mHover (); //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); mHover (); }; } 与上面方法不同的是，这个方法没有在新增li之前就为原有li绑定事件，而是在新增li后遍历所有的li（包括新增li），并一起绑定事件。虽然功能实现了，看着还挺好，但实际上无疑又增加了一个dom操作，在优化性能方面是不可取的，那么用事件委托的方式，能做到优化吗？window.onload = function(){ var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li'){ target.style.background = "red"; } }; oUl.onmouseout = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li'){ target.style.background = "#fff"; } }; //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); }; } 如上，新添加的节点是带有事件效果的。根据事件冒泡原理，不管是原有li还是新增li，只要鼠标一移入li中就等同于鼠标移入ul中，自然会触发ul的鼠标移入事件，之后我们只要在ul的事件函数中定义相关行为就可以了。我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了。这样可以大大的减少dom操作，这才是事件委托的精髓所在。7.5 总结：那什么样的事件可以用事件委托，什么样的事件不可以用呢？适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，至于focus，blur之类的就更不用说了，本身就没有冒泡的特性，自然就不能用事件委托了。8 事件对象8.1 认识事件对象事件在浏览器中是以对象的形式存在的，即event对象。触发一个事件，就会产生一个event对象，该对象包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如：鼠标操作产生的event中会包含鼠标位置的信息；键盘操作产生的event中会包含与按下的键有关的信息。所有浏览器都支持event对象，但支持方式不同，在DOM中event对象必须作为唯一的参数传给事件处理函数，在IE中event是window对象的一个属性。8.2 html事件处理程序中的事件对象&lt;input id="btn" type="button" value="click" onclick=" console.log('html事件处理程序'+event.type)"/> 这样会创建一个包含局部变量event的函数。可通过event直接访问事件对象。8.3 DOM中的事件对象DOM0级和DOM2级事件处理程序都会把event作为参数传入。参数命名：随便。习惯上用e，或者ev或者event。&lt;body> &lt;input id="btn" type="button" value="click"/> &lt;script> var btn=document.getElementById("btn"); btn.onclick=function(event){ console.log("DOM0 &amp; click"); console.log(event.type); //click } btn.addEventListener("click", function (event) { console.log("DOM2 &amp; click"); console.log(event.type); //click },false); &lt;/script> &lt;/body> DOM中事件对象的重要属性和方法。属性：type属性，用于获取事件类型target属性，用于获取事件直接作用的目标（更具体target.nodeName）currentTarget属性，用于获取事件实际绑定的目标方法：stopPropagation()方法,用于阻止事件冒泡preventDefault()方法,阻止事件的默认行为 移动端用的多8.4 IE中的事件对象第一种情况： 通过DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。&lt;body> &lt;input id="btn" type="button" value="click"/> &lt;script> var btn=document.getElementById("btn"); btn.onclick= function () { var event=window.event; console.log(event.type); //click } &lt;/script> &lt;/body> 第二种情况：通过attachEvent()添加的事件处理程序，event对象作为参数传入。&lt;body> &lt;input id="btn" type="button" value="click"/> &lt;script> var btn=document.getElementById("btn"); btn.attachEvent("onclick", function (type) { console.log(event.type); //click }) &lt;/script> &lt;/body> IE中事件对象的重要属性和方法:属性：type属性，用于获取事件类型(一样)srcElement属性，用于获取事件直接作用的目标（更具体srcElement.nodeName）cancelBubble属性，用于阻止事件冒泡。IE中cancelBubble为属性而不是方法，true表示阻止冒泡。returnValue属性，阻止事件的默认行为。false表示阻止事件的默认行为PS：targrt和srcElement的兼容性处理如下//兼容性处理 function showMsg(event){ event=event||window.event; //IE8以前必须通过window获取event，DOM中就是个简单的传参 var ele=event.target || event.srcElement; //获取目标元素，DOM中用target,IE中用srcElement alert(ele); } 参考链接：https://blog.csdn.net/aitangyong/article/details/43231111http://www.cnblogs.com/starof/p/4066381.htmlhttps://www.cnblogs.com/liugang-vip/p/5616484.htmlhttp://www.cnblogs.com/starof/p/4077532.html]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>dom事件流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于dom对象和jq对象的疑问]]></title>
    <url>%2F2019%2F02%2F18%2FF-%E5%85%B3%E4%BA%8Edom%E5%AF%B9%E8%B1%A1%E5%92%8Cjq%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%96%91%E9%97%AE%2F</url>
    <content type="text"><![CDATA[1.问题：1.1 问题提出：想要使所有div下的p标签的类名+1.因此采用下列办法： &lt;div> &lt;p class="1">1&lt;/p> &lt;p class="2">2&lt;/p> &lt;p class="3">3&lt;/p> &lt;p class="4">4&lt;/p> &lt;p class="5">5&lt;/p> &lt;/div> &lt;script src="https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js">&lt;/script> &lt;script> var allp=$("div p"); for(var i=0;i&lt;allp.length;i++){ allp[i].attr("class","i+2"); console.log(allp[i].attr("class")); } &lt;/script> 结果控制台报错：提示allp[i].attr()不是一个方法，而attr()是jq对象的方法，这个报错等于说allp[i]不是一个jq对象。参考stackoverflow ，可知$()[i]返回的的确不是jq对象，而是原生dom对象，无法使用jq方法attr() 。关于如何判断是jq对象还是dom对象，可以用常用的instanceof方法判断，也可以用只有jq对象才有的jquery属性结合if语句判断。那么，如何用jq实现上述功能？1.2 问题解决：1）转化为jq对象for(var i=0;i&lt;allp.length;i++){ $(allp[i]).attr("class",i+2); } allp[i]放在$()中则为jq对象2).eq(i)for(var i=0;i&lt;$("div p").length;i++){ $("div p").eq(i).attr("class",i+2) 。 } 这是因为jq collection 对象的eq()方法将返回以参数值为索引值的单个元素.3).each遍历$("div p").each(function(){ $(this).attr("class",$(this).index()+2); }) 当然，因为each()本身可以传参，因此可以写成$("div p").each(function(i, n){ $(this).attr("class",i+2); }) 其中，i表示index，n表示当前元素（可用this操作）4).或者更简单的，配合回调函数使用for(var i=0;i&lt;$("div p").length;i++){ $("div p").attr("class"，function(i,n){ n=+2; }) } 以上是个错误的例子。jq本身可以隐式迭代，所以这里的for循环完全是多余的，加了for循环反而是错的。隐式迭代：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用在attr中将回调函数作为参数时，回调函数本身接受两个参数。具体到例子中，i为index，n为当前元素的当前值，也就是类名，这里的类名虽然为1到5，但是是string而不是number，所以需要用number( )进行类型转换才可以运算。n最后必须return。综上，正确代码为var allp=$("div p"); allp.attr("class",function(i,n){ return Number(n)+1; }); each( )遍历，控制台打印 allp.each(function(){ console.log(this); }); 2 对象转换：顺便这里总结下jq对象和dom对象的互相转换。我们知道，dom对象只能用dom对象自己的方法，jq对象只能用jq对象自己的方法，因此有时候如果jq对象必须使用原生方法时（或者反过来），就需要进行对象转换。2.1 jq对象 = &gt; dom对象var $div=$(".div"); //jq对象 // 或者加索引值返回dom对象单体 var div=$div[0]; // 调用get()方法返回dom对象单体 var div=$div.get(i); 2.2 dom对象 = &gt; jq对象var div=documnet.getElementsByClassName("div"); //dom对象 // 直接用$()把dom对象给包装起来 var $div=$(div); // 如果需要，可以用eq()返回jq对象单体 // $div.eq(i);]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量命名规范]]></title>
    <url>%2F2019%2F02%2F12%2FF-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[一、驼峰命名法：①全部小写：变量名中的每一个逻辑断点/每个单词都用下划线隔开。比如：print_employee_paychecks()；②大小写混合：1）小驼峰法：变量一般用小驼峰法标识。第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstName、myLastName2）大驼峰法/帕斯卡命名法（Upper Camel Case/pascal）：常用于类名，函数名，属性，命名空间。相比小驼峰法，大驼峰法把第一个单词的首字母也大写了。例如：DataBaseUser二、匈牙利命名法：基本原则是：变量名=类型+对象描述。匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等。这些符号可以多个同时使用，顺序是先m_（成员变量），再指针，再简单数据类型，再其他。例如：m_lpszStr, 表示指向一个以0字符结尾的字符串的长指针成员变量。匈牙利命名法中常用的小写字母的前缀：前缀 类型a – – — – – —— —————– 数组 (array)b ———————————- 布尔值 (boolean)by———————————- 字节 (byte)c ———————————- 有符号字符 (char)cb ————————– 无符号字符 (char Byte，没有多少人用)cr ———————————- 颜色参考值 (colorRef)fn ———————————- 函数 （function）fl ———————————- 浮点（float）h ———————————- 句柄（handle）i ———————————- 整型 （int）l ———————————- 长整型 (long Int)lp———————————- 长指针（long Pointer）m ———————————- 类的成员 （member）n———————————- 短整型 (short Int)np ———————————- 近指针（near Pointer）o ———————————- 对象（object）p ———————————- 指针（pointer）re ——————————— 正则（regular expression）s ———————————- 字符串型 （string）sz ————————— 以null做结尾的字符串型 (String with Zero End)]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null 和 undefined]]></title>
    <url>%2F2019%2F02%2F12%2FF-null%E5%92%8Cundefined%2F</url>
    <content type="text"><![CDATA[一. undefined在变量声明中的体现：1）声明了、但是没有初始化的变量：var aa; alert(aa);浏览器会弹出窗口显示 undefined。因为对于使用了 var 声明但没有进行初始化定义的变量, 其值默认为 undefined。2） 未声明的变量(1)：alert(aa);浏览器不会弹出任何东西. 因为 aa 是没有声明的变量。打开 chrome 浏览器的控制台会看到报错如下：3）未声明的变量(2)：alert(typeof aa);浏览器会弹出窗口显示 undefined。对于没有声明的变量, 只能执行一种操作，即使用 typeof 操作符检验它的类型.。它的类型和声明了但没有进行初始化的变量的类型一样, 都是 undefined.二. null和undefined：alert(undefined == null); // 返回 true 对于 undefined 和 null 的相等性测试，返回 true,如上图。这是因为，undefined 是由 null 派生而来的。但是，这两者差别很大，之所以要设置两个值，让我们从历史原因说起吧1）历史原因：1995年js诞生时，最初像Java一样，只设置了 null 作为表示”无”的值。根据C语言的传统， null 被设计成可以自动转为0。但是，JavaScript的设计者 Brendan Eich，觉得这样做还不够，有两个原因。首先， null 像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象；其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果 null 自动转为0，很不容易发现错误。因此，Brendan Eich又额外设计了一个 undefined。2）最初设计：JavaScript的最初版本是这样区分的： null 是一个表示”无”的对象，转为数值时为0；undefined 是一个表示”无”的原始值，转为数值时为 NaN。Number(undefined) // NaN 5 + undefined // NaN 3）目前的用法：但是，上面这样的区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。① nullnull 是基本数据类型之一，值仅有一个，即为 null。表示”空对象”(因此类型检测返回对象)，即如果有对象，就会是一个具体的对象，如果没对象，就是 null。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。Object.getPrototypeOf(Object.prototype) // null typeof null // object 如果定义的变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子：if(abc != null){ //对abc执行某些操作 } ② undefinedundefined 是基本数据类型之一，值仅有一个，即为 undefined。表示”缺少值”(因此类型检测返回 undefined)，即此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于 undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于 undefined。（3）对象没有赋值的属性，该属性的值为 undefined。（4）函数没有返回值时，默认返回 undefined。var i; i // undefined function f(x){console.log(x)}f() // undefined var o = new Object(); o.p // undefined var x = f(); var exp = undefined; 8x // undefined ③ 如何检测某个变量是 undefined：错误的用法：if(abc==undefined) // 正如上面所说，js规定用`==` 判断时，null和undefined是等同的 正确的用法：if (typeof(abc) `==` "undefined") 或者最简单的办法： if(abc===undefined) 注意！！！ type的用法有运算符形式和函数形式，即if (typeof(abc) == “undefined”) 和 if (typeof abc == “undefined”) 效果是一样的。另外，由于typeof会返回诸如”number”的字符串形式的结果，因此==的右操作数应注意加双引号表示字符串。④ 如何检测某个变量是null：错误的用法：1、if(abc == null) // 解释同上。不过：要判断abc是 null 或者 undefined 时可使用本法。 2、if (!abc) // 这个的原理是：abc为假值，则 ! abc为真值，条件成立。然而，假值也可能是undefined，0 或 false。不过：要判断 abc是null、undefined、0 或者false 时可使用本法。 3、if(typeof abc == "null") // 为了向下兼容，abc 为 null 时，typeof null 总返回 object，所以不能这样判断。 4、if (isNull(abc)) // VBScript 中有 IsNull 这个函数，但 JavaScript 中没有。 正确的用法：1、if (! abc &amp;&amp; typeof abc != "undefined" &amp;&amp; abc != 0) // 这个的原理是：如果！abc 成立，则 abc 为假值，则 abc 要么是undefined，0，false或者null 。typeof abc!= "undefined" 排除了 undefined；exp != 0 排除了0 和 false （0= =false，0= =0）。所以，abc一定是剩下的null。 2、最简单的方法： if (abc=== null) 尽管如此，我们在 DOM 应用中，一般只需要用 (!abc) 来判断就可以了，因为 DOM 应用中，可能返回 null，可能返回 undefined，如果具体判断 null 还是 undefined 会使程序过于复杂。三. 测试对象是否存在：在 JavaScript 中,null 用于对象, undefined 用于变量，属性和方法。对象只有被定义才有可能为 null，否则为 undefined。因此，如果我们想测试对象是否存在，必须先检测对象是否已定义。因此，这是错误的：if (abc !== null &amp;&amp; typeof abc !== &quot;undefined&quot;)这是正确的：if (typeof abc !== &quot;undefined&quot; &amp;&amp; abc!== null)]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英伦摇滚入门：20支英国摇滚乐队]]></title>
    <url>%2F2019%2F02%2F11%2FM-%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F%2F</url>
    <content type="text"><![CDATA[之前看到的一篇关于英国摇滚乐队的总结。还挺好的，不全是英伦摇滚。排名不分先后，当然，我还是偏爱Oasis。1. The Beatles（披头士乐队/甲壳虫乐队）这支才华横溢的英国乐队就不用多说了，几乎是英国摇滚的代名词，屹立半个世纪不倒，他们的作品现在还传颂世界。The Beatles（披头士乐队）虽然早已不复存在，但是他们却奠定了英式摇滚的基本基调，在国际音乐界享有盛誉。他们的贵族式的优雅反击直击摇滚的核心精神：为普通人发出声音和呐喊。爱和自由、反战是披头士永恒的创作主题。披头士有两位灵魂人物，一位是John Lennon（约翰·列侬），一位是James Paul McCartney（保罗·麦卡特尼）。喜欢这支乐队的朋友可以看看乐评《最爱那一世的疯狂——“披头士热”下的英伦风情》经典专辑：《Sergeant Pepper’s Lonely Hearts Club Band》、《Abbey Road》、《Let It Be》、《Rubber Soul》、《Help!》2. The Rolling Stones（滚石乐队）The Rolling Stones（滚石乐队）是一支非常长寿的英国摇滚乐队，一直活跃在英国的摇滚乐坛，他们和披头士分庭抗礼，代表着两种不同的摇滚理念：披头士是温和的、优雅的，而滚石则是纯粹的、爆裂性的。滚石乐队成员的平均年龄已经超过了70岁，堪称英国摇滚界的活国宝，他们身先士卒证明了什么叫“老骥伏枥，志在千里”。几个“老头子”处处践行着不服老的摇滚心态，依然能够在舞台上大放光彩，不断推出新作，这才是真正的摇滚精神！绝对的硬摇滚，粗放豪气的摇滚范儿，祝福这支长寿的乐队！经典专辑：《Let It Bleed》、《Beggars Banquet》、《Exile On Main Street》3. The Who（谁人乐队）作为“布兰顿之声”的The Who（谁人乐队），他们代表着反叛与反主流的音乐风格，他们是MOD文化的代言人，四人个性放荡不羁，反叛而激进，为青年而歌，为底层人民而歌。正是The who发明了摇滚乐的砸琴砸摔鼓的表演风格，他们是纯粹硬摇乐队，是反叛的象征，他们的舞台表演风格为后世许多的摇滚乐队所模仿。The Who创造了许多的经典歌曲，至今无人能够超越。经典专辑：《Who’s Next》、《Tommy》、《My Generation》4. The Police（警察乐队）想听慢摇风格的乐迷看过来，这支乐队非常具有传奇色彩，他们靠着借贷创作的第一张专辑就大卖一万多张。他们的乐队风格有一种华丽的英式抒情的感觉，感觉主唱的爆破音特别重，他们的歌曲特别有感染力，另外主唱Sting还会唱西班牙语，非常多才多艺。这支乐队只有三个人，但是曾经获得了六次格莱美奖，乐队在义演散场之后宣布告别，但是灵魂人物Sting现在还活跃在英国乐坛之上，还多次斩获格莱美。经典专辑：《Regatta de Blanc》、《Zenyatta Mondatta》、《Wrapped Around Your Finger》5. Pink Floyd（平克·弗洛伊德）大PF是必须要说的，促使我去了解英国摇滚乐队的就是披头士和Pink Floyd（平克·弗洛伊德）了，PF不算是那种非常有盛誉的那种乐队，但是我就是喜欢。他们的音乐充满哲学的思辨气质和浪漫主义的想象力，专辑的艺术感极强，尤其是他们开创的太空迷幻摇滚，简直是致幻的LSD，令人沉醉其中不能自拔。他们在音乐技术上的突破和对迷幻摇滚新领域的开辟，都在音乐史上不可被磨灭，这支乐队有一支长达23分钟的神奇的单曲——《Echoes》，号称一曲走天下，他们的《月之暗面》（The Dark Side of The Moon）和《迷墙》（The Wall）两张专辑永垂不朽。某种程度上来说，我甚至觉得他们是一支被低估了的乐队。经典专辑：《The Wall》、《The Dark Side of the Moon》、《Ummagumma》6. Sex Pistols（性手枪乐队）要说到英国的朋克摇滚，就必须要说到Sex Pistols，在1976年，性手枪参加了伦敦牛津The 100俱乐部举办的朋克音乐节，至今这个节日还被认为是朋克文化的发源地。这是一支真正的朋克乐队，有人甚至评价道：“性手枪之后再无朋克”，如果你去听了他们的音乐，就会发现这是真的。他们的音乐充满了黑色幽默和调侃，歇斯底里的反叛甚至是下流的感觉，但这就是真正的朋克精神——彻底的毁灭与自我毁灭。他们的歌曾经登上了BBC排行榜榜首，让全英国人民都为朋克摇旗呼喊，让朋克文化高涨兴盛。但是这支乐队好景不长，他们连换了三个唱片公司，但乐队成员相继离开，最终没落令人十分惋惜。经典专辑：《Jubilee》、《Never Mind the Bollocks Here’s the Sex Pistols》7. The Clash（碰撞乐队/冲击乐队/冲撞乐队）与性手枪相比，The Clash并不算是真正的朋克乐队，因为他们后期逐渐商业化，但是The Clash前期对朋克摇滚做出了巨大的贡献。他们的首张同名专辑就一炮成名，被封为朋克圣典。但是后期的碰撞乐队逐渐吸收了许多的流行摇滚的元素，他们的MTV商业运作得很好。The Clash与Sex Pistols一起铸就了朋克乐队的高峰。碰撞关注社会底层人民的生活状况，他们的歌曲里面充满了对失业、种族歧视和黑帮犯罪势力的反抗和控诉，而且碰撞乐队在美国市场上还比较成功，让英国朋克摇滚名声在外。经典专辑：《London Calling》、《The Clash》、《Black Market Clash》8. Iron Maiden（铁娘子乐队）重金属恶魔的铁娘子乐队！生猛的铁娘子！牛逼的铁娘子！正是他们开启了英国的重金属浪潮。他们是一支霸气的重金属乐队，乐队几经分合，但是做了很多的音乐新领域的尝试，他们做了很多摇滚器乐实验，奠定了铁娘子在重金属领域中的地位。Iron Maiden的曲风非常硬朗，听得人情绪高涨，不自觉地High，主唱的声音简直是绝对的歇斯底里，他们的吉他行云流水，贝斯出神入化，想感受下重金属激情的迷妹一定要去听一下，没听过他们你都不好意思说你听过重金属。经典专辑：《Killers》、《Piece Of Mind》、《Iron Maiden》、《Number of the Beast》9. Def Leppard（威豹乐队）威豹也是英国重金属新浪潮中一支非常重要的乐队，这支乐队70年代末期组建，80年代成名，他们在硬摇滚上造诣很高。80-90年代期间是他们商业最成功的阶段，在美国都具有广泛的影响力。威豹也不是那种纯粹的重金属乐队，他们的情歌非常的好听感人，主唱Joe Elliott的声音是略带沧桑的沙哑，这些摇滚汉子唱起情歌分分钟秒杀你的心灵。另外乐队的长发造型很酷炫，而且他们是双吉他演奏，节奏非常动人优美。这个乐队最令人感动的是鼓手，只有一条手臂还怀着一颗坚毅的心重返乐队，我很敬佩这样牛逼的音乐人。另外他们的合声也是相当美丽的，很少有摇滚乐队合声如此好听，默契到位又流畅自然，分分钟刷新你的重金属三观。经典专辑；《Best of Def Leppard》、《Hysteria》、《Retro Active》10. Suede（山羊皮乐队）Suede（山羊皮乐队）在90年代非常受欢迎，一开始这支乐队其实是倍受质疑的，后来才受到了大众的喜爱。他们的风格是另类摇滚和英式摇滚。这和当时的摇滚大环境有关，90年代，英国传统摇滚乐的巅峰已经接近末声，演化出了英式摇滚，Suede其实就是这些乐队之一。他们的风格比较邪魅狂绢，充满了一种癫狂和风情万种的艺术气质，主唱的声音听多了会怀孕的。山羊皮对华挺友好的，曾经来过中国演出。还有令无数歌迷沉醉的还有主唱的颜值——他年轻的时候简直帅呆了！经典专辑：《The Drowners》、《Suede》、《Coming Up》、《Head Music》11. Oasis（绿洲乐队）Oasis（绿洲乐队）组建于曼彻斯特，是一支个性狂放的乐队，这和乐队的两兄弟的性格有关系。这支乐队最好的地方在于结合了流行摇滚与传统摇滚，传承了传统摇滚的精髓，乐评家非常钟爱这支乐队，对他们给予很高的评价。一说到英式摇滚人们首先会想到就是绿洲，其次是Blur，他们的吉他简直是神了，奠定了英式摇滚的吉他抒情风格。但是他们也叛逆咆哮，这完全不同于像披头士那样的“乖小孩”，自带一种粗犷的摇滚天性。经典专辑：《Definitely Maybe》、《Morning Glory》12. Radiohead（电台司令乐队）Radiohead（电台司令）是那种让人绝望抑郁至死的乐队，个人觉得偶尔听一下还是不错啦。这支乐队的评价还是蛮好的，他们的风格很沉郁，在歌词的创作上独具匠心。灵魂人物兼主唱Yorke性格敏感脆弱，他们的作品里充满了一种病态美学的美感，吟唱人性最卑微脆弱之处，像《Creep》这种就是他们风格的集大成之作，这种风格在摇滚乐队里是比较少见的。经典专辑：《The Bends》、《OK Computer》、《 Kid A 》13. Muse（缪斯乐队）多元的音乐风格、对英式摇滚拿捏到刚刚好的新生代英国摇滚乐队。融合重金属、电子音乐、前卫音乐、太空摇滚等等元素。更难得的是，从缪斯的歌曲里你还能听出千丝万缕的英国古典音乐气息，就像灵魂一样穿插在乐曲之中，非常特别，这在英国这样一个复古气息非常浓厚的国家非常有代表性，所以我认为他们的英式摇滚的头衔是应得的。有人说缪斯主唱Bellamy的唱腔和Yorke很像，细听确实有一点，都有一种浅唱低吟的感觉，但是Bellamy更加积极魅惑一点，不似Yorke给人彻彻底底地绝望之感。经典专辑：《Black Holes and Revelations》、《Absolution》、《The 2nd Law》14. Blur（模糊乐队/布勒乐队/污点乐队）这支乐队和绿洲一起是一个神奇的存在，最为乐迷津津乐道的就是Blur（模糊乐队）与绿洲的掐架了，因为他们的风格挺像的，都是英式摇滚路线。但是我觉得模糊乐队没有像绿洲那样的狂放个性，显得更加的温和内敛，所以这支乐队被认为具有披头士的神韵。很多人评价一支乐队经常说某某乐队是某某乐队的接班人，我其实并不喜欢这种评价，乐队和乐队之间是一种传承和学习的关系，但是每个乐队都是一个独立的个体，所以我觉得披头士是披头士，Blur是Blur。近几年Blur做了一些比较诡异的尝试，风格越来越让人摸不透了，不过有了自己的经典之作之后，他们想做一些新的突破也是非常勇敢的。经典专辑：《The Best Of Blur》、《The Great Escape》、《Parklife》15. Travis（特拉维斯乐队）这是来自苏格兰的一支传统摇滚乐队，他们涉足英式摇滚、传统摇滚、Post-Grunge与另类摇滚多个领域。乐队成员都是70后，他们最开始只是一个小地方的乐团，发行第二张专辑之后难掩才华，一时间成为英国摇滚乐坛巨星。其实我觉得主唱的声线是比较忧郁的，唱歌的方式有点浅唱低吟的感觉。他们也尝试过软摇滚，总之是一支听起来比较舒服的乐队。经典专辑：《The Man Who》、《Side》、《Pipe Dreams》16. Queen（皇后乐队）一支华丽丽的硬摇乐队，作品具有浓厚的歌剧色彩，非常硬，乐队的歌曲都保留了那种老式硬摇滚的精髓，键盘和完美的吉他Solo是他们的特点。主唱Freddie Mercury的声音是摇滚乐坛少有的好嗓，非常高亢嘹亮，天生是摇滚主唱的料，这也给皇后乐队注入了一种恢弘而大气磅礴的音乐感染力，但Freddie Mercury不幸因染上艾滋病辞世，全球歌迷为之震惊心痛。在失去这位灵魂人物之后，皇后乐队还是人气高涨，不断出了好作品，最终被选入摇滚名人堂。经典专辑：《A Night at The Opera》、《Innuendo》、《A Kind of Magic》17. Black Sabbath（黑色安息日乐队）一看名字就知道这是支重金属乐队，乐队组建于伯明翰。这支乐队音色纯正，音乐简单干净又粗暴，但是他们的歌曲具有深刻的现实意义。他们的歌曲关注当时的核战争和死亡，描写毒品、反叛、青年和灰暗的生活命运，反映了底层人的痛苦绝望的生活状态，深受当时年轻人的喜爱。这支乐队的辉煌时期在70年代，后来渐渐地没落。好像70年代的英国朋克乐队都很难长久，不知道这是个什么怪圈，我想这可能是因为朋克自身所带的那种毁灭性，使他们自己也无法长久吧。经典专辑：《Paranoid》、《Vol. 4》、《Master Of Reality》、《Sabbath Bloody Sabbath》18. Snow Patrol（雪地巡游者乐队）Snow Patrol（雪地巡游者乐队）是一支来自苏格兰的乐队，乐队风格清新哀婉，歌词非常的温暖感人，是当代比较成功的英国摇滚乐队。乐队风格是迷幻和另类路线，出了一些很不错的单曲，我个人比较喜欢他们的一些作品，可以拿来听听。听他们的歌曲非常的治愈，给人温暖、干净而清澈的感觉，近几年也是风生水起，至于未来还会怎样发展，还有很多的可能性。经典专辑：《Final Straw》、《Up To Now》19. Led Zeppelin（齐柏林飞船）被誉为重金属鼻祖的一支英国乐队，他们的重金属融合了朋克、中东音乐、蓝调、乡村、雷鬼音乐等等元素。他们的有的歌曲听起来很忧伤，令人神往遐思，代入感极强。有很多歌曲的歌词非常的有深度，甚至是对人性的拷问和追寻。他们的音乐前奏都非常漂亮，节奏感超强。虽然是重金属乐队，但是其并没有像后期的重金属乐队那样太多的嘶吼和器乐嘈杂，很是入耳。经典专辑：《Led Zeppelin Ⅳ》、《Houses of the Holy》、《Physical Graffiti》20. The Kinks（奇想乐队）奇想是一支老乐队了，他们主要活跃在60-70年代，在流行摇滚上造诣颇高，曲风也是蛮广的，迷幻、流行随手拈来。作为“不列颠入侵”的主要乐队之一，奇想与披头士、谁人和滚石并称为英国摇滚乐坛“Big Four”，当时的英国摇滚就是这四个乐队大放异彩、风靡全球。奇想也是摇滚名人堂的成员，但是96年这个乐队就解散了。他们的歌曲听着很舒服，充满怀旧伤感之情。可惜的是，这支本来很优秀的乐队在当时有点被披头士的巨大光芒掩盖了，现在去重新发现下也是不错的。经典专辑：《Face to Face》、《Muswell Hillbillies》、《Arthur》英国的摇滚乐队不胜枚举，大大小小的、成名的不成名的、大众的和小众的非常多，他们各有风格，但是真正能够在摇滚史上留下名字的乐队还是少数。总的来说，英国摇滚的特点是自成一派的英式摇滚，还有PF所创立的迷幻摇滚流派，加之上世纪70年代的朋克摇滚，这些都是英国土生土长的摇滚形式。除此外，英国摇滚还有其独有的思想性，从披头士的爱、和平、反战，到朋克对现实的抨击，及众多英式摇滚乐队的壮大复兴，都是英国摇滚乐的迷人之处。]]></content>
      <categories>
        <category>Music</category>
        <category>Britpop</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2F2017%2F01%2F19%2Ftest%2F</url>
    <content type="text"><![CDATA[just a test just a test just a test just a test just a test just a test just a test just a test just a test just a test test]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[About]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[关于这个博客学习笔记心得和感想关于我感兴趣的领域是： 前端：未来希望成为一名前端工程师 音乐：英伦摇滚，尤其是 Oasis 英语：业余翻译兼退休汉化者 游戏：某游戏论坛养老版主。平时玩 RPG 游戏较多，看重剧情 历史：中东地区 其它：探索中…社区：掘金SegmentFaultGitHub]]></content>
  </entry>
  <entry>
    <title><![CDATA[Categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
