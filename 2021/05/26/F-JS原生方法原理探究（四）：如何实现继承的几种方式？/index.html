<!-- build time:Sun Dec 05 2021 09:50:02 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/prism.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">JS 原生方法原理探究（四）：如何实现继承的几种方式？</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.1k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><span id="more"></span><p>这是JS 原生方法原理探究系列的第四篇文章。本文会介绍如何实现 JS 中常见的几种继承方式，同时简要它们的优缺点。</p><h3 id="实现继承的方法"><a class="markdownIt-Anchor" href="#实现继承的方法"></a> 实现继承的方法</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/8.jpg" alt=""></p><p>实现继承的方法共有 7 种，这 7 种方法并不是互相独立的，它们之间更像是一种互补或者增强的关系。</p><ul><li>原型链继承和借用构造函数继承分别解决了<strong>继承父类方法</strong>和<strong>继承父类属性</strong>的问题，这两个方法结合就得到了组合继承；</li><li>原型式继承的核心是实现对象的浅拷贝并进行增强，寄生式继承则将这个过程封装成一个返回对象的函数；</li><li>寄生组合式继承结合了寄生式继承和组合式继承，是相对比较完美的方案。</li><li>Class extends 继承是 ES6 的，本质上是寄生组合式继承的一种运用</li></ul><p>下面的示例中，<code>SuperType</code> 表示父类，<code>SubType</code> 表示继承父类的子类。</p><h3 id="1原型链继承"><a class="markdownIt-Anchor" href="#1原型链继承"></a> 1）原型链继承</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getNames</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperTye</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原型链继承的核心就一句话：用父类实例作为子类原型，这使得子类实例最终可以访问父类上的属性和其原型上的方法。而它的缺点也很明显：</p><p>第一：由于父类构造函数只调用了一次，导致子类的原型都统一指向了这次调用所创建的父类实例，所以子类实例在访问一些自身没有的引用类型的属性时，实际上访问的都是那同一个父类实例上的属性。但通常，实例和实例之间应该都有自己的属性副本，不应该共享属性</p><p>第二：同样是由于只调用了一次父类构造函数，所以子类无法向父类传参</p><h3 id="2借用构造函数继承"><a class="markdownIt-Anchor" href="#2借用构造函数继承"></a> 2）借用构造函数继承</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SupterTye</span><span class="token punctuation">(</span><span class="token parameter">names</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>names <span class="token operator">=</span> names
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getNames</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>借用构造函数继承也称为经典继承，这里所谓的借用指的是借用父类构造函数，它的核心就是完全不使用原型，而是在子类构造函数中通过 call 调用父类构造函数，从而增强子类实例 —— 相当于把父类实例上的属性都搬到子类实例这里来。</p><p>这种继承方法的优点就在于，它解决了原型链继承的缺点，我们现在可以往父类传参了，而且每次 new 子类的时候都会重新调用一次父类，这使得子类的所有实例都有自己的属性副本。</p><p>属性是没问题了，方法的继承又有了问题。由于父类构造函数是重复调用的，所以每个实例都有自己的方法副本，但问题是，方法并不需要副本，所有实例完全应该共享同一个方法，所以这里为每个实例重复创建同一个方法，就存在一定的性能问题。此外，对于父类原型上的方法，子类是无法继承的，因为这种继承方式并没有使用到原型。</p><h3 id="3组合继承"><a class="markdownIt-Anchor" href="#3组合继承"></a> 3）组合继承</h3><p>看起来，原型链继承擅长方法继承，而借用构造函数继承擅长属性继承，那么能不能取二者之长呢？实际上，结合两者的优点，就是所谓的组合继承了。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">names</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>names <span class="token operator">=</span> names
<span class="token punctuation">&#125;</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getNames</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>组合继承使用原型链继承的方式去继承方法，使用构造函数继承的方式去继承属性。</p><p>PS：组合继承和原型链继承都重写了子类的原型，在重写之前，子类的原型的 <code>constructor</code> 是指向子类的，重写后就不是了，因为子类的原型被代之以一个 new 创建的对象字面量。这里可以通过 <code>SubType.prototype.constructor = SubType</code> 修复 constructor 的指向。</p><h3 id="4-原型式继承"><a class="markdownIt-Anchor" href="#4-原型式继承"></a> 4） 原型式继承</h3><p>原型式继承所做的事情类似于浅拷贝一个对象，再通过自定义的方式增强新对象。它能够方便地实现在不同对象之间共享信息，同时又不需要额外创建构造函数（内部做了处理）。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span>
    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
fucntion <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> anotherObj <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
anotherObj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Tom'</span>
anotherObj<span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ES5 在规范层面实现了原型式继承，也就是所谓的 <code>Object.create()</code> 方法，上面代码可以改为：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span>
    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> anotherObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法所做的事情和 createObject 方法是一样的，它最终会返回一个新对象，而这个新对象的原型是传入的参数（我们传入的参数一般充当一个原型对象）。而且，当我们传参 <code>null</code> 的时候，它最终会返回一个没有原型的纯粹的对象，也就是所谓的裸对象（naked object）。</p><h3 id="5-寄生式继承"><a class="markdownIt-Anchor" href="#5-寄生式继承"></a> 5） 寄生式继承</h3><p>寄生式继承在原型式继承的基础上，为新对象增加了方法：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span>
    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">createObject</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 对象浅拷贝</span>
    <span class="token keyword">let</span> anotherObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
    <span class="token comment">// 对象增强</span>
    anotherObj<span class="token punctuation">.</span><span class="token function-variable function">getFriends</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> anotherObj
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> anotherObj <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6寄生组合式继承"><a class="markdownIt-Anchor" href="#6寄生组合式继承"></a> 6）寄生组合式继承</h3><p>寄生组合式继承的出现是为了解决组合继承存在的一些问题，这种继承基本上是完美的了。</p><p>组合继承最大的问题在于，它两次调用了父类构造函数。第一次是在子类构造函数中 call 调用父类构造函数，这个时候实际上已经使得子类实例拥有了父类的属性；第二次是 new 调用父类构造函数并作为子类的原型，这时候又使得子类原型上也有了父类的属性。因此这两次调用带来的开销问题不说，更关键的是出现了两组重复的属性，这完全是不必要的。所以，利用寄生组合式继承，我们可以做到<strong>只调用一次父类构造函数</strong>。</p><p>假设我们现在有一个父类，然后需要实现一个继承父类的子类。用寄生组合式继承的话，代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jack'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getFriends</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// 属性继承</span>
    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span><span class="token parameter">sup<span class="token punctuation">,</span>sub</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>sup<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
    sub<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> sub
    <span class="token comment">// 或者直接</span>
    sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>sup<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span><span class="token punctuation">&#123;</span>
        constructor<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
            value<span class="token operator">:</span> sub
            <span class="token comment">// enumerable 默认为 false</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 方法继承</span>
<span class="token function">inherit</span><span class="token punctuation">(</span>SuperType<span class="token punctuation">,</span>SubType<span class="token punctuation">)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意几个要点：</p><ul><li>属性继承仍然是采用借用构造函数继承的方式，关键是方法继承。这里通过一个 <code>inherit</code> 函数接受父类和子类，让子类继承父类的方法。在具体实现中，我们不再像原型链继承或者组合继承那样，new 一个父类构造函数作为子类的原型 —— 虽然效果看起来一样，但这是一次多余的、应该避免的父类调用。相反，我们借鉴了寄生式继承的做法，创建了一个父类原型的副本作为子类的原型。子类原型和父类原型之间其实是通过 <code>__proto__</code> 联系起来的，因此在通过子类实例访问相关方法的时候，可以确保是沿着 <code>子类实例 =&gt; 子类实例.__proto__ = 子类原型 =&gt; 子类原型.__proto__ = 父类原型</code> 这样的原型链查找，最终一定可以找到父类原型上的方法，因此就实现了方法继承。</li><li>寄生组合式继承同样重写了子类原型，所以需要修复 constructor 的指向，指回子类本身。因为 <code>Object.create</code> 本身接受两个参数，第二个参数可以设置其返回对象的属性的特性，所以也可以在传参时顺便修复 constructor 的指向</li></ul></div><div class="post-nav"><div class="post-nav-prev"><a href="/2021/05/26/F-JS%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20instanceof%EF%BC%9F/" rel="prev" title="JS 原生方法原理探究（五）：如何实现 instanceof？"><i class="fa fa-angle-double-left"></i>&nbspJS 原生方法原理探究（五）：如何实现 instanceof？</a></div><div class="post-nav-next"><a href="/2021/05/26/F-JS%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20new%EF%BC%9F/" rel="next" title="JS 原生方法原理探究（三）：如何实现 new 操作符？">JS 原生方法原理探究（三）：如何实现 new 操作符？&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">实现继承的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">1）原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">2）借用构造函数继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">3）组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">4） 原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">5） 寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">6）寄生组合式继承</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>function send_valine_Server(){var e="desp=",t=document.title,n=t.indexOf("|"),a=(t.substring(0,n),document.URL),s=new Date,l=document.getElementsByClassName("vnick vinput")[0].value||"Anonymous",i=(document.getElementsByClassName("vmail vinput")[0].value,document.getElementsByClassName("vlink vinput")[0].value,document.getElementsByClassName("veditor vinput")[0].value),o=e+"文章："+a+"\n\n昵称："+l+"\n\n留言："+i+"\n\n时间："+s.toLocaleString(),v=new XMLHttpRequest;v.open("POST","https://sc.ftqq.com/"+SCKEY_Server+".send",!0),v.setRequestHeader("Content-type","application/x-www-form-urlencoded"),v.send(title1+"&"+o)}new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0});var title1="text=你的博客有新的评论",SCKEY_Server="SCT99005TwWJDrDKdBwQGK0YmcPRAsr4B",ValineButton=document.getElementsByClassName("vsubmit vbtn")[0];ValineButton.onclick=send_valine_Server</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/prism.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:150,height:300,vOffset:-120,hOffset:-5},mobile:{show:!1},react:{opacityDefault:1e3,opacityOnHover:1e3},log:!1})</script></body></html><!-- rebuild by neat -->