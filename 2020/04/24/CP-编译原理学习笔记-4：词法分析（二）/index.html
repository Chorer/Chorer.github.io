<!-- build time:Thu Jul 16 2020 12:28:39 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">编译原理学习笔记-4：词法分析(二)等价转换与DFA的化简</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-04-24&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.7k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp10 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-00.png" alt=""></p><a id="more"></a><blockquote><p>编译有五大步骤，本篇笔记将继续讲解编译的第一步：词法分析。内容主要涉及：1. 正规式、正规文法、有限自动机三者的转换；2. 确定有限自动机的化简</p></blockquote><h3 id="1-正规式和正规文法的等价性"><a href="#1-正规式和正规文法的等价性" class="headerlink" title="1. 正规式和正规文法的等价性"></a>1. 正规式和正规文法的等价性</h3><h4 id="①-为何等价？"><a href="#①-为何等价？" class="headerlink" title="① 为何等价？"></a>① 为何等价？</h4><p>正规文法（四元式）定义了某种正规语言，正规式表示了某个正规集，它也定义了某种正规语言，因此可以说<strong>正规式和正规文法是等价的</strong>。即：</p><p>对于任意一个正规文法，存在一个定义同一语言的正规式；对任意一个正规式，存在一个生成同一语言的正规文法。</p><h4 id="②-正规式转换为正规文法"><a href="#②-正规式转换为正规文法" class="headerlink" title="② 正规式转换为正规文法"></a>② 正规式转换为正规文法</h4><p>将正规式 <code>r</code> 转换为正规文法 <code>G</code>，核心是将正规式拆分为正规文法的多个产生式，这是一个<strong>由一到多</strong>的过程。正规文法最终必须有一个开始符号，于是我们选定 <code>S</code> 作为开始符号，令 <code>S → r</code>，然后逐步对 <code>r</code> 进行拆分，生成多个产生式。</p><p>拆分规则如下：</p><ul><li><code>A → xy</code> 可拆分为 <code>A → xB</code>，<code>B → y</code></li><li><code>A → x*y</code> 可拆分为 <code>A → xA</code>，<code>A → y</code></li><li><code>A → x|y</code> 可拆分为 <code>A → x</code>，<code>A → y</code></li></ul><p>对于规则二，实际我们知道 <code>x*y</code> 是形如 <code>xxxxxxy</code> 的，所以需要进行循环替换，必须有 <code>A → xA</code>；符号串最后有个 <code>y</code>，所以必须有 <code>A → y</code>。</p><p>以 <code>R = a(a|d)*</code> 这个正规式为例，将其转换为正规文法的过程如下：</p><pre class="line-numbers language-js"><code class="language-js">S → R → <span class="token function">a</span><span class="token punctuation">(</span>a<span class="token operator">|</span>d<span class="token punctuation">)</span><span class="token operator">*</span>
S → aA<span class="token punctuation">,</span>A → <span class="token punctuation">(</span>a<span class="token operator">|</span>d<span class="token punctuation">)</span><span class="token operator">*</span>
S → aA<span class="token punctuation">,</span>A → <span class="token punctuation">(</span>a<span class="token operator">|</span>d<span class="token punctuation">)</span><span class="token operator">*</span>ε
S → aA<span class="token punctuation">,</span>A → <span class="token punctuation">(</span>a<span class="token operator">|</span>d<span class="token punctuation">)</span>A<span class="token punctuation">,</span>A → ε
S → aA<span class="token punctuation">,</span>A → aA<span class="token punctuation">,</span>A → dA<span class="token punctuation">,</span>A → ε
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，正规文法中的 <code>P = {S → aA,A → aA,A → dA,A → ε}</code>，<code>Vn = {S,A}</code>，<code>Vt = {a,d,ε}</code>。正规文法为 <code>G = {Vn,Vt,P,S}</code></p><p>以 <code>R = (ab|a)*</code> 这个正规式为例，它的正规文法是什么呢？可能会有下面这种写法：</p><pre class="line-numbers language-js"><code class="language-js">S → R → <span class="token punctuation">(</span>ab<span class="token operator">|</span>a<span class="token punctuation">)</span><span class="token operator">*</span> → <span class="token punctuation">(</span>ab<span class="token operator">|</span>a<span class="token punctuation">)</span><span class="token operator">*</span>ε
S → <span class="token punctuation">(</span>ab<span class="token operator">|</span>a<span class="token punctuation">)</span>S<span class="token punctuation">,</span>S → ε
S → AS<span class="token punctuation">,</span>A → <span class="token punctuation">(</span>ab<span class="token operator">|</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span>S → ε
S → AS<span class="token punctuation">,</span>A → ab<span class="token punctuation">,</span>A → a<span class="token punctuation">,</span>S → ε
S → AS<span class="token punctuation">,</span>A → aB<span class="token punctuation">,</span>B → b<span class="token punctuation">,</span>A → a<span class="token punctuation">,</span>S → ε
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种写法是错误的，因为它<strong>没有严格按照规则进行转化</strong>。问题出在从 <code>S → (ab|a)S</code> 到 <code>S → AS,A → (ab|a)</code> 这一步，规则其实是：<code>A → xy</code> 可拆分为 <code>A → xB</code>，<code>B → y</code> ，右部第一个正规式必须保留，不能被替换，被替换的应该是第二个正规式。</p><p>正确写法如下：</p><pre class="line-numbers language-js"><code class="language-js">S → R → <span class="token punctuation">(</span>ab<span class="token operator">|</span>a<span class="token punctuation">)</span><span class="token operator">*</span> → <span class="token punctuation">(</span>ab<span class="token operator">|</span>a<span class="token punctuation">)</span><span class="token operator">*</span>ε
S → <span class="token punctuation">(</span>ab<span class="token operator">|</span>a<span class="token punctuation">)</span>S<span class="token punctuation">,</span>S → ε
S → abS<span class="token punctuation">,</span>S → aS<span class="token punctuation">,</span>S → ε
S → aA<span class="token punctuation">,</span>A → bS<span class="token punctuation">,</span>S → aS<span class="token punctuation">,</span>S → ε
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="③-正规文法转换为正规式"><a href="#③-正规文法转换为正规式" class="headerlink" title="③ 正规文法转换为正规式"></a>③ 正规文法转换为正规式</h4><p>将正规文法 <code>G</code> 转换为正规式 <code>r</code>，核心是将正规文法的多个产生式合并为一个正规式，这是一个<strong>由多到一</strong>的过程。</p><p>合并的规则如下：</p><ul><li><code>A → xB</code>，<code>B → y</code> 可合并为 <code>A → xy</code></li><li><code>A → xA</code>，<code>A → y</code> 可合并为 <code>A → x*y</code></li><li><code>A → x</code>，<code>A → y</code> 可合并为 <code>A → x|y</code></li></ul><p>以下面这个正规文法为例：</p><pre class="line-numbers language-js"><code class="language-js">S → aA
S → a
A → aA
A → dA
A → a
A → d
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>先观察，将相似的进行两两合并，所以有 <code>S = aA|a</code>，<code>A = aA|dA</code>，<code>A = a|d</code>。</p></li><li><p>后两个都是 <code>A</code>，所以合并，有：</p><p><code>A = (aA|dA)|(a|d) = (a|d)A(a|d) = (a|d)*(a|d)</code></p></li><li><p>将 <code>A</code> 代入 <code>S = aA|a</code>，有：</p><p><code>S = aA|a = a((a|d)*(a|d))|a = a(a|d)+|a = a(a|d)+|aε = a((a|d)+|ε) = a(a|d)*</code></p></li></ul><p>所以，有：<code>S = a(a|d)*</code>。需要注意中间推导过程中的 <code>(a|d)+|ε</code>，实际上可以看作是正则闭包与空符号串的并集，所以替换为一个闭包。</p><h3 id="2-正规式和有限自动机的等价性"><a href="#2-正规式和有限自动机的等价性" class="headerlink" title="2. 正规式和有限自动机的等价性"></a>2. 正规式和有限自动机的等价性</h3><p>正规式表示了某种语言，有限自动机也表示了某种语言，这两者也具有等价性：</p><ul><li>对于有限自动机 <code>M</code>，可以构造一个正规式 <code>R</code>，使得 <code>L(R) = L(M)</code>。</li><li>每个正规式 <code>R</code>，可以构造一个有限自动机 <code>M</code>，使得 <code>L(M) = L(R)</code>。</li></ul><h4 id="①-有限自动机转化为正规式"><a href="#①-有限自动机转化为正规式" class="headerlink" title="①  有限自动机转化为正规式"></a>① 有限自动机转化为正规式</h4><p>有限自动机转化为正规式，核心是构造一个开始状态 <code>X</code> 和一个终止状态 <code>Y</code>，之后不断简化与合并状态转化的过程，使得从 <code>X</code> 到 <code>Y</code> 只需要经过一步。</p><p>合并规则如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-1.png" style="zoom:50%"></p><p>以下面这个有限自动机为例：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-2.png" style="zoom:50%"></p><p>首先构造开始符号 <code>X</code> 和终结符号 <code>Y</code>，并与原有限自动机的开始符号和终结符号进行连接：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-3.png" style="zoom:50%"></p><p>按照规则逐步进行合并：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-4.png" style="zoom:50%"></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-5.png" style="zoom:50%"></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-6.png" style="zoom:50%"></p><p>当 <code>X</code> 到 <code>Y</code> 一步到位的时候，说明转换已经完成。最终我们得到的正规式即：</p><p><code>L(R) = (a|b)*(aa|bb)(a|b)*</code></p><p><strong>注意：</strong>这里的转化务必严格按照规则进行，虽然 0 自转和 <code>aa(a|b)*</code> 先合并，最后得到的正规式也是一样的，但这并不是基于基本规则进行的合并，因此必须先合并 <code>aa(a|b)*</code> 和 <code>ε</code>（这是基于基本规则进行的合并）。</p><h4 id="②-正规式转化为有限自动机"><a href="#②-正规式转化为有限自动机" class="headerlink" title="②  正规式转化为有限自动机"></a>② 正规式转化为有限自动机</h4><p>这个过程实际上是有限自动机转化为正规式的逆过程，核心就是不断对正规式进行拆分，直到不可以再继续拆分为止。</p><p>基本的转换规则如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-7.png" style="zoom:67%"></p><p>下面以正规式 <code>R = (a*b)*ba(a|b)*</code> 为例，将其转化为等价的有限自动机：</p><p>首先拆解为四个部分：<code>(a*b)*</code>，<code>b</code>，<code>a</code>，<code>(a|b)*</code>，以 <code>S</code> 作为开始符号。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-8.png" style="zoom:80%"></p><p>将两个闭包进行拆解：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-9.png" alt=""></p><p>将最后一个笛卡尔积和闭包进行拆解，得到最终的有限自动机如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-10.png" alt=""></p><h3 id="3-确定有限自动机的化简"><a href="#3-确定有限自动机的化简" class="headerlink" title="3. 确定有限自动机的化简"></a>3. 确定有限自动机的化简</h3><p>在上一篇笔记中，将非确定有限自动机 NFA 确定化之后，得到了确定有限自动机 DFA，接下来考虑 DFA 的化简。DFA 的化简指的是找到这么一个 DFA，它的状态数比原 DFA 更少，但是整体与原 DFA 是等价的。</p><h4 id="第一步：删除无用状态"><a href="#第一步：删除无用状态" class="headerlink" title="第一步：删除无用状态"></a>第一步：删除无用状态</h4><p>无用状态指的是从初态出发，不管输入的是什么符号都无法到达的那个状态，这个状态没有意义，直接删除即可。</p><h4 id="第二步：合并等价状态"><a href="#第二步：合并等价状态" class="headerlink" title="第二步：合并等价状态"></a>第二步：合并等价状态</h4><p>如果两个状态，不管输入的是什么符号，到达的状态的集合都是<strong>当前已划分的状态集合</strong>的子集，那么这两个状态就是等价的，既然是等价的，就可以进行合并；与之相反，则称两个状态可区别，两个可区别的状态，化简到最后还是分开的，不会进行合并。</p><p>用一个例子来说明：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-11.png" style="zoom:50%"></p><p>将这个 DFA 进行化简的步骤是这样的：</p><p><strong>① 划分非终态集和终态集：</strong></p><p>根据非终态和终态，划分出了两个集合：<code>{1,2,3,4}</code> 和 <code>{5,6,7}</code>。此时，<strong>当前已划分的状态集合</strong>就是这两个集合。</p><p><strong>② 从 a 和 b 分别考察终态集：</strong></p><p><code>{5,6,7}</code>的各个状态经过输入 <code>a</code> 后，到达了其它状态，这些状态汇总的集合是 <code>{4,7}</code>，该状态集合不是<strong>当前已划分的状态集合</strong>的子集，所以这里要进行划分。因为 6，7 经过输入 <code>a</code> 都是到达 4，但是 5 却是到达 7，所以划分为 <code>{6,7}</code> 和 <code>{5}</code></p><p>那么 6，7 是不是就等价了，可以合并了呢？并不是，还需要看 b 弧。<code>{6,7}</code>的各个状态经过输入 <code>b</code> 后，到达了其它状态，这些状态汇总的集合是 <code>{1,2}</code>，这个状态集合是<strong>当前已划分的状态集合</strong> <code>{1,2,3,4}</code>的子集。所以 6，7不拆开，还是 <code>{6,7}</code>。</p><p>自此，<strong>当前已划分的状态集合</strong>为 <code>{1,2,3,4}</code> ， <code>{5}</code>，<code>{6,7}</code>。</p><p><strong>③ 从 a 和 b 分别考察非终态集：**</strong></p><p><code>{1,2,3,4}</code> 的各个状态经过输入 <code>a</code> 后，到达了其它状态，这些状态汇总的集合是 <code>{1,4,6,7}</code>，该状态集合不是<strong>当前已划分的状态集合</strong>的子集，所以这里要进行划分。因为 1，2 到达 6，7，3，4 到达 1，4，所以这里划分为 <code>{1,2}</code> 和 <code>{3,4}</code>。</p><p>自此，<strong>当前已划分的状态集合</strong>为 <code>{1,2}</code> ，<code>{3,4}</code>， <code>{5}</code>，<code>{6,7}</code>。</p><p>接着看 b 弧。<code>{1,2}</code> 的各个状态经过输入 <code>b</code> 后，到达了其它状态，这些状态汇总的集合是 <code>{3}</code>，这个状态集合是<strong>当前已划分的状态集合</strong> <code>{3,4}</code> 的子集，所以这里不拆开，还是 <code>{1,2}</code></p><p><code>{3,4}</code> 的各个状态经过输入 <code>b</code> 后，到达了其它状态，这些状态汇总的集合是 <code>{5,6}</code>，注意这个状态集合并不是<strong>当前已划分的状态集合</strong> 的子集，所以这里要进行划分。因为 3 到达 5，4 到达 6，所以拆分为 <code>{3}</code> 和 <code>{4}</code>。</p><p><strong>④ 确定最终已划分的状态集合</strong></p><p>经过 ab 的测试后，<strong>当前已划分的状态集合</strong>为 <code>{1,2}</code> ，<code>{3}</code>，<code>{4}</code> ，<code>{5}</code>，<code>{6,7}</code>。</p><p><strong>⑤ 等价状态的合并</strong></p><p>在同一个集合中的状态都是等价的，要考虑将它们进行合并。还是来看这张图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-11.png" style="zoom:50%"></p><p>首先，6 和 7 是等价的，考虑去掉 7 与它的各条线。7–4 线与 6–4 线等价，把 7–4 线去除；5–7 线等价于 5–6 线，将 5–7 线替换为 5–6 线；7–2 线、2–7 线有等价的 6–1 线、1–6 线（因为 1 和 2 等价），可以将 7–2 线、2–7 线去除，同时把与 1 等价的 2 也去掉。最后还剩下 2–3 线，它等价于 1–3 线，因此可以把 2–3 线去掉。</p><p>最终化简得到的 DFA 如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-12.png" style="zoom:67%"></p><p><strong>注意：</strong></p><p>DFA 化简之后一定要进行检查，确定每一个状态集合的每一个状态经过 ab 后到达的状态的集合都是当前已划分集合的子集。比方说，在上面这个例子中，如果我们是先考察非终态集，那么最后划分得到的状态集合将是：为 <code>{1,2}</code> ，<code>{3,4}</code> ，<code>{5}</code>，<code>{6,7}</code>。如果不做检查，就会按照这些集合进行最终的化简；但实际上，经过检查后会发现，<code>{3,4}</code> 的每一个状态经过 b 后到达的状态的集合为 <code>{5,6}</code>，这个集合不是当前任何一个已划分集合的子集，所以 3 和 4 实际上不是等价的，不能放在一个集合中。但是为什么一开始会觉得 3 和 4 应该在一起呢？是因为我们当时先检查的是非终态集合，没有检查终态集合，终态集合在那个时候只有 <code>{5,6,7}</code> ，是暂时还没有划分的。</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/04/25/OS-Linux%20%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/" rel="prev" title="Linux 系统操作"><i class="fa fa-angle-double-left"></i>&nbspLinux 系统操作</a></div><div class="post-nav-next"><a href="/2020/04/21/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10%EF%BC%9A%E6%AD%BB%E9%94%81/" rel="next" title="操作系统学习笔记-10：死锁">操作系统学习笔记-10：死锁&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-正规式和正规文法的等价性"><span class="toc-text">1. 正规式和正规文法的等价性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#①-为何等价？"><span class="toc-text">① 为何等价？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#②-正规式转换为正规文法"><span class="toc-text">② 正规式转换为正规文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#③-正规文法转换为正规式"><span class="toc-text">③ 正规文法转换为正规式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-正规式和有限自动机的等价性"><span class="toc-text">2. 正规式和有限自动机的等价性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#①-有限自动机转化为正规式"><span class="toc-text">① 有限自动机转化为正规式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#②-正规式转化为有限自动机"><span class="toc-text">② 正规式转化为有限自动机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-确定有限自动机的化简"><span class="toc-text">3. 确定有限自动机的化简</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一步：删除无用状态"><span class="toc-text">第一步：删除无用状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二步：合并等价状态"><span class="toc-text">第二步：合并等价状态</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2020</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->