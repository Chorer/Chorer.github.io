<!-- build time:Sat Mar 21 2020 19:31:14 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">操作系统学习笔记-2：体系结构和运行机制</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-03-17&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.2k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp10 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6-0.png" alt=""></p><a id="more"></a><h2 id="一-操作系统的体系结构"><a href="#一-操作系统的体系结构" class="headerlink" title="一. 操作系统的体系结构"></a>一. 操作系统的体系结构</h2><h3 id="1-传统的操作系统结构"><a href="#1-传统的操作系统结构" class="headerlink" title="1. 传统的操作系统结构"></a>1. 传统的操作系统结构</h3><p><strong>（1）无结构操作系统：</strong></p><p>早期的操作系统没有真正意义上的“结构”可言，只是大量的过程的集合，过程之间可以互相调用，导致操作系统内部复杂而混乱。</p><p><strong>（2）模块化结构操作系统：</strong></p><p>模块化结构的 OS 基于程序模块化开发的思想，按照功能划分了多个具有一定独立性和大小的模块，每个模块有自己的功能，同时互相之间能够通过接口实现交互。模块之下又有子模块，以此类推。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6-1.png" alt=""></p><ul><li>模块的大小：划分过小，就会引起模块之间联系过多；划分过大，就会引起内部联系增加，复杂度提高</li><li>模块的独立性：两个衡量标准，即低耦合、高内聚。耦合度指的是模块之间的互相联系和影响，内聚性指的是模块内部各部分之间的紧密程度</li></ul><blockquote><p>模块化开发的 OS 虽然提高了 OS 设计的正确性、可理解性、可维护性，加速了开发过程，但是也存在着一定的问题：接口难以满足实际需求；多个决定齐头并进，呈现出“无序性”。</p></blockquote><p><strong>（3）分层式结构操作系统</strong></p><p>为了将“无序性”转化成“有序性”，采用了<strong>自底向上</strong>方法，在目标系统和裸机（宿主）系统之间铺设多个中间层，使得目标系统最终得以在裸机系统上运行。</p><p>从层次来看，为了使<strong>每一步设计都建立在可靠的基础上</strong>（这正是模块化结构 OS 缺失的），规定每一层仅能使用其底层提供的功能和服务 —— 这就使得调试变得非常容易，比如调试 A2 层的时候，可以只考虑 A1 层，因为 A2 层依赖 A1 层的服务和功能。一层一层自底向上增添，每一层实现一些功能，最后构成一个完整的 OS。</p><p>聚焦于单个层次，每个层次都由若干个模块构成。</p><blockquote><p>分层式结构的 OS 虽然保证了系统的正确性、可扩充性和易维护性，但是由于是分层单向依赖，使得层次和层次之间的<strong>通信</strong>成为了一个问题。执行一个简单的功能，可能需要穿越多个层次完成通信。</p></blockquote><h3 id="2-微内核操作系统结构"><a href="#2-微内核操作系统结构" class="headerlink" title="2. 微内核操作系统结构"></a>2. 微内核操作系统结构</h3><h4 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h4><p><strong>（1）足够小的内核：</strong></p><p>包含 —— 与硬件处理紧密相关的部分；基本的功能；客户与服务器之间的通信</p><p><strong>（2）基于客户/服务器模式 ：</strong></p><p>OS 最基本的部分放在内核中，其它绝大部分功能则在微内核外面的一组服务器（进程）中实现，比如 IO 设备管理服务器、进程服务器等。客户与服务器之间通过消息传递机制实现信息交互，如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-2.webp" alt=""></p><p><strong>（3）应用“机制与策略分离”原理</strong>：</p><ul><li>机制：实现某个功能的具体执行机构</li><li>策略：在机制基础上借助某些算法实现功能</li></ul><p>在微内核 OS 中，通常将机制放在 OS 的微内核中。</p><p><strong>（4）采用面向对象技术：</strong></p><p>基于“抽象”“隐蔽”原则控制系统的复杂性，基于“对象”“封装”“继承”确保系统的正确性、可靠性、易修改性、易扩展性。</p><h4 id="2-2-功能"><a href="#2-2-功能" class="headerlink" title="2.2 功能"></a>2.2 功能</h4><ul><li>进程（线程）管理：进程通信、切换、调度等</li><li>低级存储器管理</li><li>中断和陷入管理</li></ul><h4 id="2-2-优缺点"><a href="#2-2-优缺点" class="headerlink" title="2.2 优缺点"></a>2.2 优缺点</h4><table><thead><tr><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">提高了系统可扩展性</td><td style="text-align:center">采用了小的内核</td></tr><tr><td style="text-align:center">增强了系统的可靠性</td><td style="text-align:center">C/S模式和消息传递机制</td></tr><tr><td style="text-align:center">较好的可移植性</td><td style="text-align:center">运行效率有所降低</td></tr><tr><td style="text-align:center">提供了对分布式系统的支持</td><td style="text-align:center">传统 OS 只需进行两次变态，而微内核 OS 需进行多次变态（具体下文会提及）</td></tr><tr><td style="text-align:center">融入了面向对象技术</td></tr></tbody></table><h2 id="二-操作系统的运行机制"><a href="#二-操作系统的运行机制" class="headerlink" title="二. 操作系统的运行机制"></a>二. 操作系统的运行机制</h2><h3 id="1-相关概念普及"><a href="#1-相关概念普及" class="headerlink" title="1. 相关概念普及"></a>1. 相关概念普及</h3><h4 id="1-1-两种指令"><a href="#1-1-两种指令" class="headerlink" title="1.1  两种指令"></a>1.1 两种指令</h4><p><strong>特权指令：</strong></p><p>指的是有特殊权限的指令，比如：<strong>清内存、置时钟、分配系统资源、修改虚存的段表和页表，修改用户的访问权限</strong>等。这类指令使用不慎将导致系统崩溃，因此不能直接向用户程序开放使用这些指令的权限。</p><p><strong>非特权指令：</strong></p><p>相对于特权指令来说的普通指令，任何程序都可以使用，比如运算指令等。</p><h4 id="1-2-两种处理器状态"><a href="#1-2-两种处理器状态" class="headerlink" title="1.2 两种处理器状态"></a>1.2 两种处理器状态</h4><p>CPU 的核心态或者用户态可以看作一种状态，一种模式或者一种级别。</p><p><strong>核心态（目态）：</strong>当处于核心态时，可以使用特权指令或者非特权指令（陷入指令是例外，它只能在用户态下执行）</p><p><strong>用户态（管态）：</strong>当处于用户态时，只能使用非特权指令</p><h4 id="1-3-两种程序"><a href="#1-3-两种程序" class="headerlink" title="1.3 两种程序"></a>1.3 两种程序</h4><p><strong>内核程序：</strong>运行在核心态下，可以执行特权指令</p><p><strong>应用程序：</strong>运行在用户态下，为了系统安全着想，它只能执行非特权指令</p><h3 id="2-操作系统的内核"><a href="#2-操作系统的内核" class="headerlink" title="2. 操作系统的内核"></a>2. 操作系统的内核</h3><p>先看计算机系统的结构层次：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-3.png" style="zoom:67%"></p><p>重点在 OS 的内核，它是 OS 最基本、最核心的部分。</p><p><strong>大内核：</strong></p><p>如果内核不仅包括了时钟管理、中断处理以及原语（设备驱动、CPU 切换），还包含了进程管理、存储器管理以及设备管理等功能，那么就属于<strong>大内核</strong>。</p><p>大内核虽然使得内部代码非常庞大复杂，但是在用户态与核心态之间的切换，相对来说是很快的，这是因为大内核集成了进程管理、存储器管理等；</p><p><strong>微内核：</strong></p><p>如果内核仅由时钟管理、中断处理以及原语（设备驱动、CPU 切换）构成，那么这种内核属于<strong>微内核</strong>；</p><p>微内核的代码结构相对来说就很清晰、便于维护，但是由于微内核只集成了时钟管理、中断处理等这些最最基本的功能，所以在涉及到进程管理、存储器管理等时，就可能需要频繁变态（切换到用户态），而变态是需要消耗时间的，这无疑就会降低运行的性能。</p><h3 id="3-中断机制"><a href="#3-中断机制" class="headerlink" title="3. 中断机制"></a>3. 中断机制</h3><h4 id="3-1-为什么需要中断？"><a href="#3-1-为什么需要中断？" class="headerlink" title="3.1 为什么需要中断？"></a>3.1 为什么需要中断？</h4><p>在第一篇笔记中，我们说过，早期的操作系统只能串行跑程序，一个完成之后才能轮到下一个，这种情况下资源利用率显然是很低的；于是后来有了多道批处理系统，可以并发执行程序，为什么能够并发执行呢？这其实依赖于中断机制。</p><ul><li>CPU 从用户态切换到核心态，能且<strong>只能通过 中断 这一途径</strong></li><li>而从核心态切换到用户态，只需要执行一个特权指令</li></ul><h4 id="3-2-中断的分类"><a href="#3-2-中断的分类" class="headerlink" title="3.2 中断的分类"></a>3.2 中断的分类</h4><ul><li><p>内中断（异常、例外、陷入）：内中断的中断信号来自于 CPU 内部，和执行的指令有关</p><ul><li>自愿中断：比如 系统调用 这一指令中断</li><li>强迫中断：硬件故障、软件中断（比如不合法的运算）</li></ul></li><li><p>外中断（狭义的中断）：外中断的中断信号来自于 CPU 外部，和执行的指令无关</p><ul><li>外设请求：比如 I/O 操作完成后发出的中断信号</li><li>人工干预：比如用户强行终止进程</li></ul></li></ul><p>此外，还有另一种分类方式：</p><ul><li>硬中断：是由诸如磁盘，网卡，键盘，时钟等的外设发出中断信号的</li><li>软中断：是执行中断指令产生的，通常是一些对 I/O 的请求</li></ul><h4 id="3-3-中断的过程演示"><a href="#3-3-中断的过程演示" class="headerlink" title="3.3 中断的过程演示"></a>3.3 中断的过程演示</h4><p>我们用一个过程来演示中断的发生：</p><p><strong>（Session 1）时间片用完了：</strong></p><p>比方说，现在有个 A 进程正在用户态下运行。一段时间后，该进程消耗完了本次的时间片，那么操作系统内核中的计时部件知道时间到了，就会向 CPU 发射一个中断信号。CPU 接收到中断信号后，肯定要针对本次<strong>中断</strong>进行处理，但是它自己是无法处理的，需要<strong>借助操作系统</strong>内核的中断处理程序处理，而该程序又需要运行在核心态下，所以，此时 CPU 由一开始的用户态切换成了核心态。操作系统内核的中断处理程序针对中断信号进行处理，发现原来是 A 进程的时间片用完了，应该轮到 B 进程运行了，那么它就会把 CPU 使用权移交给 B 进程，让 B 进程开始运行，此时 CPU 也切换回用户态。</p><p><strong>（Session 2）要进行输出：</strong></p><p>B 进程正常运行，这时候执行到的某一行代码要求进行输出操作。前面我们说过，输入输出是特权指令，B 作为一个普通的用户程序来说，是不能直接执行特权指令的，因此，B 进程通过系统调用的方式向 CPU 发射一个中断信号，CPU 接收到中断信号后，肯定要针对本次<strong>中断</strong>进行处理，但是它自己是无法处理的，需要<strong>借助操作系统</strong>内核的中断处理程序处理，而该程序又需要运行在核心态下，所以，此时 CPU 由一开始的用户态切换成了核心态。操作系统内核的中断处理程序针对中断信号进行处理，发现原来是 B 进程要进行输出，那么它就会让打印机这一 I/O 设备开始工作。对于 B 进程，此时它要暂停运行，等待 I/O 完成。而这段空闲的时间不能浪费，所以操作系统就会把 CPU 使用权移交给 C 进程，让 C 进程开始运行，此时 CPU 也切换回用户态。</p><p><strong>（Session 3）输出完成了：</strong></p><p>现在，C 进程和 I/O 设备并发运行，在 I/O 设备搞定了自己的工作后，它会向 CPU 发射一个中断信号。一如既往地，CPU 再次变成核心态，操作系统介入，发现原来是输出工作完成了，应该让上次暂停的 B 进程继续运行了，那么它就会把 CPU 使用权再次移交给 B 进程，让 B 进程往后运行，此时 CPU 也切换回用户态。</p><h3 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4. 系统调用"></a>4. 系统调用</h3><h4 id="4-1-为什么需要系统调用"><a href="#4-1-为什么需要系统调用" class="headerlink" title="4.1 为什么需要系统调用"></a>4.1 为什么需要系统调用</h4><p>操作系统作为连接 用户/应用程序 和 计算机硬件 的中间层，需要向上提供一些接口以方便用户或者应用程序使用它的服务，这些接口包括命令接口和程序接口。</p><p>命令接口即联机命令接口和脱机命令接口，用户可以直接使用这些接口；而程序接口则是由一组系统调用组成的，用户需要通过程序间接使用：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-4.png" alt=""></p><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。系统中的各种共享资源归操作系统管理，因此在用户程序中，凡是和资源相关的操作，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成，从而保证系统的<strong>稳定性和安全性</strong>，防止用户进行非法操作。</p><h4 id="4-2-分类"><a href="#4-2-分类" class="headerlink" title="4.2 分类"></a>4.2 分类</h4><ul><li>设备管理：完成设备的 请求/释放/启动 等</li><li>文件管理：完成文件的 读写增删 等</li><li>进程控制：完成进程的 创建/撤销/阻塞/唤醒 等</li><li>进程通信：完成进程之间的 消息传递/信号传递 等</li><li>内存管理：完成内存的 分配/回收 等</li></ul><p>这些功能都涉及到了特权指令，因此系统调用虽然是在用户态发出的，但是他的处理是需要在核心态下完成的。</p><p>PS：部分的库函数是对系统调用的封装</p><h4 id="4-3-过程"><a href="#4-3-过程" class="headerlink" title="4.3 过程"></a>4.3 过程</h4><p>传递系统调用的参数 ==&gt; 在<strong>用户态</strong>下执行陷入指令，发生内中断，进入核心态 ==&gt; 在核心态下执行系统调用相应服务程序 ==&gt; 返回用户程序</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/03/17/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%EF%BC%9A%E8%BF%9B%E7%A8%8B/" rel="prev" title="操作系统学习笔记-3：进程"><i class="fa fa-angle-double-left"></i>&nbsp操作系统学习笔记-3：进程</a></div><div class="post-nav-next"><a href="/2020/03/14/CP-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%EF%BC%9A%E5%BC%95%E8%AE%BA/" rel="next" title="编译原理学习笔记-1：引论">编译原理学习笔记-1：引论&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-操作系统的体系结构"><span class="toc-text">一. 操作系统的体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-传统的操作系统结构"><span class="toc-text">1. 传统的操作系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-微内核操作系统结构"><span class="toc-text">2. 微内核操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-特点"><span class="toc-text">2.1 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-功能"><span class="toc-text">2.2 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-优缺点"><span class="toc-text">2.2 优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-操作系统的运行机制"><span class="toc-text">二. 操作系统的运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-相关概念普及"><span class="toc-text">1. 相关概念普及</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-两种指令"><span class="toc-text">1.1 两种指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-两种处理器状态"><span class="toc-text">1.2 两种处理器状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-两种程序"><span class="toc-text">1.3 两种程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-操作系统的内核"><span class="toc-text">2. 操作系统的内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-中断机制"><span class="toc-text">3. 中断机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-为什么需要中断？"><span class="toc-text">3.1 为什么需要中断？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-中断的分类"><span class="toc-text">3.2 中断的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-中断的过程演示"><span class="toc-text">3.3 中断的过程演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-系统调用"><span class="toc-text">4. 系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-为什么需要系统调用"><span class="toc-text">4.1 为什么需要系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-分类"><span class="toc-text">4.2 分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-过程"><span class="toc-text">4.3 过程</span></a></li></ol></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->