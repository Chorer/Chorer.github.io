<!-- build time:Thu Mar 26 2020 23:13:44 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">call() 和 apply() 的相关介绍和应用场景</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-08-05&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp951&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp3 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/this/">this</a></div></div><div class="post-content"><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/callapplybind.jpg" alt=""></p><a id="more"></a><h2 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h2><pre class="line-numbers language-js"><code class="language-js">fun<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> <span class="token punctuation">[</span>param1<span class="token punctuation">,</span>param2<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
fun<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p><code>call()</code> 和 <code>apply()</code> 返回函数应该返回的值，<code>bind()</code> 返回一个经过硬绑定的新函数。</p><h2 id="参数介绍："><a href="#参数介绍：" class="headerlink" title="参数介绍："></a>参数介绍：</h2><p>第一个参数为 thisArg，其取值有以下几种情况：</p><ul><li><p>不传/ 传null/ 传undefined：非严格模式下，this 指向 window 对象；严格模式下指向 undefined；</p></li><li><p>传递基本类型：this 指向其对应的包装对象，如 String、Number、Boolean</p></li><li><p>传递一个对象：函数中的 this 指向这个对象</p></li></ul><p>第二个参数有以下几种情况：</p><ul><li>不传/ 传null/ 传undefined：表示不需要传入任何参数</li><li><code>call()</code> 和 <code>bind()</code> 的第二个参数都是参数列表，而 <code>apply()</code> 则是参数数组（或者类数组）—— 尽管如此，在这些参数传递给调用函数时，仍然是以参数列表的形式传递的（这一点很重要）。</li></ul><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p><code>call()</code> 和 <code>apply()</code> 一经调用则立即执行函数，而 <code>bind()</code> 则只是完成了函数的 this 绑定。因为函数不会立刻执行，所以适合在事件绑定函数中使用 <code>bind()</code> ，这样既完成了绑定，也确保了<strong>仅当事件触发时</strong>才执行函数。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在<a href="">这篇文章</a>说过，<code>call()</code>，<code>apply()</code> 和 <code>bind()</code> 都可以改变 this 的指向，什么时候需要改变 this 的指向呢？大部分时候其实是为了<strong>借用方法</strong>，即在对象上调用其自身不具备的方法。看一下下面的例子：</p><p><strong>1.判断数据类型</strong><br>利用 <code>Object.prototype.toString.call()</code> 可以准确地判断数据类型，如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"[object String]"</span> <span class="token comment" spellcheck="true">//true</span>
Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"[object Array]"</span>  <span class="token comment" spellcheck="true">//true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原理就是：在任何值上调用 <strong>Object 原生的 toString() 方法</strong>，都会返回一个格式为 [object NativeconstructorName] 的字符串。据此可以准确判断任何值的数据类型。<br>既然 Array 和 Function 都继承了 Object 的该方法，为什么不直接在它们身上调用？这是因为 <code>toString()</code> 被重写过了，<strong>不是原生方法</strong>，因此这里改为调用 Object 的该方法，并将 this 绑定给对应的值。</p><p><strong>2.模拟浅拷贝</strong><br>模拟浅拷贝的过程中，需要剔除原型链上的属性，考虑到源对象可能基于 <code>Object.create()</code> 创建，而这样的对象是没有 <code>hasOwnProperty()</code> 方法的，因此我们不在源对象身上直接调用该方法，而是通过 <code>Object.prototype.hasOwnProperty.call()</code> 的方式去调用，因为 Object 一定是有这个方法的，我们可以借用一下。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>nextSource<span class="token punctuation">,</span> nextKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    to<span class="token punctuation">[</span>nextKey<span class="token punctuation">]</span> <span class="token operator">=</span> nextSource<span class="token punctuation">[</span>nextKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>3.继承</strong><br>JavaScript 的几种继承方式中，有一种就是借用构造函数：<br>假设有子构造函数 <code>Son</code> 和父构造函数 <code>Parent</code>。对于 <code>Son</code> 而言，其内部的 this 将指向稍后实例化的对象，利用这一点，我们在 <code>Son</code> 的内部通过 <code>call()</code> 或者 <code>apply()</code> 调用 <code>Parent</code>，同时传参 this，这样就可以增强子类实例。</p><p><strong>4.类数组借用数组的方法</strong><br>例如 arguments 是类数组，并不具备数组的 <code>forEach()</code> 方法，那么我们可以通过 <code>call()</code> 调用数组的该方法，同时将方法里面的 this 绑定到 arguments 上：</p><pre class="line-numbers language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>forEach<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>5.求数组的最值</strong><br>核心是 <code>apply()</code> 可用于展开数组，即我们前面说过的将参数数组转化为参数列表。<br>例如我们要求一个数组的最大值，虽然 Math 对象有 <code>max()</code> 方法，但该方法只接受参数列表。那么这时候，我们可以通过 <code>apply()</code> 去调用该方法，从而展开数组</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

Math<span class="token punctuation">.</span>max<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 5</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参考：<br><a href="https://www.cnblogs.com/onepixel/p/6034307.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/6034307.html</a><br><a href="https://juejin.im/post/5d469e0851882544b85c32ef" target="_blank" rel="noopener">https://juejin.im/post/5d469e0851882544b85c32ef</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/08/06/F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/" rel="prev" title="数据类型判断"><i class="fa fa-angle-double-left"></i>&nbsp数据类型判断</a></div><div class="post-nav-next"><a href="/2019/08/03/F-JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="next" title="《JavaScript 高级程序设计》阅读笔记 1：最佳实践">《JavaScript 高级程序设计》阅读笔记 1：最佳实践&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本语法："><span class="toc-text">基本语法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#返回值"><span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参数介绍："><span class="toc-text">参数介绍：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行"><span class="toc-text">执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用场景"><span class="toc-text">应用场景</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->