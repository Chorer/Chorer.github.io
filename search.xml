<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解闭包]]></title>
    <url>%2F2019%2F02%2F27%2F%E3%80%90%E8%BD%AC%E3%80%91%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言：本篇博客不是原创，而是转载自@王福朋 王老师的系列文章。系列文章共计18篇，主要涉及js中的两座“大山”—-原型和闭包，由于原型部分我在另外一篇博客有介绍，所以这里只集合了他关于闭包的几篇讲解，包括了作用域、执行上下文等。我很喜欢他的讲解方式：图文并茂+循序渐进。原作者：王福朋原始出处：深入理解JavaScript原型和闭包转载授权:1.简述执行上下文（上）：什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：这是第一种情况。下面还有。先来个简单的。有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。下面还有。。。第三种情况。在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。好了，“准备工作”介绍完毕。我们总结一下，在“准备工作”中完成了哪些工作：变量、函数表达式——变量声明，默认赋值为undefined；this——赋值；函数声明——赋值；这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的。细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。这里解释一下为什么代码段分为这三种。所谓“代码段”就是一段文本形式的代码。首先，全局代码是一种，这个应该没有非议，本来就是手写文本到&lt;script&gt;标签里面的。其次，eval代码接收的也是一段文本形式的代码。最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。这样解释应该能理解了。最后，eval不常用，也不推荐大家用。2.简述执行上下文（下）：继续上面的内容。上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：变量、函数表达式——变量声明，默认赋值为undefined；this——赋值；函数声明——赋值；如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。另外一点不同在于，函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。全局代码的上下文环境数据内容为：如果代码段是函数体，那么在此基础上需要附加：给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。3.执行上下文栈继续上文的内容。执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。其实这是一个压栈出栈的过程——执行上下文栈。 如下图：可根据以下代码来详细介绍上下文栈的压栈、出栈过程。如上代码。在执行代码之前，首先将创建全局上下文环境。然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。执行到第13行，调用bar函数。跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。并将这个执行上下文环境压栈，设置为活动状态。执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。要说闭包，咱们还得先从自由变量和作用域说起。4.作用域提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：再比如for语句：所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——javascript除了全局作用域之外，只有函数可以创建的作用域。所以，我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。jQuery就是一个很好的示例：下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。说到这里，咱们又可以拿出jquery源码来讲讲了。jQuery源码的最外层是一个自动执行的匿名函数：为什么要这样做呢？原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。下一节将把作用域和执行上下文环境结合起来说一说。可见，要理解闭包，不是一两句话能说清楚的。5.作用域和上下文环境上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。另外，对上下文环境不了解的朋友，可以回过头看看前面。第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。结束了 ！最后我们可以把以上这几个图片连接起来看看。连接起来看，还是挺有意思的。作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。6.从自由变量到作用域链先解释一下什么是“自由变量”。在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。上面描述的只是跨一步作用域去寻找。如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。这个一步一步“跨”的路线，我们称之为——作用域链。我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；第四步，跳转到第一步。以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。7.闭包前面提到的上下文环境和作用域的知识，一方面是必须了解的知识，一方面也是理解闭包的基础。至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。闭包的作用，简而言之一句话：可以在其他的执行上下文中，访问到函数的内部变量。第一，函数作为返回值如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。第二，函数作为参数被传递如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。上一节讲到自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。咱们可以拿本文的第一段代码（稍作修改）来分析一下。第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域.。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。使用闭包会增加内容开销，现在很明显了吧！第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。正如我们所看到的，闭包和作用域、上下文环境有着密不可分的关系。另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么，因为这些BUG可能完全在你的知识范围之外。到现在闭包就简单介绍完了。8.补充：上下文环境和作用域的关系本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。在说明之前，咱们先用简单的语言来概括一下这两个的区别。8.1. 上下文环境：可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？8.2. 作用域：首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。8.3. 两者：一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。上面的文字不理解没关系，且看下面的例子。第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境。讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>作用域</tag>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大一下的一些计划]]></title>
    <url>%2F2019%2F02%2F24%2F%E5%A4%A7%E4%B8%80%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[1.关于英语准备英语竞赛和四级考试，重点是听力和写作；2.前端2.1. 旧东西的收尾，具体来说包括：妙味课堂视频（进阶系列），这部分的速度尽量加快SegmentFault上js进阶的相关文章。由于是js中的难点，并且在面试中出现比较多，所以慢慢来。打算是每周攻克一个或两个【进阶1期】 调用堆栈【进阶2期】 作用域闭包【进阶3期】 this全面解析【进阶4期】 深浅拷贝原理【进阶5期】 原型Prototype【进阶6期】 高阶函数【进阶7期】 事件机制【进阶8期】 Event Loop原理【进阶9期】 Promise原理【进阶10期】Async/Await原理【进阶11期】防抖/节流原理【进阶12期】模块化详解【进阶13期】ES6重难点【进阶14期】计算机网络概述【进阶15期】浏览器渲染原理2.2. 《js高程》的阅读。之所以单独拎出这一点，因为这学期基本不可能读完这么厚的书。所以打算是在学习h5的时候同步阅读本书。2.3. 找一个小项目做。初步决定是类似坦克大战这种面向对象的小游戏，也有可能是hexo的一个主题2.4. 新东西的开始html5+css3，了解新特性，重点放在css动画。如果有时间，就学习ajax和jq。jq不作为重点。PS：不看慕课网。4.关于阅读看两本历史相关的书，大概是以下其中两本：中东问题：《奥斯曼帝国六百年》《穿越百年中东》《中东生死门》以色列/犹太人：《我为何放弃做犹太人》《耶路撒冷异乡人》《我的一生》《我的应许之地》《以色列123》《爱与黑暗的故事》《犹太国》《犹太复国主义史》巴勒斯坦：《最后的天空之后》伊拉克：《搅动世界的伊拉克》阿拉伯：《阿拉伯的劳伦斯》战争回忆录：《南瓜花》5.游戏可能会把巫师3+dlc打通关，当然，前提是有时间。还有记住要克制，不要泛滥。6.剩下的好好学习课程知识啦]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解line-height]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height%2F</url>
    <content type="text"><![CDATA[1.相关概念普及：1.1 顶线，中线，基线和底线 ：直接见下图。inline-block和inline都可以有这四种线。其中，我们重点研究基线，即base line。基线并不是汉字文字的下端沿，而是英文字母“x”的下端沿。1.2 行高：即line-height，是指同一个元素中，两个文本行基线间的垂直距离。12345678&lt;div style="width:170px;"&gt; &lt;span style="font-size:16px;line-height:20px;background:red;"&gt; I'm the first line &lt;/span&gt; &lt;span style="font-size:16px; line-height:40px;background:green;"&gt; I'm the second line &lt;/span&gt;&lt;/div&gt;比如上图或者下图中两条红线之间的距离。1.3 行距：上行的底线和下一行的顶线之间的距离就是行距，行距的一半称为半行距1.4 字体大小：即font-size，是指同一行的顶线和底线之间的距离从上图我们就可以看出，行距、font-size与行高之间的关系满足行距 = （行高 - font-size）当font-size等于行高时，行距 = 0，如下图而当font-size大于行高时，行距为负值，则两行重叠，如下图：1.5 CSS boxes的四种类型（containing boxes、inline boxes、line boxes、content area)1.5.1 content area （内容区）：内容区是包围着文字的一种box，无法显示出来。在没有其他因素 (比如padding) 的影响时，内容区的高度即为font-size。1.5.2 inline box (行内框) ：每个行内元素会生成一个行内框，行内框是一个浏览器渲染模型中的一个概念，无法显示出来。在没有其他因素 (比如padding) 的影响时，行内框的高度即为内容区的高度；设定line-height后，实际改变的是行距，行内框的高度将由 内容区 变为 内容区＋行距。因此，此时会有行内框高度=行高。1.5.3 3.line box（行框） ：行框是指本行的一个虚拟的矩形框，由该行中一个个行内框组成。行框也是浏览器渲染模式中的一个概念，无法显示出来。行框高度等于本行中所有行内框高度的最大值。当有多行内容时，每一行都有自己的行框。1.5.4 containing box（包含框）：包裹着上述三种box的box2. line-height的取值方法与继承一般而言，line-height只影响行内元素( 包括行内替换元素和行内非替换元素，如img和span )，并不能直接应用于块级元素。但是line-height 具有可继承性，块级元素的子元素会继承该特性，并且在行内元素上生效。一般情况下，浏览器默认的line-height为1.2。可以自定义 line-height 覆盖这个初始值，那么该怎样设置line-height呢？有以下5种方式：line-height是个可继承属性，它的继承规则比较复杂。需要提前说明的是：line-height的大小与font-size息息相关，除了指定line-height为多少px，剩下的设置方式都是基于font-size算出来的。 下面一一解释。inherit ：继承父元素line-height的值，所以父元素的是多少就是多少。 如果其后代元素不设置line-height 的话，也会是这个值。数字＋px： 假设设置 line-height 为20px，那么该行的行高就是20px，与 font-size 无关，不会随着 font-size 做相应比例的缩放。 这个长度值（20px）会被后代元素继承，所有的后代元素会使用这个相同的、继承的 line-height (20px)，除非后代元素设定 line-height 。数字＋％ ：假设自身的 font-size 为16px，line-height 设为120%。那么其行高为：16 * 120% = 19.2px。即 line-height 是根据自身的 font-size 计算出来的。 子元素会继承父元素的line-height，它继承的不是百分比而是父元素line-height计算后的最终值。normal ：假设设置line-height 为 normal ，则会根据浏览器的解析情况给元素分配一个倍数，一般是1.2，即line-height为字体的1.2倍。与上一个不同的是，其子元素不再继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~可见，子元素随着自身 font-size 的大小而做相应比例的缩放。纯数字/缩放因子 ：如果既想要 normal 的灵活，又想设置一个自定义的值，那就要用 纯数字 。纯数字方式与 normal 唯一的不同，在于数值的大小不一定是1.2，而是完全由你自己决定。同样地，其子元素不是继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~总结如下：那么，哪一种是最好的方式呢？ 一般来数，设置行高的值为纯数字是最推荐的方式，因为其会随着对应的 font-size 而缩放。3 line-height实现垂直居中的原理通常情况下，div中的a标签包含文本，文本将默认出现在div的顶端，如果想要垂直居中，可以设置div的高度等于行高，由于行高不直接作用于块状元素且行高可以继承，所以实际上等效于设置a的行高等于div的高度。a的行高即a的行内框高度，即 内容区＋行距。行高默认是浏览器分配的1.2，由于此时重新设置了行高☞☞所以行距跟着改变☞☞所以内容区上下往外延伸☞☞即行内框整体延伸。但是，文字始终在行内框里垂直居中，行内框延伸的终点是div的高度，也就是延伸至行内框高度等于div高度。此时，文本自然会在div中垂直居中。]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[提问的智慧]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7%2F</url>
    <content type="text"><![CDATA[提问领域的“圣经”，虽然很难严格按照里面的标准规范自己的行为，但是可以作为一个提醒的方式。译文应该是很长时间没维护了，因为bug被直接翻译为“臭虫”的情况屡见不鲜，但是总体上还是可以把英文原文要表达的意思说明白的。之所以放在博客，一是阅读体验，因为博客的TOC自动生成目录会使得阅读本文更加轻松；二是迁移，这类长文我认为不适合放在笔记里。主要是个人需要，所以悄悄地copy下来了，没有去要授权。原文：http://doc.zengrong.net/smart-questions/cn.html?from=singlemessage下面是正文提问前在通过电邮、新闻组或论坛提技术问题以前，做以下事情：1.尝试在你准备提问论坛的历史文档中搜索答案2.尝试搜索互联网以找到答案3.尝试阅读手册以找到答案4.尝试阅读“常见问题文档”（FAQ）以找到答案5.尝试自己检查或试验以找到答案6.尝试请教懂行的朋友以找到答案如果你是程序员，尝试阅读源代码以找到答案提问时，请先表明你已做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中 学到的东西 ，我们喜欢回答那些表现出能从答案中学习的人。运用某些策略，比如用谷歌（Google）搜索你遇到的各种错误提示（既搜索 谷歌论坛，也搜索网页）， 这样很可能直接就找到了解决问题的文档或邮件列表线索。 即使没有结果，在邮件列表或新闻组寻求帮助时提一句“我在谷歌中搜过下列句子但没有找到什么有用的东西” 也是件好事，至少它表明了搜索引擎不能提供哪些帮助。将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。别着急，不要指望几秒钟的谷歌搜索就能解决一个复杂的问题。读一下常见问题文档。在向专家提问之前，先向后靠靠放松一下，再思考一下问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑抛出，只因你的第一次搜索没有结果（或者结果太多）。认真地思考，准备好你的问题。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想 “愚蠢的问题……”，一边按将错就错的答案回复你，并且希望这种只是得到你自己“问的问题”而非真正所需的解答，给你一个教训。永远不要假设你 有资格 得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社区贡献经验，而不仅仅是消极地要求从别人那获取知识的问题，你将“挣到”答案。另一方面，表明你有能力也乐意参与问题的解决是个很好的开端。“有没有人能指个方向？”，我这还差点什么？”，“我应该查哪个网站？”，通常要比 “请给出我可以用的完整步骤”更容易得到回复，因为你表明了只要有人能指个方向，你就很乐意完成剩下的过程。提问时仔细挑选论坛要对在哪提问留心，如果你做了下述事情，多半会被一笔勾销或被看成“失败者”：张贴与论坛主题无关的问题在面向高级技术问题的论坛上张贴肤浅的问题，或者反之。在太多不同的新闻组同时张贴给既非熟人也没有义务解决你问题的人发送你私人的电邮为保护通信的渠道不被无关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想让这种事落到自己头上的。因此，第一步是找对论坛。谷歌和其它搜索引擎还是你的朋友，可以用它们搜索你遇到困难的软硬件问题最相关的项目网站。那里通常都有项目的常见问题（FAQ）、邮件列表及文档的链接。如果你的努力（包括 阅读 FAQ）都没有结果，这些邮件列表就是最后能取得帮助的地方。项目的网站也许还有报告bug的流程或链接，如果是这样，去看看。向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个内容丰富的网页的作者想充当你的免费顾问，不要对你的问题是否会受到欢迎做太乐观的估计──如果你不确定，向别处发或者压根别发。在选择论坛、新闻组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以明确你的问题是否切题。发贴前先翻翻已有的帖子，这样可以让你感受一下那里行事的方式。事实上，张贴前在新闻组或邮件列表的历史文档中搜索与你问题相关的关键词是个极好的主意，也许就找到答案了。即使没有，也能帮助你归纳出更好的问题。别象机关枪似的一次性“扫射”所有的帮助渠道，这就象大喊大叫一样会令人不快，温柔地一个一个来。弄懂主题！最典型的错误之一是在某种致立于跨平台可移植的语言、库或工具的论坛中提关于 Unix 或 Windows 操作系统程序接口的问题。如果你不明白为什么这是大错，最好在搞清楚概念前什么也别问。一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回答。有几个道理支持这点，一是看潜在的回复者有多少，二是看论坛的参与者有多少，黑客更愿回答能启发多数人的问题。可以理解，老练的黑客和一些流行软件的作者正在承受过多的不当消息。就象那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端──已经好几次了，一些流行软件的作者退出了对自己软件的支持，因为伴随而来的涌入其私人邮箱的垃圾邮件变得无法忍受。面向新手的论坛和互联网中继聊天（IRC）通常响应最快本地的用户组织或者你所用的 Linux 发行版也许正在宣传新手取得帮助的论坛或 IRC 通道（在一些非英语国家，新手论坛很可能还是邮件列表），这些地方是开始提问的好去处，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 通道是公开邀请提问的地方，通常可以得到实时的回复。事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的项目论坛或邮件列表，（否则）该项目的黑客可能仅仅回复“用 我们的 代码”。在任何论坛发贴以前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。通过论坛或 IRC 通道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发者保留。所以先在论坛或 IRC 中寻求与该项目相关的帮助。第二步，使用项目的邮件列表当某个项目存在开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文档和主页，找到项目的邮件列表并使用它。采用这种办法有几个很好的理由：向个别开发者提的问题（如果）足够好，也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为骚扰个别开发者的理由。向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导）也许太忙以至于没法回答你的问题。大多数邮件列表都要存档，那些存档将被搜索引擎索引，如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。如果一个项目既有 “用户” 也有“开发者”（或 “黑客”）邮件列表或论坛，而你又不摆弄那些代码，向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会遭受你的噪音干扰。然而，如果你 确信 你的问题不一般，而且在“用户” 列表或论坛中几天都没有回复，可以试试“开发者”列表或论坛。建议你在张贴前最好先暗暗地观察几天,至少看看最近几天保存的帖子,以了解那的行事方式（事实上这是参与任何私有或半私有列表的好主意）如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。使用有意义且明确的主题在邮件列表、新闻组或论坛中，主题是你在五十个或更少的字以内吸引有资格专家注意的黄金机会，不要用诸如 “请帮我” （更别提大写的 “请帮我！！！！”，这种主题的消息会被条件反射式地删掉）之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题描述。使用主题的好惯例是“对象──偏差”（式的描述），许多技术支持组织就是这样做的。在“对象”部分指明是哪一个或哪一组东西有问题，在“偏差”部分则描述与期望的行为不一致的地方。愚蠢：救命啊！我的笔记本视频工作不正常！明智：X.org 6.8.1 扭曲鼠标光标，MV1005 型号的某显卡芯片组更明智：使用 MV1005 型号的某显卡芯片组在 X.org 6.8.1 的鼠标光标被扭曲编写 “对象──偏差”式描述的过程有助于你组织对问题的细致思考。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在 X.org 中出现？或只是在其 6.8.1 版中？是针对某显卡芯片组？或者只是其中的 MV1005 型号？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。更一般地，想象一下在一个只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接就找到答案的线索，而不用再次发贴提问。如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象 “Re: 测试” 或者 “Re: 新bug”的消息不太可能引起足够的注意。同时，将回复中与新主题不甚相关的引用内容尽量删除。对于列表消息，不要直接点击回复（按钮）来开始一个全新的线索，这将限制你的观众。有些邮件阅读程序，比如 mutt，允许用户按线索排序并通过折叠线索来隐藏消息，这样做的人永远看不到你发的消息。仅仅改变主题还不够。mutt 和其它一些邮件阅读程序还要检查邮件头主题以外的其它信息，以便为其指定线索，所以宁可发一个全新的邮件。在论坛，因为消息与特定的线索紧密结合，并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧。不是所有论坛都允许在回复中出现分离的主题，而且这样做了基本上没有人会去看。不过，通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该线索的人读到。所以，除非你 只想 在该线索当前活跃的人群中提问，还是另起炉灶比较好。使问题容易回复以“请向……回复”来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，换个好点的；如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。在论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是敏感的（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如“留意本线索”、“有回复发送邮件”等功能。用清晰、语法、拼写正确的语句书写经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程（我敢打赌）。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将时间花在其它地方。清楚、良好地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意（你的问题）麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它 必须 很准确，而且有迹象表明你是在思考和关注问题。正确地拼写、使用标点和大小写，不要将“its”混淆为“it’s”，“loose”搞成“lose”或者将“discrete”弄成 “discreet”。不要全部用大写，这会被视为无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox [注：著名黑客，Linux 内核的重要参与者] 也许可以这样做，但你不行。）一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。也不要使用即时通讯中的简写，如将“you”简化为“u”会使你看起来象一个为了节约二次击键的半文盲式的傻子。更糟的是，如果象个小孩似地鬼画桃符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。如果在非母语论坛提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍（是的，我们通常看得出其中的差别）。同时，除非你知道回复者使用的语言，请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被阅读就被直接删除的可能性降到最低。如果你用英语书写但它是你的第二语言，最好提醒潜在的回复者语言上可能的困难以便绕过这个问题，比如：英语不是我的母语，请谅解拼写错误。如果您使用某某语言，请电邮/私聊我，也许我需要您的协助翻译我的问题。对于这个技术术语本身我很熟悉，但对于它的一些俚语或习惯表达方式就不太明白了。我已经同时用某某语及英语提问，如果您使用两者之一回复，我很乐意翻译。使用易于读取且标准的文件格式发送问题如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：使用纯文本而不是 HTML（超文本标注语言）（ 关闭HTML 并不难）使用 MIME（多用途互联网邮件扩展）附件通常没有问题，前提是真正有内容（譬如附带的源文件或补丁），而不仅仅是邮件客户端程序生成的模板（譬如只是消息内容的拷贝）。不要发送整段只是单行句子但多次折回的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的文本终端阅读邮件，设置你的行折回点小于 80 列。但是，也 不要 用任何固定列折回数据（譬如日志文件拷贝或会话记录）。数据应该原样包含，使回复者确信他们看到的是与你看到的一样的东西。在英语论坛中，不要使用’Quoted-Printable’ MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持。当它们分断时，那些文本中四处散布的 “=20”符号既难看也分散注意力，甚至有可能破坏内容的语意。永远 不要 指望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就象有人将还在冒热气的猪粪倒在你门口时你的反应一样。即使他们能够处理，也很厌恶这么做。如果你从使用视窗的电脑发送电子邮件，关闭问题颇多的微软“聪明引用”功能（在“工具” -&gt; “自动纠正选项”的“输入时自动格式化”下去掉聪明引用的选框），以免在你的邮件中到处散布垃圾字符。在论坛，勿滥用“表情符号”和“HTML”功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。如果你使用图形用户界面的邮件客户端程序(如网景公司的 Messenger、微软公司的 Outlook 或者其它类似的)，注意它们的缺省配置不一定满足这些要求。大多数这类程序有基于菜单的“查看源码”命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。描述问题应准确且有内容仔细、清楚地描述问题的症状描述问题发生的环境(主机、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：“Fedora Core 7”、“Slackware 9.1”等）描述提问前做过的研究及其理解。描述提问前为确定问题而采取的诊断步骤。描述最近对计算机或软件配置的任何相关改变。如果可能，提供在可控环境下重现问题的方法。尽最大努力预测黑客会提到的问题，并提前备好答案。如果你认为是代码有问题，向黑客提供在可控环境下重现问题的方法尤其重要。当你这么做时，得到有用且及时回复的可能性将大大增加。西蒙.泰瑟姆（Simon Tatham）写过一篇 如何有效报告bug的文章，我强烈推荐各位阅读。量不在多，精炼则灵你应该（写得）精炼且有内容，简单地将一大堆代码或数据罗列在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝试将其裁剪得越小越好。至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到 有用的 回复。第三，在提纯bug报告的过程中，你可能自己就找到了解决办法或权宜之计。别急于宣称找到bug当你在一个软件中遇到问题，除非你 非常、非常 的有根据，不要动辄声称找到了bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你（声称）发现了文档的“bug”，你应该能提供相应位置的替代文本。记住，还有许多其它用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时就应该发现了（你在报怨前已经做了这些，是吧 ？）。这也意味着很有可能是你弄错了而不是软件本身有问题。编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了bug，也就置疑了他们的能力，即使你是对的，也有可能会使其中的部分人感到不快。（此外，）在主题中嚷嚷“bug”也是特别不老练的。提问时，即使你私下非常确信已经发现一个真正的bug，最好写得像是你做错了什么。如果真的有bug，你会在回复中看到这点。这样做的话，如果真的有bug，维护者就会向你道歉，这总比你弄砸了然后欠别人一个道歉要强。低声下气代替不了做自己的家庭作业有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端：“我知道我只是个可怜的新丁，一个失败者，但……”。这既使人困扰，也没有用，当伴随着对实际问题含糊的描述时还特别令人反感。别用低级灵长类动物的办法浪费你我的时间，相反，尽可能清楚地描述背景情况和你的问题，这比低声下气更好地摆正了你的位置。有时，论坛设有单独的初学者提问版面，如果你真的认为遇到了肤浅的问题，到那去就是了，但一样别低声下气。描述问题症状而不是猜测告诉黑客是什么导致了问题是没用的（如果你的诊断理论是了不起的东西，你还会向别人咨询求助吗？）。所以，确保只是告诉他们问题的原始症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述自己的猜测很重要，应清楚地说明这只是你的猜测并描述为什么它们不起作用。愚蠢：我在编译内核时接连遇到 SIG11 错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？明智：我组装的电脑（K6/233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机 20 分钟左右、做内核编译时频繁地报 SIG11 错，但在头 20 分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问题，相关的典型编译会话日志附后。由于以上这点许多人似乎难以掌握，这里有句话可以提醒你：“所有的诊断专家都来自密苏里州”。美国国务院的官方座右铭则是“让我看看”（出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：“我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。”）针对诊断者而言，这并不是怀疑，而只是一种真实而有用的需求，以便让他们看到与你看到的原始证据尽可能一致的东西，而不是你的猜测与总结。（所以，）让我们看看。按时间先后罗列问题症状刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你、电脑和软件在崩溃前都做了什么。在命令行处理的情况下，有会话日志（如运行脚本工具生成的）并引用相关的若干（如20）行记录会非常有帮助。如果崩溃的程序有诊断选项（如-v详述开关），试着选择这些能在记录中增加排错信息的选项。记住，“多”不等于“好”。试着选取适当的排错级别以便提供有用的信息而不是将阅读者淹没在垃圾中。如果你的记录很长（如超过四段），在开头简述问题随后按时间先后罗列详细过程也许更有用。这样，黑客在读你的记录时就知道该注意哪些内容了。描述目标而不是过程如果你想弄清楚如何做某事（而不是报告一个bug），在开头就描述你的目标，然后才陈述遇到问题的特定步骤。经常出现这种情况，寻求技术帮助的人在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身有问题，结果要费很大的劲才能通过。愚蠢：我怎样才能让某图形程序的颜色拾取器取得十六进制的 RGB 值？明智：我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的 RGB 值。第二种提法是明智的，它使得建议采用更合适的工具以完成任务的回复成为可能。别要求私下回复电邮黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为回复者也因为能力和学识被其它同行看到而得到某种回报。当你要求私下回复时，此过程和回报都被中止。别这样做，让 回复者 来决定是否私下回答──如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人毫无意义。对这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么“向我发电邮，我将为论坛归纳这些回复”将是神奇的句子。试着将邮件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你必须信守诺言。提问应明确漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人（假如只是因为他们承担了太多工作的话），这些人对于没有止境的时间无底洞极其敏感，所以他们也倾向于讨厌那些漫无边际的问题。如果你明确了想让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力并间接地设定了他们为帮助你需要花费的时间和精力上限，这很好。要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很忙的专家那里得到解答。所以限定你的问题以使专家回答时需要付出的时间最少──这通常与简化问题还不太一样。举个例，“请问可否指点一下哪有好一点的 X 解释？”通常要比“请解释一下 X”明智。如果你的代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。关于代码的问题别要求他人给你出问题的代码排错而不提及应该从何入手。张贴几百行的代码，然后说一声“它不能运行”会让你得不到理睬。只贴几十行代码，然后说一句“在第七行以后，本应该显示，但实际出现的是”非常有可能让你得到回复。最精确描述代码问题的方法是提供一个能展示问题的最小测试样例。什么是最小测试样例？它是对问题的展现，只需要刚好能够重现非预期行为的代码即可。如何生成一个最小测试样例？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样例（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源码并去除那些与问题无关的代码段。你能提供的最小测试样例越小越好（参见 量不在多，精炼则灵 ）。生成一个非常小的最小测试样例并不总是可能，但尽力去做是很好的锻练，这有可能帮助你找到需要自己解决的问题。即使你找不到，黑客们喜欢看到你努力过，这将使他们更合作。如果你只是想让别人帮忙审一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。别张贴家庭作业式问题黑客们善于发现“家庭作业”式的问题。我们中的大多数人已经做了自己的家庭作业，那是该 你 做的，以便从中学到东西。问一下提示没有关系，但不是要求完整的解决方案。如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户组、论坛或（作为最后一招）在项目的“用户”邮件列表或论坛中提问。尽管黑客们 会 看出来，一些老用户也许仍会给你提示。删除无意义的要求抵制这种诱惑，即在求助消息末尾加上诸如“有人能帮我吗？”或“有没有答案？”之类在语义上毫无意义的东西。第一，如果问题描述还不完整，这些附加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如“是的，你可以得到帮助”和“不，没有给你的帮助”。一般来说，避免提“是或否”类型的问题，除非你想得到 “是或否”类型的回答。不要把问题标记为“紧急”， 即使对你而言的确如此这是你的问题，不要我们的。宣称“紧急”极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关照。而且“紧急”或其它有类似含义的主题有可能触发垃圾过滤规则，潜在的回复者可能永远看不到你的问题！有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌地提到这点，人们也许会有足够的兴趣快一点回答。当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原因这样做几乎肯定不行。事实上，张贴诸如“紧急：帮我救救这个毛绒绒的小海豹！”肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄懂了再发贴也不迟。礼貌总是有益的礼貌一点，使用“请”和“谢谢你的关注”或者“谢谢你的关照”，让别人明白你感谢他们无偿花时间帮助你。坦率地讲，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要（同时也不能替代它们）。黑客们一般宁可读有点唐突但技术鲜明的bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价它的）然而，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。（我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的“提前谢了”，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的建议是要么先说 “提前谢了”，事后 再 对回复者表示感谢，要么换种方式表达，譬如用“谢谢你的关注”或“谢谢你的关照”）。问题解决后追加一条简要说明问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比较恰当。最理想的方式是向最初提问的线索回复此消息，并在主题中包含“已解决”、“已搞定”或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见线索 “问题 X”和“问题 X-已解决”的潜在回复者就明白不用再浪费时间了（除非他个人觉得“问题 X”有趣），因此可以利用此时间去解决其它问题。追加的消息用不着太长或太复杂，一句简单的“你好──是网线坏了！谢谢大家──比尔”就比什么都没有要强。事实上，除非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。对于有深度的问题，张贴排错历史的摘要是恰当的。描述问题的最终状态，说明是什么解决了问题，在此之后 才指明可以避免的弯路。应避免的弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。最后，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题叙述到最后不知所终总是令人沮丧的，黑客们痒痒地渴望它们被解决。“挠痒痒”为你挣到的信誉将对你下次再次张贴提问非常非常的有帮助。考虑一下怎样才能避免他人将来也遇到类似的问题，问问自己编一份文档或 FAQ 补丁会不会有帮助，如果是的话就将补丁发给维护者。在黑客中，这种良好的后继行动实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。如何解读回答“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸有一个古老而神圣的传统：如果你收到“读读该死的手册”（RTFM） 的回复，发信人认为你应该去“读读该死的手册”。他或她多半是对的，去读一下吧。“读读该死的手册”（RTFM）有个年轻一点的亲戚，如果你收到“搜搜该死的网络”（STFW）的回复，发信人认为你应该“搜搜该死的网络”。那人多半也是对的，去搜一下吧。(更温和一点的说法是“谷歌是你的朋友！”)在论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种关照，提问前应该先搜索一下文档。通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息很容易找到。第二，自已找要比别人喂到嘴里能学得更多。你不应该觉得这样就被冒犯了，按黑客的标准，回复者没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。如果还不明白……如果你看不懂回答，不要马上回复一个要求说明的消息，先试试那些最初提问时用过的相同工具（如手册、FAQ、网页、懂行的朋友等）试着搞懂回答。如果还是需要说明，展现你已经明白的。譬如，假如我告诉你：“看起来象是某输入项有问题，你需要清除它”，接着是个 不好 的回帖：“什么是某输入项？”。而这是一个 很好 的跟帖：“是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？”对待无礼很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱的人是很自然的。如果你觉得被冒犯了，试着平静地反应。如果有人真的做了过格的事，邮件列表、新闻组或论坛中的前辈多半会招呼他。如果这 没有 发生而你却光火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而 你 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外来者，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。（有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，缺少用于润滑人类社会“正常”交往所需的脑电路。这既可能是真也可能是假。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们 喜欢 现在这个样子，并且一般都对病号标记有站得住脚的怀疑。）在下一节，我们会谈到另一个问题，当 你 行为不当时会受到的“冒犯”。别像失败者那样反应在黑客社区的论坛中有那么几次你可能会搞砸──以本文描述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反，你该这样去做：熬过去，这很正常。事实上，它是有益健康与恰当的。社区的标准不会自己维持，它们是通过参与者积极而 公开 地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称“如果你不想帮助用户就闭嘴”。有思路的参与者纷纷离开的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。是夸张的“友谊”（以上述方式）还是有用？挑一个。记着：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要容易得多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃那样对你。有时候，即使你没有搞砸（或者只是别人想象你搞砸了）， 有些人也会无缘无故地攻击你本人。在这种情况下，报怨倒是 真的 会把问题搞砸。这些找茬者要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些找茬者在给自己找麻烦，这点你不用操心。也别让自己卷入口水战，大多数口水战最好不要理睬──当然，是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其中之后（这也是可能的）。提问禁忌下面是些典型的愚蠢问题和黑客不回答它们时的想法。问：我到哪可以找到某程序或 X 资源？问：我怎样用 X 做 Y？问：如何配置我的 shell 提示？问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？问：我的{程序、配置、SQL 语句}不运行了问：我的视窗电脑出问题了，你能帮忙吗？问：我的程序不运行了，我认为系统工具X有问题问：我安装 Linux 或 X 遇到困难，你能帮忙吗？问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？问：我到哪可以找到某程序或 X 资源？答：在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 谷歌 吗？问：我怎样用 X 做 Y？答：如果你想解决的是 Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对要解决的 Y 问题糊涂，还被特定形势禁锢了思维。等他们把问题弄好再说。问：如何配置我的 shell 提示？答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 “读读该死的手册”（RTFM），然后自己去找出来。问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？答：试试就知道了。如果你试过，你既知道了答案，又不用浪费我的时间了。问：我的{程序、配置、SQL 语句}不运行了答：这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下：你还有什么补充吗？噢，太糟了，希望你能搞定。这跟我究竟有什么关系？问：我的视窗电脑出问题了，你能帮忙吗？答：是的，把视窗垃圾删了，装个象 Linux 或 BSD 的开源操作系统吧。注意：如果程序有官方的视窗版或者与视窗有交互(如 Samba)，你 可以 问与视窗相关的问题，只是别对问题是由视窗操作系统而不是程序本身造成的回复感到惊讶，因为视窗一般来说太差，这种说法一般都成立。问：我的程序不运行了，我认为系统工具 X 有问题答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文档作后盾。问：我安装 Linux 或 X 遇到困难，你能帮忙吗？答：不行，我需要亲手操作你的电脑才能帮你排错，去向当地的 Linux 用户组寻求方便的帮助（你可以在 这里 找到用户组列表）注意：如果安装问题与某 Linux 发行版有关，在针对 它 的邮件列表、论坛或本地用户组织中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 “linux”和 所有 被怀疑的硬件 [作关键词] 仔细搜索。问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？答：想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。好问题与坏问题最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。愚蠢：我在哪能找到关于 Foonly Flurbamatic 设备的东西？这个问题在乞求得到 “搜搜该死的网络”（STFW） 式的回复。明智： 我用谷歌搜索过“Foonly Flurbamatic 2600”，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。愚蠢： 我不能编译某项目的源代码，它为什么这么破？提问者假设是别人搞砸了，太自大了。明智： 某项目的源代码不能在某 Linux 6.2 版下编译。我读了常见问题文档，但其中没有与某 Linux 相关的内容。这是编译时的记录，我做错了什么吗？提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，这家伙值得注意。愚蠢： 我的主板有问题，谁能帮我？某黑客对此的反应可能是：“是的，还需要帮你拍背和换尿布吗？”，然后是敲下删除键。明智： 我在 S2464 主板上试过 X、Y 和 Z，当它们都失败后，又试了 A、B 和 C。注意我试 C 时的奇怪症状，显然某某东西正在做某某事情，这不是期望的行为。通常在 Athlon MP 主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？相反地，这个人看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。在最后那个问题中，注意“给我一个回答”与“请帮我看看我还能再做点什么测试以得到启发”之间细微但重要的差别。事实上，最后那个问题基本上源于 2001 年 8 月 Linux 内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。事后，当我感谢大家并评论这次良好的经历时，一个 Linux 内核邮件列表的成员谈到，他认为我得到答案并不是因为我的名字挂在列表上，而只是因为我正确的提问方式。黑客们在某种方面是非常不留情面的精英分子。我想在这事上他是对的，如果我 表现得 象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。如果得不到回答如果得不到回答，请不要认为我们不想帮你，有时只是因为被问到的小组成员的确不知道答案。没有回复不等于不被理睬，当然必须承认从外面很难看出两者的差别。一般而言，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。有许多在线与本地的用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。还有众多大小商业公司提供签约支持服务，别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。象 Linux 这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。如何更好地回答态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 FAQ 都不知道。如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。如果帮不了忙，别妨碍。 不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。探索性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。尽管对那些懒虫报怨一声“读读该死的手册”（RTFM）是正当的，指出文档的位置（即使只是建议做个谷歌关键词搜索）会更好如果你决意回答，给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。请回答真正的问题！如果提问者已经做了自己该做的研究，并且说明尝试过X，Y，Z，A，B与C都没有得到想要的結果，那么回复“试试A或B” 或者给出一个内容为 “试一下X，Y，Z，A，B或C”的链接将极其无益！帮助你的社区从中学习。当回复一个好问题时，问问自己 “如何修改相关文件或 FAQ 文档以免再次解答同样的问题？”，接着再向文档维护者发一份补丁。如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟“授人以鱼，不如授人以渔”。补充(XY Problem)：What is it?The XY problem is asking about your attempted solution rather than your actual problem. This leads to enormous amounts of wasted time and energy, both on the part of people asking for help, and on the part of those providing help.User wants to do X.User doesn’t know how to do X, but thinks they can fumble their way to a solution if they can just manage to do Y.User doesn’t know how to do Y either.User asks for help with Y.Others try to help user with Y, but are confused because Y seems like a strange problem to want to solve.After much interaction and wasted time, it finally becomes clear that the user really wants help with X, and that Y wasn’t even a suitable solution for X.The problem occurs when people get stuck on what they believe is the solution and are unable step back and explain the issue in full.What to do about it?Always include information about a broader picture along with any attempted solution.If someone asks for more information, do provide details.If there are other solutions you’ve already ruled out, share why you’ve ruled them out. This gives more information about your requirements.Remember that if your diagnostic theories were accurate, you wouldn’t be asking for help right?]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[游戏往事]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[对以前游玩刺客信条系列时的一些简单记录。&gt;&gt;佛罗伦萨译：当我年少轻狂时，我曾拥有自由，但我并不明白它的意义。我曾拥有时间，但我没有意识到它的珍贵。我曾拥有爱，但我从未用心去体会。数十年的时间考验后，我终于理解了三者的真谛。现在，我已风烛残年，这种理解已经逐渐变成一种满足。爱，自由和时间，曾一度被我挥霍，而今成为了我前进的动力。而我将最特别的爱，献给最亲爱的你和我们的孩子们，以及刺客联盟的兄弟姐妹们，并献给赋予我们生命的那壮美奇妙，让人产生无限遐想的世界。此爱永恒，Mia Sofia&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ——艾吉奥·奥迪托雷第一次接触刺客信条II，可以追溯到七年前。本是相当久远的时间，然而每每回首再看上面这段话，依旧觉得内心波澜起伏，好像一瞬间，耶路撒冷、佛罗伦萨、罗马、君士坦丁堡的一幕幕都引入眼帘，而Ezio的一生像走马灯一样飞快在我的脑海里闪过。&gt;&gt;加勒比海荡气回肠的加勒比海之旅以如此平静的方式结束。爱德华在最后摘下一朵红花送给女儿，这一幕在今天看来仍然美妙而浪漫，它带给我的视觉冲击力难以言说。“如果没有黄金，我们早就是英雄了”黑胡子的这句话也许是对那个航海时代最好的概括。爱德华最后得到了黄金、跻身上流贵族之列，然而代价之深重恐怕只有他自己清楚。大概人总会有一种错觉，以为离去的人其实还活着。在安妮最后弹唱这首《The parting glass》的时候，爱德华恍惚之间仿佛看到昔日的朋友们正在与自己举杯共饮，片刻后才回过神，他们早就不在了。“晚安，愿快乐与你们相伴”Of all the money that ere I had, I’ve spent it in good company,过去我所有的积蓄，我都已和伙伴们一同分享And of all the harm that ere I’ve done, alas was done to none but me.而我做过的所有伤人之事，唉，受伤的只是我自己And all I’ve done for want of wit, to memory now I cannot recall.我为寻求智慧所做的一切，已成了不可追的回忆So fill me the parting glass, goodnight and joy be with you all.就为我添满这杯离别酒吧，晚安，愿快乐与你们常伴Of all the comrades that ere I had, they’re sorry for my going away,我所有的战友们，都不舍我即将离去And of all the sweethearts that ere I’ve had , they wish me one more day to stay,而我所有的情人们，都希望我多留一日But since it falls unto my lot that I should rise and you should not,但因为我深感起身之时已至 诸君安坐I’ll gently rise and I’ll softly call, Goodnight and joy be with you all.我会轻轻站起并柔声祝道，晚安，愿快乐与你们常伴A man may drink and not be drunk,一位男子大可畅饮但不该喝醉A man may fight and may not be slain一位男子大可战斗但不该嗜杀A man may court a pretty girl一位男子大可追求可爱的女孩and perhaps be welcome back again.而且或许还能欣然再相见But since it has so ordered been by a time to rise可是人生注定如此 有时起And a time to fall又有时落Come fill to me the Parting glass, goodnight and joy be withyou all.为我添满这杯离别酒，晚安，愿快乐与你们常伴Come fill to me the Parting glass, goodnight and joy be with you all.为我添满这杯离别酒，晚安，愿快乐与你们常伴]]></content>
      <categories>
        <category>Gaming</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于js对象和jq对象的疑问]]></title>
    <url>%2F2019%2F02%2F15%2F%24(%20)%5Bi%5D%E8%BF%94%E5%9B%9E%E7%9A%84%E4%B8%8D%E6%98%AFjq%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[问题：想要使所有div下的p标签的类名+1.因此采用下列办法：1234567&lt;div&gt; &lt;p class="1"&gt;1&lt;/p&gt; &lt;p class="2"&gt;2&lt;/p&gt; &lt;p class="3"&gt;3&lt;/p&gt; &lt;p class="4"&gt;4&lt;/p&gt; &lt;p class="5"&gt;5&lt;/p&gt;&lt;/div&gt;12345678&lt;script src="https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js"&gt;&lt;/script&gt;&lt;script&gt; var allp=$("div p"); for(var i=0;i&lt;allp.length;i++)&#123; allp[i].attr("class","i+2"); console.log(allp[i].attr("class")); &#125;&lt;/script&gt;结果控制台报错：提示allp[i].attr不是一个方法，而attr是jq对象的方法，这个报错等于说allp[i]不是一个jq对象。参考stackoverflow ，可知$()[i]返回的的确不是jq对象，而是原生dom对象，无法使用jq方法attr() 。关于如何判断是jq对象还是dom对象，可以用常用的instanceof方法判断，也可以用只有jq对象才有的jquery属性结合if语句判断。那么，如何用jq实现上诉功能？1）转化为jq对象123for(var i=0;i&lt;allp.length;i++)&#123; $(allp[i]).attr("class",i+2); &#125;allp[i] 放在$( )中则为jq对象2).eq(i)123for(var i=0;i&lt;$("div p").length;i++)&#123; $("div p").eq( i ).attr("class",i+2) 。 &#125;这是因为jq collection 对象的eq( )方法将返回以参数值为索引值的单个元素.3).each遍历123$("div p").each(function()&#123; $(this).attr("class",$(this).index()+2); &#125;)当然，因为each()本身可以传参，因此可以写成123$("div p").each(function(i, n)&#123; $(this).attr("class",i+2); &#125;)其中，i表示index，n表示当前元素（可用this操作）4).或者更简单的，配合回调函数使用12345for(var i=0;i&lt;$("div p").length;i++)&#123; $("div p").attr("class"，function(i,n)&#123; n=+2; &#125;)&#125;以上是个错误的例子。jq本身可以隐式迭代，所以这里的for循环完全是多余的，加了for循环反而是错的。隐式迭代：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用在attr中将回调函数作为参数时，回调函数本身接受两个参数。具体到例子中，i为index，n为当前元素的当前值，也就是类名，这里的类名虽然为1到5，但是是string而不是number，所以需要用number( )进行类型转换才可以运算。n最后必须return。综上，正确代码为1234var allp=$("div p"); allp.attr("class",function(i,n)&#123; return Number(n)+1; &#125;);each( )遍历，控制台打印123allp.each(function()&#123; console.log(this); &#125;);]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建：编辑工具的选择]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[Hexo是静态博客网站，必须先在本地编辑好md文件再推送到网站上去—md文件也就是所谓的用markdown语法编写内容的文件。“工欲善其事，必先利其器”，因此我们需要一个合适的markdown编辑工具，它必须具备以下特点：1.可导出md文件到本地，并随时进行修改2.可提供分屏预览，支持同步滚动和定位3.启动时响应速度快，编辑时渲染速度快以下是一些工具在markdown编写方面的优劣比较，可酌情进行选择。（平台：windows）印象笔记印象笔记自带markdown编辑器,如下图：优点：提供分屏预览，无需直接编写md代码，只需点击按钮即可，操作方便缺点：无法导出md文件到本地，这是它的致命缺点。sublime text3优点：安装插件后可以提供分屏预览缺点：预览效果极差，超出的文本内容无法自动换行显示，而是直接隐藏。如下图红框部分Typora优点：简洁美观缺点：不提供分屏预览，md代码编辑完成后回车即自动渲染出文本来。（虽然它认为这是优点，很多人习惯的却是分屏）Atom优点：提供分屏预览，有较多可拓展插件缺点：响应速度极慢，编辑时明显感觉卡顿；软件过大，大概100多m；安装插件极其困难，失败率较高HexoEditor优点：简洁美观，提供分屏预览，图片插入方便缺点：需要用npm指令下载安装，和Atom插件安装如出一辙，很容易卡死Hexo-admin非工具。Hexo自带的博客后台管理，可以在web ui界面下进行编辑优点：提供分屏预览缺点：界面过于简陋，自定义程度较低，本地服务器必须一直开着才能使用Vscode这是这么多工具中我觉得体验最好的，本篇博客也是用vscode编写。优点：提供分屏预览、同步滚动等；较多markdown插件和主题；启动速度快，使用流畅不卡顿，渲染速度很快缺点：需要自己写md代码，不过鉴于md语法并不复杂，我觉得这个缺点完全可以忽略不计。最后是博客编写方面的一点小tip：原生markdown语法并不支持定义字体颜色和大小等样式，但是由于在hexo中，我们编写的md文件最后会生成对应的html文件，所以完全可以在编写的时候使用html语法，浏览器会自动解析并渲染文件中包含的标签等。比如，上面就可以通过将句子放在span标签中，再加上内联样式达到荧光高亮的效果。不止是样式，我们还可以用&lt;br&gt;标签实现换行,让每一段不至于太紧凑。（md中空格是会被合并的，这点和html一样）]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>编辑工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建：Hexo+Github pages]]></title>
    <url>%2F2019%2F02%2F15%2Fhexo%2Bgithub%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[初衷：之前我习惯用印象笔记进行知识的收集和整理，虽然很好用，但终归只适合输入而不适合输出。我需要的是一个更加开放的平台，在这上面可以输出： 1.学习的收获 ；2.生活的感想 ；3.有价值的分享，因此有了这个博客网站。用hexo+github pages 可以很方便地搭建一个个人博客网站，不需要购买域名和服务器，只需要按部就班操作即可。我自己大概是花了两三个小时搞定，主要是因为对git bash的使用不够熟悉，因此走了一些弯路。实际上动作快的话半个小时就可以搞定。下面是对部署过程的大概介绍，以及必须注意的事项（划重点，也就是所谓的“坑”）。由于本文参考了大量博客，所以在文末我会列出原文链接。一.Github，Github pages ，Hexo首先介绍一下这三个东西，有大概的了解、知道是什么东西就可以。GitHub是一个面向开源及私有软件项目的托管平台，而GIthub Pages则是github的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，现在大多用来开发和制作个人博客网站。它的好处在于域名和服务器都是免费提供的，并且没有网站数量的限制。而Hexo 是一个快速、简洁且高效的博客框架，它使用Markdown解析文章，在几秒内，就可以利用靓丽的主题生成静态网页。（关于Hexo的详细介绍，请看官方文档 https://hexo.io/zh-cn/docs/ ，这里就不展开了）。因此，可以说github和hexo是绝配。接下来，开始我们的工作。二. 环境和必要准备我个人的环境：win10，64bit必要准备：你需要（1）github账号 ：前往https://github.com/ 官网注册就好（2）git ： 最新版本的git（本文发表的时候是2.20.1版本），前往https://git-scm.com/ 官网下载并安装。安装完后前往git文件夹下打开git bash，运行以下命令：git config --global user.name &quot;username&quot; git config --global user.email &quot;your mail&quot; 注：将username替换为自己的github账号名，将your mail替换为自己注册github时绑定的邮箱。这一步非常重要，当时部署的时候我因为遗漏了这一步，导致后面报错.（3）node.js ： 前往 https://nodejs.org/en/ 下载并安装。这两个的安装比较简单，一路next就好，不过我推荐还是修改一下路径，尽量放在自己可以找到的位置。（4）hexo ：打开git文件夹下的git bash，运行 以下命令安装hexonpm install -g hexo-cli依次运行以下命令进行hexo的初始化$ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 注：请将上面代码的&lt;folder&gt;替换成你自己想要的文件夹名字，以我为例，我想要在git文件夹下新建一个Myblog文件夹以存放站点文件，那么我这里的代码就应该是$ hexo init Myblog $ cd Myblog $ npm install 成功之后，我们会在git文件夹下看到新建的Myblog文件夹，这个就是我们的站点文件夹，网站相关文件都存放在这里。这里顺便介绍一下cd Myblog的作用，可以理解为“进入Myblog运行git bash”，你也可以在Myblog中右键运行git bash（如下图），效果是一样的。在之后介绍的操作中，凡是需要输入命令的，请确保你已经cd进自己的站点文件夹。接着上面的代码，我们继续运行：1hexo server这将在本地打开我们的网站，当提示”xxx is running at xxx“的时候，我们可以通过http://localhost:4000/ 这个网址预览我们的网站，想要切断连接，只需要在命令行窗口按下ctrl+c。至此，hexo博客已经在本地搭建好了。接下来，我们要将hexo和github进行对接。三. hexo与github 实现对接1.建立仓库还记得我们之前注册的github账号吗？现在，请进入github网站，并点击头像选择your repository，我们现在需要创建一个仓库（也就是repository）用于存放相关站点文件。按照下图顺序进行设置：其中，Repository name也即是我们的仓库名字，必须是 Github账号名称.github.io的格式。比如你的github名字是ccc，那么仓库名字必须是ccc.github.io 。2.对接github在git bash中运行以下命令，安装 hexo-deployer-git 插件。1npm install hexo-deployer-git --save运行以下命令，创建SSH key。（注：和上面一样，请将your mail替换成github邮箱地址）$ ssh-keygen -t rsa -C &quot;your mail&quot; 前往 C:\Users\Administrator.ssh\id_rsa.pub （注意，这只是大概位置。不同系统路径可能不同，但是大同小异）打开id_rsa.pub文件（可以用记事本打开，但是推荐用sublime text）。复制文件中的全部内容，前往 https://github.com/settings/keys ，将刚才复制的内容粘贴在New SSH key 的文本框中。前往站点目录下（例如：git/ Myblog），打开_config.yml 文件，对文件末尾进行如下修改：# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 在这里要注意，1）所有的冒号距离右边的内容之间都有一个空格，如果没有空格，则修改是无效的。2）和前面一样，将usename替换成我们自己的github用户名 。 3）repo后面的地址，在旧版本的hexo中是http地址，但在新版本的hexo用的是ssh地址，我们统一用如上所示的ssh地址。有些博客由于没有进行更新，在说明这个问题的时候依然用的是http地址，造成了一定程度上的误导。运行以下命令，对接并推送内容到github。$ hexo g $ hexo d 等待片刻，打开 https://&lt;Github账号名称&gt;.github.io （例如 https://ccc.github.io ) 即可进入你搭建好的个人博客网站了。当然，网站默认用的是landscape主题，比较难看，关于主题的美化和后期一些插件的添加，可以参考文章末尾贴出的链接。PS：这里顺便介绍一下常用的 hexo 命令：hexo clean ————————&gt;清除缓存文件和已生成的静态文件hexo g 或者 hexo generate ————————&gt;生成静态文件hexo d 或者hexo deploy ————————&gt;生成静态文件并部署到仓库hexo s 或者 hexo server —————————&gt;在本地打开网站一般来说，在对网站进行修改后，我们可以先用hexo g和hexo s 在本地预览效果，如果效果符合预期的话再用hexo d 推送到 github。当然，可能会遇到本地打开和域名打开的效果不一致，这种情况下通常是因为 1. 没有用hexo clean 清除缓存 2. 没有清除浏览器缓存（ctrl+f5 ） 3.忘记用hexo d 将本地文件推送到github 4. 本地和线上的同步本身需要时间，所以上述方法如果无效，可以尝试等几分钟，再打开网站就正常显示了。参考自：https://www.jianshu.com/p/3a05351a37dchttps://www.simon96.online/2018/10/12/hexo-tutorial/]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM Core 与 HTML-DOM]]></title>
    <url>%2F2019%2F02%2F14%2FDOM%20Core%20%E5%92%8CHTML%20DOM%2F</url>
    <content type="text"><![CDATA[DOM（文档对象模型）是由W3C制定的一套访问和操作XML（eXtensible Markup Language）文档的标准，即API。比如DOM告诉JavaScript引擎如何在浏览器窗口中显示和操作XML创建的标记（Tag）。DOM与特定的平台、浏览器、语言无关，很多种语言都实现了DOM，比如因为JavaScript和PHP都实现了DOM，所以 JavaScript中有getElementsByTagName()方法，PHP中也有 getElementsByTagName()，getElementsByTagName()方法是DOM规定的访问XML文档的接口。XML与HTML相似，但两者是有区别。XML和HTML都来自于SGML，它们都含有标记，有着相似的语法，HTML和XML的最大区别在 于：HTML是一个定型的标记语言，用固定的标记来描述和显示数据，比如&lt;h1&gt;表示首行标题，有固定的尺寸；而XML没有固定的标记，只能通过自定义的标记来描述数据的形式和结构，而不能显示。HTML是将数据 和显示混在一起，而XML则是将数据和显示分开来。那为什么能使用DOM访问和操作HTML文档（即网页）呢？Web语义化的一个发展方向是将HTML逐 渐演变为更有语义、能将数据内容与现实分离的XML，但HTML不可能立即演变为XML，目前推荐使用的是一个过渡产物——XHTML。HTML与 XHTML网页形成的节点树（统称为HTML节点树）在结构上与XML节点树一样，可以看做是一个符合DOM的XML文档，因此可以使用实现了DOM的程 序语言（如JavaScript、PHP等）来访问和操作HTML文档，即访问和操作那些节点。由于HTML与XML的相似性及差异，JavaScript不仅实现了标准的DOM方法和属性（即由W3C制定的），而且还实现了HTML特有的 DOM方法和属性，前者称为DOM Core，并不专属于JavaScript，后者称为HTML-DOM。不管是DOM Core还是HTML-DOM，我们在使用JavaScript的时候要注意浏览器之间的兼容性，因为不同的浏览器对这两类方法和属性的支持可能不一样。 这里不详谈DOM Core和HTML-DOM，以及跨浏览器兼容性，教材上都有详细描述。但一般推荐使用DOM Core方法和属性，尽管稍显繁杂。常见的Core DOM方法如下：1、创建节点createElement()createTextNode()2、复制节点cloneNode()3、插入节点appendChild()insertBefore()4、删除节点removeChild()5、替换节点replaceChild()6、查找和设置节点属性setAttribute()getAttribute()7、查找节点getElementById()getElementsByTagName()hasChildNode()常见的Core DOM属性如下：node.childNodesnode.firstChildnode.lastChildnode.nextSiblingnode.previousSiblingnode.parentNode]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件相关概念详解]]></title>
    <url>%2F2019%2F02%2F13%2F%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[事件：事件是用户或浏览器自身执行的某种动作，如click,load和mouseover都是事件的名字。响应某个事件的函数叫做事件处理函数 / 事件处理程序 / 事件句柄。如果想要绑定多个函数，则需要用到事件监听器。1. 事件绑定的几种方式javascript给DOM绑定事件处理函数总的来说有2种方式：在html文档中绑定、在js代码中绑定。下面的方式1、方式2属于在html中绑定事件，方式3、方式4和方式5属于在js代码中绑定事件，其中，方式4和5属于事件监听，而方式5是最推荐的做法。1）在html文档中绑定方式1：1&lt;input type="button" id="btn" onclick="函数名( )"&gt;方式2：1&lt;input type="button" id="btn" onclick="直接写函数内容"&gt;2）在js代码中绑定方式3：1document.getElementById("btn").onclick=function( )&#123; &#125;;说明：方式3也称为“DOM0级事件处理程序”。它无法绑定多个事件，当绑定多个事件的时候，只有最后一个会生效，其他皆被覆盖）方式4：[object].attachEvent(“事件类型”,”处理函数”)说明：①方式4也称为“IE事件处理程序”。这种方法不属于w3c标准，并且仅IE8及以下支持该方法；②事件类型要加on；③如下图，b中声明a函数时分配了一块内存地址 ，两个dom.attachEvent(&#39;onclick&#39;,a)中的a都指向的是下面定义的a；c中只是两个函数体一样的匿名函数，分别有各自的内存地址，故认为是两个不同的函数对象方式5：[object].addEventListener(“事件类型”,”处理函数”,”冒泡事件或捕获事件”);说明：①方式5也称为“DOM2级事件处理程序”。w3c正统标准，IE9及以上、Chrome、Firefox等支持该方法；②事件类型不加on；③第三个参数不设置的时候，默认为false即冒泡；④ 同一个事件处理函数可以绑定2次,一次用于事件捕获，一次用于事件冒泡；如果绑定的是同一个事件处理函数，并且都是事件冒泡类型或者事件捕获类型，那么只能绑定一次；⑤ 不同的事件处理函数可以重复绑定，这点与上面attachEvent是一样的2. 事件处理函数的执行顺序方式123都不能实现事件的重复绑定，所以自然也就不存在执行顺序的问题。方式4和方式5可以重复绑定特性，所以需要了解下执行顺序的问题。结论：对于addEventListener，如果给目标的同一个事件绑定多个处理函数，先绑定的先执行。 attachEvent则刚好相反，后绑定的先执行，这是因为采用attachEvent的是IE8-，而IE8-是不支持dom事件流模型的。12345678910111213&lt;script&gt; window.onload = function()&#123; var outA=document.getElementById("outA"); outA.addEventListener('click',function()&#123;alert(1);&#125;,false); outA.addEventListener('click',function()&#123;alert(2);&#125;,true); outA.addEventListener('click',function()&#123;alert(3);&#125;,true); outA.addEventListener('click',function()&#123;alert(4);&#125;,true); &#125;;&lt;/script&gt;&lt;body&gt; &lt;div id="outA"&gt; &lt;/div&gt;&lt;/body&gt;当点击outA的时候，会依次打印出1、2、3、4。这里特别需要注意：我们是同时给outA这个元素绑定了多个onclick事件处理函数，没有涉及父子元素，所以也不涉及事件冒泡和事件捕获的问题，即addEventListener的第三个参数在这种场景下，没有什么用处，直接忽略之。如果是通过事件冒泡或者是事件捕获触发outA的click事件，那么函数的执行顺序会有变化。3. 事件捕获和事件冒泡我们知道HTML中的元素是可以嵌套的，形成类似于树的层次关系。比如下面的代码：12345&lt;div id="outA"&gt; &lt;div id="outB"&gt; &lt;div id="outC"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;如果点击了最内侧的outC，那么外侧的outB和outC算不算被点击了呢？很显然算，不然就没有必要区分事件冒泡和事件捕获了，这一点各个浏览器厂家也没有什么疑义。假如outA、outB、outC都注册了click类型事件处理函数，当点击outC的时候，触发顺序是A–&gt;B–&gt;C，还是C–&gt;B–&gt;A呢？如果浏览器采用的是事件冒泡，那么触发顺序是C–&gt;B–&gt;A，由内而外，像气泡一样，从水底浮向水面；如果采用的是事件捕获，那么触发顺序是A–&gt;B–&gt;C，从上到下，像石头一样，从水面落入水底。一般来说事件冒泡机制用的更多一些，所以在IE8以及之前，IE只支持事件冒泡。IE9+/FF/Chrome这2种模型都支持，可以通过addEventListener的第三个参数来设定，false代表事件冒泡，true代表事件捕获。12345678910111213141516171819&lt;script&gt; window.onload = function()&#123; var outA = document.getElementById("outA"); var outB = document.getElementById("outB"); var outC = document.getElementById("outC"); // 使用事件冒泡 outA.addEventListener('click',function()&#123;alert(1);&#125;,false); outB.addEventListener('click',function()&#123;alert(2);&#125;,false); outC.addEventListener('click',function()&#123;alert(3);&#125;,false); &#125;;&lt;/script&gt;&lt;body&gt;&lt;div id="outA"&gt; &lt;div id="outB"&gt; &lt;div id="outC"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;使用的是事件冒泡，当点击outC的时候，打印顺序是3–&gt;2–&gt;1。如果将false改成true使用事件捕获，打印顺序是1–&gt;2–&gt;3。4. DOM事件流4.1 事件流定义：事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点与根节点之间按照特定的顺序如流水一样传播，路径所经过的所有节点都会收到该事件，这个传播过程即事件流。4.2 事件流模型：事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即由内到外捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即由外到内4.3 DOM事件流：4.3.1 dom事件流定义：DOM标准采用捕获+冒泡的DOM事件流。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。4.3.2 dom事件流包括：DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。事件捕获阶段：实际目标(&lt;div&gt;)在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。上图中为1~3.处于目标阶段：事件在&lt;div&gt;上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。冒泡阶段：事件又传播回文档。4.3.3 dom事件流与冒泡、捕获将DOM事件流看作整个过程，那么其实 useCapture=false意味着：将该事件处理函数加入到冒泡阶段，在冒泡阶段会被调用；useCapture=true意味着：将该事件处理函数加入到捕获阶段，在捕获阶段会被调用。从DOM事件流模型可以看出，捕获阶段的事件处理函数，一定比冒泡阶段的事件处理函数先执行。4.3.4 dom事件流的相关概念1） target:触发事件的某个具体对象，固定不变的。2） currentTarget:绑定事件的对象，恒等于this，可能出现在事件流的任意一个阶段中。动态变化的。控制台：点击最里面的son3后，可以看到target一直不变，而由于冒泡，导致currentTarget动态变化。3） 两者的应用场合通常情况下target和currentTarget是一致的，我们只要使用terget即可，但有一种情况必须区分这三者的关系，那就是在父子嵌套的关系中，父元素绑定了事件，单击了子元素（根据事件流，在不阻止事件流的前提下他会传递至父元素，导致父元素的事件处理函数执行），这时候currentTarget指向的是父元素，因为他是绑定事件的对象，而target指向了子元素，因为他是触发事件的那个具体对象PS：注意！！！并非所有的事件都会经过冒泡阶段 。所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。5. DOM事件流中的“事件处理函数的执行顺序”我们回头再来说事件处理函数的执行顺序。点击outC的时候，打印顺序是 :capture1–&gt;capture2–&gt;target2–&gt;target1–&gt;bubble2–&gt;bubble1。由于outC是我们触发事件的目标对象，在outC上注册的几个事件处理函数都属于DOM事件流中的目标阶段。对同一个绑定对象（这里是outC）而言，同处于目标阶段的多个函数的执行顺序：先注册的先执行，后注册的后执行。这就是上面我们说的，在目标对象（outC）上绑定的函数是采用捕获，还是采用冒泡，都没有什么关系，因为冒泡和捕获只是对父元素上的函数执行顺序有影响，对自己没有什么影响。至此我们可以给出事件函数执行顺序的结论了：捕获阶段的处理函数最先执行，其次是目标阶段的处理函数，最后是冒泡阶段的处理函数。目标阶段的处理函数如果有多个，则先注册的先执行，后注册的后执行。6. 阻止事件冒泡和捕获默认情况下，多个事件处理函数会按照DOM事件流模型中的顺序执行。如果子元素上发生某个事件，不需要执行父元素上注册的事件处理函数，那么我们可以停止捕获和冒泡，避免没有意义的函数调用。前面提到的5种事件绑定方式，都可以实现阻止事件的传播。由于第5种方式，是最推荐的做法。所以我们基于第5种方式，看看如何阻止事件的传播行为。注意：IE8以及IE8之前可以通过 window.event.cancelBubble=true阻止事件的继续传播；IE9+/FF/Chrome通过event.stopPropagation()阻止事件的继续传播。当点击outC的时候，打印出capture–&gt;target，不会打印出bubble。因为当事件传播到outC上的处理函数时，通过stopPropagation阻止了事件的继续传播，所以不会继续传播到冒泡阶段。想要在哪个节点阻止传播，就在哪个节点的事件处理函数中添加stopPropagation，记得要传参。7. 事件代理/事件委托7.1 概述：事件委托又叫事件代理。JavaScript高级程序设计上讲:事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。我们可以用取快递的例子来理解这个东西。假设：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台也会在收到寄给新员工的快递后核实并代为签收。这里其实还有2层意思的：第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；第二，新员工也是可以被前台代为签收的，即程序中新添加的dom节点也是有事件的。7.2 为什么要使用事件委托：简单来说，就是为了减少不必要的dom操作，优化性能。一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了。比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢？如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，自然性能就会更好。7.3 事件委托的原理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。7.4 事件委托如何实现：终于到了本文的核心部分了。在介绍事件委托的方法之前，我们先来看例一：需求：不管点击哪个li，都能弹出123：123456&lt;ul id="ul1"&gt;&lt;li&gt;111&lt;/li&gt;&lt;li&gt;222&lt;/li&gt;&lt;li&gt;333&lt;/li&gt;&lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;123456789window.onload = function()&#123;var oUl = document.getElementById("ul1");var aLi = oUl.getElementsByTagName('li');for(var i=0;i&lt;aLi.length;i++)&#123;aLi[i].onclick = function()&#123;alert(123);&#125;&#125;&#125;上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作:首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；那么我们用事件委托的方式做又会怎么样呢？123456window.onload = function()&#123;var oUl = document.getElementById("ul1");oUl.onclick = function()&#123;alert(123);&#125;&#125;我们让父级ul监听点击事件，则不管是哪个li被点击————由于冒泡原理，事件最终都会冒泡到ul上，触发ul上的点击事件，弹出123。当然，这里当点击ul的时候，也是会触发的。那么问题就来了，如果我想让事件代理的效果跟直接给某个指定的节点的事件效果一样怎么办？比如说只有点击li才会触发，不怕，我们有绝招：事件本身是一个对象，即Event对象，事件发生时该对象作为参数传给回调函数。而Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称之为事件源.也就是说，target可以表示为当前的事件直接操作的那个dom。当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：1234567891011window.onload = function()&#123; var oUl = document.getElementById("ul1"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125;这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？请看例二：123456&lt;div id="box"&gt;&lt;input type="button" id="add" value="添加" /&gt;&lt;input type="button" id="remove" value="删除" /&gt;&lt;input type="button" id="move" value="移动" /&gt;&lt;input type="button" id="select" value="选择" /&gt;&lt;/div&gt;123456789101112131415161718window.onload = function()&#123;var Add = document.getElementById("add");var Remove = document.getElementById("remove");var Move = document.getElementById("move");var Select = document.getElementById("select");Add.onclick = function()&#123;alert('添加');&#125;;Remove.onclick = function()&#123;alert('删除');&#125;;Move.onclick = function()&#123;alert('移动');&#125;;Select.onclick = function()&#123;alert('选择');&#125;&#125;上面实现的效果很简单，4个按钮对应4个不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？1234567891011121314151617181920212223window.onload = function()&#123;var oBox = document.getElementById("box");oBox.onclick = function (ev) &#123;var ev = ev || window.event;var target = ev.target || ev.srcElement;if(target.nodeName.toLocaleLowerCase() == 'input')&#123;switch(target.id)&#123;case 'add' :alert('添加');break;case 'remove' :alert('删除');break;case 'move' :alert('移动');break;case 'select' :alert('选择');break;&#125;&#125;&#125;&#125;可见，用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？请看例三：我们的需求是是：①移入li，li变红，移出li，li变白②对于点击按钮后新增的li节点，仍然具有该效果。以下是正常的方法：1234567&lt;input type="button" name="" id="btn" value="添加" /&gt;&lt;ul id="ul1"&gt;&lt;li&gt;111&lt;/li&gt;&lt;li&gt;222&lt;/li&gt;&lt;li&gt;333&lt;/li&gt;&lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;12345678910111213141516171819202122window.onload = function()&#123;var oBtn = document.getElementById("btn");var oUl = document.getElementById("ul1");var aLi = oUl.getElementsByTagName('li');var num = 4;//鼠标移入变红，移出变白for(var i=0; i&lt;aLi.length;i++)&#123;aLi[i].onmouseover = function()&#123;this.style.background = 'red';&#125;;aLi[i].onmouseout = function()&#123;this.style.background = '#fff';&#125;&#125;//添加新节点oBtn.onclick = function()&#123;num++;var oLi = document.createElement('li');oLi.innerHTML = 111*num;oUl.appendChild(oLi);&#125;;&#125;你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去——这是因为li遍历这一动作发生在新增li这一动作之前，在那个时候已经确定了li的个数是4，因此只绑定了4个li。这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环封装在一个函数里，命名为mHover，如下：1234567891011121314151617181920212223242526window.onload = function()&#123;var oBtn = document.getElementById("btn");var oUl = document.getElementById("ul1");var aLi = oUl.getElementsByTagName('li');var num = 4;function mHover () &#123;//鼠标移入变红，移出变白for(var i=0; i&lt;aLi.length;i++)&#123;aLi[i].onmouseover = function()&#123;this.style.background = 'red';&#125;;aLi[i].onmouseout = function()&#123;this.style.background = '#fff';&#125;&#125;&#125;mHover ();//添加新节点oBtn.onclick = function()&#123;num++;var oLi = document.createElement('li');oLi.innerHTML = 111*num;oUl.appendChild(oLi);mHover ();&#125;;&#125;与上面方法不同的是，这个方法没有在新增li之前就为原有li绑定事件，而是在新增li后遍历所有的li（包括新增li），并一起绑定事件。虽然功能实现了，看着还挺好，但实际上无疑又增加了一个dom操作，在优化性能方面是不可取的，那么用事件委托的方式，能做到优化吗？12345678910111213141516171819202122232425262728window.onload = function()&#123;var oBtn = document.getElementById("btn");var oUl = document.getElementById("ul1");var aLi = oUl.getElementsByTagName('li');var num = 4;//事件委托，添加的子元素也有事件oUl.onmouseover = function(ev)&#123;var ev = ev || window.event;var target = ev.target || ev.srcElement;if(target.nodeName.toLowerCase() == 'li')&#123;target.style.background = "red";&#125;&#125;;oUl.onmouseout = function(ev)&#123;var ev = ev || window.event;var target = ev.target || ev.srcElement;if(target.nodeName.toLowerCase() == 'li')&#123;target.style.background = "#fff";&#125;&#125;;//添加新节点oBtn.onclick = function()&#123;num++;var oLi = document.createElement('li');oLi.innerHTML = 111*num;oUl.appendChild(oLi);&#125;;&#125;如上，新添加的节点是带有事件效果的。根据事件冒泡原理，不管是原有li还是新增li，只要鼠标一移入li中就等同于鼠标移入ul中，自然会触发ul的鼠标移入事件，之后我们只要在ul的事件函数中定义相关行为就可以了。我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了。这样可以大大的减少dom操作，这才是事件委托的精髓所在。7.5 总结：那什么样的事件可以用事件委托，什么样的事件不可以用呢？适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，至于focus，blur之类的就更不用说了，本身就没有冒泡的特性，自然就不能用事件委托了。8 事件对象8.1 认识事件对象事件在浏览器中是以对象的形式存在的，即event对象。触发一个事件，就会产生一个event对象，该对象包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如：鼠标操作产生的event中会包含鼠标位置的信息；键盘操作产生的event中会包含与按下的键有关的信息。所有浏览器都支持event对象，但支持方式不同，在DOM中event对象必须作为唯一的参数传给事件处理函数，在IE中event是window对象的一个属性。8.2 html事件处理程序中的事件对象12&lt;input id="btn" type="button" value="click"onclick=" console.log('html事件处理程序'+event.type)"/&gt;这样会创建一个包含局部变量event的函数。可通过event直接访问事件对象。8.3 DOM中的事件对象DOM0级和DOM2级事件处理程序都会把event作为参数传入。参数命名：随便。习惯上用e，或者ev或者event。12345678910111213&lt;body&gt;&lt;input id="btn" type="button" value="click"/&gt;&lt;script&gt; var btn=document.getElementById("btn"); btn.onclick=function(event)&#123; console.log("DOM0 &amp; click"); console.log(event.type); //click &#125; btn.addEventListener("click", function (event) &#123; console.log("DOM2 &amp; click"); console.log(event.type); //click &#125;,false);&lt;/script&gt;&lt;/body&gt;DOM中事件对象的重要属性和方法。属性：type属性，用于获取事件类型target属性，用于获取事件直接作用的目标（更具体target.nodeName）currentTarget属性，用于获取事件实际绑定的目标方法：stopPropagation()方法,用于阻止事件冒泡preventDefault()方法,阻止事件的默认行为 移动端用的多8.4 IE中的事件对象第一种情况： 通过DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。12345678910&lt;body&gt;&lt;input id="btn" type="button" value="click"/&gt;&lt;script&gt;var btn=document.getElementById("btn");btn.onclick= function () &#123;var event=window.event;console.log(event.type); //click&#125;&lt;/script&gt;&lt;/body&gt;第二种情况：通过attachEvent()添加的事件处理程序，event对象作为参数传入。123456789&lt;body&gt;&lt;input id="btn" type="button" value="click"/&gt;&lt;script&gt;var btn=document.getElementById("btn");btn.attachEvent("onclick", function (type) &#123;console.log(event.type); //click&#125;)&lt;/script&gt;&lt;/body&gt;IE中事件对象的重要属性和方法:属性：type属性，用于获取事件类型(一样)srcElement属性，用于获取事件直接作用的目标（更具体srcElement.nodeName）cancelBubble属性，用于阻止事件冒泡。IE中cancelBubble为属性而不是方法，true表示阻止冒泡。returnValue属性，阻止事件的默认行为。false表示阻止事件的默认行为PS：targrt和srcElement的兼容性处理如下12345678//兼容性处理function showMsg(event)&#123;event=event||window.event;//IE8以前必须通过window获取event，DOM中就是个简单的传参var ele=event.target || event.srcElement;//获取目标元素，DOM中用target,IE中用srcElementalert(ele);&#125;参考链接：https://blog.csdn.net/aitangyong/article/details/43231111http://www.cnblogs.com/starof/p/4066381.htmlhttps://www.cnblogs.com/liugang-vip/p/5616484.htmlhttp://www.cnblogs.com/starof/p/4077532.html]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>dom事件流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量的两种命名方式]]></title>
    <url>%2F2019%2F02%2F12%2F%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%91%BD%E5%90%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、驼峰命名法：①全部小写：变量名中的每一个逻辑断点/每个单词都用下划线隔开。比如：print_employee_paychecks()；②大小写混合：1）小驼峰法：变量一般用小驼峰法标识。第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstName、myLastName2）大驼峰法/帕斯卡命名法（Upper Camel Case/pascal）：常用于类名，函数名，属性，命名空间。相比小驼峰法，大驼峰法把第一个单词的首字母也大写了。例如：DataBaseUser二、匈牙利命名法：基本原则是：变量名=类型+对象描述。匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等。这些符号可以多个同时使用，顺序是先m_（成员变量），再指针，再简单数据类型，再其他。例如：m_lpszStr, 表示指向一个以0字符结尾的字符串的长指针成员变量。匈牙利命名法中常用的小写字母的前缀：前缀 类型a – – — – – —— —————– 数组 (array)b ———————————- 布尔值 (boolean)by———————————- 字节 (byte)c ———————————- 有符号字符 (char)cb ————————– 无符号字符 (char Byte，没有多少人用)cr ———————————- 颜色参考值 (colorRef)fn ———————————- 函数 （function）fl ———————————- 浮点（float）h ———————————- 句柄（handle）i ———————————- 整型 （int）l ———————————- 长整型 (long Int)lp———————————- 长指针（long Pointer）m ———————————- 类的成员 （member）n———————————- 短整型 (short Int)np ———————————- 近指针（near Pointer）o ———————————- 对象（object）p ———————————- 指针（pointer）re ——————————— 正则（regular expression）s ———————————- 字符串型 （string）sz ————————— 以null做结尾的字符串型 (String with Zero End)]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null和undefined]]></title>
    <url>%2F2019%2F02%2F12%2Fnull%E5%92%8Cundefined%2F</url>
    <content type="text"><![CDATA[一. undefined在变量声明中的体现：1）声明了、但是没有初始化的变量：var aa; alert(aa); 浏览器会弹出窗口显示 undefined。因为对于使用了 var 声明但没有进行初始化定义的变量, 其值默认为 undefined.2） 未声明的变量(1)：alert(aa); 浏览器不会弹出任何东西. 因为 aa 是没有声明的变量。打开 chrome 浏览器的控制台会看到报错如下：3）未声明的变量(2)：alert(typeof aa); 浏览器会弹出窗口显示 undefined。对于没有声明的变量, 只能执行一种操作，即使用 typeof 操作符检验它的类型.。它的类型和声明了但没有进行初始化的变量的类型一样, 都是 undefined.二. null和undefined：alert(undefined == null); // 返回 true 对于undefined 和null 的相等性测试，返回 true,如上图。这是因为，undefined是由null派生而来的。但是，这两者差别很大，之所以要设置两个值，让我们从历史原因说起吧1）历史原因：1995年js诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象；其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。因此，Brendan Eich又额外设计了一个undefined。2）最初设计：JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。Number(undefined) // NaN 5 + undefined // NaN 3）目前的用法：但是，上面这样的区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。①nullnull是基本数据类型之一，值仅有一个，即为null。表示”空对象”(因此类型检测返回对象)，即如果有对象，就会是一个具体的对象，如果没对象，就是null。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。Object.getPrototypeOf(Object.prototype) // null typeof null // object 如果定义的变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子：if(abc != null){ //对abc执行某些操作 } ②undefinedundefined是基本数据类型之一，值仅有一个，即为undefined。表示”缺少值”(因此类型检测返回undefined)，即此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。var i; i // undefined function f(x){console.log(x)}f() // undefined var o = new Object(); o.p // undefined var x = f(); var exp = undefined; 8x // undefined ③如何检测某个变量是undefined：错误的用法：if(abc==undefined) // 正如上面所说，js规定用== 判断时，null和undefined是等同的正确的用法：if (typeof(abc) `==` &quot;undefined&quot;) 或者最简单的办法：if(abc===undefined) 注意！！！ type的用法有运算符形式和函数形式，即if (typeof(abc) == “undefined”) 和 if (typeof abc == “undefined”) 效果是一样的。另外，由于typeof会返回诸如”number”的字符串形式的结果，因此==的右操作数应注意加双引号表示字符串。④如何检测某个变量是null：错误的用法：1、if(abc == null)// 解释同上。不过：要判断abc是 null 或者 undefined 时可使用本法。2、if ( !abc)// 这个的原理是：abc为假值，则 ! abc为真值，条件成立。然而，假值也可能是undefined，0 或 false。不过：要判断 abc是null、undefined、0 或者false 时可使用本法。3、if(typeof abc == &quot;null&quot;)// 为了向下兼容，abc 为 null 时，typeof null 总返回 object，所以不能这样判断。4、 if ( isNull (abc) )// VBScript 中有 IsNull 这个函数，但 JavaScript 中没有。=============================================================================正确的方法：1、 if (! abc &amp;&amp; typeof abc != &quot;undefined&quot; &amp;&amp; abc != 0)// 这个的原理是：如果！abc 成立，则 abc 为假值，则 abc 要么是undefined，0，false或者null 。typeof abc!= “undefined” 排除了 undefined；exp != 0 排除了0 和 false （0= =false，0= =0）。所以，abc一定是剩下的null。2、最简单的方法：if (abc=== null) 尽管如此，我们在 DOM 应用中，一般只需要用 (! abc) 来判断就可以了，因为 DOM 应用中，可能返回 null，可能返回 undefined，如果具体判断 null 还是 undefined 会使程序过于复杂。三. 测试对象是否存在：在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法。对象只有被定义才有可能为 null，否则为 undefined。因此，如果我们想测试对象是否存在，必须先检测对象是否已定义。因此，这是错误的：if (abc !== null &amp;&amp; typeof abc !== “undefined”)这是正确的：if (typeof abc !== &quot;undefined&quot; &amp;&amp; abc!== null)]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型和继承]]></title>
    <url>%2F2019%2F02%2F12%2F%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[这几天在掘金上阅读到了一篇关于原型的文章，角度较之前看到的几篇博客都不一样，顿时感觉我对于原型的知识点还没有完全吃透。鉴于本篇文章很可能会进行不定期的修订和拓展，故在此附上更新日志，以简单记录我在学习上的认知更新。2019.2.24js继承的几种实现方式2019.2.19完善关于constructor属性的介绍比对new和Object.create()的本质区别纠正隐式原型的错误写法（之前没看仔细，一直写错，今天报错才发现）1.创建对象的方法在了解原型链之前，首先先了解一下创建对象的几种方式，为后面做个铺垫。介绍以下三种。代码：1234567891011121314151617&lt;script type="text/javascript"&gt;// 第一种方式：字面量var o1 = &#123;name: 'o1'&#125;var o2 = new Object(&#123;name: 'o2'&#125;)// 第二种方式：构造函数var M = function (name) &#123; this.name = name; &#125;var o3 = new M('o3')// 第三种方式：Object.createvar p = &#123;name: 'p'&#125;var o4 = Object.create(p)console.log(o1)console.log(o2)console.log(o3)console.log(o4)&lt;/script&gt;打印结果：2.构造函数、实例、原型、原型链先来一张图简单了解一下2.1 什么是原型？实例？构造函数？首先是代码12var M = function (name) &#123; this.name = name; &#125;var o3 = new M('o3')实例就是通过new一个构造函数生成的对象。在本例中o3就是实例，M就是构造函数。每个函数都有prorotype属性，每个对象都有proto 属性（隐式原型,读作dunder prototype）从上图中可以知道，实例的protpo指向原型对象。从上图中可以知道，实例的构造函数的prototype也是指向原型对象。原型对象的construor指向构造函数。再来通过下面这个图来理解一下2.2 什么是原型链？简单理解就是原型组成的链，实例的proto就是原型，而原型也是一个对象，也有proto属性，它会指向另一个原型…………就这样可以一直通过proto向上找，这就是原型链，当向上找找到Object这个构造函数的原型（即null）时，这条原型链就算到头了。也就是说，原型链的尽头是null 。2.3 原型作用何在？原型的存在是为了帮助实现继承。我们先来思考一个问题：假如现在通过一个构造函数创建了多个实例，想要给它们添加同一个方法，该怎么做呢？1.给每个实例去添加。太过麻烦，并不是一个明智的选择；2.在构造函数的内部添加方法。这样做的话在每次用构造函数创建实例时都会大量产生方法的副本，这些方法副本功能一样，实际却是不同的。这会影响性能，且不利于代码复用；3 .这时，就该用上原型了。只要给构造函数的原型添加一个方法，那么构造函数的所有实例便都有了这个方法。接着上面的例子继续演示：123456789function M(name) &#123;this.name = name;&#125;var o3 = new M('o3')var o5 = new M('o5')M.prototype.say=furnction()&#123;console.log('hello world')&#125; o3.say() o5.say() console.log(o3.say()==o5.say()); // true打印结果按照JS引擎的分析方式，在访问一个实例的方法时，首先在实例本身中找，如果找到了就说明其构造函数先前是有定义这个方法的(this)；如果没找到就去实例的原型中找，还没找到就再沿着原型链往上找，直到找到。当然，不止方法，属性也是可以继承自原型的。那么怎么判断属性是实例本身具有的还是继承的？对实例用 hasOwnProperty( )方法即可。那么实例为何有这个方法？同样是继承来的。 由于所有的对象的原型链都会找到追溯到Object.prototype，因此所有的对象都会有Object.prototype的方法，其中就包括 hasOwnProperty( )方法 。2.4 访问原型可以用obj.prototype，obj.__proto__，或者obj.getPrototypeOf()。这里重点说后面两个。__proto__属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，更不推荐通过这种方式修改实例的原型，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用 Object.getPrototypeOf()。2.5 原型、构造函数、实例、Function、Object的关系前面我们给出了一幅图简单梳理了一下关系，但想追本溯源，光靠那张图是不够的。下面我们给出另一张更详细的图。请先记住，Function和Object 是特殊的构造函数。首先从构造函数Foo（或任意一个普通构造函数）出发，它创建了实例f1和f2等，而实例的__proto__指向了Foo.prototype这个原型，该原型的__proto__向上再次指向其他构造函数的原型，一直向上，最终指向Object这个构造函数的原型，即Object.prototype。而Object.prototype的 __proto__指向了null，这时我们说到达了原型链的终点null。回过头看，该原型又被Object构造函数的实例的__proto__指向，而函数的实例就是我们通常通过字面量创建的那些对象，也即是图中的o1，o2。那么，普通构造函数（这里指Foo）和特殊构造函数Object又来自于哪里？答案是，来自于另一个特殊构造函数Function。实际上，所有的函数都是由Function函数创建的实例，而构造函数当然也是函数，所以也来自于Function。从图中可以看到，实例Foo的__proto__和实例Object的__proto__ 都指向了 Function的prototype，即Function.prototype 。既然所有的函数都是由Function函数创建的实例，那么Function又是怎么来的？答案是，Function自己创造了自己。它既作为创造其他实例函数的构造函数而存在，也作为实例函数而存在，所以可以在图上看到作为实例的Function的__proto__ 指向了作为构造函数的Function的prototype,即Function.__proto__ ===Function.prototype正如我们前面所说的，Function.prototype的__proto__也像其他构造函数.prototype的__proto__一样，最终指向Object.porototype，而Object.porototype的__proto__最终指向null，原型链结束。可以发现，经过简单梳理，这几者的关系没有我们想象的那么复杂。一句话，看懂这幅图就够了。3.instanceof的原理instanceof 沿着 实例—&gt; proto —&gt; …….. 这条线来找，同时沿着 实例的构造函数的prototype—&gt;proto —&gt; …….. 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。如下图，很显然 f1 instanceof Object 成立注意：正因为 instanceof 的原理如上所述，因此实例的instanceof在比较的时候，与原型链上向上找的的构造函数相比都是true。继续上面的代码那怎么判断实例是由哪个构造函数生成的呢？这时候就要用到constructor了。实例的原型的构造函数， obj.proto.constructor4.constructor属性4.1 定义：构造函数的prototype属性指向它的原型对象，在原型对象中有一个constructor属性，指向该构造函数。值类型（除了null和undefined，这两者不具有这个属性）的constructor是只读的，不可修改，引用类型的constructor是可修改的，例如5.2提到的修复指向。4.2 修复constructor的指向：为了实现从父类到子类方法的继承，一般会重写构造函数的原型，如：12345678function Person()&#123; .........&#125;function Student()&#123; .........&#125;Student.prototype = new Person()var student = new Obj()这将使得实例student具有构造函数Person的方法，但同时也会导致constructor的指向出现问题，造成继承链的紊乱，因此为了修复这个错误指向，需要显式指定obj.prototype.constructor = obj 。拿下面例子说明：未重写原型对象之前，实例化了一个dog；第6行重写了原型对象，使其指向另一个实例（等式右边是字面量，因此可以看作是由Object构造函数实例化出来的一个对象），之后实例化了一个cat。查看dog和cat的constructor：12console.log(dog.constructor); //function Animal()console.log(cat.constructor); //function Object()12dog.say(); //wancat.say(); //miao首先，构造函数没有constructor属性，这导致了它构造的实例也没有constructor属性，所以，实例将沿着原型链(注意，构造函数不算在原型链里)向上追溯对应的原型对象的constructor属性。dog.constructor可以指向原来的构造函数，说明原来的原型对象还存在；而cat.constructor 指向另一个构造函数，是因为Animal( )的原型被重写，并且作为Object( )构造函数的一个实例而存在，那么由cat实例出发，向上进行constructor属性追溯的时候，最终会找到Object( ) 构造函数。同样的，正因为原型重写前后创建的实例分别对应了初始原型和新的原型，所以我们可以对旧实例调用初始原型的方法、对新实例调用新的原型的方法，放在本例子中，就表现为dog依然可以调用say( )方法发出wan，而cat也可以调用say( )方法发出miao 。总结：重写原型对象之后，会切断构造函数与最初原型之间的连接，使新构造的实例对象的原型指向重写的原型，而先前构造的实例对象的原型还是指向最初原型。在这种情况下，先前的实例对象可以使用最初原型的方法，新的实例对象可以使用重写的原型的方法。5. new和Object.create() 的区别：这里，让我们回到文章开头提到的创建对象的三种方式。重点介绍后两种。5.1 newnew一个构造函数时，实际发生的过程是：123var o=&#123;&#125;;o.__proto__=M.prototypeM.call(o)第一步，创建一个空对象o；第二步，令空对象的proto指向构造函数M的prototype；第三步，令构造函数M中的this指针指向o，使得o具有M的属性或方法，因为M无返回值或返回的不是对象，所以最后会返回o 。在这里要注意下面这个坑：1234var Base = function()&#123;this.a = 2;&#125;;console.log(Base.a);构造函数就好比印钞机，而它创建的实例就好比钞票。构造函数中的this.xxxx都是为了实例而准备的属性和方法，这些this在构造函数内，但并不指向构造函数，而是在new构造函数执行的时候转而指向新实例。构造函数自身没有这些属性和方法，像上面那样调用Base的a属性是会报错的，Base根本没有a属性。5.1.1 手动实现new运算符下面根据new的工作原理通过代码手动实现一下new运算符123456789var new2 = function (func) &#123;var o = Object.create(func.prototype); //创建对象var k = func.call(o); //改变this指向，把结果付给kif (typeof k === 'object') &#123; //判断k的类型是不是对象return k; //是，返回k&#125; else &#123;return o; //不是，返回构造函数的执行结果&#125;&#125;验证经过上图一系列折腾，不难看出，我们手动编写的new2和new运算符的作用是一样的。5.2 Object.create()Object.create()方法创建一个新对象（实例），并使用现有的对象(参数)作为新创建的对象的proto 也就是说，这个方法可以起到指定原型的作用。执行Object.create() 时，实际发生的过程是：12345Object.create = function (o) &#123; var F = function () &#123;&#125;; F.prototype = o; return new F();&#125;;第一步，创建空的构造函数；第二步，令构造函数的prototype指向传入的对象；实际上也相当于 令新实例的proto指向传入的对象第三步，实例化一个对象并返回这里，如果Object.create()接受的参数是null，即var obj = Object.create(null),则obj是真正意义上的空对象，不具有hasOwnProperty(),toString()等方法或属性。6 js实现父类到子类的继承的7种方式6.1.原型链继承核心：重写子类原型，代之以父类的实例12345function Person()&#123; this.age=[6,12,24];&#125;function Worker()&#123;&#125;Worker.prototype = new Person();缺点：创建子类实例时，无法向父类构造函数传参；对一个子类实例的引用类型属性的操作将会影响其他子类实例，即引用属性共享12345var worker1 = new Worker()var worker2 = new Worker()worker1.age.push(48)alert(worker1.age) //[6,12,24,48]alert(worker2.age) //[6,12,24,48]6.2.借用构造函数继承又称为冒充继承、经典继承、伪造对象继承核心：使用父类的构造函数来增强子类实例，等同于复制父类的实例属性给子类（不使用原型）123456789101112function Person(name)&#123; this.age=[6,12,24]; this.name=name;&#125;function Worker(name)&#123; Person.call(this,name);&#125;var worker1 = new Worker()var worker2 = new Worker()worker1.age.push(48)alert(worker1.age) //[6,12,24,48]alert(worker2.age) //[6,12,24]缺点：虽然消除了原型链继承的缺点，但是不利于实现函数复用，每个子类都有父类实例函数的副本，影响性能。6.3.组合继承核心：原型链继承+借用构造函数继承。即使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.12345678910111213function Person()&#123; this.age=[6,12,24];&#125;Person.prototype.shout=function()&#123; alert("Ahhhhhh");&#125;function Worker()&#123; Person.call(this); ...其余新增属性。。。&#125;Worker.prototype=new Person()Worker.prototype.constructor=Worker //别忘记修正constructor的指向var worker1 = new Worker()缺点：很常用的继承方式，但也有缺点，就是代码第11、13行合计调用了两次父类函数，造成了不必要的消耗。6.4.原型式继承用到了object()，规范化之后即为Object.create()核心：利用Object.create()对传入其中的对象进行浅拷贝12345var Person = &#123; age: [6,12,24]&#125;var worker1 = Object.create(Person)var worker2 = Object.create(Person)缺点：和原型链继承一样，存在引用属性共享的问题。123worker1.age.push(48)alert(worker1.age) //[6,12,24,48]alert(worker2.age) //[6,12,24,48]原因很好解释，因为worker1无age属性，因此向它的原型查找，它的原型恰好就是Person对象。因此实际上是在改动Person的age属性。6.5.寄生继承核心：创建一个函数用于封装继承的过程，在函数内部增强对象，最后将其返回123456789101112var Person = &#123; age: [6,12,24]&#125;function createAnother(Person)&#123; var worker0 = Object.create(Person); worker0.shout = function()&#123; alert("Ahhhhh"); &#125;; return worker0;&#125;var worker1 = createAnother(Person)worker1.shout()缺点：和原型链继承一样，存在引用属性共享的问题;和经典继承一样，无法实现函数复用6.6.寄生组合继承核心：结合寄生式继承和组合继承的优点，避免为了指定子类的原型而二次调用父类的构造函数1234567891011121314151617181920212223//封装函数。功能：在避免二次调用父类函数的前提下令子类原型指向父类实例function inheritPrototype(subType, superType)&#123; var obj = Object.create(superType.prototype); subType.prototype = obj; subType.prototype.constructor = subType; //修正constructor的指向&#125;// 父类初始化实例属性和原型属性function Person()&#123; this.age=[6,12,24]&#125;Person.prototype.shout = function()&#123; alert("Ahhhhhh");&#125;;// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）function Worker()&#123; Person.call(this);&#125;// 调用函数，令子类原型指向父类实例inheritPrototype(Worker, Person);优点：基本完美的继承方式，无任何缺点，也是目前库实现的方式。6.7.extends类继承1234567891011121314151617181920// 父类class Person &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; shout() &#123; alert("Ahhhhhh"); &#125;&#125;//子类继承父类class Worker extends Person&#123; constructor(name,age,job)&#123; super(name,age); this.job = job; &#125; work() &#123; alert("I am working"); &#125;&#125;解释：可以看作是ES6新增的语法糖，使得js中继承的写法更趋向于传统的面向对象语言。super是关键字，代表父类构造函数，只有在子类的构造函数中调用super()函数，才能让父类构造出this给子类去丰富。参考：http://www.cnblogs.com/wangfupeng1988/p/3978131.htmlhttps://www.cnblogs.com/chengzp/p/prototype.htmlhttps://juejin.im/post/5c6a9c10f265da2db87b98f3https://www.cnblogs.com/94pm/p/9113434.htmlhttps://segmentfault.com/a/1190000016891009]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>原型</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery AJAX load()方法中代码执行顺序的问题]]></title>
    <url>%2F2019%2F02%2F12%2FjQuery%20AJAX%20load()%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题来源于菜鸟教程介绍jq load() 方法时用的一个实例：js：12345678$("button").click(function()&#123; $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr)&#123; if(statusTxt=="success") alert("外部内容加载成功!"); if(statusTxt=="error") alert("Error: "+xhr.status+": "+xhr.statusText); &#125;);&#125;);html：12&lt;div id="div1"&gt;&lt;h2&gt;使用 jQuery AJAX 修改该文本&lt;/h2&gt;&lt;/div&gt;&lt;button&gt;获取外部内容&lt;/button&gt;这里作为load方法参数的函数是一个回调函数。什么是回调函数呢？我们先来看看回调的英文定义：A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。字面上的理解，回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。那么根据这个解释，这段代码应该是先执行load(“demo_test.txt”) 加载外部内容，之后再执行回调函数弹出alert。但是实际运行后发现和预想的不一样：从结果来看，是先弹出alert再改变文本内容。那么，为什么会这样呢？难道上面的说法有误？为了进一步验证，修改代码如下：$(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){ alert(responseTxt); if(statusTxt==&quot;success&quot;){ 运行：很明显文本内容已经改变，说明前面关于回调函数最后执行的说法是没问题的。接着猜想，之所以先弹出alert再改变文本内容，可能是因为必须等回调函数执行完后才能把文本渲染到浏览器上。为了进一步验证，修改代码如下：12345$("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr)&#123; if(statusTxt=="success")&#123; debugger； console.log("1"); &#125;运行：控制台中没有打印出1，且程序中断，说明此时回调函数还在执行当中，但是文本内容却已经改变了。这说明上面的猜想错误—–即文本渲染到浏览器上不需要等到回调函数执行结束。但是，那只是一般情况！！问题就在于，alert是可以阻塞浏览器的渲染工作的！重新运行最初的代码，可以看到还是先弹出alert，文本没变，但是这时候点开控制台的elements，可以看到图中红框显示这时候文本的内容其实已经改变了。虽然文本内容看上去不变——但是实际情况是文本内容已经改变了，也就是load()方法已经生效了，只是alert阻塞了浏览器将它渲染出来。在这里还要注意，alert可以阻塞浏览器的渲染，而debugger是没办法的。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AJAX</tag>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英伦摇滚入门：20支英国摇滚乐队]]></title>
    <url>%2F2019%2F02%2F11%2F%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F%2F</url>
    <content type="text"><![CDATA[之前看到的一篇关于英国摇滚乐队的总结。还挺好的，不全是英伦摇滚。排名不分先后，当然，我还是偏爱Oasis。1. The Beatles（披头士乐队/甲壳虫乐队）这支才华横溢的英国乐队就不用多说了，几乎是英国摇滚的代名词，屹立半个世纪不倒，他们的作品现在还传颂世界。The Beatles（披头士乐队）虽然早已不复存在，但是他们却奠定了英式摇滚的基本基调，在国际音乐界享有盛誉。他们的贵族式的优雅反击直击摇滚的核心精神：为普通人发出声音和呐喊。爱和自由、反战是披头士永恒的创作主题。披头士有两位灵魂人物，一位是John Lennon（约翰·列侬），一位是James Paul McCartney（保罗·麦卡特尼）。喜欢这支乐队的朋友可以看看乐评《最爱那一世的疯狂——“披头士热”下的英伦风情》经典专辑：《Sergeant Pepper’s Lonely Hearts Club Band》、《Abbey Road》、《Let It Be》、《Rubber Soul》、《Help!》2. The Rolling Stones（滚石乐队）The Rolling Stones（滚石乐队）是一支非常长寿的英国摇滚乐队，一直活跃在英国的摇滚乐坛，他们和披头士分庭抗礼，代表着两种不同的摇滚理念：披头士是温和的、优雅的，而滚石则是纯粹的、爆裂性的。滚石乐队成员的平均年龄已经超过了70岁，堪称英国摇滚界的活国宝，他们身先士卒证明了什么叫“老骥伏枥，志在千里”。几个“老头子”处处践行着不服老的摇滚心态，依然能够在舞台上大放光彩，不断推出新作，这才是真正的摇滚精神！绝对的硬摇滚，粗放豪气的摇滚范儿，祝福这支长寿的乐队！经典专辑：《Let It Bleed》、《Beggars Banquet》、《Exile On Main Street》3. The Who（谁人乐队）作为“布兰顿之声”的The Who（谁人乐队），他们代表着反叛与反主流的音乐风格，他们是MOD文化的代言人，四人个性放荡不羁，反叛而激进，为青年而歌，为底层人民而歌。正是The who发明了摇滚乐的砸琴砸摔鼓的表演风格，他们是纯粹硬摇乐队，是反叛的象征，他们的舞台表演风格为后世许多的摇滚乐队所模仿。The Who创造了许多的经典歌曲，至今无人能够超越。经典专辑：《Who’s Next》、《Tommy》、《My Generation》4. The Police（警察乐队）想听慢摇风格的乐迷看过来，这支乐队非常具有传奇色彩，他们靠着借贷创作的第一张专辑就大卖一万多张。他们的乐队风格有一种华丽的英式抒情的感觉，感觉主唱的爆破音特别重，他们的歌曲特别有感染力，另外主唱Sting还会唱西班牙语，非常多才多艺。这支乐队只有三个人，但是曾经获得了六次格莱美奖，乐队在义演散场之后宣布告别，但是灵魂人物Sting现在还活跃在英国乐坛之上，还多次斩获格莱美。经典专辑：《Regatta de Blanc》、《Zenyatta Mondatta》、《Wrapped Around Your Finger》5. Pink Floyd（平克·弗洛伊德）大PF是必须要说的，促使我去了解英国摇滚乐队的就是披头士和Pink Floyd（平克·弗洛伊德）了，PF不算是那种非常有盛誉的那种乐队，但是我就是喜欢。他们的音乐充满哲学的思辨气质和浪漫主义的想象力，专辑的艺术感极强，尤其是他们开创的太空迷幻摇滚，简直是致幻的LSD，令人沉醉其中不能自拔。他们在音乐技术上的突破和对迷幻摇滚新领域的开辟，都在音乐史上不可被磨灭，这支乐队有一支长达23分钟的神奇的单曲——《Echoes》，号称一曲走天下，他们的《月之暗面》（The Dark Side of The Moon）和《迷墙》（The Wall）两张专辑永垂不朽。某种程度上来说，我甚至觉得他们是一支被低估了的乐队。经典专辑：《The Wall》、《The Dark Side of the Moon》、《Ummagumma》6. Sex Pistols（性手枪乐队）要说到英国的朋克摇滚，就必须要说到Sex Pistols，在1976年，性手枪参加了伦敦牛津The 100俱乐部举办的朋克音乐节，至今这个节日还被认为是朋克文化的发源地。这是一支真正的朋克乐队，有人甚至评价道：“性手枪之后再无朋克”，如果你去听了他们的音乐，就会发现这是真的。他们的音乐充满了黑色幽默和调侃，歇斯底里的反叛甚至是下流的感觉，但这就是真正的朋克精神——彻底的毁灭与自我毁灭。他们的歌曾经登上了BBC排行榜榜首，让全英国人民都为朋克摇旗呼喊，让朋克文化高涨兴盛。但是这支乐队好景不长，他们连换了三个唱片公司，但乐队成员相继离开，最终没落令人十分惋惜。经典专辑：《Jubilee》、《Never Mind the Bollocks Here’s the Sex Pistols》7. The Clash（碰撞乐队/冲击乐队/冲撞乐队）与性手枪相比，The Clash并不算是真正的朋克乐队，因为他们后期逐渐商业化，但是The Clash前期对朋克摇滚做出了巨大的贡献。他们的首张同名专辑就一炮成名，被封为朋克圣典。但是后期的碰撞乐队逐渐吸收了许多的流行摇滚的元素，他们的MTV商业运作得很好。The Clash与Sex Pistols一起铸就了朋克乐队的高峰。碰撞关注社会底层人民的生活状况，他们的歌曲里面充满了对失业、种族歧视和黑帮犯罪势力的反抗和控诉，而且碰撞乐队在美国市场上还比较成功，让英国朋克摇滚名声在外。经典专辑：《London Calling》、《The Clash》、《Black Market Clash》8. Iron Maiden（铁娘子乐队）重金属恶魔的铁娘子乐队！生猛的铁娘子！牛逼的铁娘子！正是他们开启了英国的重金属浪潮。他们是一支霸气的重金属乐队，乐队几经分合，但是做了很多的音乐新领域的尝试，他们做了很多摇滚器乐实验，奠定了铁娘子在重金属领域中的地位。Iron Maiden的曲风非常硬朗，听得人情绪高涨，不自觉地High，主唱的声音简直是绝对的歇斯底里，他们的吉他行云流水，贝斯出神入化，想感受下重金属激情的迷妹一定要去听一下，没听过他们你都不好意思说你听过重金属。经典专辑：《Killers》、《Piece Of Mind》、《Iron Maiden》、《Number of the Beast》9. Def Leppard（威豹乐队）威豹也是英国重金属新浪潮中一支非常重要的乐队，这支乐队70年代末期组建，80年代成名，他们在硬摇滚上造诣很高。80-90年代期间是他们商业最成功的阶段，在美国都具有广泛的影响力。威豹也不是那种纯粹的重金属乐队，他们的情歌非常的好听感人，主唱Joe Elliott的声音是略带沧桑的沙哑，这些摇滚汉子唱起情歌分分钟秒杀你的心灵。另外乐队的长发造型很酷炫，而且他们是双吉他演奏，节奏非常动人优美。这个乐队最令人感动的是鼓手，只有一条手臂还怀着一颗坚毅的心重返乐队，我很敬佩这样牛逼的音乐人。另外他们的合声也是相当美丽的，很少有摇滚乐队合声如此好听，默契到位又流畅自然，分分钟刷新你的重金属三观。经典专辑；《Best of Def Leppard》、《Hysteria》、《Retro Active》10. Suede（山羊皮乐队）Suede（山羊皮乐队）在90年代非常受欢迎，一开始这支乐队其实是倍受质疑的，后来才受到了大众的喜爱。他们的风格是另类摇滚和英式摇滚。这和当时的摇滚大环境有关，90年代，英国传统摇滚乐的巅峰已经接近末声，演化出了英式摇滚，Suede其实就是这些乐队之一。他们的风格比较邪魅狂绢，充满了一种癫狂和风情万种的艺术气质，主唱的声音听多了会怀孕的。山羊皮对华挺友好的，曾经来过中国演出。还有令无数歌迷沉醉的还有主唱的颜值——他年轻的时候简直帅呆了！经典专辑：《The Drowners》、《Suede》、《Coming Up》、《Head Music》11. Oasis（绿洲乐队）Oasis（绿洲乐队）组建于曼彻斯特，是一支个性狂放的乐队，这和乐队的两兄弟的性格有关系。这支乐队最好的地方在于结合了流行摇滚与传统摇滚，传承了传统摇滚的精髓，乐评家非常钟爱这支乐队，对他们给予很高的评价。一说到英式摇滚人们首先会想到就是绿洲，其次是Blur，他们的吉他简直是神了，奠定了英式摇滚的吉他抒情风格。但是他们也叛逆咆哮，这完全不同于像披头士那样的“乖小孩”，自带一种粗犷的摇滚天性。经典专辑：《Definitely Maybe》、《Morning Glory》12. Radiohead（电台司令乐队）Radiohead（电台司令）是那种让人绝望抑郁至死的乐队，个人觉得偶尔听一下还是不错啦。这支乐队的评价还是蛮好的，他们的风格很沉郁，在歌词的创作上独具匠心。灵魂人物兼主唱Yorke性格敏感脆弱，他们的作品里充满了一种病态美学的美感，吟唱人性最卑微脆弱之处，像《Creep》这种就是他们风格的集大成之作，这种风格在摇滚乐队里是比较少见的。经典专辑：《The Bends》、《OK Computer》、《 Kid A 》13. Muse（缪斯乐队）多元的音乐风格、对英式摇滚拿捏到刚刚好的新生代英国摇滚乐队。融合重金属、电子音乐、前卫音乐、太空摇滚等等元素。更难得的是，从缪斯的歌曲里你还能听出千丝万缕的英国古典音乐气息，就像灵魂一样穿插在乐曲之中，非常特别，这在英国这样一个复古气息非常浓厚的国家非常有代表性，所以我认为他们的英式摇滚的头衔是应得的。有人说缪斯主唱Bellamy的唱腔和Yorke很像，细听确实有一点，都有一种浅唱低吟的感觉，但是Bellamy更加积极魅惑一点，不似Yorke给人彻彻底底地绝望之感。经典专辑：《Black Holes and Revelations》、《Absolution》、《The 2nd Law》14. Blur（模糊乐队/布勒乐队/污点乐队）这支乐队和绿洲一起是一个神奇的存在，最为乐迷津津乐道的就是Blur（模糊乐队）与绿洲的掐架了，因为他们的风格挺像的，都是英式摇滚路线。但是我觉得模糊乐队没有像绿洲那样的狂放个性，显得更加的温和内敛，所以这支乐队被认为具有披头士的神韵。很多人评价一支乐队经常说某某乐队是某某乐队的接班人，我其实并不喜欢这种评价，乐队和乐队之间是一种传承和学习的关系，但是每个乐队都是一个独立的个体，所以我觉得披头士是披头士，Blur是Blur。近几年Blur做了一些比较诡异的尝试，风格越来越让人摸不透了，不过有了自己的经典之作之后，他们想做一些新的突破也是非常勇敢的。经典专辑：《The Best Of Blur》、《The Great Escape》、《Parklife》15. Travis（特拉维斯乐队）这是来自苏格兰的一支传统摇滚乐队，他们涉足英式摇滚、传统摇滚、Post-Grunge与另类摇滚多个领域。乐队成员都是70后，他们最开始只是一个小地方的乐团，发行第二张专辑之后难掩才华，一时间成为英国摇滚乐坛巨星。其实我觉得主唱的声线是比较忧郁的，唱歌的方式有点浅唱低吟的感觉。他们也尝试过软摇滚，总之是一支听起来比较舒服的乐队。经典专辑：《The Man Who》、《Side》、《Pipe Dreams》16. Queen（皇后乐队）一支华丽丽的硬摇乐队，作品具有浓厚的歌剧色彩，非常硬，乐队的歌曲都保留了那种老式硬摇滚的精髓，键盘和完美的吉他Solo是他们的特点。主唱Freddie Mercury的声音是摇滚乐坛少有的好嗓，非常高亢嘹亮，天生是摇滚主唱的料，这也给皇后乐队注入了一种恢弘而大气磅礴的音乐感染力，但Freddie Mercury不幸因染上艾滋病辞世，全球歌迷为之震惊心痛。在失去这位灵魂人物之后，皇后乐队还是人气高涨，不断出了好作品，最终被选入摇滚名人堂。经典专辑：《A Night at The Opera》、《Innuendo》、《A Kind of Magic》17. Black Sabbath（黑色安息日乐队）一看名字就知道这是支重金属乐队，乐队组建于伯明翰。这支乐队音色纯正，音乐简单干净又粗暴，但是他们的歌曲具有深刻的现实意义。他们的歌曲关注当时的核战争和死亡，描写毒品、反叛、青年和灰暗的生活命运，反映了底层人的痛苦绝望的生活状态，深受当时年轻人的喜爱。这支乐队的辉煌时期在70年代，后来渐渐地没落。好像70年代的英国朋克乐队都很难长久，不知道这是个什么怪圈，我想这可能是因为朋克自身所带的那种毁灭性，使他们自己也无法长久吧。经典专辑：《Paranoid》、《Vol. 4》、《Master Of Reality》、《Sabbath Bloody Sabbath》18. Snow Patrol（雪地巡游者乐队）Snow Patrol（雪地巡游者乐队）是一支来自苏格兰的乐队，乐队风格清新哀婉，歌词非常的温暖感人，是当代比较成功的英国摇滚乐队。乐队风格是迷幻和另类路线，出了一些很不错的单曲，我个人比较喜欢他们的一些作品，可以拿来听听。听他们的歌曲非常的治愈，给人温暖、干净而清澈的感觉，近几年也是风生水起，至于未来还会怎样发展，还有很多的可能性。经典专辑：《Final Straw》、《Up To Now》19. Led Zeppelin（齐柏林飞船）被誉为重金属鼻祖的一支英国乐队，他们的重金属融合了朋克、中东音乐、蓝调、乡村、雷鬼音乐等等元素。他们的有的歌曲听起来很忧伤，令人神往遐思，代入感极强。有很多歌曲的歌词非常的有深度，甚至是对人性的拷问和追寻。他们的音乐前奏都非常漂亮，节奏感超强。虽然是重金属乐队，但是其并没有像后期的重金属乐队那样太多的嘶吼和器乐嘈杂，很是入耳。经典专辑：《Led Zeppelin Ⅳ》、《Houses of the Holy》、《Physical Graffiti》20. The Kinks（奇想乐队）奇想是一支老乐队了，他们主要活跃在60-70年代，在流行摇滚上造诣颇高，曲风也是蛮广的，迷幻、流行随手拈来。作为“不列颠入侵”的主要乐队之一，奇想与披头士、谁人和滚石并称为英国摇滚乐坛“Big Four”，当时的英国摇滚就是这四个乐队大放异彩、风靡全球。奇想也是摇滚名人堂的成员，但是96年这个乐队就解散了。他们的歌曲听着很舒服，充满怀旧伤感之情。可惜的是，这支本来很优秀的乐队在当时有点被披头士的巨大光芒掩盖了，现在去重新发现下也是不错的。经典专辑：《Face to Face》、《Muswell Hillbillies》、《Arthur》英国的摇滚乐队不胜枚举，大大小小的、成名的不成名的、大众的和小众的非常多，他们各有风格，但是真正能够在摇滚史上留下名字的乐队还是少数。总的来说，英国摇滚的特点是自成一派的英式摇滚，还有PF所创立的迷幻摇滚流派，加之上世纪70年代的朋克摇滚，这些都是英国土生土长的摇滚形式。除此外，英国摇滚还有其独有的思想性，从披头士的爱、和平、反战，到朋克对现实的抨击，及众多英式摇滚乐队的壮大复兴，都是英国摇滚乐的迷人之处。]]></content>
      <categories>
        <category>Music</category>
        <category>Britpop</category>
      </categories>
  </entry>
</search>
