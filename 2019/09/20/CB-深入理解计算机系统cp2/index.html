<!-- build time:Sat Nov 09 2019 21:34:39 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Chor&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third party/pace-theme-flash.css"><link rel="icon" href="/images/me.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><i class="fa fa-bars"></i> <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">HOME</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">CATEGORIES</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">ARCHIVES</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">TAGS</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">ABOUT</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="/" class="logo">Chor&#39;s Blog</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">深入理解计算机系统cp2：定点数的表示和运算</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-09-20&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp9 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/计算机系统/">计算机系统</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-0.jpg" alt=""><br><a id="more"></a><br>在<a href="https://chorer.github.io/2019/09/16/CB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1/">深入理解计算机系统cp1：存储单位、数制、编码</a>中解释了字符编码，我们知道了计算机是怎么把字符转化为二进制的；本文将解释数字编码，介绍计算机如何把数字转化为二进制，以及相关的运算问题。</p><h1 id="1-定点数的表示"><a href="#1-定点数的表示" class="headerlink" title="1.定点数的表示"></a>1.定点数的表示</h1><h2 id="1-1-无符号数"><a href="#1-1-无符号数" class="headerlink" title="1.1 无符号数"></a>1.1 无符号数</h2><ul><li>定义：无符号数就是没有体现正负号的数（这意味着所有的无符号数实际上都是正数），整个机器字长的全部二进制位均为数值位，没有符号位。以<code>108D</code>为例，它对应的二进制数是 <code>1101100</code>，这实际上也就是它的无符号数，可以看到所有的位都是数值位。</li><li>表示范围：以八位二进制数为准，范围就是 <code>00000000</code> 到 <code>11111111</code>，也就是 0 到 255</li></ul><h2 id="1-2-有符号数"><a href="#1-2-有符号数" class="headerlink" title="1.2 有符号数"></a>1.2 有符号数</h2><ul><li><p>定义：有符号数就是有体现正负号的数，整个机器字长的全部二进制位中，最高位作为符号位，0 表示正数，1 表示负数，其余位则是数值位。依然以<code>108D</code>为例，它对应的二进制数是 <code>1101100</code>，而对应的有符号数则要在最前面加上符号位 0，即它的有符号数是 <code>01101100</code>.</p></li><li><p>表示范围：以八位二进制数为准，范围应该是从负数到正数，即从 <code>11111111</code> 到 <code>01111111</code>，也就是 -127 到 127</p></li></ul><h3 id="1-2-1-真值和机器数"><a href="#1-2-1-真值和机器数" class="headerlink" title="1.2.1.真值和机器数"></a>1.2.1.真值和机器数</h3><ul><li>真值：就是带有正负号的实际十进制数，比如上面例子中，<code>+108D</code>就是真值</li><li>机器数：机器数就是一个数在计算机中的二进制表示形式，注意<strong>机器数是由符号位和数值位</strong>构成的，比如上面例子中，<code>01101100</code> 就是机器数。</li></ul><p><code>-156D</code>（真值）= <code>110011100B</code>(机器数)</p><h3 id="1-2-2-原码、反码、补码和移码"><a href="#1-2-2-原码、反码、补码和移码" class="headerlink" title="1.2.2.原码、反码、补码和移码"></a>1.2.2.原码、反码、补码和移码</h3><h4 id="1-原码表示法"><a href="#1-原码表示法" class="headerlink" title="(1)原码表示法"></a>(1)原码表示法</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-1.png" alt=""></p><p>简单点理解，原码就是符号位加上真值（二进制）的绝对值，同时用逗号将符号位和数值位隔开。比如，+1 就是 <code>0,0000001</code>，-1 就是 <code>1,0000001</code>。</p><p>原码的特点是简单、直观，但是原码在进行加法运算的时候会出现问题。正数加正数或者负数加负数是正常的，但是正数加负数就会出错。比如我们现在想要计算 -1+3，我们心想：-1 是 <code>10000001</code>，+3 是 <code>00000011</code>，加起来得到的是 <code>10000100</code>，所以结果是 -4，但 -1+3 应该是等于 2，所以这个结果是错的。我们发现，本来应该做的是加法运算，但实际上变成了减法运算（-1-3=-4）。</p><p>我们首先想到，可以通过将“正数加负数”转化为“正数减正数”来手动纠正这个错误。上面的例子就变成 <code>00000011</code> 减 <code>00000001</code>，结果是 <code>00000010</code>，也就是 2，这个结果是正确的。</p><p>但是每次都这样手动转化，计算起来还是太麻烦了。于是我们接着想：有没有一种方法，可以让“正数加负数”中的<strong>负数等价于一个正数</strong>，从而确保始终进行的是相加操作呢？</p><p>于是这时候就引出了补码的概念。</p><h4 id="2-补码表示法"><a href="#2-补码表示法" class="headerlink" title="(2)补码表示法"></a>(2)补码表示法</h4><ul><li><p>补数和模：理解补码之前，我们先来理解两个概念：<strong>补数</strong>和<strong>模</strong>。<br>拿时钟举例，想要从10点拨到8点，有两种做法，一种是逆时针拨2个单位，记作-2；一种是顺时针拨10个单位，记作+10，这两种操作是等效的(有点<strong>负数等价于一个正数</strong>的意思)。这时候我们就说，-2 是 +10 以 12 为模的补数，记作<code>-2≡+10(mod 12)</code>，同理，-5 相当于 +7，-4 相当于 +8。</p></li><li><p>那么怎么基于补数和模的概念将“正数加负数”转化为“正数加正数” —— 即怎么令<strong>负数等价于一个正数</strong>呢？假设我们现在有一个寄存器可以存放四位二进制数（此时，模为16），我们想要让 <code>1011</code> 变成 <code>0000</code>，最容易想到的办法就是 <code>1011-1011=0000</code>，注意这里是正数加负数。想要变成正数加正数，就要找到等价于 <code>-1011</code> 的正数，<code>-1011</code> 就是 -11，-11 以 16 为模的补数就是 +5，+5 就是 <code>+0101</code>，这个正是我们要找的那个等价正数，因此这时候，<code>1011-1011</code> 变成了 <code>1011+0101</code>，其结果是 <code>10000</code>，不要忘了寄存器只能存放四位，所以结果其实是 <code>0000</code>，恰好与我们“正数加负数”时得到的结果无异。</p></li><li><p>接着引入补码的概念：</p><ul><li>对于正数：正数的补码和原码相同；</li><li>对于负数：负数的补码等于其原码在保持符号位不变的情况下，其余各位取反，末位加一（取反加一）。<strong>注意</strong>，补码的补码等于原码，这可以用来根据补码求原码。</li><li>也可以用下图方法计算补码：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-2.png" alt=""></li></ul></li></ul><p>还是上面的例子，<code>1011-1011</code>，也就是11-11，我们考虑+11和-11，+11的原码=补码=<code>01011</code>，-11的原码是<code>11011</code>，因此补码是<code>10101</code>，那么<code>01011+10101</code>就会等于<code>100000</code>，因为寄存器是五位的，把前面的1去掉，那么结果就是<code>00000</code>，也就是0，和上面的运算结果一致。</p><h4 id="3-反码表示法"><a href="#3-反码表示法" class="headerlink" title="(3)反码表示法"></a>(3)反码表示法</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-3.png" alt=""></p><p>反码很好理解：</p><ul><li>正数：反码等于原码等于补码；</li><li>负数：反码等于原码保持符号位不变的情况下其余各位取反。也就是说，补码=反码+1</li><li>反码的反码等于原码，这可以用来根据反码求原码。</li></ul><h4 id="4-移码表示法"><a href="#4-移码表示法" class="headerlink" title="(4)移码表示法"></a>(4)移码表示法</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-4.png" alt=""></p><p>补码存在的问题是，仅从补码本身来看，很难比较两个数的大小，为此引入了移码的概念。移码指的是在真值（二进制）的基础上加上一个偏移量，通常这个偏移量是2^n。其中，n是数值位的位数。例如，对于<code>-10101</code>，其移码是<code>2^7+(-10101)=10000000+(010101)=0,1101011</code>。<br>当然，我们有简单的方法可以计算一个数的移码：不管正数还是负数，其移码都等于补码的符号位取反。</p><h1 id="2-定点数的加减运算"><a href="#2-定点数的加减运算" class="headerlink" title="2.定点数的加减运算"></a>2.定点数的加减运算</h1><h2 id="2-1-补码的加减运算"><a href="#2-1-补码的加减运算" class="headerlink" title="2.1 补码的加减运算"></a>2.1 补码的加减运算</h2><p>定点数的加减运算实际上就是补码的加减运算。我们来看一个例子：</p><blockquote><p>假设机器字长为 8 位（含1位符号位），A=15，B=-24，现在求 A+B 和 A-B。</p></blockquote><p>A 的补码是 <code>0,0001111</code>，B 的补码是 <code>1,1101000</code>，那么 <code>0,0001111+1,1101000=1,1110111</code>，转化为原码，再转化为真值，得到 -9，这是正确的。同理，A-B 就是 A+(-B)，-B 的补码是 <code>0,0011000</code>，那么 <code>0,0001111+0,0011000=0,0100111</code>，最后转化为真值，得到 +39，这也是正确的。<br>我们再来看另一个例子：</p><blockquote><p>假设机器字长为 8 位（含1位符号位），A=15，B=-24，C=124，现在求 A+C 和 B-C。</p></blockquote><p>我们同样按照上面的流程来进行计算，最后得出：A+C 结果是 -117，B-C 结果是 +108，这两个都是错误的。为什么会出现这样的情况呢？</p><h2 id="2-2-溢出"><a href="#2-2-溢出" class="headerlink" title="2.2 溢出"></a>2.2 溢出</h2><p>这种情况就叫<strong>溢出</strong>。出现的原因，简单来说就是：运算结果太大了，或者运算结果太小了。就上面的题而言，8 位二进制数所能表示的数字的范围是有限的，当正数加正数的时候，结果可能过大，超出了最大值，此时称为<strong>上溢</strong>；当负数加负数的时候，结果可能过小，够不到最小值，此时称为<strong>下溢</strong>。如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-5.png" alt=""></p><p>我们拿 3 位二进制数来理解这个问题。假设 3 位二进制数可以表示的范围如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-6.png" alt=""></p><p>现在我们进行 2+2 操作，那么就是 <code>010+010</code>，结果就是 <code>100</code>，这已经超出了正数可以表示的最大范围，也就是发生了上溢。所以此时得到的是 -4，这是一个错误的结果。</p><h2 id="2-3-溢出的判断"><a href="#2-3-溢出的判断" class="headerlink" title="2.3 溢出的判断"></a>2.3 溢出的判断</h2><p>前面说过，溢出的原因要么是运算结果太大，要么是运算结果太小，其实从这句话我们可以看出，<strong>正数和负数相加是不会发生溢出的</strong>，因为其结果必然在可以表示的范围内，唯一可能会发生溢出的情况，要么是正数加正数，要么是负数加负数。那么，如何判断在这两种情况下是否会发生溢出呢？有三个方法：</p><h3 id="1-一位符号位：比较操作数符号位与结果数符号位"><a href="#1-一位符号位：比较操作数符号位与结果数符号位" class="headerlink" title="(1) 一位符号位：比较操作数符号位与结果数符号位"></a>(1) 一位符号位：比较操作数符号位与结果数符号位</h3><p>我们还是拿上面的第二个例子解释：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-7.png" alt=""></p><p>可以看到，A+C 中，两个操作数符号位都是 0，也就是都是正数，但结果数的符号位却是 1 ，也就是负数，那么很明显它发生了上溢；</p><p>同理，B-C 中，两个操作数符号位都是 1，也就是都是负数，但结果数的符号位却是 0，也就是正数，那么很明显它发生了下溢。</p><h3 id="2-一位符号位：看符号位与最高数值位的进位情况"><a href="#2-一位符号位：看符号位与最高数值位的进位情况" class="headerlink" title="(2) 一位符号位：看符号位与最高数值位的进位情况"></a>(2) 一位符号位：看符号位与最高数值位的进位情况</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-8.png" alt=""></p><p>看第一个式子，进行运算的时候，符号位没有产生进位，但是最高数值位向前产生了进位，这时候判断它发生了上溢；<br>看第二个式子，进行运算的时候，最高数值位没有产生进位，但是符号位向前产生了进位，这时候判断它发生了下溢。</p><h3 id="3-两位符号位："><a href="#3-两位符号位：" class="headerlink" title="(3) 两位符号位："></a>(3) 两位符号位：</h3><p>这种方法是将一位符号位改为两位符号位表示：正数符号为 <code>00</code>，负数符号为 <code>11</code>。那么前面的例子就会变为：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-9.png" alt=""></p><p>这时候，计算机<strong>只需要看结果数</strong>就能知道是否发生溢出 —— 只要结果数的两位符号位相异，那么就一定是发生了溢出。<br>同理，我们回过头看第一个没有溢出的例子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-10.png" alt=""></p><p>可以发现两次运算的结果数的两位符号位都是一样的，由此判断这两次运算都没有发生溢出。</p><p>参考：<br><a href="https://www.bilibili.com/video/av66952721" target="_blank" rel="noopener">https://www.bilibili.com/video/av66952721</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/09/21/Trs-提升 Web 开发效率的vs code 扩展/" rel="prev" title="「译」提升 Web 开发效率的 VS Code 扩展"><i class="fa fa-angle-double-left"></i>&nbsp「译」提升 Web 开发效率的 VS Code 扩展</a></div><div class="post-nav-next"><a href="/2019/09/16/CB-深入理解计算机系统cp1/" rel="next" title="深入理解计算机系统cp1：存储单位、数制、编码">深入理解计算机系统cp1：存储单位、数制、编码&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-定点数的表示"><span class="toc-text">1.定点数的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-无符号数"><span class="toc-text">1.1 无符号数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-有符号数"><span class="toc-text">1.2 有符号数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-真值和机器数"><span class="toc-text">1.2.1.真值和机器数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-原码、反码、补码和移码"><span class="toc-text">1.2.2.原码、反码、补码和移码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-原码表示法"><span class="toc-text">(1)原码表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-补码表示法"><span class="toc-text">(2)补码表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-反码表示法"><span class="toc-text">(3)反码表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-移码表示法"><span class="toc-text">(4)移码表示法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-定点数的加减运算"><span class="toc-text">2.定点数的加减运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-补码的加减运算"><span class="toc-text">2.1 补码的加减运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-溢出"><span class="toc-text">2.2 溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-溢出的判断"><span class="toc-text">2.3 溢出的判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-一位符号位：比较操作数符号位与结果数符号位"><span class="toc-text">(1) 一位符号位：比较操作数符号位与结果数符号位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-一位符号位：看符号位与最高数值位的进位情况"><span class="toc-text">(2) 一位符号位：看符号位与最高数值位的进位情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-两位符号位："><span class="toc-text">(3) 两位符号位：</span></a></li></ol></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->