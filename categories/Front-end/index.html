<!-- build time:Sat May 29 2021 15:32:39 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><div class="category-page-container"><div class="category-page-title"><span class="category_title">Front-end</span></div><div class="category-page-cards"><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/28/F-JS原生方法原理探究（六）从 Babel 转译过程谈谈 ES6 实现继承的原理/">JS原生方法原理探究（六）从 Babel 转译过程浅谈 ES6 实现继承的原理</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-28&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.7k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp15 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/28/F-JS原生方法原理探究（六）从 Babel 转译过程谈谈 ES6 实现继承的原理/"><p>这是JS 原生方法原理探究系列的第六篇文章。</p><p>都说 ES6 的 Class 是 ES5 的语法糖，那么 ES6 的 Class 是如何实现的呢？其实现继承的原理又是什么呢？不妨我们通过 Babel 转译代码的方式，看看其中有什么门道。</p><p>这篇文章会从最简单的代码入手，一步步剖析相关的原理以及每个函数的作用。代码的转译直接在 <a href="https://babeljs.io" target="_blank" rel="noopener">Babel 官网</a>进行即可。</p><h3 id="ES6-的-Class-是如何实现的"><a href="#ES6-的-Class-是如何实现的" class="headerlink" title="ES6 的 Class 是如何实现的"></a>ES6 的 Class 是如何实现的</h3><p>先从最简单的一个 Parent 类看起：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>getA <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转译之后的结果是：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Constructor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Constructor</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Cannot call a class as a function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> Parent <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token string">"use strict"</span><span class="token punctuation">;</span>

    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>getA <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，这里的类实质上就是 ES5 中的构造函数，除了添加实例属性和实例方法之外，它还调用了一个 <code>_classCallCheck</code> 函数。</p><blockquote><p><strong><code>_classCallCheck</code> 函数</strong></p></blockquote><p>这个函数会接受一个实例和构造函数作为参数，内部的 <code>instance instanceof Constructor</code> 用于判断这个类是不是通过 new 调用的，如果不是就抛出一个错误。</p><p>接下来我们尝试给这个类添加原型方法和静态方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>
   <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>getA <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token function">getC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">static</span> <span class="token function">getD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">static</span> <span class="token function">getE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转译后得到：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Constructor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Constructor</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Cannot call a class as a function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> props<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> descriptor <span class="token operator">=</span> props<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    descriptor<span class="token punctuation">.</span>enumerable <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>enumerable <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    descriptor<span class="token punctuation">.</span>configurable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"value"</span> <span class="token keyword">in</span> descriptor<span class="token punctuation">)</span> descriptor<span class="token punctuation">.</span>writable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span>key<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_createClass</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">,</span> protoProps<span class="token punctuation">,</span> staticProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>protoProps<span class="token punctuation">)</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> protoProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>staticProps<span class="token punctuation">)</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">,</span> staticProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Constructor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> Parent <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">"use strict"</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>getA <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">_createClass</span><span class="token punctuation">(</span>
    Parent<span class="token punctuation">,</span>
    <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        key<span class="token punctuation">:</span> <span class="token string">"getB"</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        key<span class="token punctuation">:</span> <span class="token string">"getC"</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">getC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        key<span class="token punctuation">:</span> <span class="token string">"getD"</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">getD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        key<span class="token punctuation">:</span> <span class="token string">"getE"</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">getE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> Parent<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>emmm 看起来好像有点复杂，不过没关系，我们一个一个函数理清楚就行了。</p><p>可以看到，此时的 <code>Parent</code> 变成了一个 IIFE，IIFE 执行之后仍然是返回 Parent 类，但内部还封装了一个 <code>_createClass</code> 函数的调用。</p><blockquote><p><strong><code>_createClass</code> 函数</strong></p></blockquote><p><code>_createClass</code> 函数做了什么事呢？首先，它可以接受三个参数：</p><ul><li>第一个参数： 类（这里是 <code>Parent</code> 类）</li><li>第二个参数：存放对象的数组，每个对象都是关于类的原型方法的特性描述对象（这里是 <code>getB</code> 和 <code>getC</code>）</li><li>第三个参数：存放对象的数组，每个对象都是关于类的静态方法的特性描述对象（这里是 <code>getD</code> 和 <code>getE</code>）</li></ul><p>接着，它会依次检查是否有传第二个和第三个参数，如果有，就调用 <code>_defineProperties</code> 函数，分别为类的原型定义原型方法，为类本身定义静态方法。</p><blockquote><p><strong><code>_defineProperties</code> 函数</strong></p></blockquote><p><code>_defineProperties</code> 函数做了什么事呢？它接受类（或者类的原型）和一个存放对象的数组作为参数，之后遍历数组中的每个对象，定义每个方法的特性，并将它们逐一添加到类（或者类的原型）上面。这里涉及到的特性包括：</p><ul><li><code>enumberable</code>：该属性（方法）是否可枚举。如果方法本身已经定义了该特性，则采用该特性；如果没有定义，则定义该方法为不可枚举</li><li><code>configurable</code>：该属性（方法）是否可以配置</li><li><code>writable</code>：如果该属性是数据属性而不是访问器属性，那么会有一个 <code>value</code>，此时设置该属性为可写</li></ul><h3 id="ES6-的继承是如何实现的"><a href="#ES6-的继承是如何实现的" class="headerlink" title="ES6 的继承是如何实现的"></a>ES6 的继承是如何实现的</h3><p>好了，基本搞清楚一个 class 的原理之后，现在我们来看一下 ES6 是如何实现继承的。</p><p>将下面的代码进行转译：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>
   <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span> 
     <span class="token keyword">this</span><span class="token punctuation">.</span>getA <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> 
   <span class="token punctuation">}</span>
   <span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  
   <span class="token function">getC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">static</span> <span class="token function">getD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">static</span> <span class="token function">getE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就得到了：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"use strict"</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">"@babel/helpers - typeof"</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Symbol <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Symbol<span class="token punctuation">.</span>iterator <span class="token operator">===</span> <span class="token string">"symbol"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _typeof <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    _typeof <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> obj <span class="token operator">&amp;&amp;</span>
        <span class="token keyword">typeof</span> Symbol <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span>
        obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Symbol <span class="token operator">&amp;&amp;</span>
        obj <span class="token operator">!==</span> Symbol<span class="token punctuation">.</span>prototype
        <span class="token operator">?</span> <span class="token string">"symbol"</span>
        <span class="token punctuation">:</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_inherits</span><span class="token punctuation">(</span>subClass<span class="token punctuation">,</span> superClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> superClass <span class="token operator">!==</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> superClass <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Super expression must either be null or a function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superClass <span class="token operator">&amp;&amp;</span> superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    constructor<span class="token punctuation">:</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> subClass<span class="token punctuation">,</span> writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> configurable<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>superClass<span class="token punctuation">)</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>subClass<span class="token punctuation">,</span> superClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _setPrototypeOf <span class="token operator">=</span>
    Object<span class="token punctuation">.</span>setPrototypeOf <span class="token operator">||</span>
    <span class="token keyword">function</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      o<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> p<span class="token punctuation">;</span>
      <span class="token keyword">return</span> o<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hasNativeReflectConstruct <span class="token operator">=</span> <span class="token function">_isNativeReflectConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">_createSuperInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> Super <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">,</span>
      result<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasNativeReflectConstruct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> NewTarget <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
      result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Super<span class="token punctuation">,</span> arguments<span class="token punctuation">,</span> NewTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      result <span class="token operator">=</span> Super<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> call<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>call <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">_typeof</span><span class="token punctuation">(</span>call<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> call<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span>
      <span class="token string">"this hasn't been initialised - super() hasn't been called"</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> self<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_isNativeReflectConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Reflect <span class="token operator">===</span> <span class="token string">"undefined"</span> <span class="token operator">||</span> <span class="token operator">!</span>Reflect<span class="token punctuation">.</span>construct<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span>construct<span class="token punctuation">.</span>sham<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Proxy <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    Boolean<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>valueOf<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>
      Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _getPrototypeOf <span class="token operator">=</span> Object<span class="token punctuation">.</span>setPrototypeOf
    <span class="token operator">?</span> Object<span class="token punctuation">.</span>getPrototypeOf
    <span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> o<span class="token punctuation">.</span>__proto__ <span class="token operator">||</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> Constructor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Constructor</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Cannot call a class as a function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> props<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> descriptor <span class="token operator">=</span> props<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    descriptor<span class="token punctuation">.</span>enumerable <span class="token operator">=</span> descriptor<span class="token punctuation">.</span>enumerable <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    descriptor<span class="token punctuation">.</span>configurable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"value"</span> <span class="token keyword">in</span> descriptor<span class="token punctuation">)</span> descriptor<span class="token punctuation">.</span>writable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> descriptor<span class="token punctuation">.</span>key<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_createClass</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">,</span> protoProps<span class="token punctuation">,</span> staticProps<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>protoProps<span class="token punctuation">)</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> protoProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>staticProps<span class="token punctuation">)</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">,</span> staticProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Constructor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> Parent <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>getA <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">_createClass</span><span class="token punctuation">(</span>
    Parent<span class="token punctuation">,</span>
    <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        key<span class="token punctuation">:</span> <span class="token string">"getB"</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">getB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        key<span class="token punctuation">:</span> <span class="token string">"getC"</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">getC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        key<span class="token punctuation">:</span> <span class="token string">"getD"</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">getD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        key<span class="token punctuation">:</span> <span class="token string">"getE"</span><span class="token punctuation">,</span>
        value<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">getE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> Parent<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> Son <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>_Parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_inherits</span><span class="token punctuation">(</span>Son<span class="token punctuation">,</span> _Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> _super <span class="token operator">=</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Son<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Son<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> _super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> Son<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>emmm 好像越来越复杂了，没事，我们先稍稍简化一下（前面解释过的函数这里就直接略过了），再一个一个慢慢分析：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"use strict"</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_inherits</span><span class="token punctuation">(</span>subClass<span class="token punctuation">,</span> superClass<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> call<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_isNativeReflectConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_defineProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">_createClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword">var</span> Parent <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

  <span class="token function">_createClass</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> Parent<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> Son <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>_Parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_inherits</span><span class="token punctuation">(</span>Son<span class="token punctuation">,</span> _Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> _super <span class="token operator">=</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Son<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Son<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> _super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> Son<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里多出了很多新的函数，有的函数不是我们讨论的重点，而且也完全可以单独拎出来分析，所以这里先简单把它们的作用介绍了，之后如果忘记了函数的作用，翻到这里来看即可。</p><blockquote><p><strong><code>_typeof(obj)</code></strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">"@babel/helpers - typeof"</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Symbol <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Symbol<span class="token punctuation">.</span>iterator <span class="token operator">===</span> <span class="token string">"symbol"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _typeof <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    _typeof <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> obj <span class="token operator">&amp;&amp;</span>
        <span class="token keyword">typeof</span> Symbol <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span>
        obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Symbol <span class="token operator">&amp;&amp;</span>
        obj <span class="token operator">!==</span> Symbol<span class="token punctuation">.</span>prototype
        <span class="token operator">?</span> <span class="token string">"symbol"</span>
        <span class="token punctuation">:</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">_typeof</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是 Babel 引入的一个工具函数，主要是为了对 <code>Symbol</code> 进行正确的处理。它首先会检查当前环境是否支持原生的 <code>Symbol</code>，如果支持就直接返回 <code>typeof obj</code> 表达式的计算结果；如果不支持，再检查 <code>obj</code> 是不是通过 polyfill 实现的 <code>Symbol</code> 的一个实例，如果是就返回它的类型（也就是返回 <code>&quot;symbol&quot;</code>），如果不是，就返回 <code>typeof obj</code> 的计算结果。在这里，这个函数假定了我们当前的环境是原生支持 <code>Symbol</code> 或者通过 polyfill 实现了支持的。</p><blockquote><p><strong><code>_setPrototypeOf()</code></strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _setPrototypeOf <span class="token operator">=</span>
    Object<span class="token punctuation">.</span>setPrototypeOf <span class="token operator">||</span>
    <span class="token keyword">function</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      o<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> p<span class="token punctuation">;</span>
      <span class="token keyword">return</span> o<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先检查当前环境是否支持直接调用 <code>Object.setPrototypeOf()</code> 方法，如果不支持，就通过 <code>__proto__</code> 手动给实例建立原型关系（ <code>__proto__</code> 是一个暴露的内部属性，一般不提倡直接进行操作）。</p><blockquote><p><strong><code>_possibleConstructorReturn(self,call)</code></strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> call<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>call <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">_typeof</span><span class="token punctuation">(</span>call<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> call <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> call<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你看过 <code>new</code> 或者 <code>[[Construct]]</code> 的内部实现，就会知道，给构造函数指定了一个非空对象或者函数作为返回值之后，调用函数之后返回的将不是实例，而是这个对象或者函数。这里就是通过 <code>_possibleConstructorReturn</code> 这个函数来完成这件事的 —— 仔细看它的名字，意思不就是“构造函数可能返回的值”吗？</p><p>这个函数接受两个参数，<code>self</code> 代表构造函数的实例，<code>call</code> 代表构造函数的返回值。内部的判断也很简单，<code>call &amp;&amp; (_typeof(call) === &quot;object&quot; || typeof call === &quot;function&quot;)</code> 是检查 <code>call</code> 的类型，当它是一个对象（注意这里是使用 <code>typeof</code> 进行检查，需要排除可能为 <code>null</code> 的情况）或者函数的时候，直接将其作为返回值；否则就返回 <code>_assertThisInitialized(self)</code>。等等，怎么又来了一个新函数呢？不要急，我们接着就来看这个函数是干什么用的。</p><blockquote><p><strong><code>_assertThisInitialized(self)</code></strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_assertThisInitialized</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>self <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span>
      <span class="token string">"this hasn't been initialised - super() hasn't been called"</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> self<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看这个函数的名字 —— “断言 <code>this</code> 已经初始化”，也就是说，在调用这个方法的时候，我们期望的结果是 <code>this</code> 已经得到初始化了。这里如果检查发现 <code>this</code> 是 <code>undefined</code>，就会抛出一个错误，提示我们由于没有调用 <code>super()</code>，所以无法得到 <code>this</code>；否则就返回 <code>this</code> 。为什么要使用 <code>void 0</code> 而不是 <code>undefined</code> 呢？因为非严格模式下 <code>undefined</code> 可能会被重写，这里使用 <code>void 0</code> 更加保险。</p><blockquote><p><strong><code>_isNativeReflectConstruct()</code></strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_isNativeReflectConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Reflect <span class="token operator">===</span> <span class="token string">"undefined"</span> <span class="token operator">||</span> <span class="token operator">!</span>Reflect<span class="token punctuation">.</span>construct<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span>construct<span class="token punctuation">.</span>sham<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Proxy <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    Boolean<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>valueOf<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>
      Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法用于检测当前环境是否支持原生的 <code>Reflect</code>。为什么要做这个检查呢？后面我们再来解释。</p><p>好了，我们已经分析了这几个函数的作用，现在直接翻到最下面的代码，从 <code>Son</code> 子类看起：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> Son <span class="token operator">=</span> <span class="token comment" spellcheck="true">/*#__PURE__*/</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>_Parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">_inherits</span><span class="token punctuation">(</span>Son<span class="token punctuation">,</span> _Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> _super <span class="token operator">=</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Son<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Son<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> _super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> Son<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>Son</code> 同样是一个 IIFE，并且实际上也是返回一个 <code>Son</code> 子类构造函数，不同的是，它内部还封装了其它方法的调用。我们逐一看一下这些方法的作用。</p><blockquote><p><strong><code>_inherits(Son,_Parent)</code></strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_inherits</span><span class="token punctuation">(</span>subClass<span class="token punctuation">,</span> superClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> superClass <span class="token operator">!==</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> superClass <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Super expression must either be null or a function"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superClass <span class="token operator">&amp;&amp;</span> superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    constructor<span class="token punctuation">:</span> <span class="token punctuation">{</span> 
        value<span class="token punctuation">:</span> subClass<span class="token punctuation">,</span> 
        writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> 
        configurable<span class="token punctuation">:</span> <span class="token boolean">true</span> 
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>superClass<span class="token punctuation">)</span> <span class="token function">_setPrototypeOf</span><span class="token punctuation">(</span>subClass<span class="token punctuation">,</span> superClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>_inherit</code> 是实现继承的其中一个核心方法，可以说它的本质就是 ES5 中的寄生组合式继承。这个方法接受一个父类和子类作为参数，首先会检查父类是不是函数或者 <code>null</code>，如果不是，则抛出错误（为什么父类可以是 <code>null</code>？<a href="https://juejin.cn/post/6844903575613603853#heading-0" target="_blank" rel="noopener">从 extends 看 JS 继承</a>这篇文章进行了解释，这里我就不重复了）。</p><p>接着，调用 <code>Object.create</code> 设置父类的原型为子类原型的 <code>__proto__</code>。这里我们会看到还传入了第二个参数，这个参数是子类原型的属性的特性描述对象（descriptor），我们对 <code>constructor</code> 属性进行了设置，将它设置为可写、可配置，同时利用 <code>value</code> 修复了因重写子类原型而丢失的 <code>constructor</code> 指向。为什么不设置 <code>enumerable: false</code> 呢？因为默认就是不可枚举的，不设置也行。</p><p>最后，我们设置子类的 <code>__proto__</code> 指向父类，这是 ES5 中没有的，目的是让子类继承父类的静态方法（可以直接通过类调用的方法）。</p><p>可以看到，通过调用 <code>_inherit</code> 函数，我们已经成功让子类继承了父类的原型方法和静态方法。不过，实例上的属性怎么继承呢？这就要继续往下看了，接下来我们调用 <code>_createSuper()</code> 函数并传入派生类（子类），这不是重点，重点是它创建并返回的另一个函数 <code>_super</code>。</p><blockquote><p><strong><code>_super.call(this)</code></strong></p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_createSuper</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> hasNativeReflectConstruct <span class="token operator">=</span> <span class="token function">_isNativeReflectConstruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">_createSuperInternal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> Super <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span><span class="token punctuation">,</span>
      result<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasNativeReflectConstruct<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> NewTarget <span class="token operator">=</span> <span class="token function">_getPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
      result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Super<span class="token punctuation">,</span> arguments<span class="token punctuation">,</span> NewTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      result <span class="token operator">=</span> Super<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">_possibleConstructorReturn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>_createSuperInternal</code> 就是 <code>_super</code>，调用的时候我们绑定了其内部的 <code>this</code> 为子类实例。</p><p>它首先会根据之前的 <code>_isNativeReflectConstruct</code> 检查当前环境是否支持 <code>Reflect</code>，如果支持，则执行 <code>result = Reflect.construct(Super, arguments, NewTarget)</code>，否则执行 <code>result = Super.apply(this, arguments)</code>。</p><p>解释一下这里为什么要优先使用 <code>Reflect</code>。当执行 <code>Reflect.construct(Super, arguments, NewTarget)</code>的时候，最终会返回一个基于 <code>Super</code> 父类构造函数创建的实例，相当于执行了 <code>new Super(...arguments)</code>，但是，<strong>这个实例的 <code>__proto__</code> 的 <code>constructor</code> 是 <code>NewTarget</code></strong>，因此在某种程度上，你也可以说这就是一个子类实例，不过它拥有父类实例的所有属性。</p><p>可能你会说，这和下面的 <code>Super.apply</code> （借用构造函数继承）不是没区别吗？非也。我们使用 <code>Super.apply</code> 的时候，其实 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="noopener">new.target</a> 属性是会丢失的，就像下面这样：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// Super</span>
Super<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// undefined</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是如果使用 <code>Reflect.consturct</code> 来创建对象，则 <code>new.target</code> 不会丢失：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Super1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Super1'</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Super2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Super2'</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj1 <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Super1<span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>              
<span class="token comment" spellcheck="true">// 'Super1'</span>
<span class="token comment" spellcheck="true">//  Super1</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Super1<span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>Super2<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 'Super1'</span>
<span class="token comment" spellcheck="true">//  Super2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，即便没有通过 <code>new</code> 去调用 <code>Super1</code>，<code>new.target</code> 也仍然指向 <code>Super1</code>；而在传了第三个参数之后，<code>new.target</code> 也没有丢失，只是指向了 <code>Super2</code>（前面我们说过了，某种程度上，可以说 <code>obj1</code> 就是 <code>Super2</code> 的实例）。</p><p>所以，这里优先使用 <code>Reflect</code>，是为了保证 <code>new.target</code> 不会丢失。</p><p>之后，<code>result</code> 可能有三种取值：</p><ul><li>一个继承了父类实例所有属性的子类实例</li><li>父类构造函数的调用结果，可能是父类构造函数中自定义返回的一个非空对象</li><li>父类构造函数的调用结果，可能是默认返回的 <code>undefined</code></li></ul><p>如何处理这些不同的情况呢？这里调用了前面讲过的 <code>_possibleConstructorReturn(this,result)</code>函数，如果判断 <code>result</code> 是一个非空对象，也就是第一种和第二种取值情况，那么就直接返回 <code>result</code>；否则就是第三种情况了，此时就对当初传进去的子类实例（已经通过 <code>Super.apply</code> 对它进行了增强），也就是 <code>this</code>，进行断言，然后返回出去。</p><p>现在，让我们再回到 <code>Son</code> 构造函数。可以看到，调用它之后返回的正是 <code>_super.call(this)</code>，也就是返回 <code>result</code> 或者经过增强的<code>this</code>。这里的 <code>result</code> 我们知道也有两种取值，如果是一个继承了父类实例所有属性的子类实例，那么实际上等价于经过增强的 <code>this</code>；如果是父类构造函数中自定义返回的一个非空对象，则意味着调用 <code>Son</code>构造函数之后返回的对象实际上并没有继承父类中声明的实例属性。类似下面这样：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>b<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> Parent<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
Son<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Parent<span class="token punctuation">.</span>prortotype
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>     
<span class="token comment" spellcheck="true">// {b:1}      </span>
<span class="token comment" spellcheck="true">// 这里 `Son` 同样也是返回父类 `Parent` 的调用结果（一个对象），它并没有继承在父类上声明的实例属性 `a`。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里，我们的分析基本就结束了。希望你阅读完本文之后有所收获，若发现文章有错误，也欢迎评论区指正。</p><p>`</p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（五）：如何实现 instanceof？/">JS 原生方法原理探究（五）：如何实现 instanceof？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp561&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp2 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（五）：如何实现 instanceof？/"><p>这是JS 原生方法原理探究系列的第五篇文章。本文会介绍如何实现 <code>instanceof</code> 方法。</p><p><code>typeof</code> 操作符返回一个表示数据类型的字符串，它可以应付常规场景下的数据类型判断。对基本数据类型 <code>undefined</code>、 <code>boolean</code>、<code>string</code>、 <code>number</code>、<code>Symbol</code> 和引用数据类型 <code>function</code> 都可以正确判断，但是对 null、数组、对象则统一返回 “object”。</p><p>比如说：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">F1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">F2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">typeof</span> obj1            <span class="token comment" spellcheck="true">// ‘object’</span>
<span class="token keyword">typeof</span> obj2           <span class="token comment" spellcheck="true">// 'object' </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只能看出 <code>obj1</code> 和 <code>obj2</code> 是对象，但不知道具体是哪个构造函数创建的对象。</p><p>但使用 <code>instanceof</code> 之后，就一目了然了：</p><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token keyword">instanceof</span> <span class="token class-name">F1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1 <span class="token keyword">instanceof</span> <span class="token class-name">F2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2 <span class="token keyword">instanceof</span> <span class="token class-name">F2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据 MDN 的描述：</p><blockquote><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p></blockquote><p><code>instanceof</code> 运算符有两个操作数，左操作数通常是一个实例对象，它的类型可以是对象或者函数，也可以是基本类型（这种情况下不会报错，但总返回 <code>false</code>），右操作数通常是一个可调用的（callable）对象，我们可以直接认为它的类型应该是一个函数。</p><p>那么 <code>instanceof</code> 的实现原理是什么呢？从定义中我们可以看到，它的原理和原型链的机制有关，具体地说，它会拿到右操作数的原型对象，然后在左操作数上通过 <code>__proto__</code> 不断查找实例的原型链，只要右操作数的 <code>prototype</code> 出现在左操作数的原型链上时，就返回 true。如果原型链一直查找到尽头 —— 也就是 <code>null</code>，还没有找到右操作数的原型，就返回 <code>false</code>。</p><p>所以，在模拟实现中，我们只要不断遍历左操作数的原型链，取得原型链上的原型对象，并与右操作数的原型对象比较即可。</p><p>下面是具体的代码实现：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span>constructor<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> instance <span class="token operator">!=</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> instance <span class="token operator">!=</span> <span class="token string">'function'</span> <span class="token operator">||</span> instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> constructor <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token function">TypeError</span><span class="token punctuation">(</span><span class="token string">'the right-hand-side of instanceof must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> proto <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype
    <span class="token keyword">let</span> p <span class="token operator">=</span> instance<span class="token punctuation">.</span>__proto__
    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> proto<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
        p <span class="token operator">=</span> p<span class="token punctuation">.</span>__proto__
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（四）：如何实现继承的几种方式？/">JS 原生方法原理探究（四）：如何实现继承的几种方式？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（四）：如何实现继承的几种方式？/"><p>这是JS 原生方法原理探究系列的第四篇文章。本文会介绍如何实现 JS 中常见的几种继承方式，同时简要它们的优缺点。</p><h3 id="实现继承的方法"><a href="#实现继承的方法" class="headerlink" title="实现继承的方法"></a>实现继承的方法</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/8.jpg" alt=""></p><p>实现继承的方法共有 7 种，这 7 种方法并不是互相独立的，它们之间更像是一种互补或者增强的关系。</p><ul><li>原型链继承和借用构造函数继承分别解决了<strong>继承父类方法</strong>和<strong>继承父类属性</strong>的问题，这两个方法结合就得到了组合继承；</li><li>原型式继承的核心是实现对象的浅拷贝并进行增强，寄生式继承则将这个过程封装成一个返回对象的函数；</li><li>寄生组合式继承结合了寄生式继承和组合式继承，是相对比较完美的方案。</li><li>Class extends 继承是 ES6 的，本质上是寄生组合式继承的一种运用</li></ul><p>下面的示例中，<code>SuperType</code> 表示父类，<code>SubType</code> 表示继承父类的子类。</p><h3 id="1）原型链继承"><a href="#1）原型链继承" class="headerlink" title="1）原型链继承"></a>1）原型链继承</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getNames <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
SubType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperTye</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原型链继承的核心就一句话：用父类实例作为子类原型，这使得子类实例最终可以访问父类上的属性和其原型上的方法。而它的缺点也很明显：</p><p>第一：由于父类构造函数只调用了一次，导致子类的原型都统一指向了这次调用所创建的父类实例，所以子类实例在访问一些自身没有的引用类型的属性时，实际上访问的都是那同一个父类实例上的属性。但通常，实例和实例之间应该都有自己的属性副本，不应该共享属性</p><p>第二：同样是由于只调用了一次父类构造函数，所以子类无法向父类传参</p><h3 id="2）借用构造函数继承"><a href="#2）借用构造函数继承" class="headerlink" title="2）借用构造函数继承"></a>2）借用构造函数继承</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SupterTye</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>names <span class="token operator">=</span> names
    <span class="token keyword">this</span><span class="token punctuation">.</span>getNames <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>借用构造函数继承也称为经典继承，这里所谓的借用指的是借用父类构造函数，它的核心就是完全不使用原型，而是在子类构造函数中通过 call 调用父类构造函数，从而增强子类实例 —— 相当于把父类实例上的属性都搬到子类实例这里来。</p><p>这种继承方法的优点就在于，它解决了原型链继承的缺点，我们现在可以往父类传参了，而且每次 new 子类的时候都会重新调用一次父类，这使得子类的所有实例都有自己的属性副本。</p><p>属性是没问题了，方法的继承又有了问题。由于父类构造函数是重复调用的，所以每个实例都有自己的方法副本，但问题是，方法并不需要副本，所有实例完全应该共享同一个方法，所以这里为每个实例重复创建同一个方法，就存在一定的性能问题。此外，对于父类原型上的方法，子类是无法继承的，因为这种继承方式并没有使用到原型。</p><h3 id="3）组合继承"><a href="#3）组合继承" class="headerlink" title="3）组合继承"></a>3）组合继承</h3><p>看起来，原型链继承擅长方法继承，而借用构造函数继承擅长属性继承，那么能不能取二者之长呢？实际上，结合两者的优点，就是所谓的组合继承了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>names <span class="token operator">=</span> names
<span class="token punctuation">}</span>
SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getNames <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
SubType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>组合继承使用原型链继承的方式去继承方法，使用构造函数继承的方式去继承属性。</p><p>PS：组合继承和原型链继承都重写了子类的原型，在重写之前，子类的原型的 <code>constructor</code> 是指向子类的，重写后就不是了，因为子类的原型被代之以一个 new 创建的对象字面量。这里可以通过 <code>SubType.prototype.constructor = SubType</code> 修复 constructor 的指向。</p><h3 id="4）-原型式继承"><a href="#4）-原型式继承" class="headerlink" title="4） 原型式继承"></a>4） 原型式继承</h3><p>原型式继承所做的事情类似于浅拷贝一个对象，再通过自定义的方式增强新对象。它能够方便地实现在不同对象之间共享信息，同时又不需要额外创建构造函数（内部做了处理）。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span>
    friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
fucntion <span class="token function">createObject</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> anotherObj <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
anotherObj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Tom'</span>
anotherObj<span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ES5 在规范层面实现了原型式继承，也就是所谓的 <code>Object.create()</code> 方法，上面代码可以改为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span>
    friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> anotherObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法所做的事情和 createObject 方法是一样的，它最终会返回一个新对象，而这个新对象的原型是传入的参数（我们传入的参数一般充当一个原型对象）。而且，当我们传参 <code>null</code> 的时候，它最终会返回一个没有原型的纯粹的对象，也就是所谓的裸对象（naked object）。</p><h3 id="5）-寄生式继承"><a href="#5）-寄生式继承" class="headerlink" title="5） 寄生式继承"></a>5） 寄生式继承</h3><p>寄生式继承在原型式继承的基础上，为新对象增加了方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span>
    friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">createObject</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 对象浅拷贝</span>
    <span class="token keyword">let</span> anotherObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 对象增强</span>
    anotherObj<span class="token punctuation">.</span>getFriends <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">return</span> anotherObj
<span class="token punctuation">}</span>
<span class="token keyword">const</span> anotherObj <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6）寄生组合式继承"><a href="#6）寄生组合式继承" class="headerlink" title="6）寄生组合式继承"></a>6）寄生组合式继承</h3><p>寄生组合式继承的出现是为了解决组合继承存在的一些问题，这种继承基本上是完美的了。</p><p>组合继承最大的问题在于，它两次调用了父类构造函数。第一次是在子类构造函数中 call 调用父类构造函数，这个时候实际上已经使得子类实例拥有了父类的属性；第二次是 new 调用父类构造函数并作为子类的原型，这时候又使得子类原型上也有了父类的属性。因此这两次调用带来的开销问题不说，更关键的是出现了两组重复的属性，这完全是不必要的。所以，利用寄生组合式继承，我们可以做到<strong>只调用一次父类构造函数</strong>。</p><p>假设我们现在有一个父类，然后需要实现一个继承父类的子类。用寄生组合式继承的话，代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jack'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getFriends <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 属性继承</span>
    SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span>sup<span class="token punctuation">,</span>sub<span class="token punctuation">)</span><span class="token punctuation">{</span>
    sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>sup<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
    sub<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> sub
    <span class="token comment" spellcheck="true">// 或者直接</span>
    sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>sup<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span><span class="token punctuation">{</span>
        constructor<span class="token punctuation">:</span> <span class="token punctuation">{</span>
            value<span class="token punctuation">:</span> sub
            <span class="token comment" spellcheck="true">// enumerable 默认为 false</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 方法继承</span>
<span class="token function">inherit</span><span class="token punctuation">(</span>SuperType<span class="token punctuation">,</span>SubType<span class="token punctuation">)</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意几个要点：</p><ul><li>属性继承仍然是采用借用构造函数继承的方式，关键是方法继承。这里通过一个 <code>inherit</code> 函数接受父类和子类，让子类继承父类的方法。在具体实现中，我们不再像原型链继承或者组合继承那样，new 一个父类构造函数作为子类的原型 —— 虽然效果看起来一样，但这是一次多余的、应该避免的父类调用。相反，我们借鉴了寄生式继承的做法，创建了一个父类原型的副本作为子类的原型。子类原型和父类原型之间其实是通过 <code>__proto__</code> 联系起来的，因此在通过子类实例访问相关方法的时候，可以确保是沿着 <code>子类实例 =&gt; 子类实例.__proto__ = 子类原型 =&gt; 子类原型.__proto__ = 父类原型</code> 这样的原型链查找，最终一定可以找到父类原型上的方法，因此就实现了方法继承。</li><li>寄生组合式继承同样重写了子类原型，所以需要修复 constructor 的指向，指回子类本身。因为 <code>Object.create</code> 本身接受两个参数，第二个参数可以设置其返回对象的属性的特性，所以也可以在传参时顺便修复 constructor 的指向</li></ul><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（三）：如何实现 new？/">JS 原生方法原理探究（三）：如何实现 new 操作符？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp5 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（三）：如何实现 new？/"><p>这是JS 原生方法原理探究系列的第三篇文章。本文会介绍如何模拟实现 <code>new</code> 操作符。关于 <code>new</code> 的具体用法，MDN 已经描述得很清楚了，这里我们只做简单的介绍，具体的重点在于如何模拟实现。</p><h3 id="new-操作符的规范"><a href="#new-操作符的规范" class="headerlink" title="new 操作符的规范"></a>new 操作符的规范</h3><blockquote><p>下面展示的所有规范都是 ES5 版本的，与现在最新的规范有些区别</p></blockquote><p>首先看一下根据<a href="https://262.ecma-international.org/5.1/#sec-11.2.2" target="_blank" rel="noopener">规范</a>的描述， <code>new</code> 操作符做了什么事：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/7.jpg" alt=""></p><p>全是英文，不过没关系，我简单翻译一下：</p><p>我在使用 <code>new</code> 操作符的时候，后面跟着的构造函数可能带参数，也可能不带参数，如果不带参数的话，比如说 <code>new Fn()</code>，那么这里这个 <code>Fn</code> 就是一个 <code>NewExpression</code>；如果带参数，比如说 <code>new Fn(name,age)</code>，那么这里的 <code>Fn</code> 就是一个 <code>MemberExpression</code>。</p><p>这两种情况下使用 <code>new</code> 操作符所进行的操作有点点不同，这里拿带参数的情况说明一下：</p><ol><li>首先会对 <code>Fn</code> 这个 <code>MemberExpression</code> 求值，其结果是指向实际函数对象的一个引用，我们把这个引用作为 <code>ref</code></li><li>接着调用 <code>GetValue(ref)</code> 进行求值，得到实际的函数对象，把这个对象作为 <code>constructor</code></li><li>对 <code>Arguments</code> 也就是传进来的参数求值，得到一个参数列表，作为 <code>argList</code></li><li>如果 <code>constructor</code> 不是对象，则抛出类型错误</li><li>如果 <code>constructor</code> 没有实现内部的 <code>[[Constructor]]</code> 方法，也抛出类型错误</li><li>调用 <code>constructor</code> 的 <code>[[Constructor]]</code>方法，并将 <code>argList</code> 传入作为参数，返回调用结果</li></ol><p>从这些描述可以看出，更多的实现细节放在函数的 <code>[[Constructor]]</code> 方法里。那么这个方法具体是做什么用的呢？</p><h3 id="Constructor-的规范"><a href="#Constructor-的规范" class="headerlink" title="[[Constructor]] 的规范"></a><code>[[Constructor]]</code> 的规范</h3><p>在 JS 中，函数有两种调用方式，一种是正常调用，这将调用函数的内部方法 <code>[[Call]]</code>，还有一种是通过 new 调用，此时的函数作为一个构造函数，这将调用函数的另一个内部方法 <code>[[Consturct]]</code>。所以，要实现 <code>new</code> 操作的话，我们得先搞懂 <code>[[Construct]]</code> 内部方法做了什么事。</p><p>这里继续看<a href="https://262.ecma-international.org/5.1/" target="_blank" rel="noopener">规范</a>是怎么说的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/5.jpg" alt=""></p><p>简单翻译一下：</p><p>当通过可能为空的参数列表调用函数 <code>F</code> 的内部方法 <code>[[Construct]]</code> 的时候，会执行如下步骤：</p><ol><li>让 <code>obj</code> 作为一个新创建的原生对象</li><li>按照规范指定的，为 <code>obj</code> 设置所有内部方法</li><li>将 <code>obj</code> 的内部属性 <code>[[Class]]</code> 设置为 <code>Object</code></li><li>传参 <code>prototype</code> 调用函数 <code>F</code> 的内部方法 <code>[[Get]]</code>，获取函数的原型对象，作为 <code>proto</code></li><li>如果 <code>proto</code> 是对象，则将 <code>obj</code> 的内部属性 <code>[[Prototype]]</code> 设置为 <code>proto</code></li><li>如果 <code>proto</code> 不是对象，则将 <code>obj</code> 的内部属性 <code>[[Prototype]]</code> 设置为标准内建的 <code>Object</code> 的原型对象</li><li>调用函数 <code>F</code> 的内部方法 <code>Call</code>， <code>obj</code> 作为调用时的 this 值，此前传给 <code>[[Construct]]</code> 的参数列表作为调用时的参数。将调用后得到的结果作为 <code>result</code></li><li>如果 <code>result</code> 是对象，则将其返回</li><li>否则，返回 <code>obj</code></li></ol><p>可以说，规范已经讲得很清楚了，简单地说，在 new 一个构造函数的时候，具体会做下面的事情：</p><ul><li>内部创建一个实例对象，并指定实例对象的原型：<ul><li>如果构造函数的原型是对象，则让实例的 <code>__proto__</code> 等于构造函数的 <code>prototype</code></li><li>如果构造函数的原型不是对象，则让实例的 <code>__proto__</code> 等于 <code>Object</code> 的 <code>prototype</code></li></ul></li><li>将实例对象绑定为构造函数中的 this，此前传递进来的参数作为参数，并执行一遍构造函数</li><li>如果构造函数返回了对象，则将其作为返回值，否则将实例对象作为返回值</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>ES3 版本的实现如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span>Fn<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Fn <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>Fn <span class="token operator">+</span> <span class="token string">'is not a constructor'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    myNew<span class="token punctuation">.</span>target <span class="token operator">=</span> Fn
    <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 检测构造函数原型是不是对象</span>
    instance<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Fn<span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> Fn<span class="token punctuation">.</span>prototype <span class="token punctuation">:</span> Object<span class="token punctuation">.</span>prototype 
    <span class="token keyword">const</span> returnValue <span class="token operator">=</span> Fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> returnValue <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> returnValue <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> returnValue <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> returnValue
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ES6 版本的实现如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span>Fn<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Fn <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>Fn <span class="token operator">+</span> <span class="token string">'is not a constructor'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    myNew<span class="token punctuation">.</span>target <span class="token operator">=</span> Fn
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 检测构造函数原型是不是对象</span>
    instance<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Fn<span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> Fn<span class="token punctuation">.</span>prototype <span class="token punctuation">:</span> Object<span class="token punctuation">.</span>prototype 
    <span class="token keyword">const</span> returnValue <span class="token operator">=</span> Fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">return</span> returnValue <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> returnValue <span class="token punctuation">:</span> instance
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意几个要点：</p><ul><li>当函数是通过 new 调用的时候，<code>new.target</code> 会指向函数自身，这个“指向”的操作在代码里就是通过 <code>myNew.target = Fn</code> 体现的</li><li>为什么不直接使用 <code>const instance = Object.create(Fn.prototype)</code> 创建实例呢？根据<a href="https://262.ecma-international.org/5.1/#sec-13.2.2" target="_blank" rel="noopener">规范</a>，我们在实现 new 的时候，需要检测构造函数的原型是不是对象，如果不是对象，比如说是 null，那么实例的 <code>__proto__</code> 会指向 Object 的原型，而这里如果使用了 <code>Object.create</code>，则会导致实例的 <code>__proto__</code> 仍然指向 null。网上很多 <code>new</code> 的模拟实现直接使用了 <code>Object.create</code>，或者根本没有对构造函数的原型进行类型检查，这是不够严谨的</li><li>如果无法使用 <code>instanceof</code>，我们也可以改用 <code>typeof Fn.prototype === &#39;Object&#39; &amp;&amp; Fn.prototype !== null</code> 进行判断</li></ul><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/26/F-JS原生方法原理探究（二）：如何实现 Object.create？/">JS 原生方法原理探究（二）：如何实现 Object.create？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.1k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp4 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/26/F-JS原生方法原理探究（二）：如何实现 Object.create？/"><p>这是JS 原生方法原理探究系列的第二篇文章。本文会介绍如何实现 <code>Object.create()</code> 方法。关于这个方法的具体用法，MDN 已经描述得很清楚了，这里我们只做简单的介绍，具体的重点在于如何模拟实现。</p><h2 id="语法简介"><a href="#语法简介" class="headerlink" title="语法简介"></a>语法简介</h2><blockquote><p>调用：Object.create ( proto , propertiesObject )</p><p>返回： 一个新的实例对象</p></blockquote><p>调用这个方法的时候接受两个参数，第一个参数作为返回对象的 <code>__proto__</code>，这个参数只能是 null 或者对象（而且不能是基本类型的包装对象）。</p><p>第二个参数作为返回对象的属性描述，它和 <code>Object.defineProperties()</code> 的第二个参数形式是一样的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>
    propertyA<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        value<span class="token punctuation">:</span> xxx<span class="token punctuation">,</span>
        configurable<span class="token punctuation">:</span> xxx<span class="token punctuation">,</span>
        enumerable<span class="token punctuation">:</span> xxx<span class="token punctuation">,</span>
        writable<span class="token punctuation">:</span> xxx    
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    propertyB<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    propertyC<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个参数的每一个属性都会作为返回对象的属性，而属性值则是相应属性的特性描述（该属性的属性值、是否可读、是否可枚举、是否可配置）。第二个参数只能是对象或者 undefined（表示没有传第二个参数），不能是 null。</p><h2 id="ES-规范"><a href="#ES-规范" class="headerlink" title="ES 规范"></a>ES 规范</h2><p>对于 <code>Object.create()</code> 的具体实现，规范中其实已经描述得很清楚，可以进入<a href="http://es5.github.io/#x15.2.3.5查看：" target="_blank" rel="noopener">http://es5.github.io/#x15.2.3.5查看：</a></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/2.jpg" alt=""></p><p>我简单翻译一下这段话：</p><p><code>create()</code> 方法会创建一个具有指定原型的新对象，当调用该方法的时候，会有如下步骤：</p><ol><li>如果传入的参数 <code>O</code> 不是对象也不是 <code>null</code>，抛出 TypeError 错误</li><li>令 <code>obj</code> 作为调用 <code>new Object()</code> 方法所创建的新对象</li><li>将 <code>obj</code> 的内部属性 <code>[[prototype]]</code> 设置为 <code>O</code></li><li>如果提供了第二个参数 <code>Properties</code>，且不是 <code>undefined</code>，则调用 <code>Object.defineProperties</code> 方法并传入 <code>obj</code> 和 <code>Properties</code> 作为参数，从而为 <code>obj</code> 添加它自己的属性</li><li>返回 <code>obj</code></li></ol><p>可以说，整个过程是一目了然的，我们实现的时候也只需要按照上述步骤实现即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们先看第一种实现：</p><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>create <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>proto<span class="token punctuation">,</span>propertiesObject<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> proto <span class="token operator">!=</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> proto <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the first param must be an object or null'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> propertiesObject <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token string">'TypeError'</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> proto
    <span class="token keyword">if</span><span class="token punctuation">(</span>propertiesObject<span class="token punctuation">)</span><span class="token punctuation">{</span>
        Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>propertiesObject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本上没有什么大问题。不过，我们要留意两个地方：</p><ul><li>在这个实现中，没有检测第一个参数是不是基本类型的包装对象，只要传进来的参数是对象，我们就认为是合法的</li><li>当传入 null 也即 <code>Object.create(null)</code> 的时候，我们实际上创建了一个很纯粹的空对象，这个对象的原型直接就是 null，<code>Object.prototype</code> 甚至没有出现在该对象的原型链中，这意味这个对象不会继承 Object 的任何方法。</li></ul><p>此外，你还可能在其他地方看到类似下面这样的实现：</p><p>具体实现如下：</p><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>create <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>proto<span class="token punctuation">,</span>propertiesObject<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> proto <span class="token operator">!=</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> proto <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the first param must be an object or null'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>propertiesObject <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token string">'TypeError'</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> proto
    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 处理传参 null 的情况</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> proto
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>propertiesObject<span class="token punctuation">)</span><span class="token punctuation">{</span>
        Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>propertiesObject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个实现和前面的实现有一个很关键的区别：代码中单独处理了传参 <code>proto</code> 为 <code>null</code> 的情况。可能你会觉得很奇怪：当 <code>proto</code> 为 <code>null</code> 的时候，<code>F.prototype = proto</code> 的效果和 <code>obj.__proto__ = proto</code> 应该是一样的，为什么还要在这种情况下执行一遍 <code>obj.__proto__ = proto</code> 呢？这似乎说明，用 null 重写 F 的原型后，新创建的实例的 <code>__proto__</code> 并不是 null —— 事实上确实不是。</p><p>关于调用构造函数时会执行的操作，<a href="https://262.ecma-international.org/5.1/#sec-13.2.2" target="_blank" rel="noopener">规范</a>明确提到了这一点：</p><blockquote><p>If <a href="https://262.ecma-international.org/5.1/#sec-8" target="_blank" rel="noopener">Type</a>(<em>proto</em>) is not Object, set the [[Prototype]] internal property of <em>obj</em> to the standard built-in Object prototype object as described in <a href="https://262.ecma-international.org/5.1/#sec-15.2.4" target="_blank" rel="noopener">15.2.4</a>.</p></blockquote><p>由于我们这里是通过 new 构造函数的方式创建新对象（而不是像之前那样通过对象字面量的形式），所以在 new F 的时候，内部会检测 F 的原型是不是对象，如果不是对象，那么会把实例的 <code>__proto__</code> 链接到内建的 <code>Object.prototype</code>。因此，这里新创建的实例的 <code>__proto__</code> 还真不是 null。</p><p>但根据 <code>Object.create</code> 的实现规范，这里必须让实例的 <code>__proto__</code> 指向 null，所以才需要执行 <code>obj.__proto__ = proto</code> 去手动设置对象原型。</p><p>当然，如果我们像第一个实现那样，直接去设置对象的 <code>__proto__</code>，而不是采用构造函数的方式，就不存在这个问题了。</p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/25/F-你的手写new实现足够严谨吗？/">你的手写 new 实现足够严谨吗？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-25&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp5 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/25/F-你的手写new实现足够严谨吗？/"><p>在开始阅读这篇文章之前，你可以对比下面这两段代码的输出结果是否一致（假设 <code>myNew</code> 是你自己实现的 new 操作）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token function">myNew</span><span class="token punctuation">(</span>F<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不一样，那么可能说明你的 <code>myNew</code> 方法和标准的 <code>new</code> 操作之间存在着些许出入，这篇文章也许能够让你的方法更加完善 / 严谨。</p><h4 id="从-Object-create-说起"><a href="#从-Object-create-说起" class="headerlink" title="从 Object.create 说起"></a>从 <code>Object.create</code> 说起</h4><p>最近在刷一些手写实现原生方法的面试题，偶然看到了有一个 <code>Object.create()</code> 方法的实现是这么写的：</p><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>myCreate <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>proto<span class="token punctuation">,</span> propertyObject <span class="token operator">=</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>propertyObject <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 这里没有判断propertyObject是否是原始包装对象</span>
    <span class="token keyword">throw</span> <span class="token string">'TypeError'</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> Fn <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    Fn<span class="token punctuation">.</span>prototype <span class="token operator">=</span> proto
    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>propertyObject <span class="token operator">!==</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> propertyObject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 创建一个没有原型对象的对象，Object.create(null)</span>
      obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> obj
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而这个方法在<a href="http://es5.github.io/#x15.2.3.5" target="_blank" rel="noopener">规范</a>里的实现是这样的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/2.jpg" alt=""></p><p>简单地说，它会接受两个参数，第一个参数作为调用后返回对象的 <code>__proto__</code>，第二个参数负责配置该对象的相关属性。而<strong>这里的第一个参数，可以是对象也可以是 <code>null</code></strong>。</p><p>基本上，上面代码的实现没有什么问题，但是我突然产生了一个疑问：当第一个参数是 <code>null</code> 的时候，<code>Fn.prototype = proto</code> 已经把构造函数的原型对象设置为 <code>null</code>了，为什么后面还要在判断第一个参数为 <code>null</code> 之后设置 <code>obj.__proto__ = null</code> 呢？这两个语句的作用难道不是一样的吗？毕竟 <code>Fn.prototype</code> 和 <code>obj.__proto__</code> 都是指向同一个原型对象呀！</p><p>于是我将代码中的 <code>if (proto === null)</code> 判断去掉，并分别测试了 <code>Object.create()</code> 方法和 <code>Object.myCreate()</code> 方法：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/3.jpg" alt=""></p><p>可以看到，第二个打印是符合预期的，返回对象的 <code>__proto__</code>确实指向传入的参数 <code>null</code>；但第一个打印却和预想的不一样，展开打印对象后会发现，它其实是 <code>Object.prototype</code>。这是怎么回事呢？难道说代码中执行 <code>Fn.prototype = proto</code> 的时候，实际上实例的 <code>__proto__</code> 并没有跟着改变？</p><p>于是继续测试：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/4.jpg" alt=""></p><p>这里可以看到：用 <code>null</code> 重写构造函数的原型后，通过 new 构造函数创建的实例的 <code>__proto__</code> 并没有跟着变成 <code>null</code>，而是指向了 <code>Object.prototype</code>。</p><h4 id="调用构造函数的时候做了什么？"><a href="#调用构造函数的时候做了什么？" class="headerlink" title="调用构造函数的时候做了什么？"></a>调用构造函数的时候做了什么？</h4><p>这时候，我们可能会想到，通过 new 调用构造函数的时候，内部可能做了一些处理，导致最终返回的实例对象的 <code>__proto__</code> 和我们预期的不一致。既然如此，我们通过<a href="https://262.ecma-international.org/5.1/#sec-13.2.2" target="_blank" rel="noopener">规范</a>看一下调用构造函数的时候，具体做了什么事：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/5.jpg" alt=""></p><p>这里我们只需要关注第六步和第七步。这两步会检查构造函数的原型对象的类型，如果是一个对象，则会将其作为实例的 <code>__proto__</code>；如果不是对象，则会将 <code>Object.prototype</code> 作为实例的 <code>__proto__</code>。这就能解释为什么用 <code>null</code> 重写构造函数的原型后，实例的 <code>__proto__</code> 没有跟着改变了，因为在调用构造函数的过程中，它链接上了 <code>Object.prototype</code>，可以说，这里实例的原型链并没有断开。</p><h4 id="实现一个更严谨的-new"><a href="#实现一个更严谨的-new" class="headerlink" title="实现一个更严谨的 new"></a>实现一个更严谨的 <code>new</code></h4><p>在大部分的手写 <code>new</code> 实现中，通常都没有去检查构造函数的原型是否是一个对象。有的实现中甚至直接使用了 <code>Object.create()</code> 方法以快速地建立原型关系，就像这样：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span>Fn<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Fn <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>Fn <span class="token operator">+</span> <span class="token string">'is not a constructor'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>    
    <span class="token keyword">const</span> returnValue <span class="token operator">=</span> Fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">return</span> returnValue <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> returnValue <span class="token punctuation">:</span> instance
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里直接使用<code>Object.create()</code> 方法，是有问题的。</p><p>在前面阅读规范的时候我们已经知道了，即使传给 <code>Object.create</code> 的参数是 <code>null</code>，也会将其作为创建的对象的 <code>__proto__</code>，所以这里如果使用了 <code>Object.create</code>，并且构造函数的原型 <code>Fn.prototype</code> 还恰好就是 <code>null</code> 的话，就会导致实例的 <code>__proto__</code> 也是 <code>null</code>，这和 <code>new</code> 的实际实现是有出入的。</p><p>所以，如果想实现一个更加严谨的 <code>new</code>，那么就不应该在内部去调用 <code>Object.create</code> 方法，而应该选择手动创建一个对象并和构造函数建立原型关系，同时，我们还应该加入对构造函数原型的类型判断，看它到底是不是一个对象。</p><p>因此，上面的代码可以修改如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span>Fn<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Fn <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>Fn <span class="token operator">+</span> <span class="token string">'is not a constructor'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 检测构造函数原型是不是对象</span>
    instance<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Fn<span class="token punctuation">.</span>prototype <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> Fn<span class="token punctuation">.</span>prototype <span class="token punctuation">:</span> Object<span class="token punctuation">.</span>prototype 
    <span class="token keyword">const</span> returnValue <span class="token operator">=</span> Fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">return</span> returnValue <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> returnValue <span class="token punctuation">:</span> instance
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们再用这个改进之后的 <code>new</code> 去测试文章开头的代码：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%A0%E7%9A%84%20new%20%E5%AE%9E%E7%8E%B0%E7%9C%9F%E7%9A%84%E6%98%AF%E5%AF%B9%E7%9A%84%E5%90%97%EF%BC%9F/6.jpg" alt=""></p><p>可以看到，加入了对构造函数原型可能为 <code>null</code> 的处理之后，返回的实例的 <code>__proto__</code> 明确指向了 <code>Object.prototype</code>。现在我们实现的 <code>new</code> 就更加严谨了，而且也更接近原生的 <code>new</code> 操作。</p><p>本文到这里就结束了。不过，从语言设计的角度来说，为什么不将实例的 <code>__proto__</code> 也跟着设置为 <code>null</code> 呢？这里不断开实例的原型链，而是将其链接到 <code>Object.prototype</code> 有什么好处？大家可以在评论区留言讨论一下。另外，不排除本文存在原理性的错误或者说法上的偏颇，如果你发现了，也欢迎在评论区指正。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://262.ecma-international.org/5.1/#sec-13.2.2" target="_blank" rel="noopener">https://262.ecma-international.org/5.1/#sec-13.2.2</a></p><p><a href="http://es5.github.io/#x15.2.3.5" target="_blank" rel="noopener">http://es5.github.io/#x15.2.3.5</a></p><p><a href="https://stackoverflow.com/questions/18198178/null-prototype-object-prototype-and-object-create" target="_blank" rel="noopener">https://stackoverflow.com/questions/18198178/null-prototype-object-prototype-and-object-create</a></p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/21/F-JS原生方法原理探究（一）：如何实现call、apply 和 bind？/">JS 原生方法原理探究（一）：如何实现 call、apply 和 bind？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-21&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp11 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/21/F-JS原生方法原理探究（一）：如何实现call、apply 和 bind？/"><p>这是 JS 原生方法原理探究系列的第一篇文章。本文会介绍如何实现 call、apply 和 bind 方法。关于这几个方法的具体用法，MDN 已经描述得很清楚了，这里不再赘述。</p><h2 id="手写实现-call"><a href="#手写实现-call" class="headerlink" title="手写实现 call"></a>手写实现 call</h2><h3 id="ES3-版本"><a href="#ES3-版本" class="headerlink" title="ES3 版本"></a>ES3 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>thisArg <span class="token operator">===</span> undefined <span class="token operator">||</span> thisArg <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> globalThis
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>   
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'arguments['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'thisArg.fn('</span> <span class="token operator">+</span> args <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ES6-版本"><a href="#ES6-版本" class="headerlink" title="ES6 版本"></a>ES6 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>thisArg <span class="token operator">===</span> undefined <span class="token operator">||</span> thisArg <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> globalThis
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> thisArg<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>call</code> 调用函数的时候，可以通过传给 <code>call</code> 的 thisArg 指定函数中的 this。而只要使得函数是通过 thisArg 调用的，就能实现这一点，这就是我们的主要目标。</p><h3 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h3><ol><li>最终是通过函数去调用 <code>myCall</code> 的，所以 <code>myCall</code> 和 <code>call</code> 一样挂载在函数原型上。同时，也正因为是通过函数去调用 <code>myCall</code> 的，所以在 <code>myCall</code> 内部我们可以通过 this 拿到 <code>myCall</code>的调用者，也就是实际执行的那个函数。</li><li>按理说，<code>myCall</code> 是挂载在函数原型上，当我们通过一个非函数去调用 <code>myCall</code> 的时候，肯定会抛出错误，那么为什么还要在 <code>myCall</code> 中检查调用者的类型，并自定义一个错误呢？这是因为，当一个调用者 <code>obj = {}</code> 是一个对象，但是继承自 <code>Function</code> 的时候（<code>obj.__proto__ = Function.prototype</code>），它作为一个非函数实际上也是可以调用 <code>myCall</code> 方法的，这时候如果不进行类型检查以确保它是个函数，那么后面直接将它当作函数调用的时候，就会抛出错误了</li><li>传给 <code>call</code> 的 thisArg 如果是 null 或者 undefined，那么 thisArg 实际上会指向全局对象；如果 thisArg 是一个基本类型，那么可以使用 <code>Object()</code> 做一个装箱操作，将其转化为一个对象 —— 主要是为了确保后续可以以方法调用的方式去执行函数。那么可不可以写成 <code>thisArg = thisArg ? Object(thisArg) : globalThis</code> 呢？其实是不可以的，如果 thisArg 是布尔值 false，那么会导致 thisArg 最终等于 globalThis，但实际上它应该等于 <code>Boolean {false}</code>。</li><li>前面说过，可以在 <code>myCall</code> 里通过 this 拿到实际执行的那个函数，所以 <code>thisArg.fn = this</code> 相当于将这个函数作为 thisArg 的一个方法，后面我们就可以通过 thisArg 对象去调用这个函数了。</li><li><code>thisArg.fn = this</code> 相当于是给 thisArg 增加了一个 fn 属性，所以返回执行结果之前要 delete 这个属性。此外，为了避免覆盖 thisArg 上可能存在的同名属性 fn，这里也可以使用 <code>const fn = Symbol(&#39;fn&#39;)</code> 构造一个唯一属性，然后 <code>thisArg[fn] = this</code>。</li><li>ES3 版本和 ES6 版本主要的区别在于参数的传递以及函数的执行上：<ol><li>ES6 因为引入了剩余参数，所以不管实际执行函数的时候传入了多少个参数，都可以通过 args 数组拿到这些参数，同时因为引入了展开运算符，所以可以展开 args 参数数组，把参数一个个传递给函数执行</li><li>但在 ES3 中没有剩余参数这个东西，所以在定义 <code>myCall</code> 的时候只接收一个 thisArg 参数，然后在函数体中通过 arguments 类数组拿到所有参数。我们需要的是 arguments 中除第一个元素（thisArg）之外的所有元素，怎么做呢？如果是 ES6，直接<code>[...arguments].slice(1)</code>就可以了，但这是 ES3，于是我们只能从索引 1 开始遍历 arguments，然后 push 到一个 args 数组中了。而且还要注意的是，这里 push 进去的是字符串形式的参数，这主要是为了方便后续通过 eval 执行函数的时候，将参数一个一个传递给函数。</li><li>为什么必须通过 eval 才能执行函数呢？因为我们不知道函数实际上要接收多少个参数，况且也用不了展开运算符，所以只能构造一个可执行的字符串表达式，显式地传入函数的所有参数。</li></ol></li></ol><h2 id="手写实现-apply"><a href="#手写实现-apply" class="headerlink" title="手写实现 apply"></a>手写实现 apply</h2><p>apply 的用法和 call 很类似，因此实现也很类似。需要注意的区别是，call 在接受一个 thisArg 参数之后还可以接收多个参数（即接受的是参数列表），而 apply 在接收一个 thisArg 参数之后，通常第二个参数是一个数组或者类数组对象：</p><pre class="line-numbers language-js"><code class="language-js">fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">)</span>
fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span><span class="token punctuation">[</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果第二个参数传的是 null 或者 undefined，那么相当于是整体只传了 thisArg 参数。</p><h3 id="ES3-版本-1"><a href="#ES3-版本-1" class="headerlink" title="ES3 版本"></a>ES3 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myApply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">if</span><span class="token punctuation">(</span>thisArg <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> thisArg <span class="token operator">===</span> undefined<span class="token punctuation">)</span><span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> globalThis
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>args <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> args <span class="token operator">===</span> undefined<span class="token punctuation">)</span><span class="token punctuation">{</span>
        args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'CreateListFromArrayLike called on non-object'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> _args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        _args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'args['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> _args<span class="token punctuation">.</span>length <span class="token operator">?</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'thisArg.fn('</span> <span class="token operator">+</span> _args <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>thisArg<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ES6-版本-1"><a href="#ES6-版本-1" class="headerlink" title="ES6 版本"></a>ES6 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myApply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> thisArg <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">if</span><span class="token punctuation">(</span>thisArg <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> thisArg <span class="token operator">===</span> undefined<span class="token punctuation">)</span><span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> globalThis
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>args <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> args <span class="token operator">===</span> undefined<span class="token punctuation">)</span><span class="token punctuation">{</span>
        args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span> 
    <span class="token comment" spellcheck="true">// 如果传入的不是数组，仿照 apply 抛出错误</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'CreateListFromArrayLike called on non-object'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> thisArg<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现要点-1"><a href="#实现要点-1" class="headerlink" title="实现要点"></a>实现要点</h3><p>基本上和 call 的实现是差不多的，只是我们需要检查第二个参数的类型。</p><h2 id="手写实现-bind"><a href="#手写实现-bind" class="headerlink" title="手写实现 bind"></a>手写实现 bind</h2><p><code>bind</code> 也可以像 <code>call</code> 和 <code>apply</code> 那样给函数绑定一个 this，但是有一些不同的要点需要注意：</p><ul><li><code>bind</code> 不是指定完 this 之后直接调用原函数，而是基于原函数返回一个内部完成了 this 绑定的新函数</li><li>原函数的参数可以分批次传递，第一批可以在调用 <code>bind</code> 的时候作为第二个参数传入，第二批可以在调用新函数的时候传入，这两批参数最终会合并在一起，一次传递给新函数去执行</li><li>新函数如果是通过 new 方式调用的，那么函数内部的 this 会指向实例，而不是当初调用 <code>bind</code> 的时候传入的 thisArg。换句话说，这种情况下的 <code>bind</code> 相当于是无效的</li></ul><h3 id="ES3-版本-2"><a href="#ES3-版本-2" class="headerlink" title="ES3 版本"></a>ES3 版本</h3><p>这个版本更接近 MDN 上的 polyfill 版本。</p><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myBind <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> fnToBind <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">var</span> args1 <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> fnBound <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果是通过 new 调用</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fnBound</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> fnToBind<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> args2 <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
            <span class="token keyword">return</span> fnToBind<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span>args1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args2<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 实例继承</span>
    <span class="token keyword">var</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    Fn<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype
    fnBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> fnBound
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ES6-版本-2"><a href="#ES6-版本-2" class="headerlink" title="ES6 版本"></a>ES6 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myBind <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span><span class="token operator">...</span>args1<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> fnToBind <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">fnBound</span><span class="token punctuation">(</span><span class="token operator">...</span>args2<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果是通过 new 调用的</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fnBound</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">fnToBind</span><span class="token punctuation">(</span><span class="token operator">...</span>args1<span class="token punctuation">,</span><span class="token operator">...</span>args2<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> fnToBind<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">...</span>args1<span class="token punctuation">,</span><span class="token operator">...</span>args2<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现要点-2"><a href="#实现要点-2" class="headerlink" title="实现要点"></a>实现要点</h3><ol><li><p><code>bind</code> 实现内部 this 绑定，需要借助于 <code>apply</code>，这里假设我们可以直接使用 <code>apply</code> 方法</p></li><li><p>先看比较简单的 ES6 版本:</p><ol><li><strong>参数获取</strong>：因为 ES6 可以使用剩余参数，所以很容易就可以获取执行原函数所需要的参数，而且也可以用展开运算符轻松合并数组。</li><li><strong>调用方式</strong>：前面说过，如果返回的新函数 fnBound 是通过 new 调用的，那么其内部的 this 会是 fnBound 构造函数的实例，而不是当初我们指定的 thisArg，因此 <code>this instanceof fnBound</code>会返回 true，这种情况下，相当于我们指定的 thisArg 是无效的，new 返回的新函数等价于 new 原来的旧函数，即 new fnBound 等价于 new fnToBind，所以我们返回一个 new fnToBind 即可；反之，如果 fnBound 是普通调用，则通过 apply 完成 thisArg 的绑定，再返回最终结果。从这里可以看出，bind 的 this 绑定，本质上是通过 apply 完成的。</li></ol></li><li><p>再来看比较麻烦一点的 ES3 版本：</p><ol><li><p><strong>参数获取</strong>：现在我们用不了剩余参数了，所以只能在函数体内部通过 arguments 获取所有参数。对于 <code>myBind</code>，我们实际上需要的是除开第一个传入的 thisArg 参数之外的剩余所有参数构成的数组，所以这里可以通过 <code>Array.prototype.slice.call</code> 借用数组的 slice 方法（arguments 是类数组，无法直接调用 slice），这里的借用有两个目的：一是除去 arguments 中的第一个参数，二是将除去第一个参数之后的 arguments 转化为数组（slice 本身的返回值就是一个数组，这也是类数组转化为数组的一种常用方法）。同样地，返回的新函数 fnBound 后面调用的时候也可能传入参数，再次借用 slice 将 arguments 转化为数组</p></li><li><p><strong>调用方式</strong>：同样，这里也要判断 fnBound 是 new 调用还是普通调用。在 ES6 版本的实现中，如果是 new 调用 fnBound，那么直接返回 <code>new fnToBind()</code>，这实际上是最简单也最容易理解的方式，我们在访问实例属性的时候，天然就是按照 <code>实例 =&gt; 实例.__proto__ = fnToBind.prototype</code> 这样的原型链来寻找的，可以确保实例成功访问其构造函数 fnToBInd 的原型上面的属性；但在 ES3 的实现中（或者在网上部分 bind 方法的实现中），我们的做法是返回一个 <code>fnToBind.apply(this)</code>，实际上相当于返回一个 undefined 的函数执行结果，根据 new 的原理，我们没有在构造函数中自定义一个返回对象，因此 new 的结果就是返回实例本身，这点是不受影响的。这个返回语句的问题在于，它的作用仅仅只是确保 fnToBind 中的 this 指向 new fnBound 之后返回的实例，而并没有确保这个实例可以访问 fnToBind 的原型上面的属性。实际上，它确实不能访问，因为它的构造函数是 fnBound 而不是 fnToBind，所以我们要想办法在 fnBound 和 fnToBind 之间建立一个原型链关系。这里有几种我们可能会使用的方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 这里的 this 指的是 fnToBind</span>
fnBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样只是拷贝了原型引用，如果修改 <code>fnBound.prototype</code>，则会影响到 <code>fnToBind.prototype</code>，所以不能用这种方法</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// this 指的是 fnToBind</span>
fnBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过 <code>Object.create</code> 可以创建一个 <code>__proto__</code> 指向 <code>this.prototype</code> 的实例对象，之后再让 <code>fnBound.prototype</code> 指向这个对象，则可以在 fnToBind 和 fnBound 之间建立原型关系。但由于 <code>Object.create</code> 是 ES6 的方法，所以无法在我们的 ES3 代码中使用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// this 指的是 fnToBind</span>
<span class="token keyword">const</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
Fn<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype
fnBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是上面代码采用的方法：通过空构造函数 Fn 在 fnToBind 和 fnBound 之间建立了一个联系。如果要通过实例去访问 fnToBind 的原型上面的属性，可以沿着如下原型链查找：</p><p><code>实例 =&gt; 实例.__proto__ = fnBound.prototype = new Fn() =&gt; new Fn().__proto__ = Fn.prototype = fnToBind.prototype</code></p></li></ol></li></ol><p>​</p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/07/29/F-Vue+Koa前后端分离项目线上部署/">Vue+Koa2 前后端分离项目线上部署</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-29&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp15 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/07/29/F-Vue+Koa前后端分离项目线上部署/"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%2BKoa%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2/d0.jpg" alt=""></p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/07/27/F-concurrently实现前后端连载启动/">concurrently 实现前后端连载启动</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-27&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp361&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp1 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/07/27/F-concurrently实现前后端连载启动/"><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2020/07/26/F-聊一聊：一道 Promise 链式调用的题目/">聊一聊：一道 Promise 链式调用的题目</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.5k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp12 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2020/07/26/F-聊一聊：一道 Promise 链式调用的题目/"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/0.jpg" alt=""></p><div class="default">阅读全文......</div></a></div></article></section></div><nav class="pager-nav"><span class="page-number current">1</span><a class="page-number" href="/categories/Front-end/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/categories/Front-end/page/7/">7</a><a class="extend next" rel="next" href="/categories/Front-end/page/2/">Next »</a></nav></div></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->