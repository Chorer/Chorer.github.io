<!-- build time:Sun Sep 05 2021 14:05:20 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">编译原理学习笔记-2：文法和语言</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-03-20&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp14 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80-1.jpg"></div><a id="more"></a><blockquote><p>在 <a href="https://chorer.github.io/2020/03/14/CP-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">上一篇笔记</a>中，我们谈到了为什么需要编译以及编译的大致流程。在继续细讲每一个流程之前，我们先通过本篇笔记对一些概念和术语加以了解。</p></blockquote><h3 id="前置知识字母表和符号串">1. 前置知识：字母表和符号串</h3><h4 id="字母表">1.1 字母表</h4><p>字母表也即符号集，用 <code>∑</code>表示，它是一个包含各种符号的有穷非空集合。以汉语为例，汉语字母表就是各种汉字、数字、标点符号的集合；以英语为例，英语字母表就是各种字母、数字、标点符号的集合......那么到了编程，字母表就可能是字母、数字、各种专用符号和保留字了。</p><h4 id="符号串">1.2 符号串</h4><p><strong>相关定义：</strong></p><p>符号串是对于字母表来说的一个概念，字母表的符号串指的就是由字母表中各个字符组成的一个<strong>有穷序列</strong>。</p><p>注意这里的“有穷”，指的是符号串本身是由有穷个符号组成，但是符号串的个数是无穷多的（组合方式不同）。以字母表 <code>∑={0,1}</code> 为例，它的符号串就有：0，1，00，01，10，11，000 等等。</p><p>符号串的长度指的是符号串符号的个数，以 <code>m = 000</code> 为例，<code>|m|= 3</code>。</p><p>空符号串 <code>ε</code> 长度为 0，表示不包含任何符号，类似于编程中的空字符串 <code>&quot;&quot;</code>。所以有 <code>εm = mε= m</code>。</p><p>以 <code>m = abc</code> 为例，它的头是 <code>ε</code>，<code>a</code>，<code>ab</code>，<code>abc</code>；它的尾是 <code>ε</code>，<code>c</code>，<code>bc</code>，<code>abc</code>。而它的固有头不考虑末尾符号 <code>c</code>，固有尾不考虑首部符号 <code>a</code>。</p><p><strong>连接、方幂</strong></p><ul><li>符号串的连接：连接就是两个字符串顺序拼接，比如 <code>x = abc</code>，<code>y = def</code>，那么 <code>xy = abcdef</code>。</li><li>符号串的方幂：如果一个符号串由多个重复符号构成，如何方便地表示它呢？比如 <code>y = xxxx...xxxx</code>（n 个 x），那么就可以写成 <code>y = x^n</code>，此时 y 就是 x 的方幂。这点和数学是一样的。不过要注意，<code>x^0 ≠ 1 = ε</code>。</li></ul><h4 id="闭包">1.3 闭包</h4><p>以字母表 <code>∑ = {a,b}</code> 为例，任何由它的符号串作为构成元素的集合，都可以称作字母表的<strong>符号串集合</strong>。比如说 <code>{ab}</code>，<code>{abab,ababab}</code> 等。</p><p>两个符号串集合的乘积定义为 <code>AB = {xy| x∈A且y∈b}</code>，其实就是笛卡尔积。</p><p>一般的字符串集合可能并不能囊括一个字母表的所有符号串，但是有一种集合却能包含所有的符号串，这种特殊的集合称为闭包，记作 <code>∑*</code>。<code>*</code> 其实就是全选的意思（联想 CSS 中的通配选择符就好理解了）。</p><p><code>∑* = {ε,a,b,ab,ab,ba,aba,aab......} = ∑^0 ∪ ∑^1 ∪ ∑^2 ∪......∪ ∑^n</code></p><p>要注意的是，闭包也<strong>包含了空符号串</strong>。</p><p>将闭包中的空符号串去掉，就成为了<strong>正闭包</strong>，也即 <code>∑+</code>。显然：<code>∑*＝ ∑^0 ∪ ∑+</code>，<code>∑+ = ∑∑* ＝ ∑*∑</code>。</p><h3 id="文法">2. 文法</h3><h4 id="文法在语言体系中的位置">2.1 文法在语言体系中的位置</h4><p>语言包括<strong>语法</strong>和<strong>语义</strong>两个方面，但是语法和语义都是比较抽象的东西，所以我们需要借助一些工具来阐述它们。以语法来说，文法就是阐述它的一个工具。</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80-3.png"></div><h4 id="文法的形式定义">2.2 文法的形式定义</h4><p>文法是描述语言语法结构的形式规则。它的形式化定义是一个四元组，即 <strong>G = { V<sub>N</sub> , V<sub>T</sub> , P , S }</strong>。下面我们先给出一个自然语言的例子，然后借此来解释四元组的各个成分都是什么。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">&lt;</span>句子<span class="op">&gt;</span> → <span class="op">&lt;</span>主语<span class="op">&gt;</span> <span class="op">&lt;</span>谓语<span class="op">&gt;</span>

<span class="op">&lt;</span>主语<span class="op">&gt;</span> → <span class="op">&lt;</span>代词<span class="op">&gt;</span> <span class="op">|</span> <span class="op">&lt;</span>名词<span class="op">&gt;</span>

<span class="op">&lt;</span>谓语<span class="op">&gt;</span> → <span class="op">&lt;</span>动词<span class="op">&gt;</span> 

<span class="op">&lt;</span>代词<span class="op">&gt;</span> → 你 <span class="op">|</span> 我 <span class="op">|</span> 他

<span class="op">&lt;</span>名词<span class="op">&gt;</span> → 张三 <span class="op">|</span> 教师 <span class="op">|</span> 大学生

<span class="op">&lt;</span>动词<span class="op">&gt;</span> → 教书 <span class="op">|</span> 学习</code></pre></div><p><strong>（1）V<sub>T</sub>：</strong></p><p>V<sub>T</sub> 指的是终结符集合。终结符即 <code>terminal symbol</code>，它是文法所定义的语言的<strong>最基本</strong>符号，这意味着一个终结符不可再细分（注意“终结”这个词）。以上面为例，V<sub>T</sub> ={ 你，我，他，张三，教师，大学生，教书，学习 }。在编程语言中，终结符其实就是之前提到的 token，比如保留字、运算符、界符等这些最最基本的符号。</p><p>终结符一般用小写字母表示。</p><p><strong>（2）V<sub>N</sub>：</strong></p><p>V<sub>N</sub> 指的是非终结符集合。非终结符即 <code>nonterminal symbol</code>，它是用来表示语法成分的符号，有时候也称为“语法变量”。以上面为例，V<sub>N</sub> ={<句子>，<主语>，<谓语>，<代词>，<名词>，<动词>}。在编程语言中，我们可以说表达式或者赋值语句就是一个非终结符，因为它可以继续细分为多个 token。</动词></名词></代词></谓语></主语></句子></p><p>非终结符的“非终结”，就是说“还没有到尽头”，还可以继续拆分，一般用 &lt;&gt; 括起来。</p><p>非终结符一般用大写字母表示。</p><p><strong>PS：</strong>终结符和非终结符统称为文法符号。</p><p><strong>（3）P：</strong></p><p>P 即 <code>production</code>，指的是产生式集合。终结符和非终结符的转换依靠的就是产生式（或者说生成式，推导规则）。产生式形如 <strong>a → β</strong> （或者 <strong>a : : = β</strong> ，这种表示方法即巴科斯范式 ），意思是将 a 定义为 β。a 称为产生式左部，它是终结符集合的一个元素；而 β 称为产生式右部，它是终结符和非终结符并集的一个元素。根据前面的定义，很容易就能知道产生式的左部不能是终结符，因为左部都是可以继续细分的，但是终结符不能再细分了，而右部在一开始可能是非终结符（还没拆完），但在最后一定会变成终结符（拆完了，不能再拆了）。</p><p>以上面为例，P = {<句子>→<主语><谓语>，<主语>→<代词>|<名词>，<谓语>→<动词>}</动词></谓语></名词></代词></主语></谓语></主语></句子></p><p><strong>（4）S：</strong></p><p>S 即 <code>start symbol</code>，指的是开始符号（识别符号）。它是最开始的那条产生式的左部，一切的推导都是从它这里开始进行的，可以认为它就是最大的那个成分。所以也注定了 S 必须在 P 中至少作为某一条产生式的左部（不然无从推导）。</p><p>以上面为例，S =<句子>。</句子></p><h4 id="更简洁的形式化定义">2.3 更简洁的形式化定义</h4><p>假如现在有文法 G =（{S，A，B}，{0，1}，P，S）,</p><p>其中，P = { S → 0A，S → 1B，A → 1B，B → 1 }。</p><p>是否有更简便的方法来表示它呢？事实上，这里仅从产生式集合 P 来看，完全可以在不引起歧义的情况下推断出终结符号集，非终结符号集以及开始符号。这意味着我们可以将这三者省略，仅用产生式集合表达文法本身，也即：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">G： 
S → 0A   
S → 1B  
A → 1B
B → <span class="dv">1</span>
B → <span class="dv">0</span></code></pre></div><p>更进一步地，我们发现部分产生式的左部都是一样的，所以可以继续简写为：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">G： 
S → 0A <span class="op">|</span> 1B  
A → 1B 
B → <span class="dv">1</span> <span class="op">|</span> <span class="dv">0</span></code></pre></div><p>此时，0A 或者 1B 称为 S 的候选式（candidate），1 或者 0 称为 B 的候选式。</p><h4 id="推导">2.4 推导</h4><p><strong>（1）直接推导：</strong></p><p>假如文法 <strong>G = { V<sub>N</sub> , V<sub>T</sub> , P , S }</strong> 有一条产生式为 <strong>a → β</strong> ，γ 和 δ 是 V*= V<sub>N</sub> ∪ V<sub>T</sub> 中的任意符号（即是文法中的任意终结符或者非终结符），若有符号串满足：</p><p>V = γ a δ ，W = γ β δ</p><p>那么就说 V 可以直接推导得到 W，或者说 W 是 V 的直接推导，W 直接规约到 V —— 记作 V ⇒ W。我们看一个例子：</p><blockquote><p>假如现在有文法 G =（{S，A，B}，{0，1}，P，S），其中，P = { S → 0A，S → 1B，A → 1B，B → 1 }。</p></blockquote><p>那么以产生式 S → 0A 为例，我们是可以说 S ⇒ 0A 的，因为 S = εSε，0A = ε0Aε（别忘了，空符号串也是属于 V* 的），以此类推，所有的产生式实际上都是一个直接推导。</p><p><strong>（2）推导：</strong></p><p>推导指的是从文法的开始符号出发，反复连续地使用产生式，对非终结符施行替换和展开，最终得到一个仅由<strong>终结符</strong>构成的符号串，推导过程的每一步都是一个直接推导。</p><p>还是以上面的文法为例，那么就有 S ⇒ 0A ⇒ 01B ⇒ 011，这个序列就是从 S 到 011 的一个推导，或者说 S 可以推导出 011。</p><p>序列可以简写为 S +⇒ 011，表示经过一步或者多步推导，而 S <em>⇒ 011 表示经过 0 步或者多步推导。所以，S </em>⇒ 011 要么是 S = 011，要么是 S +⇒ 011。</p><p><strong>（3）最左/最右推导：</strong></p><p>推导的过程并不是唯一的。对于任何一步 α ⇒ β，如果都是对 α 中的<strong>最左非终结符</strong>进行替换，那么就说最左推导，反之就是最右推导。</p><p>假如给定文法G：<code>E → E + E | E * E | (E) | i</code>，由该文法最终可以推导得到句子 (i * i + i)。如果采用最右推导，那么过程就是：</p><p>E ⇒ (E) ⇒ (E + E) ⇒ (E + i) ⇒ (E * E + i) ⇒ (E * i + i) ⇒ (i * i + i)。</p><p>在每一步中，我们都尽可能地替换 α 中的最左非终结符。</p><h4 id="句型句子语言">2.5 句型、句子、语言</h4><ul><li>句型：如果 S *⇒ a，开始符号 S 可以推导得到某个符号串，那么这个符号串 a 就称为句型。以上面文法为例，0A ，01B，011 ...... 都是句型。</li><li>句子：在推导之初，句型可能既包含终结符也包含非终结符，但最终肯定只剩下终结符构成的符号串，此时这个符号串就称为句子。以上面文法为例，011 就是句子。</li><li>语言：文法产生的句子的全体就构成了语言，记作 L(G)。以上面文法为例，L(G) = { 011，11 }。</li></ul><h3 id="语法分析树与文法的二义性">3. 语法分析树与文法的二义性</h3><p>我们可以借助语法分析树（这里的语法分析树是具体语法树，即 parse tree，不是抽象语法树）这个结构来描述句型的推导。比如给定文法 G：</p><p>G = ( {S,A}，{a,b}，P，S )，其中 P ={ S → aAS，A → SbA，A → SS，S → a，A → ba }</p><p>可以这样推导出句子 aabbaa：S ⇒ aAS ⇒ aSbAS ⇒ aabAS ⇒ aabbaS ⇒ aabbaa</p><p>那么如何用分析树表达这个句子呢？如图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80-4.1.jpg" style="zoom:50%"></p><p>用根节点代表开始符号，随着推导的进行，当某个非终结符被它的候选式所替换时，这个非终结符的相应结点就会产生下一代子结点，以此类推。</p><p>有时候，对于某个句子，由于它的推导过程不唯一，所以会导致它的分析树也不唯一。之前的例子中，我们给定了文法 G：<code>E → E + E | E * E | (E) | i</code>，由这个文法推导出句子 (i * i + i)，实际上有两种方式：</p><ul><li>E ⇒ (E) ⇒ ( E + E ) ⇒ ( E + i ) ⇒ ( E * E + i ) ⇒ ( E * i + i ) ⇒ ( i * i + i )</li><li>E ⇒ (E) ⇒ (E * E ) ⇒ ( i * E ) ⇒ ( i * E + E) ⇒ ( i * i + E) ⇒ ( i * i + i )</li></ul><p>对应地有两种分析树：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%EF%BC%9A%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80-5.png" style="zoom:50%"></p><p>由于这个文法存在着某个句子对应着两棵不同的分析树，所以这个文法是<strong>二义（歧义）</strong>的。</p><p>显然，程序语言不能出现歧义。消除歧义的方法之一是改写语法，但这种改写非常困难；另一种方法就是引入 <strong>优先级</strong> ，利用符号的优先级来选择需要的推导方式。</p><p>作为描述程序语言的上下文无关文法，我们对它还有一些限制：</p><ul><li>文法中不包含形如 P → P 的产生式</li><li>每个非终结符一定可以被用到，或者本身被 S 推导得到，或者本身推导得到其它终结符串。</li></ul><h3 id="文法类型">4. 文法类型</h3><p>乔姆斯基把文法划分为四种类型（从 0 型到 1型），这四种类型层层增强，越到后面限制越大。</p><h4 id="型文法">（1） 0 型文法</h4><p>0 型文法也叫短语文法。设 G = { V<sub>N</sub> , V<sub>T</sub> , P , S }，如果它的每个产生式 α→β 都满足：</p><blockquote><p><strong>α∈(V<sub>N</sub>∪V<sub>T</sub>)</strong>* 且至少含有一个非终结符，而 <strong>β∈(V<sub>N</sub>∪V<sub>T</sub>)</strong>*</p></blockquote><p>那么这种文法就称为 0 型文法。其中，V<sub>N</sub>∪V<sub>T</sub> 代表的是终结符合集和非终结符号集的并集，注意这同样是一个字母集，所以外面加上星号，就成为我们开篇所说的字母集的闭包。也就是说，产生式的左部或者右部，必须是由终结符和非终结符构成的符号串。</p><h4 id="型文法-1">（2） 1 型文法</h4><p>在 0 型文法的基础上加以限制，规定对于每一个 α→β，都必须满足 |α| &lt;= |β|。也就是说，产生式左部符号串长度必须小于等于右部符号串长度。这里要注意一个特例就是： α → ε，虽然左部长度一定大于右部长度，但它仍然符合 1 型文法。</p><p>1 型文法也叫上下文有关文法。</p><h4 id="型文法-2">（3） 2 型文法</h4><p>在 1 型文法的基础上加以限制，规定对于每一个 α→β，都必须满足 α 是一个非终结符。也就是说，产生式左部必须得是一个非终结符。</p><p>2 型文法也叫上下文无关文法。</p><h4 id="型文法-3">（4） 3 型文法</h4><p>在 3 型文法的基础上加以限制，规定对于每一个 α→β，要么必须满足 A→ α | αB（右线性），要么必须满足 A→ α | Bα（左线性）。这里的 AB 代表非终极符号。</p><p>3 型文法也叫正规文法。</p><h3 id="文法和上下文">5. 文法和上下文</h3><p>上下文实际上是在替换非终结符的时候给予的一个限制条件。也就是说，如果文法是上下文有关的，那么进行替换的时候需要考虑上下文，反之则不必。比方说，γ a δ → γ β δ 是 1 型文法的一个产生式，γ 和 δ 都不为空，则非终结符 a 只有在 γ 和 δ 这样的一个上下文环境里才能被替换成 β。</p><p>下面我们用更加通俗的例子来解释这两种文法：</p><p>定义上下文无关文法 G ：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">Grammar → X Y Z
X → 我 <span class="op">|</span> 学校
Y → 去 <span class="op">|</span> 没有
Z → 公园 <span class="op">|</span> 人</code></pre></div><p>那么以 Grammar 作为开始符号，就会产生各种句子，其中既有像“我去公园”，“学校没有人”这种句意通顺的，也不乏“我没有人”，“学校去公园”这种狗屁不通的。为什么会产生不符合语义的句子？这是因为我们没有给定上下文的约束，也就是说，因为有了 <code>Y → 去 | 没有</code> 这条产生式，所以只要遇到 Y，推导出“去”或者“没有”就都是合理的，而全然不需要关注“去“的上文是什么，”去“的下文是什么。</p><p>但是如果定义上下文有关文法 G‘：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">Grammar → X Y Z
X → 我 <span class="op">|</span> 学校
我 Y → 我去 
学校 Y → 学校没有 
去 C → 去公园
没有 C → 没有人</code></pre></div><p>那么就完全不一样了。这时候非终结符的替换是受到上下文限制的 ——</p><p>Y 只有在上文是”我“ 的时候才能被替换成”去“，只有在上文是”学校“ 的时候才能被替换成”没有“，因此不会产生诸如”学校去“或者”我没有“这样的句子；同理，C 只有在上文是”去“ 的时候才能被替换成”公园“，只有在上文是”没有“ 的时候才能被替换成”人“，因此不会产生诸如”没有公园“或者”去人“这样的句子。这样就保证了产生的句子是符合语义的。</p><p>最后我们再来总结本篇笔记所讲的内容。在文章开始，我们先给出了一些相关术语的概念和形式，这是为了更好地在后面形式化地表示文法；接着，我们引入了文法的概念，包括它的形式化定义，它的推导；然后，我们引入了语法树的概念，用以描述推导的过程；最后，我们解释了文法的几种类型（0 ~ 3），并通过例子补充了文法在有/无上下文约束的情况下分别会推导出什么句型。</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/03/23/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%EF%BC%88%E4%B8%80%EF%BC%89/" rel="prev" title="操作系统学习笔记-4：进程同步与进程互斥（一）"><i class="fa fa-angle-double-left"></i>&nbsp操作系统学习笔记-4：进程同步与进程互斥（一）</a></div><div class="post-nav-next"><a href="/2020/03/17/T-hexo%20%E4%B8%AD%E6%96%87%E6%96%87%E7%AB%A0%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF%E7%9A%84bug%E8%A7%A3%E5%86%B3/" rel="next" title="hexo 中文文章渲染错误的bug解决">hexo 中文文章渲染错误的bug解决&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%97%E6%AF%8D%E8%A1%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E4%B8%B2"><span class="toc-text">1. 前置知识：字母表和符号串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E8%A1%A8"><span class="toc-text">1.1 字母表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E4%B8%B2"><span class="toc-text">1.2 符号串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">1.3 闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95"><span class="toc-text">2. 文法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E5%9C%A8%E8%AF%AD%E8%A8%80%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">2.1 文法在语言体系中的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">2.2 文法的形式定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E7%AE%80%E6%B4%81%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89"><span class="toc-text">2.3 更简洁的形式化定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC"><span class="toc-text">2.4 推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E5%9E%8B%E5%8F%A5%E5%AD%90%E8%AF%AD%E8%A8%80"><span class="toc-text">2.5 句型、句子、语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91%E4%B8%8E%E6%96%87%E6%B3%95%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-text">3. 语法分析树与文法的二义性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">4. 文法类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%8B%E6%96%87%E6%B3%95"><span class="toc-text">（1） 0 型文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%8B%E6%96%87%E6%B3%95-1"><span class="toc-text">（2） 1 型文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%8B%E6%96%87%E6%B3%95-2"><span class="toc-text">（3） 2 型文法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%8B%E6%96%87%E6%B3%95-3"><span class="toc-text">（4） 3 型文法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">5. 文法和上下文</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->