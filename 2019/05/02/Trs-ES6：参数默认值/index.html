<!-- build time:Fri May 03 2019 10:43:46 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Chor&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third party/jquery.fancybox.css"><link rel="icon" href="/images/me.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/prism-coy.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-coy.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="header"><span><i class="fa fa-bars"></i> <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></span><div class="blog-title"><a href="/" class="logo">Chor&#39;s Blog</a></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link">Home</a></li><li class="menu-item"><a href="/categories" class="menu-item-link">Categories</a></li><li class="menu-item"><a href="/archives" class="menu-item-link">Archives</a></li><li class="menu-item"><a href="/tags" class="menu-item-link">Tags</a></li><li class="menu-item"><a href="/about" class="menu-item-link">About</a></li></ul></nav><i id="homelink" data-link="https://chorer.github.io/"></i></header><main class="main"><section class="posts"><article class="post"><div class="post-title"><a class="post-title-link" href="/2019/05/02/Trs-ES6：参数默认值/">「译」ES6：参数默认值</a></div><div class="post-date"><span class="date-text"><i class="fa fa-calendar"></i>Date:&nbsp&nbsp2019-05-02</span></div><div class="post-tags"></div><div class="post-statistic"><span class="post-words"><i class="fa fa-pencil-square-o"></i> <span class="text_words">Count: </span><span>2.5k words</span> </span>&nbsp| &nbsp<span class="post-time"> <i class="fa fa-clock-o"></i> <span class="text_time">Time: </span><span>9 mins</span></span></div><div class="post-content"><blockquote><ul><li>原文地址：<a href="http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/" target="_blank" rel="noopener">ES6: Default values of parameters</a></li><li>原文作者：Dmitry Soshnikov</li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p>在这篇文章中我们会涉及另一个 ES6 的特性，带默认值的函数参数。正如我们将看到的，有一些微妙的案例。</p><h2 id="1-ES5-及更低版本的手动默认值"><a href="#1-ES5-及更低版本的手动默认值" class="headerlink" title="1.ES5 及更低版本的手动默认值"></a>1.ES5 及更低版本的手动默认值</h2><p>以前的默认参数值是通过以下几种可选方式手动处理的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> level<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  level <span class="token operator">=</span> level <span class="token operator">||</span> <span class="token string">'warning'</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> <span class="token string">': '</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'low memory'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// warning: low memory</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'out of memory'</span><span class="token punctuation">,</span> <span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: out of memory</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免潜在的“假值”，通常可以看到有<code>typeof</code>检查：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> level <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  level <span class="token operator">=</span> <span class="token string">'warning'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有时，你也可以检查<code>arguments.length</code>:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  level <span class="token operator">=</span> <span class="token string">'warning'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所有这些方法都行之有效，但是，它们太偏向手动了，并且不够抽象。ES6 标准化了一种句法结构，在函数头直接定义了参数默认值。</p><h2 id="2-ES6-默认值：基本实例"><a href="#2-ES6-默认值：基本实例" class="headerlink" title="2.ES6 默认值：基本实例"></a>2.ES6 默认值：基本实例</h2><p>许多语言都存在默认参数值，所以大多数开发人员应该熟悉它的基本形式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> level <span class="token operator">=</span> <span class="token string">'warning'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> <span class="token string">': '</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'low memory'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// warning: low memory</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'out of memory'</span><span class="token punctuation">,</span> <span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: out of memory</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种默认参数用法相当随便，但是却很方便。让我们深入实现细节来理清默认参数可能带来的困惑。</p><h2 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3.实现细节"></a>3.实现细节</h2><p>以下是关于 ES6 函数默认参数值的实现细节的一些特性。</p><h3 id="3-1-执行阶段的重新计值"><a href="#3-1-执行阶段的重新计值" class="headerlink" title="3.1 执行阶段的重新计值"></a>3.1 执行阶段的重新计值</h3><p>一些其他语言（例如 Python ）会在定义阶段对默认参数进行一次计值，相比之下，ECMAScript 则会在执行阶段计算默认参数值 —— 每次函数调用的时候。采用这种设计是为了避免与作为默认值的复杂对象混淆。思考下面的 Python 例子：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  x<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> x

<span class="token comment" spellcheck="true"># 我们可以看到默认值只在定义函数时被创建一次，</span>
<span class="token comment" spellcheck="true"># 并且仅作为函数的一个属性被保存起来。</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>__defaults__<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ([],)</span>

foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [1]</span>
foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [1, 1]</span>
foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [1, 1, 1]</span>

<span class="token comment" spellcheck="true"># 正如我们所说的：</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>__defaults__<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ([1, 1, 1],)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免这种情况，Python 开发人员习惯将默认值定义为<code>None</code>,并且显式检查这个值：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> None<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">if</span> x <span class="token keyword">is</span> None<span class="token punctuation">:</span>
    x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  x<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>__defaults__<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># (None,)</span>

foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [1]</span>
foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [1]</span>
foo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># [1]</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>__defaults__<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ([None],)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，这同样是不方便的手动处理实际默认值的方式，并且最初的案例让人感到疑惑。因此，为了避免这种情况，ECMAScript 会在每次函数执行时计算默认值。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1]</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1]</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一切都很好，很直观。现在我们来看下不清楚工作机制时， ES 语义何时会让我们感到困惑。</p><h3 id="3-2-外部作用域的遮蔽"><a href="#3-2-外部作用域的遮蔽" class="headerlink" title="3.2 外部作用域的遮蔽"></a>3.2 外部作用域的遮蔽</h3><p>思考下面的例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2, 不是 1!</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如我们看到的，上面的例子输出的<code>y</code>是<code>2</code>，而不是<code>1</code>。原因是参数中的<code>x</code>与全局的<code>x</code>不是同一个。由于执行阶段会计算默认值，在赋值<code>=x</code>发生的时候，<code>x</code>已经在内部作用域中解析了，并且指向了<code>x</code>参数自身。具有相同名称的参数<code>x</code>遮蔽了全局变量，使得对来自默认值的<code>x</code>的所有访问都将指向参数。</p><h3 id="3-3-参数的-TDZ-（暂时性死区）"><a href="#3-3-参数的-TDZ-（暂时性死区）" class="headerlink" title="3.3 参数的 TDZ （暂时性死区）"></a>3.3 参数的 TDZ （暂时性死区）</h3><p>ES6 提到了所谓的 <strong>TDZ</strong> （表示<strong>暂时性死区</strong>）—— 这是程序的一部分，在这个区域内变量或者参数在初始化（即接受一个值）之前将无法访问。<br>就参数而言，一个参数不能以自身作为默认值：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 抛出错误！</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们上面提到的赋值<code>=x</code>在参数作用域中解析<code>x</code>，遮蔽了全局<code>x</code>。但是，参数<code>x</code>位于 TDZ 内，在初始化之前无法访问。显然，它无法初始化为自身。</p><p>注意，上面带有<code>y</code>的例子是有效的，因为<code>x</code>已经初始化（为隐式默认值<code>undefined</code>）了。我们再来看一下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 可行</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之所以可行，是因为 ECMAScript 中的参数是按照从左到右的顺序初始化的，我们已经有可供使用的<code>x</code>了。</p><p>我们提到参数已经与“内部作用域”相关联了，在 ES5 中我们可以假定是函数体的作用域。但是，它实际上更加复杂：它可能是一个函数的作用域，或者是一个为了存储参数绑定而特别创建的中间作用域。</p><h3 id="3-4-带条件的参数中间作用域"><a href="#3-4-带条件的参数中间作用域" class="headerlink" title="3.4 带条件的参数中间作用域"></a>3.4 带条件的参数中间作用域</h3><p>事实上，如果一些（至少有一个）参数具有默认值，ES6 会定义一个中间作用域用于存储参数，并且这个作用域不与函数体的作用域共享。这是与 ES5 存在主要区别的一个方面。我们用例子来证明：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// `x` 被共用了吗？</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不，依然是 3，不是 2</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 并且外部`x`也不受影响 </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们有三个作用域：全局环境，参数环境，以及函数环境：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">:</span>  <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 内部</span>
<span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 参数</span>
<span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 全局</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以看到，当函数<code>y</code>执行时，它在最近的环境（即相同的环境）中解析<code>x</code>，且忽略了函数的作用域。</p><h4 id="3-4-1-转译为-ES5"><a href="#3-4-1-转译为-ES5" class="headerlink" title="3.4.1 转译为 ES5"></a>3.4.1 转译为 ES5</h4><p>如果我们要将 ES6 代码编译为 ES5，并看看这个中间作用域是怎样的，我们会得到下面的结果：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// ES6</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// `x` 被共用了吗？</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不，依然是 3，不是 2</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 编译为 ES5</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 设置默认值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> y <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可以清楚地看到，它更新了参数`x`</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可以清楚地看到，这个`x`来自内部作用域</span>
    <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-2-参数作用域的源由"><a href="#3-4-2-参数作用域的源由" class="headerlink" title="3.4.2 参数作用域的源由"></a>3.4.2 参数作用域的源由</h4><p>但是，设置这个参数作用域的确切目的是什么？为什么我们不能像 ES5 那样与函数体共享参数？理由是：函数体中的同名变量不应该因为名字相同而影响到闭包绑定中的捕获行为。</p><p>我们用下面的例子展示：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 捕获`x`</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是 1, 不是 2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们在函数体作用域中创建函数<code>y</code>，它将会捕获内部的<code>x</code>,也即<code>2</code>。但显而易见，它应该捕获的是外部的<code>x</code>，也即<code>1</code>(除非它被同名参数遮蔽)。</p><p>同时，我们无法在外部作用域中创建函数，这意味着我们无法从这样的函数中访问参数。我们可以这样做：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//  可以看到`x`和`y`</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2，不是4</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-3-当参数作用域未创建的时候"><a href="#3-4-3-当参数作用域未创建的时候" class="headerlink" title="3.4.3 当参数作用域未创建的时候"></a>3.4.3 当参数作用域未创建的时候</h4><p>上述的语义与默认值的手动实现完全不同：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> y <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// `x` 被共用了吗？</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是的！2</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 外部的`x`依然不受影响 </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在有一个有趣的事实：如果一个函数没有默认值，它就不会创建这个中间作用域，并且与一个函数环境中的参数绑定共享，即以 ES5 模式运行。</p><p>为什么要这么复杂呢？为什么不总是创建参数作用域呢？这仅仅和优化有关吗？并非如此。确切地说，这是为了向下兼容 ES5：上述手动实现默认值的代码应该更新函数体中的<code>x</code>（也就是参数自身，且位于相同作用域中）。</p><p>同时还要注意，那些重复声明只适用于<code>var</code>和函数。用<code>let</code>或者<code>const</code>重复声明参数是不行的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误</span>
  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-undefined检查"><a href="#4-undefined检查" class="headerlink" title="4.undefined检查"></a>4.<code>undefined</code>检查</h3><p>还要注意另一个有趣的事实，是否应用默认值，取决于对参数初始值的检查结果是否为值<code>undefined</code>。我们来证明一下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined, 2</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 2</span>

<span class="token function">foo</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined, 2</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常的编程语言中，带默认值的参数在必需参数之后，但是，上述事实允许我们在 JavaScript 中使用如下结构：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, undefined</span>
<span class="token function">foo</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2, 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-解构组件的默认值"><a href="#5-解构组件的默认值" class="headerlink" title="5. 解构组件的默认值"></a>5. 解构组件的默认值</h3><p>涉及默认值的另一个地方是解构组件的默认值。本文不会涉及解构赋值的主题，不过我们会展示一些小例子。不管是在函数参数中使用解构，还是上述的使用简单默认值，处理默认值的方式都是一样的：即在需要的时候创建两个作用域。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined, 5</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 5</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管解构的默认值更加通用，不仅仅用于函数中：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token punctuation">{</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 5</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h3><p>希望这篇简短的文章可以帮助解释 ES6 中默认值的细节。注意，在本文撰写的那一天（2014 年 8 月 21 日），默认值还没有得到真正的实现（它们都只是创建了一个与函数体共享的作用域），因为这个“第二作用域”是在最近才添加到标准草案的。默认值一定会是一个很有用的特性，它将使我们的代码更加优雅和整洁。</p><p>作者： Dmitry Soshnikov<br>发表于：2014 年 8 月 21 日</p></div></article><div class="post-toc"><div id="post-catalog-text" data-catalog="Article Catalog"></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ES5-及更低版本的手动默认值"><span class="toc-text">1.ES5 及更低版本的手动默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ES6-默认值：基本实例"><span class="toc-text">2.ES6 默认值：基本实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-实现细节"><span class="toc-text">3.实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-执行阶段的重新计值"><span class="toc-text">3.1 执行阶段的重新计值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-外部作用域的遮蔽"><span class="toc-text">3.2 外部作用域的遮蔽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-参数的-TDZ-（暂时性死区）"><span class="toc-text">3.3 参数的 TDZ （暂时性死区）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-带条件的参数中间作用域"><span class="toc-text">3.4 带条件的参数中间作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-转译为-ES5"><span class="toc-text">3.4.1 转译为 ES5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-参数作用域的源由"><span class="toc-text">3.4.2 参数作用域的源由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-当参数作用域未创建的时候"><span class="toc-text">3.4.3 当参数作用域未创建的时候</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-undefined检查"><span class="toc-text">4.undefined检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-解构组件的默认值"><span class="toc-text">5. 解构组件的默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-结论"><span class="toc-text">6. 结论</span></a></li></ol></li></ol><div id="post-toTop-text" data-totop="To the Top"></div></div><div id="vcomments"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue/tree/master/PureBlue">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/code.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5c5ffe9669609061"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:150,height:300,vOffset:-120,hOffset:-5},mobile:{show:!1},react:{opacityDefault:1e3,opacityOnHover:1e3},log:!1})</script></body></html><!-- rebuild by neat -->