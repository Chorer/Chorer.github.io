<!-- build time:Tue Mar 17 2020 17:16:02 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">用 :key 管理可复用元素</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-09-28&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp4 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/Vue/">Vue</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-4.webp" alt=""><br><a id="more"></a></p><h2 id="input-中的-key"><a href="#input-中的-key" class="headerlink" title="input 中的 key"></a><code>input</code> 中的 <code>key</code></h2><p>我们先来看一个切换登录方式的例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"isUser"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>label<span class="token operator">></span>Login <span class="token keyword">with</span> account<span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> placeholder<span class="token operator">=</span><span class="token string">"Enter your account"</span><span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>label<span class="token operator">></span>Login <span class="token keyword">with</span> email<span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> placeholder<span class="token operator">=</span><span class="token string">"Enter your email"</span><span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>

<span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"isUser=!isUser"</span><span class="token operator">></span>click to toggle<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-4.png" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-6.png" alt=""></p><p>我们会发现，在点击按钮切换登录方式后，输入框中已有的内容<strong>没有被清除</strong>，这是为什么呢？</p><p>引用官方文档的原话：</p><blockquote><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。</p></blockquote><p>这里的 <code>input</code> 实际上复用了切换之前的 <code>input</code>。而类似 <code>&lt;input&gt;</code>，<code>&lt;select&gt;</code>，<code>&lt;textarea&gt;</code> 这样的表单元素都有一个 <code>internal state</code> 保存着元素的值，在元素复用时，这个值是会得到保留的。</p><p>如果我们希望切换的时候不保留这个值呢？我们可以给两个 <code>input</code> 添加不同的 <code>key</code>。因为 Vue 是将 <code>key</code> 作为唯一标识从而来识别复用的元素的，如果两个元素的 <code>key</code> 不同，那么就相当于告诉 Vue “这两个元素是完全独立的，你不能用其中一个来复用另一个”。</p><p>接着再来看一个利用 <code>v-for</code> 生成 <code>input</code> 的例子。<br>假如我们的代码为：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item,index) in array<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        {{item}}: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token punctuation">:</span><span class="token punctuation">{</span>
        array<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">,</span><span class="token string">"D"</span><span class="token punctuation">,</span><span class="token string">"E"</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后生成的 <code>input</code> 中我们填入字符串作为 <code>internal state</code>。如图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-1.png" alt=""></p><p>在没有使用 <code>key</code> 的情况下，我们通过 <code>app.array.splice(2,0,&quot;F&quot;)</code> 在 BC 之间插入 F，发现：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-2.png" alt=""></p><p>和之前一样，因为 Vue 采用的是 <code>就地复用</code> 策略，这意味着 ABCDE 在<strong>原地不动的情况下</strong>被复用了，CDE 都被重新渲染了一次，但先前的 <code>internal state</code> 仍然保留着。</p><p>出于性能考虑，有没有办法可以只移动个别元素，单独渲染要插入的那个新元素呢？有了前面的经验，我们会想到给每个 <code>input</code> 一个 <code>key</code> 值。</p><p>首先我们尝试将 <code>index</code> 作为 <code>key</code>，之后进行插入操作，发现：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-2.png" alt=""></p><p>问题依然存在。这是因为，我们将 <code>index</code> 作为复用的判断依据，相当于告诉 Vue：“只要这两个东西的 index 一样，就进行复用”。插入之前 C 的 index 是 2，插入之后 F 的 index 也是 2，于是 F 复用了 C，同理，DE 也被复用了，并因此重新渲染了一次。</p><p><code>index</code> 是会随着插入删除改变的值，所以它实际上并不适合作为 <code>key</code>。于是我们想：在进行插入或者删除操作的时候，有没有一种值始终不会改变呢？有的，我们可以给每个元素一个单独的 id。但更简单的方法是直接使用 <code>item</code>，即元素本身的值，毕竟这个值对每个元素来说也是独一无二的。</p><p>我们将 <code>item</code> 作为 <code>key</code> ，之后进行插入操作，发现：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-3.png" alt=""></p><p>这回正常了。可以很明显地看到，每个元素都复用了先前的对应元素，这是因为此时 <code>item</code> （即元素值）才是复用的判断依据，相当于告诉 Vue：“只要这两个东西的元素值一样，就进行复用”。例如对于 C 来说，它只会复用与自己的值一样的元素，显然这个元素就是 C 本身。同理，D 复用 D，E 复用 E，CDE 都不需要重新渲染了，只需要后移以方便 F 插入，这时候的性能显然要好很多。</p><h2 id="Virtual-DOM-的-Diff-算法"><a href="#Virtual-DOM-的-Diff-算法" class="headerlink" title="Virtual DOM 的 Diff 算法"></a>Virtual DOM 的 <code>Diff</code> 算法</h2><blockquote><p>下面大致从虚拟DOM的Diff算法实现的角度去解释一下。</p></blockquote><p>vue 和 react的虚拟 DOM 的 <code>Diff</code> 算法大致相同，其核心是基于两个简单的假设：</p><ul><li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。</li><li>同一层级的一组节点，他们可以通过唯一的id进行区分。基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。</li></ul><p>引用 <a href="https://calendar.perfplanet.com/2013/diff/" target="_blank" rel="noopener">React’s diff algorithm</a> 中的例子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-1.webp" alt=""></p><p>当某一层有很多相同的节点时，也就是列表节点时，Diff 算法的更新过程默认情况下也是遵循以上原则。 比如一下这个情况：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-2.webp" alt=""></p><p>我们希望可以在 B 和 C 之间加一个 F，Diff 算法默认执行起来是这样的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-3.webp" alt=""></p><p>即把 C 更新成 F，D 更新成 C，E 更新成 D，最后再插入 E，这样显然很没有效率。<br>所以我们需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-4.webp" alt=""></p><p>所以 key 的作用主要是为了高效的更新虚拟 DOM。</p><p>参考：<br><a href="https://stackoverflow.com/questions/44077320/what-is-the-use-of-track-by-or-key-in-v-for-in-vue-js" target="_blank" rel="noopener">https://stackoverflow.com/questions/44077320/what-is-the-use-of-track-by-or-key-in-v-for-in-vue-js</a><br><a href="https://juejin.im/post/5aae19aa6fb9a028d4445d1a#comment" target="_blank" rel="noopener">https://juejin.im/post/5aae19aa6fb9a028d4445d1a#comment</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/10/02/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" rel="prev" title="Vue 组件（一）：组件的基本使用"><i class="fa fa-angle-double-left"></i>&nbspVue 组件（一）：组件的基本使用</a></div><div class="post-nav-next"><a href="/2019/09/23/CB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2-2/" rel="next" title="数据结构与算法笔记 cp2-2：线性表">数据结构与算法笔记 cp2-2：线性表&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#input-中的-key"><span class="toc-text">input 中的 key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-DOM-的-Diff-算法"><span class="toc-text">Virtual DOM 的 Diff 算法</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->