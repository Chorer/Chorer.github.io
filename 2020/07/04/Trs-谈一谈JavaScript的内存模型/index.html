<!-- build time:Sun Sep 05 2021 14:32:51 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">谈一谈JavaScript的内存模型</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-04&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.7k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp9 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/0.jpeg"></div><span id="more"></span><blockquote><ul><li>原文地址：<a target="_blank" rel="noopener" href="https://medium.com/@ethannam/javascripts-memory-model-7c972cd2c239">JavaScript’s Memory Model</a></li><li>原文作者：<a href="/@ethannam?source=post_page-----7c972cd2c239----------------------">Ethan Nam</a></li><li>译者：Chor</li></ul></blockquote><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// 声明一些变量并进行初始化</span>
<span class="kw">var</span> a <span class="op">=</span> <span class="dv">5</span>
<span class="kw">let</span> b <span class="op">=</span> <span class="st">&#39;xy&#39;</span>
<span class="kw">const</span> c <span class="op">=</span> <span class="kw">true</span>

<span class="co">// 重新赋值</span>
a <span class="op">=</span> <span class="dv">6</span>
b <span class="op">=</span> b <span class="op">+</span> <span class="st">&#39;z&#39;</span>
c <span class="op">=</span> <span class="kw">false</span> <span class="co">// TypeError: Assignment to constant variable</span></code></pre></div><p>对我们程序员来说，声明变量、进行初始化和赋值几乎是每天都在做的一件事情。不过，这些操作本质上做了什么事情呢？JavaScript 是如何在内部对这些进行处理的？更重要的是，了解 JavaScript 的底层细节对我们程序员有什么好处？</p><p>本文的大纲如下：</p><ol style="list-style-type:decimal"><li>JS 基本类型的变量声明和赋值</li><li>JS 的内存模型：调用栈和堆</li><li>JS 引用类型的变量声明和赋值</li><li>Let vs const</li></ol><hr><h1 id="js-基本类型的变量声明和赋值">JS 基本类型的变量声明和赋值</h1><p>我们先从一个简单的例子讲起：声明一个名为 <code>muNumber</code> 的变量，并初始化赋值为 23。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> myNumber <span class="op">=</span> <span class="dv">23</span></code></pre></div><p>当执行这一行代码的时候，JS 将会 ......</p><ol style="list-style-type:decimal"><li>为变量创建一个唯一的标识符（ <code>myNumber</code> ）</li><li>在栈内存中分配一块空间（将在运行时完成分配）</li><li>将值 23 保存在这个分配出去的空间中</li></ol><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1.jpeg"></div><p>我们习惯的说法是“<code>myNumber</code> 等于23”，但更严谨的说法应该是，<code>myNumber</code> 等于保存着值 23 的那个内存空间的地址。这两者的区别很关键，需要搞清楚。</p><p>如果我们创建一个新变量 <code>newVar</code> 并将 <code>myNumber</code> 赋值给它 ......</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> newVar <span class="op">=</span> myNumber</code></pre></div><p>...... 由于 <code>myNumber</code> 实际上等于内存地址 “0012CCGWH80”，因此这一操作会使得 <code>newVar</code> 也等于 “0012CCGWH80”，也就是等于保存着值 23 的那个内存地址。最终，我们可能会习惯说“<code>newVar</code> 现在等于 23 了”。</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.jpeg"></div><p>那么，如果我这样做会发生什么呢？</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">myNumber <span class="op">=</span> myNumber <span class="op">+</span> <span class="dv">1</span></code></pre></div><p><code>myNumber</code> 自然会“等于” 24，不过 <code>newVar</code> 和 <code>myNumber</code> 指向的可是同一块内存空间啊，<code>newVar</code> 是否也会“等于” 24 呢？</p><p>并不会。在 JS 中，基本数据类型是<strong>不可改变的</strong>，在 “myNumber + 1” 被解析为 “24” 的时候，JS 实际上将会在内存中重新分配一块新的空间用于存放 24 这个值，而 <code>myNumber</code> 将会转而指向这个新的内存空间的地址。</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3.jpeg"></div><p>再看一个类型的例子：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> myString <span class="op">=</span> <span class="st">&#39;abc&#39;</span>  
myString <span class="op">=</span> myString <span class="op">+</span> <span class="st">&#39;d&#39;</span></code></pre></div><p>JS 初学者可能会认为，无论字符串 <code>abc</code> 存放在内存的哪个地方，这个操作都会将字符 <code>d</code> 拼接在字符串后面。这种想法是错误的。别忘了，在 JS 中字符串也是基本类型。当 <code>abc</code> 与 <code>d</code> 拼接的时候，在内存中会重新分配一块新的空间用于存放 <code>abcd</code> 这个字符串，而 <code>myString</code> 将会转而指向这个新的内存空间的地址（同时，<code>abc</code> 依然位于原先的内存空间中）。</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/4.jpeg"></div><p>接下来我们看一下基本类型的内存分配发生在哪里。</p><hr><h1 id="js-的内存模型调用栈和堆">JS 的内存模型：调用栈和堆</h1><p>简单理解，可以认为 JS 的内存模型包含两个不同的区域，一个是调用栈，一个是堆。</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/5.jpeg"></div><p>除了函数调用之外，调用栈同时也用于存放基本类型的数据。以上一小节的代码为例，在声明变量后，调用栈可以粗略表示如下图：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/6.jpeg"></div><p>在上面这张图中，我对内存地址进行了抽象，以显示每个变量的值，但请记住，（正如之前所说的）变量始终指向某一块保存着某个值的内存空间。这是理解 let vs const 这一小节的关键。</p><p>再来看一下堆。</p><p>堆是引用类型变量存放的地方。堆相对于栈的一个关键区别就在于，堆可以存放动态增长的无序数据 —— 尤其是数组和对象。</p><hr><h1 id="js-引用类型的变量声明和赋值">JS 引用类型的变量声明和赋值</h1><p>在变量声明与赋值这方面，引用类型变量与基本类型变量的行为表现有很大的差异。</p><p>我们同样从一个简单的例子讲起。下面声明一个名为 <code>myArray</code> 的变量并初始化为一个空数组：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> myArray <span class="op">=</span> []</code></pre></div><p>当你声明一个变量 <code>myArray</code> 并通过引用类型数据（比如 <code>[]</code>）为它赋值的时候，在内存中的操作是这样的：</p><ol style="list-style-type:decimal"><li>为变量创建一个唯一的标识符（<code>myArray</code>）</li><li>在堆内存中分配一块空间（将在运行时完成分配）</li><li>这个空间存放着此前所赋的值（空数组 <code>[]</code>）</li><li>在栈内存中分配一块空间</li><li>这个空间存放着指向被分配的堆空间的地址</li></ol><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/7.jpeg"></div><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/8.jpeg"></div><p>我们可以对 <code>myArray</code> 进行各种数组操作：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">myArray</span>.<span class="at">push</span>(<span class="st">&quot;first&quot;</span>)  
<span class="va">myArray</span>.<span class="at">push</span>(<span class="st">&quot;second&quot;</span>)  
<span class="va">myArray</span>.<span class="at">push</span>(<span class="st">&quot;third&quot;</span>)  
<span class="va">myArray</span>.<span class="at">push</span>(<span class="st">&quot;fourth&quot;</span>)  
<span class="va">myArray</span>.<span class="at">pop</span>()</code></pre></div><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/9.jpeg"></div><hr><h1 id="let-vs-const">Let vs const</h1><p>通常来讲，我们应该尽可能多地使用 <code>const</code>，并且只在确定变量会<strong>改变</strong>之后才使用 <code>let</code>。</p><p>重点来了，注意这里的<strong>改变</strong>究竟指的是什么意思。</p><p>很多人会错误地认为，这里的“改变”指的是值的改变，并且可能试图用类似下面的代码进行解释：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> sum <span class="op">=</span> <span class="dv">0</span>  
sum <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span> <span class="op">+</span> <span class="dv">5</span>

<span class="kw">let</span> numbers <span class="op">=</span> []  
<span class="va">numbers</span>.<span class="at">push</span>(<span class="dv">1</span>)  
<span class="va">numbers</span>.<span class="at">push</span>(<span class="dv">2</span>)  
<span class="va">numbers</span>.<span class="at">push</span>(<span class="dv">3</span>)  
<span class="va">numbers</span>.<span class="at">push</span>(<span class="dv">4</span>)  
<span class="va">numbers</span>.<span class="at">push</span>(<span class="dv">5</span>)</code></pre></div><p>是的，用 <code>let</code> 声明 <code>sum</code> 变量是正确的，毕竟 <code>sum</code> 变量的值确实会改变；不过，用 <code>let</code> 声明 <code>numbers</code> 是错误的。而错误的根源在于，这些人认为往数组中添加元素是在改变它的值。</p><p><strong>所谓的“改变”，实际上指的是内存地址的改变</strong>。<code>let</code> 声明的变量允许我们修改内存地址，而 <code>const</code> 则不允许。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> importantID <span class="op">=</span> <span class="dv">489</span>  
importantID <span class="op">=</span> <span class="dv">100</span> <span class="co">// TypeError: Assignment to constant variable</span></code></pre></div><p>我们研究一下这里为什么会报错。</p><p>当声明 <code>importantID</code> 变量之后，某一块内存空间被分配出去，用于存放 489 这个值。牢记我们之前所说的，变量 <code>importantID</code> 从来只等于某一个内存地址。</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/10.jpeg"></div><p>当把 100 赋值给 <code>importantID</code> 的时候，由于 100 是基本类型的值，内存中会分配一块新的空间用于存放 100。之后，JS 试图将这块新空间的地址赋值给 <code>importantID</code>，此时就会报错。这其实正是我们期望的结果，因为我们根本就不想对这个非常重要的 ID 进行改动 .......</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/11.jpeg"></div><p>这样就说得通了，用 <code>let</code> 声明数组是错误的（不合适的），应该用 <code>const</code> 才行。这对初学者来说确实比较困惑，毕竟这完全不符合直觉啊！初学者会认为，既然是数组肯定需要有所改动，而 <code>const</code> 声明的常量明明是不可改动的啊，那为何还要用 <code>const</code> ？不过，你必须得记住：所谓的“改变”指的是内存地址的改变。我们再来深入理解一下，为什么在这里使用 <code>const</code> 完全没问题，并且绝对是更好的选择。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> myArray <span class="op">=</span> []</code></pre></div><p>在声明 <code>myArray</code> 之后，调用栈会分配一块内存空间，它所存放的值是指向堆中某个被分配内存空间的地址。而堆中的这个空间才是实际上存放空数组的地方。看下面的图理解一下：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/12.jpeg"></div><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/13.jpeg"></div><p>如果我们进行这些操作：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">myArray</span>.<span class="at">push</span>(<span class="dv">1</span>)  
<span class="va">myArray</span>.<span class="at">push</span>(<span class="dv">2</span>)  
<span class="va">myArray</span>.<span class="at">push</span>(<span class="dv">3</span>)  
<span class="va">myArray</span>.<span class="at">push</span>(<span class="dv">4</span>)  
<span class="va">myArray</span>.<span class="at">push</span>(<span class="dv">5</span>)</code></pre></div><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/14.jpeg"></div><p>这将会往堆中的数组添加元素。不过，<strong><code>myArray</code> 的内存地址可是至始至终都没改变的</strong>。这也就解释了为什么 <code>myArray</code> 是用 <code>const</code> 声明的，但是对它（数组）的修改却不会报错。因为，<code>myArray</code> 始终等于内存地址 “0458AFCZX91”，该地址指向的空间存放着另一个内存地址 “22VVCX011”，而这第二个地址指向的空间则真正存放着堆中的数组。</p><p>如果我们这么做，则会报错：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">myArray <span class="op">=</span> <span class="dv">3</span></code></pre></div><p>因为 3 是基本类型的值，这么做会在内存中分配一块新的空间用于存放 3，同时会修改 <code>myArray</code> 的值，使其等于这块新空间的地址。而由于 <code>myArray</code> 是用 <code>const</code> 声明的，这样修改就必然会报错。</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/15.jpeg"></div><p>下面这样做同样会报错：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">myArray <span class="op">=</span> [<span class="st">&#39;a&#39;</span>]</code></pre></div><p>由于 <code>[‘a’]</code> 是一个新的引用类型的数组，因此在栈中会分配一块新的空间来存放堆中的某个空间地址，堆中这块空间则用于存放<code>[‘a’]</code> 。之后我们试图把新的内存地址赋值给 <code>myArray</code>，这样显然也是会报错的。</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/JavaScript%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/16.jpeg"></div><p>对于用 <code>const</code> 声明的对象，它和数组的表现也是一样的。因为对象也是引用类型的数据，可以添加键，更新值，诸如此类。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> myObj <span class="op">=</span> <span class="op">&#123;&#125;</span>  
myObj[<span class="st">&#39;newKey&#39;</span>] <span class="op">=</span> <span class="st">&#39;someValue&#39;</span> <span class="co">// this will not throw an error</span></code></pre></div><h1 id="知道这些有什么用"><strong>知道这些有什么用？</strong></h1><p><a target="_blank" rel="noopener" href="https://github.blog/2018-11-15-state-of-the-octoverse-top-programming-languages/">GitHub</a> 和 <a target="_blank" rel="noopener" href="https://insights.stackoverflow.com/survey/2018/">Stack Overflow 年度开发者调查报告</a>) 的相关数据显示，JavaScript 是排名第一的语言。精通这门语言并成为一名“JS 大师”可能是我们梦寐以求的。在任何一门像样的 JS 课程或者一本书中，都会倡导我们多使用 <code>const</code> 和 <code>let</code>，少使用 <code>var</code>，但他们基本上都没有解释这其中的缘由。很多初学者会疑惑为什么有些用 <code>const</code> 声明的变量在“修改”的时候确实会报错，而有些变量却不会。我能够理解，正是这种反直觉的体验让他们更喜欢随处都使用 <code>let</code>，毕竟谁也不想踩坑嘛。</p><p>不过，这并不是我们推荐的方式。Google 作为一家拥有顶尖程序员的公司，它的 JavaScript 风格指南中就有这么一段话：用 <code>const</code> 或者 <code>let</code> 声明所有的局部变量。除非一个变量有重新赋值的需要，否则默认使用 <code>const</code> 进行声明。绝不允许使用 <code>var</code>关键字 (<a target="_blank" rel="noopener" href="https://google.github.io/styleguide/jsguide.html#features-use-const-and-let">来源</a>)。</p><p>虽然他们没有指出个中缘由，不过我认为有下面这些理由：</p><ol style="list-style-type:decimal"><li>预先避免将来可能产生的 bug</li><li>用 <code>const</code> 声明的变量在声明的时候就必须进行初始化，这会引导开发者关注这些变量在作用域中的表现，最终有助于促进更好的内存管理与性能表现。</li><li>带来更好的可读性，任何接管代码的人都能知道，哪些变量是不可修改的（就 JS 而言），哪些变量是可以重新赋值的。</li></ol><p>希望本文能够帮助你理解使用 <code>const</code> 或者 <code>let</code> 声明变量的个中缘由以及应用场景。</p><p><strong>参考：</strong></p><ol style="list-style-type:decimal"><li><a target="_blank" rel="noopener" href="https://google.github.io/styleguide/jsguide.html">Google JS Style Guide</a></li><li><a target="_blank" rel="noopener" href="https://blog.bitsrc.io/master-javascript-call-by-sharing-parameter-passing-7049d65163ed">Learning JavaScript: Call By Sharing, Parameter Passing</a></li><li><a target="_blank" rel="noopener" href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec">How JavaScript works: memory management + how to handle 4 common memory leaks</a></li></ol></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/07/11/F-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9A%84%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/" rel="prev" title="记一次小程序开发的踩坑之旅"><i class="fa fa-angle-double-left"></i>&nbsp记一次小程序开发的踩坑之旅</a></div><div class="post-nav-next"><a href="/2020/06/29/F-%E6%89%93%E5%BC%80Devtools%E5%89%8D%E5%90%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/" rel="next" title="打开DevTools前后，对象的打印有什么区别？">打开DevTools前后，对象的打印有什么区别？&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">JS 基本类型的变量声明和赋值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8%E6%A0%88%E5%92%8C%E5%A0%86"><span class="toc-text">JS 的内存模型：调用栈和堆</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">JS 引用类型的变量声明和赋值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#let-vs-const"><span class="toc-text">Let vs const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-text">知道这些有什么用？</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->