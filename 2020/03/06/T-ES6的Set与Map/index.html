<!-- build time:Sun Jul 05 2020 15:10:09 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">ES6的Set与Map</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-03-06&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.9k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/ES6/">ES6</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/ES6%E7%9A%84Set%E4%B8%8EMap/ES6%E7%9A%84Set%E4%B8%8EMap-0.jpg" alt=""></p><a id="more"></a><h3 id="Set-和-Map-出现之前"><a href="#Set-和-Map-出现之前" class="headerlink" title="Set 和 Map 出现之前"></a>Set 和 Map 出现之前</h3><p>在 ES5 中经常用对象来模拟实现 Set 集合与 Map 集合这两种数据结构，但这种做法带来了一些问题：比如利用 <code>if(obj.size)</code> 检查集合中是否存在某个元素的时候，预期行为是只要存在 <code>size</code> 就能通过 if 判断，但如果 <code>size = 0</code>，那么也无法继续执行，即使此时元素是存在的。另外，对象的键名只能是字符串，非字符串类型的键名也会通过 <code>toString()</code> 方法被转换成字符串，这意味着 <code>obj[5]</code> 与 <code>obj[&#39;5&#39;]</code> 没有区别，尽管我们本意是想创建两个不同的键；甚至，当键名是对象的时候，不管我们操作的是哪个键名（<code>obj[key1]</code> 或者 <code>obj[key2]</code>），实际操作的都是 <code>obj[&#39;[object Object]&#39;]</code>，这是因为对象会被转换成字符串 <code>&#39;[object Object]&#39;</code>，这些都是与我们的预期不符合的。因此，ES6 推出了正式的 Set 和 Map 集合。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>调用 <code>new Set()</code> 可以创建一个 Set 集合，之后通过 <code>add()</code> 添加元素，<code>size</code> 访问元素数量。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">.</span>size    <span class="token comment" spellcheck="true">// 2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>与 ES5 中对象模拟实现不同的是，Set 集合会对添加进来的元素调用 <code>Object.is()</code> 检查是否一致，由于 <code>5</code> 与 <code>&#39;5&#39;</code> 是不同的，所以 Set 可以同时存在这两个元素，不会发生类型转换（<strong>唯一的例外是 <code>+0</code> 和 <code>-0</code>，尽管 <code>Object.is(+0,-0)</code> 返回 <code>false</code>，但是 Set 集合认为这两个是一致的</strong>）；同理，也可以添加多个独立对象，它们是不会被转换成字符串的。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> key1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> key2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key1<span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key2<span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">.</span>size  <span class="token comment" spellcheck="true">// 4</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以用 <code>has()</code> 检测是否存在某个元素，用 <code>delete()</code> 移除指定元素，用 <code>clear()</code> 清空整个 Set 集合。</p><p>另外，创建 Set 集合的时候支持传参，我们可以使用像数组这样的可迭代对象来初始化 Set 集合（这也是<strong>将数组转换成 Set 集合</strong>的方法）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">.</span>size  <span class="token comment" spellcheck="true">// 4</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong>：Set 集合为了保证集合元素唯一，会对数组进行元素过滤，这一点稍后可以用来进行数组去重。</p><p>那么如何访问集合元素呢？由于 Set 集合没有键名，所以不可能像数组那样通过数值型索引值去访问某个元素，要访问 Set 集合的元素，我们需要先将<strong>集合转换成数组</strong>。这个使用展开运算符 <code>...</code> 来实现：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> <span class="token keyword">set</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">set</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">set</span><span class="token punctuation">]</span>
array   <span class="token comment" spellcheck="true">// [1,2]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组转换成集合+集合转换成数组，就可以实现数组去重：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> anotherArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">// [1,2,3,4,5,6]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此外，可以用 <code>forEach()</code> 来迭代 Set 集合中的元素，该方法的回调函数接受三个参数：<code>value</code>，<code>key</code> 以及集合本身。虽然 Set 没有 <code>key</code> 键名，但为了与数组和 <code>Map</code> 的 <code>forEach()</code> 保持一致，依然提供了 <code>key</code> 参数，它的值与 <code>value</code> 是一样的。</p><h3 id="Weak-Set"><a href="#Weak-Set" class="headerlink" title="Weak Set"></a>Weak Set</h3><p>上面的 Set 是一个强引用的集合，这指的是，如果集合中存储着对象的引用（<code>set.add(obj)</code>），那么即使我们已经在集合外面清除了对该对象的引用（<code>obj = null</code>），集合中的引用也不受影响。为了避免造成内存泄漏，我们需要一种弱引用的集合，也就是 Weak Set。</p><p>Weak Set 只存储对象的弱引用，所以如果把集合外面对象的最后一个强引用移除，则 Weak Set 中的引用也不复存在，这样就避免了内存泄露的情况。此外，它还有一些特点：</p><ul><li>不可以存储原始值，否则报错</li><li>不可迭代，所以不能使用 <code>forEach()</code>，<code>clear()</code></li><li>不支持 <code>size</code> 属性</li><li>不暴露诸如 <code>keys()</code>，<code>values()</code> 等迭代器</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>相比 Set，Map 存储的是多对键值对，并且键名和键值支持所有的数据类型。</p><p>调用 <code>new Map()</code> 可以创建一个 Map 集合，之后通过 <code>map.set(key,value)</code> 添加键值对，<code>map.get(key)</code> 访问指定键名的键值。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'Jack'</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">'I am object'</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 不同于对象，在 Map 中键名可以是对象</span>
map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 'Jack'</span>
map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 'I am object'</span>
map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'unexisted key'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 访问不存在的键，返回 undefined</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Map 同样也有 <code>has(key)</code>，<code>delete(key)</code>，<code>clear()</code>，<code>size</code> （返回键值对对数）等方法和属性。</p><p>另外，可以使用数组来初始化 Map 集合，批量添加元素。由于 Map 中的元素是键值对，所以传入的数组的元素也是数组：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span>  map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'Jack'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 'Jack'</span>
map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 12</span>
map<span class="token punctuation">.</span>size          <span class="token comment" spellcheck="true">// 2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Map 的 <code>forEach()</code> 方法的回调函数也接受三个参数：<code>value</code>，<code>key</code> 以及集合本身，这和数组更为接近，只不过数组对应的第二个参数是数值型索引值。</p><h3 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h3><p>类似的，Map 也有弱引用集合 Weak Map。Weak Map 的<strong>键名必须是对象</strong>，且保存着对象的弱引用（如果集合外面引用被清除，则集合中的引用也不复存在，且键值对会跟着被移除）；<strong>键值则不一定是对象</strong>，且当键值是对象时，它保存的依然是强引用。也就是说，Weak Map 的弱引用是针对键名来说的。</p><p>Weak Map 可以用来跟踪对象的引用，进而确保将来某一刻需要清除的对象的内存一定能够得到释放，不发生潜在的内存泄露。</p><p>举例来说，现在有一个 DOM 元素，它接受用户的输入并将输入的信息存储在一个对象中，如果没有使用 Weak Map ，那么维系 <strong>DOM 对象</strong> 与 <strong>输入信息对象</strong> 的映射关系时就有可能产生一个新的关于 DOM 对象的强引用，而在之后清除 DOM 对象原先的强引用时，该强引用可能不会被清除，这导致对象内存实际没有得到释放。但是，如果使用了 Weak Map，将 DOM 对象作为键名，输入信息对象作为键值，那么由于 Weak Map 存储的是对象的弱引用，此时就一定能保证 DOM 对象被移除后（且集合外围对象的最后一个强引用被清除），其内存能够得到释放，不会发生内存泄露的问题。</p><p>此外，Weak Map 也可以用来存储对象实例的私有变量：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> Person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> privateData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        privateData<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span>name<span class="token punctuation">,</span>age<span class="token punctuation">:</span>age<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> privateData<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
    <span class="token punctuation">}</span>
    Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getAge <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> privateData<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span>age
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的这段代码中，存在着一个 Weak Map（privateData）用来维系多个实例与自身私有变量的映射关系。每次创建新实例的时候，都会往 privateData 这个集合中添加新的”映射条目“（<code>privateData.set(this,{name:name,age:age})</code>，其中，<code>this</code> 指的是实例），键名是实例，键值是存储私有变量的对象。这么一来，当未来某一天删除实例的时候，由于集合外围的实例对象的强引用被移除，Weak Map 存储的又是实例对象的弱引用，所以保证了实弱引用也会被垃圾回收，不存在内存泄漏的问题。简而言之，只要实例被销毁，相关信息也会跟着销毁，这样就保证了信息的私有性。</p><p>此外，Weak Map 还有一些特点：</p><ul><li>不支持 <code>size</code> 属性</li><li>不可迭代，因此不支持 <code>forEach()</code> 和 <code>clear()</code></li></ul></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/03/08/F-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%20vue-awesome-swiper%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" rel="prev" title="在项目中使用 vue-awesome-swiper 遇到的问题"><i class="fa fa-angle-double-left"></i>&nbsp在项目中使用 vue-awesome-swiper 遇到的问题</a></div><div class="post-nav-next"><a href="/2020/02/14/F-Chrome%20%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E7%AE%80%E8%AE%B0/" rel="next" title="Chrome 调试技巧简记">Chrome 调试技巧简记&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-和-Map-出现之前"><span class="toc-text">Set 和 Map 出现之前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Weak-Set"><span class="toc-text">Weak Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Weak-Map"><span class="toc-text">Weak Map</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2020</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->