<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【数据类型】null和undefined]]></title>
    <url>%2F2019%2F02%2F10%2Fnull%E5%92%8Cundefined%2F</url>
    <content type="text"><![CDATA[一. undefined在变量声明中的体现：1）声明了、但是没有初始化的变量： var aa; alert(aa); 浏览器会弹出窗口显示 undefined。因为对于使用了 var 声明但没有进行初始化定义的变量, 其值默认为 undefined.2） 未声明的变量(1)： alert(aa); 浏览器不会弹出任何东西. 因为 aa 是没有声明的变量。打开 chrome 浏览器的控制台会看到报错如下： 3）未声明的变量(2)： alert(typeof aa); 浏览器会弹出窗口显示 undefined。对于没有声明的变量, 只能执行一种操作，即使用 typeof 操作符检验它的类型.。它的类型和声明了但没有进行初始化的变量的类型一样, 都是 undefined. 二. null和undefined：alert(undefined == null); // 返回 true 对于undefined 和null 的相等性测试，返回 true,如上图。这是因为，undefined是由null派生而来的。但是，这两者差别很大，之所以要设置两个值，让我们从历史原因说起吧1）历史原因：1995年js诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象；其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。因此，Brendan Eich又额外设计了一个undefined。 2）最初设计：JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 Number(undefined) // NaN 5 + undefined // NaN 3）目前的用法：但是，上面这样的区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。 ①null null是基本数据类型之一，值仅有一个，即为null。表示”空对象”(因此类型检测返回对象)，即如果有对象，就会是一个具体的对象，如果没对象，就是null。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 Object.getPrototypeOf(Object.prototype) // null typeof null // object 如果定义的变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子： if(abc != null){ //对abc执行某些操作 } ②undefined undefined是基本数据类型之一，值仅有一个，即为undefined。表示”缺少值”(因此类型检测返回undefined)，即此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。 var i; i // undefined function f(x){console.log(x)}f() // undefined var o = new Object(); o.p // undefined var x = f(); var exp = undefined; 8x // undefined ③如何检测某个变量是undefined： 错误的用法：if(abc==undefined) // 正如上面所说，js规定用== 判断时，null和undefined是等同的 正确的用法： if (typeof(abc) `==` &quot;undefined&quot;) 或者最简单的办法： if(abc===undefined) 注意！！！ type的用法有运算符形式和函数形式，即if (typeof(abc) == “undefined”) 和 if (typeof abc == “undefined”) 效果是一样的。另外，由于typeof会返回诸如”number”的字符串形式的结果，因此==的右操作数应注意加双引号表示字符串。 ④如何检测某个变量是null： 错误的用法： 1、if(abc == null)// 解释同上。不过：要判断abc是 null 或者 undefined 时可使用本法。2、if ( !abc)// 这个的原理是：abc为假值，则 ! abc为真值，条件成立。然而，假值也可能是undefined，0 或 false。不过：要判断 abc是null、undefined、0 或者false 时可使用本法。 3、if(typeof abc == &quot;null&quot;) // 为了向下兼容，abc 为 null 时，typeof null 总返回 object，所以不能这样判断。 4、 if ( isNull (abc) ) // VBScript 中有 IsNull 这个函数，但 JavaScript 中没有。 ============================================================================= 正确的方法：1、 if (! abc &amp;&amp; typeof abc != &quot;undefined&quot; &amp;&amp; abc != 0) // 这个的原理是：如果！abc 成立，则 abc 为假值，则 abc 要么是undefined，0，false或者null 。typeof abc!= “undefined” 排除了 undefined；exp != 0 排除了0 和 false （0= =false，0= =0）。所以，abc一定是剩下的null。 2、最简单的方法： if (abc=== null) 尽管如此，我们在 DOM 应用中，一般只需要用 (! abc) 来判断就可以了，因为 DOM 应用中，可能返回 null，可能返回 undefined，如果具体判断 null 还是 undefined 会使程序过于复杂。 三. 测试对象是否存在：在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法。对象只有被定义才有可能为 null，否则为 undefined。因此，如果我们想测试对象是否存在，必须先检测对象是否已定义。因此，这是错误的：if (abc !== null &amp;&amp; typeof abc !== “undefined”)这是正确的： if (typeof abc !== &quot;undefined&quot; &amp;&amp; abc!== null)]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github pages部署个人博客网站的感想]]></title>
    <url>%2F2019%2F02%2F10%2Fhexo%2Bgithub%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[题外话：之前我习惯用印象笔记进行知识的剪藏和整理，但是印象笔记本身带给我一种相对封闭的感觉，更像是比较私人的产品；而博客则相反，它更多是面向大众的、开放的，有利于个人经验的输出和知识的共享，所以拥有自己的博客非常有必要。拿博客园和CSDN来说，这两者虽然可以满足写博客的需求，但是自定义程度不够高，缺少一些个性tag。既然如此，为什么我们不自己搭建一个个人博客网站呢？ 用hexo+github pages 搭建个人博客网站是极其方便的，不需要购买域名和服务器，只需要按部就班操作，就可以在短时间内成功拥有自己的一个网站。我自己大概是花了两三个小时搞定，主要是因为对git bash的使用不够熟悉，因此走了一些弯路。实际上动作快的话半个小时就可以搞定。下面是对部署过程的大概介绍，以及必须注意的事项（划重点，也就是所谓的“坑”）。由于本文参考了大量博客，所以在文末我会列出原文链接。 一.Github，Github pages ，Hexo首先介绍一下这三个东西，有大概的了解、知道是什么东西就可以。GitHub是一个面向开源及私有软件项目的托管平台，而GIthub Pages则是github的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，现在大多用来开发和制作个人博客网站。它的好处在于域名和服务器都是免费提供的，并且没有网站数量的限制。而Hexo 是一个快速、简洁且高效的博客框架，它使用Markdown解析文章，在几秒内，就可以利用靓丽的主题生成静态网页。（关于Hexo的详细介绍，请看官方文档 https://hexo.io/zh-cn/docs/ ，这里就不展开了）。因此，可以说github和hexo是绝配。接下来，开始我们的工作。 二. 环境和必要准备我个人的环境：win10，64bit必要准备：你需要（1）github账号 ：前往https://github.com/ 官网注册就好（2）git 2.20.1 ： 即最新版本的git，前往https://git-scm.com/ 官网下载并安装。安装完后前往git文件夹下打开git bash，运行以下命令： git config –global user.name “username” git config –global user.email “your mail” 注：将username替换为自己的github账号名，将your mail替换为自己注册github时绑定的邮箱。这一步非常重要，当时部署的时候我因为遗漏了这一步，导致后面报错. （3）node.js ： 前往 https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi 下载并安装。这两个的安装比较简单，一路next就好，不过我推荐还是修改一下路径，尽量放在自己可以找到的位置。（4）hexo ：打开git文件夹下的git bash，运行 以下命令 npm install -g hexo-cli，安装hexo。之后，依次运行以下命令进行hexo的初始化 $ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 注：请将上面代码的&lt;folder&gt;替换成你自己想要的文件夹名字，以我为例，我想要在git文件夹下新建一个Myblog文件夹以存放站点文件，那么我这里的代码就应该是 $ hexo init Myblog $ cd Myblog $ npm install 成功之后，我们会在git文件夹下看到新建的Myblog文件夹，里面存放了大量文件。好了，到了这一步，请把git bash关闭，并进入你的站点文件夹里（例如：Myblog文件夹里），右键选择git bash here。如图：这样，我们会在站点目录下重新打开git bash。你可能会疑惑，这和直接去git文件夹下打开git bash有区别吗？有！！区别非常大，在站点目录下打开git bash才可以找到运行命令所需要的环境。所以这里一定要记住，在之后介绍的操作中，凡是需要输入命令的，我们都是像上图这样先打开git bash再输入。 按照上面所说的，我们右键打开git bash，并运行以下代码： 1hexo server 这将在本地打开我们的网站，当提示”xxx is running at xxx“的时候，我们可以通过http://localhost:4000/ 这个网址预览我们的网站，想要切断连接，只需要在命令行窗口按下ctrl+c。至此，hexo博客已经在本地搭建好了。接下来，我们要将hexo和github进行对接。 三. hexo与github 实现对接1.建立仓库 还记得我们之前注册的github账号吗？现在，请进入github网站，并点击头像选择your repository，我们现在需要创建一个仓库（也就是repository）用于存放相关站点文件。按照下图顺序进行设置：其中，Repository name也即是我们的仓库名字，必须是 Github账号名称.github.io的格式。比如你的github名字是ccc，那么仓库名字必须是ccc.github.io 。 2.对接github 在git bash中运行以下命令，安装 hexo-deployer-git 插件。 1npm install hexo-deployer-git --save 运行以下命令，创建SSH key。（注：和上面一样，请将your mail替换成github邮箱地址） $ ssh-keygen -t rsa -C &quot;your mail&quot; 前往 C:\Users\Administrator.ssh\id_rsa.pub （注意，这只是大概位置。不同系统路径可能不同，但是大同小异）打开id_rsa.pub文件（可以用记事本打开，但是推荐用sublime text）。复制文件中的全部内容，前往 https://github.com/settings/keys ，将刚才复制的内容粘贴在New SSH key 的文本框中。 前往站点目录下（例如：git/ Myblog），打开_config.yml 文件，对文件末尾进行如下修改： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 在这里要注意，1）所有的冒号距离右边的内容之间都有一个空格，如果没有空格，则修改是无效的。2）和前面一样，将usename替换成我们自己的github用户名 。 3）repo后面的地址，在旧版本的hexo中是http地址，但在新版本的hexo用的是ssh地址，我们统一用如上所示的ssh地址。有些博客由于没有进行更新，在说明这个问题的时候依然用的是http地址，造成了一定程度上的误导。 运行以下命令，对接并推送内容到github。 $ hexo g $ hexo d 等待片刻，打开 https://&lt;Github账号名称&gt;.github.io （例如 https://ccc.github.io ) 即可进入你搭建好的个人博客网站了！当然，网站默认用的是landscape主题，比较难看，关于主题的美化和后期一些插件的添加，可以参考文章末尾贴出的链接。 PS： 这里顺便介绍一下常用的 hexo 命令：hexo clean ————————&gt;清除缓存文件和已生成的静态文件hexo g 或者 hexo generate ————————&gt;生成静态文件 hexo d 或者hexo deploy ————————&gt;生成静态文件并部署到仓库 hexo s 或者 hexo server —————————&gt;在本地打开网站 一般来说，在对网站进行修改后，我们可以先用hexo g和hexo s 在本地预览效果，如果效果符合预期的话再用hexo d 推送到 github。当然，可能会遇到本地打开和域名打开的效果不一致，这种情况下通常是因为 1. 没有用hexo clean 清除缓存 2. 没有对浏览器用ctrl+f5 清除缓存 3.忘记用hexo d 将本地文件推送到github 4. 本地和线上的同步本身需要时间，所以上述方法如果无效，可以尝试等几分钟，再打开网站就正常显示了。 参考自：https://www.jianshu.com/p/3a05351a37dchttps://www.simon96.online/2018/10/12/hexo-tutorial/]]></content>
      <categories>
        <category>心得和感想</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>网站搭建</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery AJAX load()方法中代码执行顺序的问题]]></title>
    <url>%2F2019%2F02%2F10%2FjQuery%20AJAX%20load()%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题来源于菜鸟教程介绍jq load() 方法时用的一个实例：js：12345678$(&quot;button&quot;).click(function()&#123; $(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr)&#123; if(statusTxt==&quot;success&quot;) alert(&quot;外部内容加载成功!&quot;); if(statusTxt==&quot;error&quot;) alert(&quot;Error: &quot;+xhr.status+&quot;: &quot;+xhr.statusText); &#125;);&#125;); html：12&lt;div id=&quot;div1&quot;&gt;&lt;h2&gt;使用 jQuery AJAX 修改该文本&lt;/h2&gt;&lt;/div&gt;&lt;button&gt;获取外部内容&lt;/button&gt; 这里作为load方法参数的函数是一个回调函数。什么是回调函数呢？我们先来看看回调的英文定义： A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。字面上的理解，回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。那么根据这个解释，这段代码应该是先执行load(“demo_test.txt”) 加载外部内容，之后再执行回调函数弹出alert。但是实际运行后发现和预想的不一样：从结果来看，是先弹出alert再改变文本内容。那么，为什么会这样呢？难道上面的说法有误？为了进一步验证，修改代码如下： $(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){ alert(responseTxt); if(statusTxt==&quot;success&quot;){ 运行：很明显文本内容已经改变，说明前面关于回调函数最后执行的说法是没问题的。接着猜想，之所以先弹出alert再改变文本内容，可能是因为必须等回调函数执行完后才能把文本渲染到浏览器上。为了进一步验证，修改代码如下： 12345$(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr)&#123; if(statusTxt==&quot;success&quot;)&#123; debugger； console.log(&quot;1&quot;); &#125; 运行：控制台中没有打印出1，且程序中断，说明此时回调函数还在执行当中，但是文本内容却已经改变了。这说明上面的猜想错误—–即文本渲染到浏览器上不需要等到回调函数执行结束。但是，那只是一般情况！！问题就在于，alert是可以阻塞浏览器的渲染工作的！ 重新运行最初的代码，可以看到还是先弹出alert，文本没变，但是这时候点开控制台的elements，可以看到图中红框显示这时候文本的内容其实已经改变了。虽然文本内容看上去不变——但是实际情况是文本内容已经改变了，也就是load()方法已经生效了，只是alert阻塞了浏览器将它渲染出来。在这里还要注意，alert可以阻塞浏览器的渲染，而debugger是没办法的。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AJAX</tag>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
</search>
