<!-- build time:Sat Nov 09 2019 21:43:36 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Chor&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third party/pace-theme-flash.css"><link rel="icon" href="/images/me.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><i class="fa fa-bars"></i> <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">HOME</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">CATEGORIES</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">ARCHIVES</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">TAGS</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">ABOUT</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="/" class="logo">Chor&#39;s Blog</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">前端模块化</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-10-18&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp9 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/模块化/">模块化</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96-1-1.png" alt=""></p><a id="more"></a><h2 id="为什么需要模块化？"><a href="#为什么需要模块化？" class="headerlink" title="为什么需要模块化？"></a>为什么需要模块化？</h2><p>早期的开发没有模块化，会有两个灾难性的问题：即 <strong>全局污染</strong> 以及 <strong>依赖管理混乱</strong>。</p><p><strong>1. 全局污染：</strong></p><p>A 引入 a.js，B 引入 b.js，这些代码最后都是存在于全局作用域里，难保不会出现变量命名冲突的问题。</p><p><strong>2. 依赖管理混乱：</strong></p><p>js 文件之间存在依赖关系，那么被依赖项必须出现在前面，也就是说要遵守一定的顺序。要是有几十个文件，那么就得先确定好互相之间的依赖关系，然后手动排序，累觉不爱。</p><h2 id="早期解决方案："><a href="#早期解决方案：" class="headerlink" title="早期解决方案："></a>早期解决方案：</h2><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>每个 js 文件中都用一个匿名自执行函数来封装数据。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    num<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// b.js</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    num<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nice，这样子 a.js 和 b.js 都有各自的 num，互不影响了。但是，我在全局作用域下好像拿不到函数里的东西？？？</p><h3 id="IIFE-增强版"><a href="#IIFE-增强版" class="headerlink" title="IIFE 增强版"></a>IIFE 增强版</h3><p>让 IIFE 返回一个对象，暴露给全局作用域</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span>
<span class="token keyword">var</span> moduleA <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    gain<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> num<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    add<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      num<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，全局可以通过 <code>moduleA</code> 拿到函数里的变量。不过，要是 b.js 不小心脑袋抽筋，也将 IIFE 返回给一个叫做 <code>moduleA</code> 的变量呢？命名冲突的问题还是没解决。</p><p>这之后提出了<strong>模块化</strong>的概念。</p><h2 id="模块化解决方案："><a href="#模块化解决方案：" class="headerlink" title="模块化解决方案："></a>模块化解决方案：</h2><p>那么，模块化到底需要解决什么问题呢？我们先设想一下可能有以下几点：</p><ul><li>安全地包装一个模块的代码，避免全局污染</li><li>唯一标识一个模块</li><li>优雅地将模块 api 暴露出去</li><li>方便地使用模块</li><li>…….</li></ul><h3 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h3><p><strong>1.1 介绍：</strong></p><p>CommonJS 的一个模块就是一个脚本文件，通过执行该文件来加载模块<br>。CommonJS 规范规定，每个模块内部，<code>module</code> 变量代表当前模块。这个变量是一个对象，它的 <code>exports</code> 属性（即 <code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的 <code>module.exports</code> 属性。</p><p><strong>1.2 导出模块：</strong></p><p>Node.js 是 CommonJS 规范的实现。为了方便，Node.js 为每个模块提供一个 <code>exports</code> 变量，指向 <code>module.exports</code>。这等同在每个模块头部，有一行这样的命令：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> exports <span class="token operator">=</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以，我们有两种导出模块的方式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span>
<span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    num<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 方式1</span>
 module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    num<span class="token punctuation">,</span>
    print
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 方式2</span>
exports<span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>print <span class="token operator">=</span> print<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3 加载模块：</strong></p><p>另外，我们也有两种加载模块的方式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// main.js</span>

<span class="token comment" spellcheck="true">// 方式1</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 方式2（解构赋值）</span>
<span class="token keyword">var</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>print <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CommonJS 的特点是：</p><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>CommonJS 是针对服务端的模块化解决方案，为何它不能用于前端呢？因为 CommonJS 是同步而不是异步的，在我们 require 模块的时候，如果迟迟没有返回结果，那么就会阻塞后面代码的执行，甚至会阻止页面的渲染。</p><p>所以这时候有了 AMD 规范，即<strong>异步模块加载规范</strong>。<br>AMD 与 CommonJS 的主要区别就是异步模块加载 —— 即使 require 的模块还没有获取到，也不会影响后面代码的执行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><p>RequireJS 实现了这个规范。</p><p>当然，后面还出现了 CMD、UMD。</p><h3 id="3-ES6-Module"><a href="#3-ES6-Module" class="headerlink" title="3. ES6 Module"></a>3. ES6 Module</h3><p><strong>3.1 介绍：</strong></p><p>ES6 在语言规格层面上实现了模块功能，完全可以取代现有的 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p><strong>3.2 导出模块</strong></p><p>有三种方式可以导出模块：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span>

<span class="token comment" spellcheck="true">// 方式一（声明的同时导出）</span>
<span class="token keyword">export</span> <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  num<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 方式二（统一导出。推荐）</span>
<span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  num<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>add <span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 方式三（允许重命名，次数不限）</span>
<span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  num<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>
  num <span class="token keyword">as</span> new_num<span class="token punctuation">;</span>
  add <span class="token keyword">as</span> new_add<span class="token punctuation">;</span>
  add <span class="token keyword">as</span> newer_add<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.3 加载模块</strong></p><p>同样的，加载模块也有多种方式。其中，整体加载会把之前导出的变量和函数挂载在一个对象上。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// main.js</span>

<span class="token comment" spellcheck="true">// 方式一：</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>add <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./module.js'</span>

<span class="token comment" spellcheck="true">// 方式二（允许重命名）：</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
  num <span class="token keyword">as</span> new_num<span class="token punctuation">;</span>
  add <span class="token keyword">as</span> new_add<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./module.js'</span>

<span class="token comment" spellcheck="true">// 方式三（整体加载）：</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> obj <span class="token keyword">from</span> <span class="token string">'./module.js'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.4 export default</strong></p><p><code>export default</code> 其实用得更多。<code>import</code> 在非整体加载的时候要求我们事先知道导出的变量或者函数的名字，但是如果使用 <code>export default</code> 导出，那么后续加载模块的时候，名字可以任取，也就是说，我们并不需要知道原模块中变量或者函数的名字。例如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// main.js</span>
<span class="token keyword">import</span> func <span class="token keyword">from</span> <span class="token string">'./module.js'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，要注意两点：</p><ul><li><p><code>export default</code> 实际上是把后面跟着的东西赋值给 <code>default</code> 变量，所以后面不能是变量的声明</p></li><li><p>因为 <code>export default</code> 是指定的<strong>默认输出</strong>，这意味着一个模块文件中只能有一条 <code>export default</code> 语句（当然，可以与 <code>export</code> 一起用），也因为这样，<code>import</code> 后面不需要大括号，因为它只可能接受一个项。</p></li></ul><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><ul><li><p>CommonJS 模块输出的是值的拷贝，ES6 模块输出的是值的引用</p></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</p></li></ul><h3 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h3><p>CommonJS 模块输出的是值的拷贝：</p><p>也就是说，输出之后，原模块内部该值怎么变化，都不会影响到导出去的那个值，两者在内存中有各自的空间。</p><p>关于这点，很多文章会用类似下面的方式去证明：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span>
<span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  num<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>add <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// main.js</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">console</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 1</span>
obj<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为这里是拷贝了 <code>num</code>，所以 <code>add</code> 操作后只是 <code>module.js</code> 中的 <code>num</code> 加一（词法作用域），<code>main.js</code> 中拷贝得到的 <code>num</code> 不变。</p><p>这个证明方法其实有问题。因为 <code>module.exports</code> 对象中的 <code>num</code> 属性本来就有值的拷贝了，此方法并不能证明值的拷贝是由 CommonJS 的底层实现的。，而且，把上面代码改为对应的 es6 module 版本(此时本来应该是引用)，会发现得到同样的结果，更证明了这一点。详情看:</p><p><a href="https://www.jianshu.com/p/1cfc5673e61d" target="_blank" rel="noopener">如何正确证明 CommonJS 模块导出是值的拷贝，而 ES module 是值的引用？</a></p><p>ES6 模块输出的是值的引用：</p><p>JS 引擎对脚本静态分析的时候，遇到模块加载命令 <code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。<br>这意味着，原模块中值的改变会动态映射到 <code>main.js</code> 中</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span>
<span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  num<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> num<span class="token punctuation">.</span>add <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>add <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./module.js'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这个引用是动态变化的。</p><p>另外，原模块导出的变量在 <code>main.js</code> 中表现为一个只读常量，也就是说我们不能在 <code>main.js</code> 中对它重新赋值，这会报错：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>obj <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./module.js'</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>
num<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// TypeError: Assignment to constant variable</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// {.......}</span>
obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Sam"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 没毛病</span>
obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// TypeError: Assignment to constant variable </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于引用类型，可以给它添加属性，但赋值同样是不行的。</p><h3 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h3><p>运行时加载：</p><p>CommonJS 是运行时加载的。也就是说，在 require 时，先执行整个模块（加载里面所有的方法），生成一个对象，然后再从这个对象上面读取实际要用到的方法，这种加载称为“运行时加载”。</p><p>编译时加载:</p><p>ES6 模块是运行时加载的。也就是说，其设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量（只加载需要的方法）。这种加载称为“编译时加载”。<br>import 有提升现象，因为这是在编译阶段就执行的。</p><p>以这段代码为例：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//ES6模块</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'module.js'</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//CommonJS 模块</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>对于 CommonJS，当 require 模块时，原模块会运行一遍，并返回一个包含所有 api 的对象，并将这个对象缓存起来。此后，无论多少次加载这个模块都是取这个缓存的值，也就是第一次运行的结果，除非手动清除。</p></li><li><p>对于 ES6，在编译阶段遇到 import 时，不会像 CommonJS 一样去执行模块，而是生成一个动态的只读引用，当真正需要的时候再到模块里去取值，所以 ES6模块是动态引用，并且不会缓存值。</p></li></ul><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/41568986" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41568986</a><br><a href="https://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/module</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/10/19/F-Webpack（一）：安装和基础配置/" rel="prev" title="Webpack（一）：安装和基础配置"><i class="fa fa-angle-double-left"></i>&nbspWebpack（一）：安装和基础配置</a></div><div class="post-nav-next"><a href="/2019/10/13/F-file 协议导致的跨域问题以及解决方案/" rel="next" title="file 协议导致的跨域问题以及解决方案">file 协议导致的跨域问题以及解决方案&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么需要模块化？"><span class="toc-text">为什么需要模块化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#早期解决方案："><span class="toc-text">早期解决方案：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IIFE"><span class="toc-text">IIFE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IIFE-增强版"><span class="toc-text">IIFE 增强版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块化解决方案："><span class="toc-text">模块化解决方案：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CommonJS"><span class="toc-text">1.CommonJS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AMD"><span class="toc-text">2.AMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ES6-Module"><span class="toc-text">3. ES6 Module</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-模块与-CommonJS-模块的差异"><span class="toc-text">ES6 模块与 CommonJS 模块的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#其一"><span class="toc-text">其一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其二"><span class="toc-text">其二</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->