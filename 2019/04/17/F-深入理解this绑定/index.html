<!-- build time:Sun Sep 05 2021 14:32:52 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">深入理解this绑定</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-04-17&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp16 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/this/">this</a> <a href="/tags/调用栈/">调用栈</a></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A-0.jpg"></div><span id="more"></span><p>最近在阅读《你不知道的JavaScript》，再次补充了一下之前不熟悉的this绑定问题，在这里做一下阅读笔记。（很多晦涩的概念包括闭包、作用域链等都和js中的调用栈有关，所以也得另外找个时间系统学一下了）</p><h2 id="调用位置">1.调用位置</h2><p>JS 中的词法作用域是静态的，需要关注的往往是函数的声明位置而不是调用位置 —— 例如闭包引用自由变量时，应该注意闭包函数的声明位置；而 this 却在某种程度上类似于动态作用域，this 到底绑定的是谁，要看函数的调用位置（或者说调用方法），只有在函数调用的时候 this 的指向才能被确定。</p><p>确定当前执行函数的调用位置，有两种方法： ### 1.1 分析调用栈</p><p>调用栈即：为了到达当前执行位置所调用的所有函数。当前执行函数的调用位置就在调用栈中该函数的前一个调用中。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">baz</span>()<span class="op">&#123;</span>
    <span class="co">//当前调用栈是:baz</span>
    <span class="co">// 因此，当前调用位置是全局作用域</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;baz&quot;</span>)<span class="op">;</span>
    <span class="at">bar</span>()<span class="op">;</span> <span class="co">// bar的调用位置</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">bar</span>()<span class="op">&#123;</span>
    <span class="co">// 当前调用栈是baz -&gt; bar</span>
    <span class="co">// 因此，当前调用位置在baz中</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;bar&quot;</span>)<span class="op">;</span>
    <span class="at">foo</span>()<span class="op">;</span> <span class="co">// foo的调用位置</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">foo</span>()<span class="op">&#123;</span>
    <span class="co">// 当前调用栈是baz -&gt; bar -&gt; foo</span>
    <span class="co">// 因此，当前调用位置在bar中</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;foo&quot;</span>)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="at">baz</span>()<span class="op">;</span> <span class="co">// &lt;-- baz的调用位置</span></code></pre></div><p>如上代码，例如当前执行函数为bar，bar函数的调用位置即bar函数的前一个调用，分析调用栈baz -&gt; bar可知，是baz。</p><h3 id="设置断点或debugger">1.2 设置断点或debugger</h3><p>上面的方法将调用栈当作了函数调用链，这种方法比较麻烦，且容易出错，所以我们采取设置断点或debugger的方法寻找调用位置。我们在上面代码的foo函数中的第一行插入<code>debugger;</code>，那么运行代码时（当前执行函数是foo），调试器会在那个位置暂停，右侧的call stack展示了当前位置的函数调用列表，即调用栈。而调用位置就是栈中的第二个元素。</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A-2.png"></div><h2 id="绑定规则">2.绑定规则</h2><h3 id="默认绑定">2.1 默认绑定</h3><p>可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。独立函数调用（如代码中的foo函数，它是直接使用不带任何修饰的函数引用进行调用的）应用的就是默认绑定规则。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>()<span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
<span class="at">foo</span>()<span class="op">;</span>   <span class="co">//2</span></code></pre></div><p>但是，函数==运行在严格模式==时，this 的默认绑定将无法绑定全局对象，而是绑定到 undefined。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>    
    <span class="st">&quot;use strict&quot;</span><span class="op">;</span>   <span class="co">// 函数运行在严格模式下</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
<span class="at">foo</span>()<span class="op">;</span> <span class="co">// TypeError: Cannot read property &#39;a&#39; of undefined</span></code></pre></div><p>同时，函数在==严格模式下调用==时，默认绑定不受影响。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span> 
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
(<span class="kw">function</span>()<span class="op">&#123;</span> 
    <span class="st">&quot;use strict&quot;</span><span class="op">;</span>  <span class="co">//函数在严格模式下调用    </span>
    <span class="at">foo</span>()<span class="op">;</span> <span class="co">// 2</span>
<span class="op">&#125;</span>)()<span class="op">;</span></code></pre></div><h3 id="隐式绑定">2.2 隐式绑定</h3><p>当函数引用有上下文对象时（或者说被某个对象“包含”/“拥有”），隐式绑定规则会把函数中的this绑定到这个上下文对象。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">&#125;;</span>
<span class="va">obj</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 2</span></code></pre></div><p>对象属性引用链中只有上一层或者说最后一层在调用中起作用。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>()<span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> obj1 <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">obj2</span><span class="op">:</span> obj2
<span class="op">&#125;;</span>
<span class="kw">var</span> obj2 <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">42</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> foo
<span class="op">&#125;</span>
<span class="va">obj1</span>.<span class="va">obj2</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 42</span></code></pre></div><h4 id="隐式丢失">2.2.1 隐式丢失</h4><p>隐式绑定在一些情况下会丢失绑定对象，应用默认绑定，使this指向全局对象或者undefined。以下情况会发生隐式丢失： * 将绑定上下文对象的函数赋值给变量并调用</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span><span class="dv">2</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">&#123;</span>
        <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)
    <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> a <span class="op">=</span> <span class="dv">3</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="va">obj</span>.<span class="at">foo</span>
<span class="at">bar</span>()    <span class="co">// 3</span></code></pre></div><p>虽然 bar 是 obj.foo 的一个引用，但实际上是直接引用了 foo 函数本身，此时的 bar() 是不带任何修饰的函数调用，因此使用了默认绑定 * 传入回调函数</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">bar</span>(fn)<span class="op">&#123;</span>
    <span class="at">fn</span>()<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span><span class="dv">2</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">&#123;</span>
        <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)<span class="op">;</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> a <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>
<span class="at">bar</span>(<span class="va">obj</span>.<span class="at">foo</span>)<span class="op">;</span></code></pre></div><p>传参其实是隐式赋值，即把实参（这里是绑定上下文对象的函数的引用）赋值给形参变量，该变量也是直接引用了foo 函数本身，和上面的情况其实是一样的。</p><p>这也解释了为什么传参给 setTimeout 函数时会发生隐式丢失：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="kw">function</span>()<span class="op">&#123;</span>
        <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)
    <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> a <span class="op">=</span> <span class="dv">3</span>
<span class="at">setTimeout</span>(<span class="va">obj</span>.<span class="at">foo</span><span class="op">,</span> <span class="dv">100</span>) <span class="co">// 3</span></code></pre></div><p>因为上面的代码实际上相当于：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">(<span class="kw">function</span> <span class="at">setTimeout</span>(fn<span class="op">,</span><span class="dv">100</span>)<span class="op">&#123;</span>
    <span class="co">// 100......</span>
    <span class="at">fn</span>()<span class="op">;</span>
<span class="op">&#125;</span>)(<span class="va">obj</span>.<span class="at">foo</span>)<span class="op">;</span></code></pre></div><p>PS：从另一个角度来理解就是，setTimeout 本身其实是通过 window 对象调用的，这会导致回调函数中的 this 指向全局 window 对象。</p><h3 id="显式绑定">2.3 显式绑定</h3><h4 id="call-和-apply">2.3.1 <code>call()</code> 和 <code>apply()</code></h4><p><code>call()</code> 或者 <code>apply()</code> 方法接受一个 thisArg，将函数的 this 绑定到该 thisArg。 thisArg 的取值有以下四种情况：</p><ul><li><p>不传，或者传null、undefined：函数中的 this 指向 window 对象</p></li><li><p>传递另一个函数的函数名：函数中的 this 指向这个函数的引用</p></li><li><p>传递字符串、数值或布尔类型等基本类型：函数中的 this 指向其对应的包装对象，如 String、Number、Boolean</p></li><li><p>传递一个对象：函数中的 this 指向这个对象</p></li></ul><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>()<span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)
<span class="op">&#125;</span>
<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">&#125;</span>
<span class="va">foo</span>.<span class="at">call</span>(obj)<span class="op">;</span> <span class="co">// 2</span></code></pre></div><h4 id="硬绑定-bind">2.3.2 硬绑定 <code>bind()</code></h4><p>但是这两种方法依然无法解决绑定丢失的问题，所以有了硬绑定。硬绑定的一个例子如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
  <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
  <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">&#125;;</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;</span>
  <span class="va">foo</span>.<span class="at">call</span>(obj)<span class="op">;</span>
<span class="op">&#125;;</span>
<span class="at">bar</span>()<span class="op">;</span>  <span class="co">// 2</span>
<span class="at">setTimeout</span>(bar<span class="op">,</span> <span class="dv">100</span>)<span class="op">;</span>  <span class="co">// 2</span>

<span class="va">bar</span>.<span class="at">call</span>(window)<span class="op">;</span>  <span class="co">//无效，硬绑定之后的this不可再更改</span></code></pre></div><p>这里的 bar 函数就实现了一个硬绑定，它将 this 绑定的过程封装在了函数内部，之后不管怎么调用 bar 函数，this 的绑定都不会丢失。</p><p>硬绑定的典型应用场景是：</p><ol style="list-style-type:decimal"><li>创建一个包裹函数，负责接收参数并返回值。</li></ol><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(something) <span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span><span class="op">,</span> something )<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">a</span> <span class="op">+</span> something<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">&#125;;</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="kw">function</span>() <span class="op">&#123;</span>
    <span class="cf">return</span> <span class="va">foo</span>.<span class="at">apply</span>( obj<span class="op">,</span> arguments )<span class="op">;</span>
<span class="op">&#125;;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="at">bar</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// 2 3</span>
<span class="va">console</span>.<span class="at">log</span>( b )<span class="op">;</span> <span class="co">// 5</span></code></pre></div><ol start="2" style="list-style-type:decimal"><li>创建一个可以重复使用的辅助函数。</li></ol><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(something) <span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span><span class="op">,</span> something )<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">a</span> <span class="op">+</span> something<span class="op">;</span>
<span class="op">&#125;</span>

<span class="co">// 简单的辅助绑定函数</span>
<span class="kw">function</span> <span class="at">bind</span>(fn<span class="op">,</span> obj) <span class="op">&#123;</span>
    <span class="cf">return</span> <span class="kw">function</span>() <span class="op">&#123;</span>
        <span class="cf">return</span> <span class="va">fn</span>.<span class="at">apply</span>(obj<span class="op">,</span> arguments)<span class="op">;</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">&#125;;</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="at">bind</span>( foo<span class="op">,</span> obj )<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="at">bar</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// 2 3</span>
<span class="va">console</span>.<span class="at">log</span>( b )<span class="op">;</span> <span class="co">// 5</span></code></pre></div><p>ES5 提供了内置方法 Function.prototype.bind，对上面这种辅助函数进行了封装：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(something) <span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span><span class="op">,</span> something)<span class="op">;</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">a</span> <span class="op">+</span> something<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">&#125;;</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">bind</span>(obj)<span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> <span class="at">bar</span>(<span class="dv">3</span>)<span class="op">;</span> <span class="co">// 2 3</span>
<span class="va">console</span>.<span class="at">log</span>(b)<span class="op">;</span> <span class="co">// 5</span></code></pre></div><p><code>bind()</code>方法将返回一个完成硬绑定的新函数。</p><h4 id="api调用的上下文">2.3.3 API调用的“上下文”</h4><p>同样可以解决绑定丢失的问题。 JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和 <code>bind(..)</code>一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">id</span><span class="op">:</span> <span class="st">&quot;awesome&quot;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> myArray <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]
<span class="co">// 调用foo(..)时把this绑定到obj</span>
<span class="va">myArray</span>.<span class="at">forEach</span>( <span class="kw">function</span> <span class="at">foo</span>(el) <span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>( el<span class="op">,</span> <span class="kw">this</span>.<span class="at">id</span> )<span class="op">;</span>
<span class="op">&#125;,</span> obj )<span class="op">;</span>
<span class="co">// 1 awesome 2 awesome 3 awesome</span></code></pre></div><h3 id="new-绑定">2.4 new 绑定</h3><p>在<a href="https://chorer.github.io/2019/03/31/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/#5-1-new">这篇文章</a>中，其实已经谈到了new的内部原理，在这里再做一下总结 —— 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作： * 1.创建一个新对象 * 2.为该对象执行<code>[[prototype]]</code>链接 * 3.将该对象绑定到构造函数的this * 4.如果函数没有显式返回对象，则new操作最终将返回步骤1中创建的新对象</p><p>基于这些步骤，我们就可以手写实现new了，具体过程依然可以参考上面链接的文章。</p><p>有时候会将硬绑定与new一起使用，目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数（<strong>柯里化</strong>）</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(p1<span class="op">,</span> p2) <span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="at">val</span> <span class="op">=</span> p1 <span class="op">+</span> p2<span class="op">;</span>
<span class="op">&#125;</span>

<span class="co">// 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么</span>
<span class="co">// 反正使用new时this会被修改</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">bind</span>( <span class="kw">null</span><span class="op">,</span> <span class="st">&quot;p1&quot;</span> )<span class="op">;</span>

<span class="kw">var</span> baz <span class="op">=</span> <span class="kw">new</span> <span class="at">bar</span>( <span class="st">&quot;p2&quot;</span> )<span class="op">;</span>

<span class="va">baz</span>.<span class="at">val</span><span class="op">;</span> <span class="co">// p1p2</span></code></pre></div><h2 id="this的判断">3. this的判断</h2><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条this绑定规则。可以按照下面的顺序来进行判断：</p><ol style="list-style-type:decimal"><li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 <code>var bar = new foo()</code></li><li>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 <code>var bar = foo.call(obj2)</code></li><li>函数是否通过某个上下文对象调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。 <code>var bar = obj1.foo()</code></li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。 <code>var bar = foo()</code></li></ol><h2 id="绑定例外">4.绑定例外</h2><h3 id="被忽略的this">4.1 被忽略的this</h3><p>把<code>null</code>或者<code>undefined</code>作为this的绑定对象传入<code>call</code>、<code>apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认规则。</p><p>下面两种情况下会传入<code>null</code>： * 使用<code>apply(..)</code>来展开一个数组，并当作参数传入一个函数 * <code>bind(..)</code>可以对参数进行柯里化（预先设置一些参数）</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a<span class="op">,</span> b) <span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;a:&quot;</span> <span class="op">+</span> a <span class="op">+</span> <span class="st">&quot;，b:&quot;</span> <span class="op">+</span> b )<span class="op">;</span>
<span class="op">&#125;</span>
<span class="co">// 把数组”展开“成参数</span>
<span class="va">foo</span>.<span class="at">apply</span>( <span class="kw">null</span><span class="op">,</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] )<span class="op">;</span> <span class="co">// a:2，b:3</span>

<span class="co">// 使用bind(..)进行柯里化</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">bind</span>( <span class="kw">null</span><span class="op">,</span> <span class="dv">2</span> )<span class="op">;</span>
<span class="at">bar</span>( <span class="dv">3</span> )<span class="op">;</span> <span class="co">// a:2，b:3 </span></code></pre></div><p>总是传入<code>null</code>来忽略 this 绑定可能产生一些副作用 —— 如果某个函数确实使用了 this，那默认绑定规则会把 this 绑定到全局对象中。</p><p><span style="background-color:#fffa7d">更安全的做法</span>:</p><p>传入一个空对象（而非 null），把 this 绑定到这个对象不会对你的程序产生任何副作用。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a<span class="op">,</span> b) <span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="st">&quot;a:&quot;</span> <span class="op">+</span> a <span class="op">+</span> <span class="st">&quot;，b:&quot;</span> <span class="op">+</span> b )<span class="op">;</span>
<span class="op">&#125;</span>

<span class="co">// 我们的空对象</span>
<span class="kw">var</span> ø <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="kw">null</span>)<span class="op">;</span>

<span class="co">// 把数组”展开“成参数</span>
<span class="va">foo</span>.<span class="at">apply</span>( ø<span class="op">,</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] )<span class="op">;</span> <span class="co">// a:2，b:3</span>

<span class="co">// 使用bind(..)进行柯里化</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">bind</span>( ø<span class="op">,</span> <span class="dv">2</span> )<span class="op">;</span>
<span class="at">bar</span>(<span class="dv">3</span>)<span class="op">;</span> <span class="co">// a:2，b:3 </span></code></pre></div><h3 id="间接引用">4.2 间接引用</h3><p>你可能会有意无意地创建一个函数的间接引用，尤其是在赋值的时候</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()</span>
<span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
<span class="kw">var</span> o <span class="op">=</span> <span class="op">&#123;</span> <span class="dt">a</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span> <span class="dt">foo</span><span class="op">:</span> foo <span class="op">&#125;;</span>
<span class="kw">var</span> p <span class="op">=</span> <span class="op">&#123;</span> <span class="dt">a</span><span class="op">:</span> <span class="dv">4</span><span class="op">&#125;;</span>

<span class="va">o</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 3</span>
(<span class="va">p</span>.<span class="at">foo</span> <span class="op">=</span> <span class="va">o</span>.<span class="at">foo</span>)()<span class="op">;</span> <span class="co">// 2</span></code></pre></div><h3 id="软绑定">4.3 软绑定</h3><ul><li>硬绑定可以把 this 强制绑定到指定的对象（new除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this。</li><li>如果给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</li></ul><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// 默认绑定规则，优先级排最后</span>
<span class="co">// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this</span>
<span class="cf">if</span>(<span class="op">!</span><span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">softBind</span>)<span class="op">&#123;</span>
    <span class="va">Function</span>.<span class="va">prototype</span>.<span class="at">softBind</span> <span class="op">=</span> <span class="kw">function</span>(obj) <span class="op">&#123;</span>
        <span class="kw">var</span> fn <span class="op">=</span> <span class="kw">this</span><span class="op">;</span>
        <span class="co">// 捕获所有curried参数</span>
        <span class="kw">var</span> curried <span class="op">=</span> [].<span class="va">slice</span>.<span class="at">call</span>( arguments<span class="op">,</span> <span class="dv">1</span> )<span class="op">;</span> 
        <span class="kw">var</span> bound <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;</span>
            <span class="cf">return</span> <span class="va">fn</span>.<span class="at">apply</span>(
                (<span class="op">!</span><span class="kw">this</span> <span class="op">||</span> <span class="kw">this</span> <span class="op">===</span> (window <span class="op">||</span> global)) <span class="op">?</span> 
                    obj : <span class="kw">this</span>.<span class="va">curried</span>.<span class="va">concat</span>.<span class="at">apply</span>( curried<span class="op">,</span> arguments )
            )<span class="op">;</span>
        <span class="op">&#125;;</span>
        <span class="va">bound</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>( <span class="va">fn</span>.<span class="at">prototype</span> )<span class="op">;</span>
        <span class="cf">return</span> bound<span class="op">;</span>
    <span class="op">&#125;;</span>
<span class="op">&#125;</span></code></pre></div><p>使用：软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默认绑定，则会将 this 绑定到 obj。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;name:&quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">name</span>)<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span> <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;obj&quot;</span> <span class="op">&#125;,</span>
    obj2 <span class="op">=</span> <span class="op">&#123;</span> <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;obj2&quot;</span> <span class="op">&#125;,</span>
    obj3 <span class="op">=</span> <span class="op">&#123;</span> <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;obj3&quot;</span> <span class="op">&#125;;</span>

<span class="co">// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj</span>
<span class="kw">var</span> fooOBJ <span class="op">=</span> <span class="va">foo</span>.<span class="at">softBind</span>( obj )<span class="op">;</span>
<span class="at">fooOBJ</span>()<span class="op">;</span> <span class="co">// name: obj </span>

<span class="co">// 隐式绑定规则</span>
<span class="va">obj2</span>.<span class="at">foo</span> <span class="op">=</span> <span class="va">foo</span>.<span class="at">softBind</span>( obj )<span class="op">;</span>
<span class="va">obj2</span>.<span class="at">foo</span>()<span class="op">;</span> <span class="co">// name: obj2 &lt;---- 看！！！</span>

<span class="co">// 显式绑定规则</span>
<span class="va">fooOBJ</span>.<span class="at">call</span>( obj3 )<span class="op">;</span> <span class="co">// name: obj3 &lt;---- 看！！！</span>

<span class="co">// 绑定丢失，应用软绑定</span>
<span class="at">setTimeout</span>( <span class="va">obj2</span>.<span class="at">foo</span><span class="op">,</span> <span class="dv">10</span> )<span class="op">;</span> <span class="co">// name: obj</span></code></pre></div><h2 id="this词法">5 this词法</h2><h3 id="箭头函数">5.1 箭头函数</h3><p>ES6新增了箭头函数，上述四条规则对这种函数是不生效的。 &gt;箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this。</p><p>拿下面的代码举例，箭头函数在词法层面的上一层是<code>foo()</code>，所以它的 this 和<code>foo()</code>的 this 是一样的。由于<code>foo()</code>的 this 绑定到<code>obj1</code>，所以<code>bar</code>（引用箭头函数）的 this 也会绑定到<code>obj1</code>。需要注意的是，箭头函数的绑定无法被修改 —— 因为箭头函数没有自己的 this，所以是不能对它使用 <code>call</code>，<code>apply</code>，<code>bind</code> 的，new 也不行。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
    <span class="co">// 返回一个箭头函数</span>
    <span class="cf">return</span> (a) <span class="op">=&gt;</span> <span class="op">&#123;</span>
        <span class="co">// this继承自foo()</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="kw">this</span>.<span class="at">a</span> )<span class="op">;</span>
    <span class="op">&#125;;</span>
<span class="op">&#125;</span>

<span class="kw">var</span> obj1 <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">&#125;;</span>

<span class="kw">var</span> obj2 <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">3</span>
<span class="op">&#125;</span>
<span class="co">// 绑定foo()的this为obj1</span>
<span class="kw">var</span> bar <span class="op">=</span> <span class="va">foo</span>.<span class="at">call</span>( obj1 )<span class="op">;</span>
<span class="va">bar</span>.<span class="at">call</span>( obj2 )<span class="op">;</span> <span class="co">// 2，不是3！</span></code></pre></div><p>另外，一定不要弄错作用域链的分析，比如下面这段代码：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> group <span class="op">=</span> <span class="op">&#123;</span>
  <span class="dt">title</span><span class="op">:</span> <span class="st">&quot;Our Group&quot;</span><span class="op">,</span>
  <span class="dt">students</span><span class="op">:</span> [<span class="st">&quot;John&quot;</span><span class="op">,</span> <span class="st">&quot;Pete&quot;</span><span class="op">,</span> <span class="st">&quot;Alice&quot;</span>]<span class="op">,</span>

  <span class="at">showList</span>() <span class="op">&#123;</span>
    <span class="kw">this</span>.<span class="va">students</span>.<span class="at">forEach</span>(
      student <span class="op">=&gt;</span> <span class="at">alert</span>(<span class="kw">this</span>.<span class="at">title</span> <span class="op">+</span> <span class="st">&#39;: &#39;</span> <span class="op">+</span> student)
    )<span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;;</span>

<span class="va">group</span>.<span class="at">showList</span>()<span class="op">;</span></code></pre></div><p>一定要记住 JS 采用的是词法作用域，词法作用域即静态作用域，它连同作用域链在函数创建的时候就确定了。</p><p>上面代码中，由于 <code>forEach</code> 只是一次<strong>动态的函数调用</strong>，因此它并不作为<strong>静态作用域链</strong>的一环，作用域链实际是 <code>arrow function =&gt; showList =&gt; global</code>，对于箭头函数，其父级作用域不是动态调用的 <code>forEach</code>，而是静态声明的 <code>showList</code>，因此箭头函数的 <code>this</code> 指向等于 <code>shwoList</code> 的 <code>this</code> 指向等于 <code>group</code>。</p><p>那么 <code>arrow function =&gt; showList =&gt; forEach =&gt; global</code> 是什么呢？是调用栈。调用栈是包含 <code>forEach</code> 这一环的。</p><p>箭头函数常用于回调函数中，例如事件处理器或者定时器。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>      
    <span class="at">setTimeout</span>(() <span class="op">=&gt;</span> <span class="op">&#123;</span> 
          <span class="co">// 同样的，这里的 this 在词法上不是继承自 setTimeout，而是继承自foo</span>
          <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">a</span>)     
     <span class="op">&#125;,</span><span class="dv">100</span>)
<span class="op">&#125;</span> 
 
<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>     
    <span class="dt">a</span><span class="op">:</span><span class="dv">2</span>
<span class="op">&#125;</span>
<span class="va">foo</span>.<span class="at">call</span>(obj) <span class="co">// 2</span></code></pre></div><h3 id="self-this-与箭头函数">5.2 <code>self = this</code> 与箭头函数</h3><p>this 在通常情况下都是动态作用域的，而箭头函数很明显是静态（词法）作用域。实际上，在 ES6 之前，也有类似于箭头函数的模式 —— <code>self = this</code>，它可以实现词法作用域的效果：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
    <span class="kw">var</span> self <span class="op">=</span> <span class="kw">this</span><span class="op">;</span> <span class="co">// lexical capt ure of this</span>
    <span class="at">setTimeout</span>( <span class="kw">function</span>() <span class="op">&#123;</span>
        <span class="va">console</span>.<span class="at">log</span>( <span class="va">self</span>.<span class="at">a</span> )<span class="op">;</span> <span class="co">// self只是继承了foo()函数的this绑定</span>
    <span class="op">&#125;,</span> <span class="dv">100</span> )<span class="op">;</span>
<span class="op">&#125;</span>

<span class="kw">var</span> obj <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">2</span>
<span class="op">&#125;;</span>

<span class="va">foo</span>.<span class="at">call</span>(obj)<span class="op">;</span> <span class="co">// 2</span></code></pre></div><h3 id="代码风格统一">5.3 代码风格统一</h3><p>如果你经常编写this风格的代码，但是绝大部分时候都会使用<code>self = this</code>或者箭头函数来否定this机制，那你或许应当：</p><ol style="list-style-type:decimal"><li>只使用词法作用域并完全抛弃错误 this 风格的代码；</li><li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。</li></ol><p>当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/04/23/To-%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B9%B3%E5%8F%B0/" rel="prev" title="分享一些实用工具和平台"><i class="fa fa-angle-double-left"></i>&nbsp分享一些实用工具和平台</a></div><div class="post-nav-next"><a href="/2019/04/13/T-%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/" rel="next" title="由一道题引发的思考">由一道题引发的思考&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E4%BD%8D%E7%BD%AE"><span class="toc-text">1.调用位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9%E6%88%96debugger"><span class="toc-text">1.2 设置断点或debugger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99"><span class="toc-text">2.绑定规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="toc-text">2.1 默认绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-text">2.2 隐式绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E4%B8%A2%E5%A4%B1"><span class="toc-text">2.2.1 隐式丢失</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-text">2.3 显式绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call-%E5%92%8C-apply"><span class="toc-text">2.3.1 call() 和 apply()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E7%BB%91%E5%AE%9A-bind"><span class="toc-text">2.3.2 硬绑定 bind()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#api%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">2.3.3 API调用的“上下文”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E7%BB%91%E5%AE%9A"><span class="toc-text">2.4 new 绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-text">3. this的判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E4%BE%8B%E5%A4%96"><span class="toc-text">4.绑定例外</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84this"><span class="toc-text">4.1 被忽略的this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%BC%95%E7%94%A8"><span class="toc-text">4.2 间接引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E7%BB%91%E5%AE%9A"><span class="toc-text">4.3 软绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E8%AF%8D%E6%B3%95"><span class="toc-text">5 this词法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">5.1 箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self-this-%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">5.2 self &#x3D; this 与箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%BB%9F%E4%B8%80"><span class="toc-text">5.3 代码风格统一</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->