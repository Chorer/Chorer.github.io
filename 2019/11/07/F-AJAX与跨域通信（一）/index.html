<!-- build time:Sun Nov 28 2021 10:22:27 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/prism.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">AJAX 与跨域通信（一）：AJAX 与同源策略</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-11-07&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp12 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/AJAX/">AJAX</a> <a href="/tags/跨域/">跨域</a></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX-0.jpg"></div><span id="more"></span><h3 id="ajax-解决了什么问题">1.AJAX 解决了什么问题？</h3><p>在很久以前，如果浏览器需要从服务器请求资源，其交互模式为：</p><p>客户端发出请求 ==&gt; 服务端接收请求并返回相应 HTML 文档 ==&gt; 页面刷新，客户端加载新的 HTML文档</p><p>很显然，在这种情况下，即使只是为了更新部分数据，我们也不得不重新加载整个重绘的页面。而 AJAX 的出现解决了这个问题。</p><p>AJAX 即异步 JavaScript 和 XML，它可以在不重新加载整个网页的情况下，对网页的某部分进行异步更新。</p><h3 id="xmlhttprequest-对象">2.XMLHttpRequest 对象</h3><p>AJAX 的核心实现依靠的是浏览器提供的 <code>XMLHttpRequest</code> 对象。可以看作是一个构造函数，由此我们可以通过 <code>const xhr = new XMLHttpRequest()</code> 创建一个 XML 对象的实例，该实例有以下方法：</p><ul><li><code>open()</code>：准备启动一个 AJAX 请求；</li><li><code>setRequestHeader()</code>：设置请求头部信息；</li><li><code>send()</code>：发送 AJAX 请求；</li><li><code>getResponseHeader()</code>: 获得响应头部信息；</li><li><code>getAllResponseHeader()</code>：获得一个包含所有头部信息的长字符串；</li><li><code>abort()</code>：取消异步请求；</li></ul><p>以及以下属性：</p><ul><li><code>responseText</code>：包含响应主体返回文本；</li><li><code>responseXML</code>：如果响应的内容类型是 text/xml 或 application/xml，该属性将保存包含着相应数据的 XML DOM文档；</li><li><code>status</code>：响应的 HTTP 状态；</li><li><code>statusText</code>：HTTP 状态的说明；</li><li><code>readyState</code>：表示“请求”/“响应”过程的当前活动阶段</li></ul><h3 id="ajax-请求">3.AJAX 请求</h3><h4 id="创建-xml-对象的实例">3.1 创建 XML 对象的实例：</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="准备请求">3.2 准备请求</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'demo.php?name=Sam&amp;job=coder'</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>open()</code> 方法接收三个参数：请求方法，请求 URL 地址和是否为异步请求的布尔值。</p><ul><li>请求方法：有 GET 和 POST 两种，GET 请求用于向服务器拿取数据，我们可以像示例代码中那样给 URL 加上查询参数，即 <code>?name=Sam&amp;job=coder</code>，表示要查询的特定资源；POST 请求用于向服务器提交数据，数据存放的位置通过 <code>send()</code> 方法的参数来指定。那么，对于 GET 请求，<code>send()</code> 方法是否可以不传递参数呢？——不可以，应该传递 <code>null</code>。</li><li>请求 URL：可以是相对路径和绝对路径</li><li>是否为异步请求：true 为异步，false 为同步。</li></ul><h4 id="设置请求头">3.3 设置请求头</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Header'</span><span class="token punctuation">,</span><span class="token string">'Value'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每个 HTTP 请求和响应都会带有相应的头部信息，包含一些与数据、收发者网络环境与状态等相关信息。 默认情况下，当发送 AJAX 请求时，会附带以下头部信息： * Accept：浏览器能够处理的内容类型； * Accept-Charset: 浏览器能够显示的字符集； * Accept-Encoding：浏览器能够处理的压缩编码； * Accept-Language：浏览器当前设置的语言； * Connection：浏览器与服务器之间连接的类型； * Cookie：当前页面设置的任何Cookie； * Host：发出请求的页面所在的域； * Referer：发出请求的页面URI； * User-Agent：浏览器的用户代理字符串；</p><p>另外，我们还可以通过 <code>setRequestHeader()</code> 方法来设置请求头信息。该函数接受两个参数：头部字段（部分默认的或者自定义的）的名称和头部字段的值。</p><p>这个方法要在 <code>open()</code> 和 <code>send()</code> 之间调用</p><h4 id="发送请求">3.4 发送请求</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token comment">// 或者 </span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data_holder<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="处理响应">3.5 处理响应</h4><p>目前为止，我们只是发送了请求，还没有针对服务器的响应结果做出一些处理。比方说，响应成功了怎么怎么样，响应失败了怎么怎么样。但是怎么知道是成功还是失败呢？这里就用到前面讲过的 <code>xhr.status</code> 属性，状态码可分为五大类：</p><table><thead><tr class="header"><th>状态码</th><th>范围</th><th>分类</th></tr></thead><tbody><tr class="odd"><td>1XX</td><td>100-101</td><td>信息提示</td></tr><tr class="even"><td>2XX</td><td>200-206</td><td>成功</td></tr><tr class="odd"><td>3XX</td><td>300-305</td><td>重定向</td></tr><tr class="even"><td>4XX</td><td>400-415</td><td>客户端错误</td></tr><tr class="odd"><td>5XX</td><td>500-505</td><td>服务器错误</td></tr></tbody></table><p>当然还有具体的分类，这里不展开讲。 那么，根据 <code>xhr.status</code> 这个响应结果，我们就可以进行相应处理了：<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">...</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Request was unsuccessful: "</span> <span class="token operator">+</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>这么写对于同步请求（我们前面设置 <code>open()</code> 时第三个参数是 false）来说当然没问题 —— 因为是同步的，所以一定是 send 之后，服务器那边响应结果了才会继续执行后面判断 status 的代码，那么不管请求成功还是失败，这个判断一定是可以被正常执行的。但是如果是异步请求呢？对于异步请求，不需要等待服务器响应结果我们就可以执行后面的判断了，甚至可能出现一种情况是：服务器还没来得及响应结果，判断已经先执行了。那么这时候，请求一定会失败。</p><p>也就是说，我们需要加一层判断，确保收到服务器的响应结果之后，再去判断请求成功还是失败。这里就用到前面讲过的 <code>xhr.readyState</code> 属性，readyState 会随着 AJAX 的进程而不断变化，我们可以通过 <code>onreadystatechange()</code> 去监听它的变化，进而判断何时收到服务器的响应结果。</p><p>readyState 可取值有：</p><table><thead><tr class="header"><th>状态值</th><th>含义</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>0</td><td>未初始化</td><td>尚未调用 <code>open()</code> 方法</td></tr><tr class="even"><td>1</td><td>启动</td><td>已经调用 <code>open()</code> 方法，但尚未调用 <code>send()</code> 方法</td></tr><tr class="odd"><td>2</td><td>发送</td><td>已经调用 <code>send()</code> 方法，但尚未接收到响应</td></tr><tr class="even"><td>3</td><td>接受</td><td>已经接收到部分响应数据</td></tr><tr class="odd"><td>4</td><td>完成</td><td>已经接收到全部响应数据，而且已经可以在客户端使用了</td></tr></tbody></table><p>那么，前面的代码就变成了：<pre class="line-numbers language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readystate <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Request was unsuccessful: "</span> <span class="token operator">+</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="取消异步请求">3.6 取消异步请求</h4><p>设想这么一种情况：我们正在上传一张图片（也就是发送一个 AJAX 请求），由于耗时过长，我们决定取消上传，那么取消上传其实就是取消 AJAX 请求，这是通过 <code>abort()</code> 方法实现的。一旦调用这个方法，xhr 就会停止触发事件，而且也不再允许访问任何与响应相关的对象属性。在终止请求之后，不要忘了对 xhr 对象解引用。</p><p>正常上传：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX-1.png"></div><p>取消上传：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX-2.png"></div><h3 id="xmlhttprequest-2-级">4.XMLHttpRequest 2 级</h3><h4 id="formdata">4.1 FormData</h4><p>通常提交表单数据的时候，这些数据需要经过序列化，虽然 <code>$('#form').serialize()</code> 可以实现序列化，但对于文件流无能为力。而 <code>FormData</code> 不仅可以做到表单序列化，而且支持异步上传二进制文件。<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'Sam'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// or</span>
<span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h4 id="超时设定">4.2 超时设定</h4><p>为 <code>xhr.timeout</code> 指定一个毫秒为单位的时间，一旦浏览器在这个规定的时间内没有收到响应，就会触发 <code>timeout</code> 事件，执行回调函数。<pre class="line-numbers language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span><span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Request was unsuccessful:"</span> <span class="token operator">+</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      <span class="token comment">//......</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'timeout.php'</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">ontimeout</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Request did not return in a second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>注意：这时候很可能出现一种情况，就是超过1秒后浏览器没收到响应，因此终止了请求，而这时候恰好 <code>xhr.status</code> 为4，因此又调用函数进行判断，这个判断需要访问 <code>xhr.status</code> 属性，而请求已经被终止，这个属性是无法访问的，此时要用 <code>try...catch...</code> 捕获这个错误。</p><h4 id="overridemimetype-方法">4.3 overrideMimeType() 方法</h4><p>服务器返回的响应头中有一个是 <code>Content-Type</code>，用以告诉客户端返回的资源类型（MIME）以及应该用什么编码去解码。例如 <code>Content-Type:text/html;charset=UTF-8</code>，那么客户端就会通过 UTF-8 对资源进行解码，然后对资源进行 HTML 解析。 但可能存在一种情况：虽然服务器返回数据是 XML，但 MIME 类型指定为 <code>text/plain</code>，那么这时候客户端就会当作纯文本去处理了，这显然不对，所以我们可以利用 <code>overrideMineType()</code> 方法重写响应的 MIME 类型，这样，客户端就可以将其当作 XML 去处理了。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'text.php'</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">overrideMineType</span><span class="token punctuation">(</span><span class="token string">'text/xml'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，必须在 send 调用之前重写。</p><h4 id="进度事件">4.4 进度事件</h4><p>Progress Events规范规范定义了与客户端与服务器通信相关的一系列事件，这些事件监听了通信进程中的各个关键节点，使我们能够以<strong>更细的颗粒度</strong>掌控数据传输过程中的细节。有以下6个进度事件：</p><ul><li>loadstart：在接受到响应数据的第一个字节时触发</li><li>progress：在接受响应期间持续不断地触发</li><li>error：在请求错误时触发</li><li>abort：在因为调用 <code>abort()</code> 方法而终止连接时触发</li><li>load：在接收到完整的响应数据时触发</li><li>loadend：在通信完成或触发 error、abort、load 事件后触发</li></ul><p>每个请求都从触发 loadstart 事件开始，接下来是一或多个 progress 事件，然后触发 error、abort 或 load 中的一个，最后以触发 loadend 事件结束。</p><p>有没有发现，前面的 <code>xhr.readyState == 4</code> 以及这里的 <code>load</code> 事件都可以判断是否接受到完整响应？ <code>load</code> 事件实际上简化了这个过程，它不需要像前者那样，既绑定一个监听函数又做一次 <code>readyState</code> 的判断，而只需要绑定监听函数即可。<pre class="line-numbers language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//....</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 变成</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//....</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="同源策略">5.同源策略</h3><blockquote><p>浏览器的同源策略即 Same-Origin Policy （SOP），它限制了不同源之间执行特定操作。</p></blockquote><h4 id="源">5.1 源</h4><p>一个源由<strong>协议</strong>、<strong>端口</strong>、<strong>域名</strong>组成，只要有一个不同，就认为是不同源。</p><p>以 http://test.com/dist/demo.html 为例，不同源以及同源可能有以下情况：</p><table style="width:100%"><colgroup><col width="12%"><col width="81%"><col width="6%"></colgroup><thead><tr class="header"><th>类型</th><th>URL</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>不同协议</td><td>https://test.com/dist/demo.html</td><td>失败</td></tr><tr class="even"><td>不同端口</td><td>http://test.com:80/dist/demo.html</td><td>失败</td></tr><tr class="odd"><td>不同域名</td><td>http://test.cn/dist/demo.html 或者 http://www.test.com/dist/demo.html</td><td>失败</td></tr><tr class="even"><td>不同路径</td><td>http://test.com/dist2/demo.html</td><td>成功</td></tr></tbody></table><h4 id="特定操作">5.2 特定操作</h4><p>特定操作指的是：</p><ul><li>读取 Cookie、LocalStorage、IndexedDB</li><li>获取 DOM 元素</li><li>发送 AJAX 请求</li></ul><p>为什么同源策略要禁止不同源之间进行这些操作呢？我们不妨假设一下，不存在同源策略、且不同源之间这些操作是允许的，看看可能会发生什么事。</p><ul><li><p>如果 A 源可以读取 B 源的 Cookie、LocalStorage、IndexDB，那么等于 B 源存储的信息都暴露了，那将毫无隐私可言。所以同源策略禁止不同源之间读取 Cookie、LocalStorage、IndexDB；</p></li><li><p>如果 A 源可以获取 B 源的 DOM 元素，那么假定用户访问了在 A 源中用 iframe 引入的 B 源网页，他的所有操作就都会在我们的掌握之中，因为我们可以在 A 源操作 B 源的 DOM 元素；</p></li><li><p>如果 A 源可以自由发送 AJAX 请求给 B 源，那么可能会遇到 CSRF 攻击。假定现在有一个用户首先登录了 <a href="">Bank.com</a>，那么本地客户端就会保存这个网站的 Cookie （里面记录了用户在该网站的身份信息）。之后用户不小心点进了危险网站 <a href="">Evil.com</a>，这个网站做了一些设置，一旦用户进入，就自动发送 AJAX 请求给 <a href="">Bank.com</a>，由于发送请求的时候，浏览器会自动在本地检索目标网站的 Cookie ，并添加到请求报文中随着请求一起发送给目标网站，所以目标网站检测到 Cookie 确实没问题，就会响应这个请求 —— 而这个请求实际上可能执行了类似删除数据这样的敏感操作。</p></li></ul><h3 id="跨域通信">6.跨域通信</h3><p>这样看来，同源策略确实很有存在的必要，不然网络安全无从谈起。</p><blockquote><p>等等，既然有同源策略的限制，那 A 源怎么去请求 B 源的数据呢？</p></blockquote><p>我们知道，第三方接口通常都是运行在单独的服务器上的。比如说，当前 web 页面运行在 <code>http://test.com/index.html</code> 这个服务器地址上，页面需要访问的接口运行在 <code>http://api.test.com</code> 这个服务器地址上。那么，通过浏览器访问 web 页面的时候，浏览器会针对接口地址发起 AJAX 请求，相当于 A 域需要请求 B 域的资源。</p><p>但同源策略是禁止这种行为的，这样的话我们要怎么进行跨域通信呢？</p><p>参考： * 《JavaScript 高级程序设计》第三版 * <a target="_blank" rel="noopener" href="https://juejin.im/post/5a20b1f1f265da432529179c#heading-16">再也不学AJAX了！（二）使用AJAX</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/11/07/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="prev" title="AJAX 与跨域通信（二）：跨域解决方案"><i class="fa fa-angle-double-left"></i>&nbspAJAX 与跨域通信（二）：跨域解决方案</a></div><div class="post-nav-next"><a href="/2019/10/26/F-%E4%BD%BF%E7%94%A8Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/" rel="next" title="使用 Vue 脚手架搭建项目">使用 Vue 脚手架搭建项目&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">1.AJAX 解决了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xmlhttprequest-%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.XMLHttpRequest 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax-%E8%AF%B7%E6%B1%82"><span class="toc-text">3.AJAX 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-xml-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">3.1 创建 XML 对象的实例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E8%AF%B7%E6%B1%82"><span class="toc-text">3.2 准备请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">3.3 设置请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-text">3.4 发送请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94"><span class="toc-text">3.5 处理响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-text">3.6 取消异步请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xmlhttprequest-2-%E7%BA%A7"><span class="toc-text">4.XMLHttpRequest 2 级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#formdata"><span class="toc-text">4.1 FormData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E8%AE%BE%E5%AE%9A"><span class="toc-text">4.2 超时设定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#overridemimetype-%E6%96%B9%E6%B3%95"><span class="toc-text">4.3 overrideMimeType() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%BA%A6%E4%BA%8B%E4%BB%B6"><span class="toc-text">4.4 进度事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-text">5.同源策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90"><span class="toc-text">5.1 源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E6%93%8D%E4%BD%9C"><span class="toc-text">5.2 特定操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1"><span class="toc-text">6.跨域通信</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>function send_valine_Server(){var e="desp=",t=document.title,n=t.indexOf("|"),a=t.substring(0,n),s=document.URL,l=new Date,i=document.getElementsByClassName("vnick vinput")[0].value,o=document.getElementsByClassName("vmail vinput")[0].value,v=document.getElementsByClassName("vlink vinput")[0].value,m=document.getElementsByClassName("veditor vinput")[0].value,r=e+"|昵称：|邮箱：|网站地址：|当前页面：|评论内容：|跳转链接：|评论时间\n|----|----|----|----|\n|   "+i+"   |   "+o+"  |  "+v+"|   "+a+"| "+m+"| "+s+"|"+l.toLocaleString()+"|",u=new XMLHttpRequest;u.open("POST","https://sc.ftqq.com/"+SCKEY_Server+".send",!0),u.setRequestHeader("Content-type","application/x-www-form-urlencoded"),u.send(title1+"&"+r)}new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0});var title1="text=你的博客有新的评论",SCKEY_Server="SCT99005TwWJDrDKdBwQGK0YmcPRAsr4B",ValineButton=document.getElementsByClassName("vsubmit vbtn")[0];ValineButton.onclick=send_valine_Server</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->