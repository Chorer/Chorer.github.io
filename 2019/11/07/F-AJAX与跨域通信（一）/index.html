<!-- build time:Wed Jan 20 2021 10:22:17 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">AJAX 与跨域通信（一）：AJAX 与同源策略</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-11-07&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.1k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp11 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/AJAX/">AJAX</a> <a href="/tags/跨域/">跨域</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX-0.jpg" alt=""></p><a id="more"></a><h3 id="1-AJAX-解决了什么问题？"><a href="#1-AJAX-解决了什么问题？" class="headerlink" title="1.AJAX 解决了什么问题？"></a>1.AJAX 解决了什么问题？</h3><p>在远古时代，如果浏览器需要从服务器请求资源，其交互模式为 “客户端发出请求 -&gt; 服务端接收请求并返回相应 HTML 文档 -&gt; 页面刷新，客户端加载新的 HTML文档”，很显然，在这种情况下，即使只是为了更新部分数据，我们也不得不重新加载整个重绘的页面。而 AJAX 的出现解决了这个问题。</p><p>AJAX 即异步 JavaScript 和 XML，它可以在不重新加载整个网页的情况下，对网页的某部分进行异步更新。</p><h3 id="2-XMLHttpRequest-对象"><a href="#2-XMLHttpRequest-对象" class="headerlink" title="2.XMLHttpRequest 对象"></a>2.XMLHttpRequest 对象</h3><p>AJAX 的核心实现依靠的是浏览器提供的 <code>XMLHttpRequest</code> 对象。可以看作是一个构造函数，由此我们可以通过 <code>const xhr = new XMLHttpRequest()</code> 创建一个 XML 对象的实例，该实例有以下方法：</p><ul><li><code>open()</code>：准备启动一个 AJAX 请求；</li><li><code>setRequestHeader()</code>：设置请求头部信息；</li><li><code>send()</code>：发送 AJAX 请求；</li><li><code>getResponseHeader()</code>: 获得响应头部信息；</li><li><code>getAllResponseHeader()</code>：获得一个包含所有头部信息的长字符串；</li><li><code>abort()</code>：取消异步请求；</li></ul><p>以及以下属性：</p><ul><li><code>responseText</code>：包含响应主体返回文本；</li><li><code>responseXML</code>：如果响应的内容类型是 text/xml 或 application/xml，该属性将保存包含着相应数据的 XML DOM文档；</li><li><code>status</code>：响应的 HTTP 状态；</li><li><code>statusText</code>：HTTP 状态的说明；</li><li><code>readyState</code>：表示“请求”/“响应”过程的当前活动阶段</li></ul><h3 id="3-AJAX-请求"><a href="#3-AJAX-请求" class="headerlink" title="3.AJAX 请求"></a>3.AJAX 请求</h3><h4 id="3-1-创建-XML-对象的实例："><a href="#3-1-创建-XML-对象的实例：" class="headerlink" title="3.1 创建 XML 对象的实例："></a>3.1 创建 XML 对象的实例：</h4><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-2-准备请求"><a href="#3-2-准备请求" class="headerlink" title="3.2 准备请求"></a>3.2 准备请求</h4><pre class="line-numbers language-js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'demo.php?name=Sam&amp;job=coder'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>open()</code> 方法接收三个参数：请求方式，请求 URL 地址和是否为异步请求的布尔值。</p><ul><li>请求方式：有 GET 和 POST 两种，GET 请求用于向服务器拿取数据，我们可以像示例代码中那样给 URL 加上查询参数，即 <code>?name=Sam&amp;job=coder</code>，表示要查询的特定资源；POST 请求用于向服务器发送要保存的数据，数据存放的位置通过 <code>send()</code> 方法的参数来指定。那么，对于 GET 请求，<code>send()</code> 方法是否可以不传递参数呢？——不可以，应该传递 <code>null</code>。</li><li>请求 URL：可以是相对路径和绝对路径</li><li>是否为异步请求：true 为异步，false 为同步。</li></ul><h4 id="3-3-设置请求头"><a href="#3-3-设置请求头" class="headerlink" title="3.3 设置请求头"></a>3.3 设置请求头</h4><pre class="line-numbers language-js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Header'</span><span class="token punctuation">,</span><span class="token string">'Value'</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每个 HTTP 请求和响应都会带有相应的头部信息，包含一些与数据、收发者网络环境与状态等相关信息。<br>默认情况下，当发送 AJAX 请求时，会附带以下头部信息：</p><ul><li>Accept：浏览器能够处理的内容类型；</li><li>Accept-Charset: 浏览器能够显示的字符集；</li><li>Accept-Encoding：浏览器能够处理的压缩编码；</li><li>Accept-Language：浏览器当前设置的语言；</li><li>Connection：浏览器与服务器之间连接的类型；</li><li>Cookie：当前页面设置的任何Cookie；</li><li>Host：发出请求的页面所在的域；</li><li>Referer：发出请求的页面URI；</li><li>User-Agent：浏览器的用户代理字符串；</li></ul><p>另外，我们还可以通过 <code>setRequestHeader()</code> 方法来设置请求头信息。该函数接受两个参数：头部字段（部分默认的或者自定义的）的名称和头部字段的值。</p><p>这个方法要在 <code>open()</code> 和 <code>send()</code> 之间调用</p><h4 id="3-4-发送请求"><a href="#3-4-发送请求" class="headerlink" title="3.4 发送请求"></a>3.4 发送请求</h4><pre class="line-numbers language-js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 或者 </span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data_holder<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-5-处理响应"><a href="#3-5-处理响应" class="headerlink" title="3.5 处理响应"></a>3.5 处理响应</h4><p>目前为止，我们只是发送了请求，还没有针对服务器的响应结果做出一些处理。比方说，响应成功了怎么怎么样，响应失败了怎么怎么样。但是怎么知道是成功还是失败呢？这里就用到前面讲过的 <code>xhr.status</code> 属性，状态码可分为五大类：</p><table><thead><tr><th>状态码</th><th>范围</th><th>分类</th></tr></thead><tbody><tr><td>1XX</td><td>100-101</td><td>信息提示</td></tr><tr><td>2XX</td><td>200-206</td><td>成功</td></tr><tr><td>3XX</td><td>300-305</td><td>重定向</td></tr><tr><td>4XX</td><td>400-415</td><td>客户端错误</td></tr><tr><td>5XX</td><td>500-505</td><td>服务器错误</td></tr></tbody></table><p>当然还有具体的分类，这里不展开讲。<br>那么，根据 <code>xhr.status</code> 这个响应结果，我们就可以进行相应处理了：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">...</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Request was unsuccessful: "</span> <span class="token operator">+</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这么写对于同步请求（我们前面设置 <code>open()</code> 时第三个参数是 false）来说当然没问题 —— 因为是同步的，所以一定是 send 之后，服务器那边响应结果了才会继续执行后面判断 status 的代码，那么不管请求成功还是失败，这个判断一定是可以被正常执行的。但是如果是异步请求呢？对于异步请求，不需要等待服务器响应结果我们就可以执行后面的判断了，甚至可能出现一种情况是：服务器还没来得及响应结果，判断已经先执行了。那么这时候，请求一定会失败。</p><p>也就是说，我们需要加一层判断，确保收到服务器的响应结果之后，再去判断请求成功还是失败。这里就用到前面讲过的 <code>xhr.readyState</code> 属性，readyState 会随着 AJAX 的进程而不断变化，我们可以通过 <code>onreadystatechange()</code> 去监听它的变化，进而判断何时收到服务器的响应结果。</p><p>readyState 可取值有：</p><table><thead><tr><th>状态值</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>未初始化</td><td>尚未调用 <code>open()</code> 方法</td></tr><tr><td>1</td><td>启动</td><td>已经调用 <code>open()</code> 方法，但尚未调用 <code>send()</code> 方法</td></tr><tr><td>2</td><td>发送</td><td>已经调用 <code>send()</code> 方法，但尚未接收到响应</td></tr><tr><td>3</td><td>接受</td><td>已经接收到部分响应数据</td></tr><tr><td>4</td><td>完成</td><td>已经接收到全部响应数据，而且已经可以在客户端使用了</td></tr></tbody></table><p>那么，前面的代码就变成了：</p><pre class="line-numbers language-js"><code class="language-js">xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readystate <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Request was unsuccessful: "</span> <span class="token operator">+</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-6-取消异步请求"><a href="#3-6-取消异步请求" class="headerlink" title="3.6 取消异步请求"></a>3.6 取消异步请求</h4><p>设想这么一种情况：我们正在上传一张图片（也就是发送一个 AJAX 请求），由于耗时过长，我们决定取消上传，那么取消上传其实就是取消 AJAX 请求，这是通过 <code>abort()</code> 方法实现的。一旦调用这个方法，xhr 就会停止触发事件，而且也不再允许访问任何与响应相关的对象属性。在终止请求之后，不要忘了对 xhr 对象解引用。</p><p>正常上传：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX-1.png" alt=""></p><p>取消上传：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AAJAX-2.png" alt=""></p><h3 id="4-XMLHttpRequest-2-级"><a href="#4-XMLHttpRequest-2-级" class="headerlink" title="4. XMLHttpRequest 2 级"></a>4. XMLHttpRequest 2 级</h3><h4 id="4-1-FormData"><a href="#4-1-FormData" class="headerlink" title="4.1 FormData"></a>4.1 FormData</h4><p>通常提交表单数据的时候，这些数据需要经过序列化，虽然 <code>$(&#39;#form&#39;).serialize()</code> 可以实现序列化，但对于文件流无能为力。而 <code>FormData</code> 不仅可以做到表单序列化，而且支持异步上传二进制文件。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
data<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'Sam'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// or</span>
<span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>forms<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-超时设定"><a href="#4-2-超时设定" class="headerlink" title="4.2 超时设定"></a>4.2 超时设定</h4><p>为 <code>xhr.timeout</code> 指定一个毫秒为单位的时间，一旦浏览器在这个规定的时间内没有收到响应，就会触发 <code>timeout</code> 事件，执行回调函数。</p><pre class="line-numbers language-js"><code class="language-js">xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span><span class="token number">300</span><span class="token punctuation">)</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Request was unsuccessful:"</span> <span class="token operator">+</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">//......</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'timeout.php'</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>ontimeout <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Request did not return in a second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这时候很可能出现一种情况，就是超过1秒后浏览器没收到响应，因此终止了请求，而这时候恰好 <code>xhr.status</code> 为4，因此又调用函数进行判断，这个判断需要访问 <code>xhr.status</code> 属性，而请求已经被终止，这个属性是无法访问的，此时要用 <code>try...catch...</code> 捕获这个错误。</p><h4 id="4-3-overrideMimeType-方法"><a href="#4-3-overrideMimeType-方法" class="headerlink" title="4.3 overrideMimeType() 方法"></a>4.3 overrideMimeType() 方法</h4><p>服务器返回的响应头中有一个是 <code>Content-Type</code>，用以告诉客户端返回的资源类型（MIME）以及应该用什么编码去解码。例如 <code>Content-Type:text/html;charset=UTF-8</code>，那么客户端就会通过 UTF-8 对资源进行解码，然后对资源进行 HTML 解析。<br>但可能存在一种情况：虽然服务器返回数据是 XML，但 MIME 类型指定为 <code>text/plain</code>，那么这时候客户端就会当作纯文本去处理了，这显然不对，所以我们可以利用 <code>overrideMineType()</code> 方法重写响应的 MIME 类型，这样，客户端就可以将其当作 XML 去处理了。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'text.php'</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">overrideMineType</span><span class="token punctuation">(</span><span class="token string">'text/xml'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，必须在 send 调用之前重写。</p><h4 id="4-4-进度事件"><a href="#4-4-进度事件" class="headerlink" title="4.4 进度事件"></a>4.4 进度事件</h4><p>Progress Events规范规范定义了与客户端与服务器通信相关的一系列事件，这些事件监听了通信进程中的各个关键节点，使我们能够以<strong>更细的颗粒度</strong>掌控数据传输过程中的细节。有以下6个进度事件：</p><ul><li>loadstart：在接受到响应数据的第一个字节时触发</li><li>progress：在接受响应期间持续不断地触发</li><li>error：在请求错误时触发</li><li>abort：在因为调用 <code>abort()</code> 方法而终止连接时触发</li><li>load：在接收到完整的响应数据时触发</li><li><p>loadend：在通信完成或触发 error、abort、load 事件后触发</p><p>每个请求都从触发 loadstart 事件开始，接下来是一或多个 progress 事件，然后触发 error、abort 或 load 中的一个，最后以触发 loadend 事件结束。</p></li></ul><p>有没有发现，前面的 <code>xhr.readyState == 4</code> 以及这里的 <code>load</code> 事件都可以判断是否接受到完整响应？ <code>load</code> 事件实际上简化了这个过程，它不需要像前者那样，既绑定一个监听函数又做一次 <code>readyState</code> 的判断，而只需要绑定监听函数即可。</p><pre class="line-numbers language-js"><code class="language-js">xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//....</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 变成</span>
xhr<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//....</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-同源策略"><a href="#5-同源策略" class="headerlink" title="5. 同源策略"></a>5. 同源策略</h3><blockquote><p>浏览器的同源策略即 Same-Origin Policy （SOP），它限制了不同源之间执行特定操作。</p></blockquote><h4 id="5-1-源"><a href="#5-1-源" class="headerlink" title="5.1 源"></a>5.1 源</h4><p>一个源由<strong>协议</strong>、<strong>端口</strong>、<strong>域名</strong>组成，只要有一个不同，就认为是不同源。</p><p>以 <a href="http://test.com/dist/demo.html" target="_blank" rel="noopener">http://test.com/dist/demo.html</a> 为例，不同源以及同源可能有以下情况：</p><table><thead><tr><th>类型</th><th>URL</th><th>结果</th></tr></thead><tbody><tr><td>不同协议</td><td><a href="https://test.com/dist/demo.html" target="_blank" rel="noopener">https://test.com/dist/demo.html</a></td><td>失败</td></tr><tr><td>不同端口</td><td><a href="http://test.com:80/dist/demo.html" target="_blank" rel="noopener">http://test.com:80/dist/demo.html</a></td><td>失败</td></tr><tr><td>不同域名</td><td><a href="http://test.cn/dist/demo.html" target="_blank" rel="noopener">http://test.cn/dist/demo.html</a> 或者 <a href="http://www.test.com/dist/demo.html" target="_blank" rel="noopener">http://www.test.com/dist/demo.html</a></td><td>失败</td></tr><tr><td>不同路径</td><td><a href="http://test.com/dist2/demo.html" target="_blank" rel="noopener">http://test.com/dist2/demo.html</a></td><td>成功</td></tr></tbody></table><h4 id="5-2-特定操作："><a href="#5-2-特定操作：" class="headerlink" title="5.2 特定操作："></a>5.2 特定操作：</h4><p>特定操作指的是：</p><ul><li>读取 Cookie、LocalStorage、IndexDB</li><li>获取 DOM 元素</li><li>发送 AJAX 请求</li></ul><p>为什么同源策略要禁止不同源之间进行这些操作呢？我们不妨假设一下，不存在同源策略、且不同源之间这些操作是允许的，看看可能会发生什么事。</p><ul><li><p>我A源可以读取B源的 Cookie、LocalStorage、IndexDB，那么等于B源存储的信息都暴露了，所以同源策略禁止不同源之间读取 Cookie、LocalStorage、IndexDB；</p></li><li><p>A源可以获取B源的 DOM 元素。那么假定用户访问了我在A源中用 iframe 引入的B源网页，他的所有操作都会在我们的掌握之中，因为我们可以在A源操作B源的 DOM 元素；</p></li><li><p>A 源可以自由发送 AJAX 请求给B源。假定现在有一个用户首先登录了 <a href="">Bank.com</a>，那么本地客户端的 Cookie 就会记录用户在该网站的身份信息，之后用户不小心点进了危险网站 <a href="">Evil.com</a>，这个网站做了一些设置，一旦用户进入，就自动发送 AJAX 请求给 <a href="">Bank.com</a>，由于发送请求的时候，浏览器会自动在本地检索目标网站的 Cookie ，并添加到请求报文中，所以此时目标网站的 Cookie 被请求携带着发送过去了，而 <a href="">Bank.com</a> 的响应头又是携带着 Cookie 返回的，那么这时候等于 <a href="">Evil.com</a> 已经拿到了这个 Cookie。也就是说，发送请求前它确实拿不到这个 Cookie（是浏览器给请求报文加上的，不是我们），但接受到响应后它的的确确拿到了，于是事情一发不可收拾……</p></li></ul><h3 id="6-跨域通信"><a href="#6-跨域通信" class="headerlink" title="6. 跨域通信"></a>6. 跨域通信</h3><p>这样看来，同源策略确实很有存在的必要，不然网络安全无从谈起。等等，既然有同源策略的限制，那我A域怎么去请求B域中的资源呢？也就是说，要怎么解决跨域通信的问题呢？</p><p>参考：</p><ul><li>《JavaScript 高级程序设计》第三版</li><li><a href="https://juejin.im/post/5a20b1f1f265da432529179c#heading-16" target="_blank" rel="noopener">再也不学AJAX了！（二）使用AJAX</a></li></ul></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/11/07/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="prev" title="AJAX 与跨域通信（二）：跨域解决方案"><i class="fa fa-angle-double-left"></i>&nbspAJAX 与跨域通信（二）：跨域解决方案</a></div><div class="post-nav-next"><a href="/2019/10/26/F-%E4%BD%BF%E7%94%A8Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/" rel="next" title="使用 Vue 脚手架搭建项目">使用 Vue 脚手架搭建项目&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AJAX-解决了什么问题？"><span class="toc-text">1.AJAX 解决了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-XMLHttpRequest-对象"><span class="toc-text">2.XMLHttpRequest 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AJAX-请求"><span class="toc-text">3.AJAX 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-创建-XML-对象的实例："><span class="toc-text">3.1 创建 XML 对象的实例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-准备请求"><span class="toc-text">3.2 准备请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-设置请求头"><span class="toc-text">3.3 设置请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-发送请求"><span class="toc-text">3.4 发送请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-处理响应"><span class="toc-text">3.5 处理响应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-取消异步请求"><span class="toc-text">3.6 取消异步请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-XMLHttpRequest-2-级"><span class="toc-text">4. XMLHttpRequest 2 级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-FormData"><span class="toc-text">4.1 FormData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-超时设定"><span class="toc-text">4.2 超时设定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-overrideMimeType-方法"><span class="toc-text">4.3 overrideMimeType() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-进度事件"><span class="toc-text">4.4 进度事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-同源策略"><span class="toc-text">5. 同源策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-源"><span class="toc-text">5.1 源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-特定操作："><span class="toc-text">5.2 特定操作：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-跨域通信"><span class="toc-text">6. 跨域通信</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->