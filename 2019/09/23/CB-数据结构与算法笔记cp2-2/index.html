<!-- build time:Tue Oct 22 2019 13:51:48 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Chor&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third party/pace-theme-flash.css"><link rel="icon" href="/images/me.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="header"><div class="header_top"><span class="theme"><i class="fa fa-bars"></i> <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">HOME</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">CATEGORIES</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">ARCHIVES</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">TAGS</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">ABOUT</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="/" class="logo">Chor&#39;s Blog</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">数据结构与算法笔记 cp2-2：线性表</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-09-23&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.9k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/数据结构/">数据结构</a> <a href="/tags/算法/">算法</a></div></div><div class="post-content"><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/数据结构与算法笔记cp2：线性表-0.jpg" alt=""><br><a id="more"></a></p><h2 id="线性表的链式存储结构-链表"><a href="#线性表的链式存储结构-链表" class="headerlink" title="线性表的链式存储结构 / 链表"></a>线性表的链式存储结构 / 链表</h2><h3 id="1-1-定义："><a href="#1-1-定义：" class="headerlink" title="1.1 定义："></a>1.1 定义：</h3><blockquote><p>线性表的链式存储结构不限制数据元素的物理存储状态，也就是说，其数据元素的物理位置是随机的。</p></blockquote><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-4.png" alt=""></p><p>对于每一个元素来说，它需要存储自身信息在<strong>数据域</strong>中，还需要存储直接后继的位置信息在<strong>指针域</strong>中，这两部分信息共同构成一个结点（Node）。n 个结点就<br>链结成一个<strong>链表</strong>，如果每一个结点只有一个指针域，那么它就是单链表。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-5.png" alt=""></p><p><strong>头指针</strong>：头指针保存第一个结点（首元结点）的存储位置，因为最后一个结点没有后继结点，所以它的指针域为空(<code>NULL</code> / <code>^</code>)。</p><p><strong>头结点</strong>：有时候，首元结点前还会设置一个头结点，有头结点的时候，头指针保存的是头结点的存储位置。对于头结点，其数据域不一定要包含信息，其指针域则保存的是首元结点的存储位置。如下图所示：</p><p>Tip: 设计头结点是为了操作的统一。</p><p>链表并不是<strong>随机存取结构</strong>，并不能根据一个给定元素就能马上找到另一个目标元素，而是只能从头指针开始顺链查找，这称为<strong>顺序存取结构</strong>。</p><h3 id="1-2-单链表："><a href="#1-2-单链表：" class="headerlink" title="1.2 单链表："></a>1.2 单链表：</h3><p>在开始之前，我们还是先定义单链表中每个结点的结构：</p><pre><code class="c">typedef struct Link{
    char elem; // 数据域
    struct Link * next; // 指针域
}link; // link为结点名，每个结点都是一个 link 结构体
</code></pre><p>Tip：因为指针也是指向一个结点，这里尤其要注意将指针类型声明为 <code>struct Link</code></p><p><strong>(1) 初始化空表：</strong></p><pre><code class="c">link * initLink(){
    link * p=(link*)malloc(sizeof(link));// 创建一个头结点
    link * temp=p;// 声明头指针并指向头结点
    temp-&gt;next=NULL; // 头结点的指针域置空
    return p;
}
</code></pre><p><strong>(2) 整表创建：</strong></p><p>例如，创建一个存储 {1,2,3,4} 且无头结点的链表：</p><pre><code class="c">link * initLink(){
    link * temp = (link*)malloc(sizeof(link));// 创建首元结点
    link * p = temp;// 创建头指针并指向首元结点

    // 首元节点先初始化
    temp-&gt;elem = 1;
    temp-&gt;next = NULL;

    // 从第二个节点开始创建
    for (int i=2; i&lt;5; i++) {
     // 创建一个新节点并初始化
        link *a=(link*)malloc(sizeof(link));
        a-&gt;elem=i;
        a-&gt;next=NULL;
        // 将temp节点与新建立的a节点建立逻辑关系
        temp-&gt;next=a;
        // 指针temp每次都指向新链表的最后一个节点
        temp=temp-&gt;next;
    }
    //返回建立的节点，只返回头指针 p 即可，通过头指针即可找到整个链表
    return p;
}
</code></pre><p><strong>(3) 查找元素：</strong></p><pre><code class="c">p 为原链表，elem 表示被查找的元素
int selectElem(link * p,int elem){
    // 新建一个指针，直接指向首元结点
    link * t = p-&gt;next;
    while(t &amp;&amp; t-&gt;elem!= elem){
        t=t-&gt;next;
    }
    return p;
}
</code></pre><p>因为存在头结点，所以这里首先获取首元结点，然后从首元结点开始依次往后面遍历，查找是否有符合的元素。如果查找成功，返回的 p 是元素的地址，查找失败则返回 NULL。</p><p><strong>(4) 修改元素：</strong></p><pre><code class="c">// add 表示更改结点在链表中的位置，newElem 为新的数据域的值
link *amendElem(link * p,int add,int newElem){
    link * temp=p-&gt;next;
    // 遍历到被删除结点
    for (int i=1; i&lt;add; i++) {
        temp=temp-&gt;next;
    }
    temp-&gt;elem=newElem;
    return p;
}
</code></pre><p><strong>(5) 删除元素：</strong><br>包括两步，一个是摘除结点并改变连接，一个是释放被摘除结点的内存。关键代码是：</p><pre><code class="c">temp-&gt;next=temp-&gt;next-&gt;next;
</code></pre><p>如下图所示：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-6.png" alt=""></p><p>具体实现代码是：</p><pre><code class="c">//p为原链表，add为要删除元素的值
link * delElem(link * p,int add){
    // temp 首先指向首元结点
    link * temp=p;
    // 先寻找被删除结点的上一个结点
    for (int i=1; i&lt;add-1; i++) {
        temp=temp-&gt;next;
    }
    link * del=temp-&gt;next;// 单独设置一个指针指向被删除结点，后面方便释放其内存
    temp-&gt;next=temp-&gt;next-&gt;next;
    free(del);// 手动释放该结点，防止内存泄漏
    return p;
}
</code></pre><p>注意这是没有头结点的情况，如果有头结点，循环判断应该是 i&lt;add，因为这时候的 temp 指向的是头结点。</p><p><strong>(6) 插入元素：</strong><br>包括两步，一个是将插入位置后的结点作为新结点的 next，一个是将新结点作为插入位置前的结点的 next，也就是关键代码：</p><pre><code class="c">new-&gt;next=temp-&gt;next;
temp-&gt;next=new;
</code></pre><p>如下图所示：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-7.png" alt=""></p><p>注意：这里顺序不能颠倒，如果是先确定插入位置前结点和新结点的连接，那么插入位置后结点将无法获取，因为其获取是依赖于插入位置前结点的next的，而这个next已经被覆盖。</p><p>具体代码为：</p><pre><code class="c">// p为原链表，elem表示新数据元素，add表示新元素插入的位置
link * insertElem(link * p,int elem,int add){
    link * temp=p;// 创建指向头结点的指针
    // 遍历寻找插入位置前的结点
    for(int i=1;i&lt;add;i++){
        if(temp==NULL){
            printf(&quot;插入位置无效\n&quot;);
            return p;
        }
        temp=temp-&gt;next;
    }
    // 创建新结点并初始化
    link * c=(link*)malloc(sizeof(link));
    c-&gt;elem=elem;
    // 改变连接关系
    c-&gt;next=temp-&gt;next;
    temp-&gt;next=c;
    return p;
}
</code></pre><p>if 语句用来判断 add 是否合法，因为如果 add 过大，那么一直遍历下去会得到一个 next 为 NULL 的temp，之后报错。</p><h3 id="1-3-循环链表："><a href="#1-3-循环链表：" class="headerlink" title="1.3 循环链表："></a>1.3 循环链表：</h3><p>当单链表中最后一个结点的指针域不为空，而是<strong>指向头结点</strong>的时候，就形成一个环，这叫循环链表。循环链表进行元素遍历的时候，循环终止条件不再是 <code>p-&gt;next=NULL</code>，而是 <code>p-&gt;next=L</code>。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/数据结构与算法笔记cp2：线性表-8.png" alt=""></p><p>如果使用尾指针，那么可以用O(1)的时间找到尾结点和首元结点，而且可以简化合并两个循环链表的过程：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/数据结构与算法笔记cp2：线性表-9.png" alt=""></p><p>对于上面这两个循环链表，合并的思路大概是：A表尾连B表头。所以这里要改变 rearA-&gt;next，事先要先保存一开始的 rearA-&gt;next，即A表的头结点，之后将B表的首元结点给 rearA-&gt;next；之后我们要将一开始保留的A表头结点作为 rearB-&gt;next，事先要先保存一开始的 rearA-&gt;next，即B表的头结点，方便最后释放内存。</p><p>用图片表示的思路是：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/数据结构与算法笔记cp2：线性表-10.png" alt=""></p><p>用代码表示的思路是：</p><pre><code class="c">p=rearA-&gt;next;
rearA-&gt;next=rearB-&gt;next-&gt;next;
reerB-&gt;next=p;
free(p);
</code></pre><h3 id="1-4-双向链表"><a href="#1-4-双向链表" class="headerlink" title="1.4 双向链表"></a>1.4 双向链表</h3><p>单链表的每一个结点中，额外多出一个指向前驱结点的指针域，这时候就成了双向链表。双向链表的尾结点指针域指向头结点时，就成了双向循环链表，如下图：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/数据结构与算法笔记cp2：线性表-11.png" alt=""></p><p><strong>插入操作</strong></p><p>插入操作一定要注意顺序，我们可以先处理新结点的前驱和后继，之后再依次处理后结点、前结点。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/数据结构与算法笔记cp2：线性表-12.png" alt=""></p><pre><code class="c">// 新结点的前驱后继
s-&gt;prior = p;
s-&gt;next = p-&gt;next;
// 后结点
p-&gt;next-&gt;prior = s;
// 前结点
p-&gt;next = s;
</code></pre><p><strong>删除操作</strong></p><p>删除很简单，如下图把中间的p删除，那么对于后结点，我们要修复它的前驱指针；对于前结点，我们要修复它的后继指针，最后一步是释放被删除结点的内存</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/数据结构与算法笔记cp2：线性表-13.png" alt=""></p><pre><code class="c">p-&gt;prior-&gt;next = p-&gt;next;
p-&gt;next-prior = p-&gt;prior;
</code></pre></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/09/28/F-用 key 管理可复用元素/" rel="prev" title="用 :key 管理可复用元素"><i class="fa fa-angle-double-left"></i>&nbsp用 :key 管理可复用元素</a></div><div class="post-nav-next"><a href="/2019/09/22/CB-数据结构与算法笔记cp2-1/" rel="next" title="数据结构与算法笔记 cp2-1：线性表">数据结构与算法笔记 cp2-1：线性表&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top"><i class="fa fa-th-large"></i>Catalog</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表的链式存储结构-链表"><span class="toc-text">线性表的链式存储结构 / 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-定义："><span class="toc-text">1.1 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-单链表："><span class="toc-text">1.2 单链表：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-循环链表："><span class="toc-text">1.3 循环链表：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-双向链表"><span class="toc-text">1.4 双向链表</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/search.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:150,height:300,vOffset:-120,hOffset:-5},mobile:{show:!1},react:{opacityDefault:1e3,opacityOnHover:1e3},log:!1})</script></body></html><!-- rebuild by neat -->