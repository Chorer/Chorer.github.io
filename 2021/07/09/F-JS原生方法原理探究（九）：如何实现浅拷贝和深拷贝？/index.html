<!-- build time:Sat Jul 10 2021 15:31:40 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">JS 原生方法原理探究（九）：如何手写实现浅拷贝和深拷贝？</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-07-09&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp13 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><a id="more"></a><blockquote><p>这是JS 原生方法原理探究系列的第九篇文章。本文会介绍如何手写实现浅拷贝和深拷贝。</p></blockquote><h2 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h2><h3 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h3><p>对原对象进行浅拷贝，会生成一个和它“一样”的新对象。但是这种拷贝只会拷贝原对象第一层的基本类型属性，引用类型属性仍然和原对象共享同一个。</p><p>用一个简单的例子来理解：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token string">'Jack'</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        c<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>obj1<span class="token punctuation">)</span>
obj1<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'Tom'</span>
obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>a<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 'Tom'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>a<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 'Jack'   </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，因为新对象拷贝了原对象第一层的基本类型属性，所以修改 <code>obj1.a</code> 的值并不会影响 <code>obj2.a</code> 的值；同时，因为新对象和原对象共享同一个第一层的引用类型属性，所以修改 <code>obj1.b</code> 对象也会影响到 <code>obj2.b</code> 对象。</p><h3 id="如何实现浅拷贝？"><a href="#如何实现浅拷贝？" class="headerlink" title="如何实现浅拷贝？"></a>如何实现浅拷贝？</h3><p>JS 中常见的浅拷贝方法有 <code>Object.assign()</code>、<code>...</code> 展开运算符以及数组的 <code>slice</code> 方法。但是如果我们要自己实现一个浅拷贝，应该怎么做呢？</p><p>其实也很简单，因为浅拷贝只作用在第一层，所以只需要遍历原对象，将它的每一个成员添加到新对象上就行。这里说的原对象指的是对象字面量、数组、类数组对象、Set 以及 Map 这些可以遍历的对象。对于其它的不可遍历对象以及基本类型的值直接将其返回即可。</p><p>代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getType</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toSrting<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 可以遍历的数据类型</span>
<span class="token keyword">let</span> iterableList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Object'</span><span class="token punctuation">,</span><span class="token string">'Array'</span><span class="token punctuation">,</span><span class="token string">'Arguments'</span><span class="token punctuation">,</span><span class="token string">'Set'</span><span class="token punctuation">,</span><span class="token string">'Map'</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">// 浅拷贝</span>
<span class="token keyword">function</span> <span class="token function">shallowCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> type <span class="token operator">=</span> <span class="token function">getType</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>iterableList<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 如果是 Set 或者 Map</span>
    obj<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        type <span class="token operator">===</span> <span class="token string">'Set'</span> <span class="token operator">?</span> res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">:</span> res<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>        
    <span class="token comment" spellcheck="true">// 如果是对象字面量、类数组对象或者数组</span>
    Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>        
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些要点：</p><ul><li>初始化新对象 <code>res</code>：获取原对象 <code>obj</code> 的构造函数，用于创建一个和原对象同类型的实例</li><li>这里遍历对象或者数组有三种方式，第一种是使用 <code>Reflect.ownKeys()</code> 获取自身所有属性（无论是否可以枚举），第二种是使用 <code>for……in</code> + <code>hasOwnProperty()</code> 获取自身所有可枚举属性，第三种是使用 <code>Object.keys()</code> 一次性获取自身所有可枚举属性</li></ul><h2 id="实现对象深拷贝"><a href="#实现对象深拷贝" class="headerlink" title="实现对象深拷贝"></a>实现对象深拷贝</h2><h3 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h3><p>对原对象进行深拷贝，会生成一个和它“一样”的新对象。深拷贝会拷贝原对象所有层级上的基本类型属性和引用类型属性。还是通过一个例子理解一下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token string">'Jack'</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        c<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span>
obj1<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'Tom'</span>
obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>a<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 'Tom'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>a<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 'Jack'   </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，无论对 <code>obj1</code> 作出什么修改，都不会影响到 <code>obj2</code>，反之亦然，两者是完全独立的。</p><h3 id="如何实现深拷贝？"><a href="#如何实现深拷贝？" class="headerlink" title="如何实现深拷贝？"></a>如何实现深拷贝？</h3><p>常见的实现深拷贝的方式是 <code>JSON.parse(JSON.stringify())</code>。它可以应付一般的深拷贝场景，但是也存在着不少问题，这些问题基本都是出现在序列化的环节。</p><ol><li><p>Date 类型的属性经过深拷贝之后会变成字符串：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    date <span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// {date: "2021-07-04T13:01:35.934Z"}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>正则类型和错误类型的属性经过深拷贝之后会变成空对象：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    reg <span class="token punctuation">:</span> <span class="token regex">/\d+/gi</span><span class="token punctuation">,</span>
    error <span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// {reg:{},error:{}}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果 key 的 value 是函数类型、 <code>undefined</code> 类型、<code>Symbol</code> 类型，则经过深拷贝之后会丢失：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 如果是对象，属性直接丢失</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    name<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>
    sym<span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    age<span class="token punctuation">:</span> <span class="token number">12</span>
<span class="token punctuation">}</span>
JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// {age:12}</span>
<span class="token comment" spellcheck="true">// 如果是数组，则变为 "null"</span>
<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    undefined<span class="token punctuation">,</span>
    <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token number">12</span>
<span class="token punctuation">]</span>
JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//  ["null","null","null"12]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果 key 是 <code>Symbol</code> 类型，则经过深拷贝之后会丢失：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span>
obj<span class="token punctuation">[</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// {a:1}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>NaN</code>、<code>Infinity</code>、<code>-Infinity</code> 经过深拷贝之后会变成 null</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span><span class="token number">NaN</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span><span class="token number">Infinity</span><span class="token punctuation">,</span>
    c<span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">Infinity</span>
<span class="token punctuation">}</span>
JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// {a:null,b:null,c:null}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>可能导致 <code>constructor</code> 指向丢失：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> obj2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// Super</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// Object   </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>JSON.stringify()</code> 只能序列化对象自身的可枚举属性，而 <code>constructor</code> 并不是实例对象自身的属性，而是实例的原型对象的属性。因此在序列化实例对象 obj1 的时候，实际上并不会去处理 <code>constructor</code> 的指向，这样，它的指向就成为了默认的 Object。</p></li><li><p>存在循环引用的问题</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>a <span class="token operator">=</span> obj
JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的 obj 对象存在循环引用，也就是说，它是一个环状结构（非树状）的对象，这样的对象是无法转化为 JSON 的，因此会报错：can’t convert circular structure to JSON。</p></li></ol><p>此外，我们也可以考虑使用 Lodash 提供的深拷贝方法。不过，如果要自己实现深拷贝，应该怎么做呢？我们一步一步来看。</p><h4 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h4><p>深拷贝的核心其实就是==浅拷贝 + 递归==，不管层级嵌套有多深，我们总可以通过不断的递归到达对象的最里层，完成基本类型属性以及不可遍历的引用类型属性的拷贝。</p><p>下面是最基础的深拷贝版本：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> cloneTarget <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            cloneTarget<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> cloneTarget
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> target
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里只考虑数组和对象字面量的情况。根据初始传入的 <code>target</code> 是一个对象字面量还是数组，决定最终返回的 <code>cloneTarget</code> 是对象还是数组。接着遍历 <code>target</code> 的每一个自身属性，递归调用 <code>deepClone</code>，如果属性已经是基本类型，则直接返回；如果还是对象或者数组，就和初始的 <code>target</code> 进行一样的处理。最后，把处理好的结果一一添加给 <code>cloneTarget</code>。</p><h4 id="解决循环引用导致的爆栈问题"><a href="#解决循环引用导致的爆栈问题" class="headerlink" title="解决循环引用导致的爆栈问题"></a>解决循环引用导致的爆栈问题</h4><p>但是，这里存在一个循环引用的问题。</p><p>假设深拷贝的目标是下面这样的对象：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>a <span class="token operator">=</span> obj
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样的对象，结构中存在回环，即存在循环引用：<code>obj</code> 通过属性 a 引用了自身，而 a 也一定会有一个属性 a 再次引用自身 …… 最终会导致 <code>obj</code> 无限嵌套下去。而深拷贝的过程中因为用到了递归，无限嵌套的对象就会导致无限的递归，不断地压栈最终会导致堆栈溢出。</p><p>如何解决循环引用带来的爆栈问题呢？其实也很简单，<strong>只需要给递归创建一个出口即可</strong>。对于初次传入的对象或者数组，会用一个 WeakMap 记录当前目标和拷贝结果的映射关系，当检测到再次传入相同的目标时，就不再进行重复的拷贝，而是直接从 WeakMap 中取出它对应的拷贝结果返回。</p><blockquote><p>这里的“返回”其实就给递归创建了一个出口，因此不会无限递归下去，也就不会爆栈了。</p></blockquote><p>因此改进后的代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> target <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> cloneTarget <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 处理循环引用的问题</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
        map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>cloneTarget<span class="token punctuation">)</span>
        Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            cloneTarget<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>map<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> cloneTarget
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> target
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="处理其它数据类型"><a href="#处理其它数据类型" class="headerlink" title="处理其它数据类型"></a>处理其它数据类型</h4><p>始终记住，我们要处理的是三类目标：</p><ul><li>基本数据类型：直接返回即可</li><li>可以继续遍历的引用数据类型：除了上面已经处理的对象字面量和数组，还有类数组对象、Set、Map 。它们都属于可以继续遍历的、可能存在嵌套的引用类型，因此在处理的时候就需要递归</li><li>不能继续遍历的引用数据类型：包括函数、错误对象、日期对象、正则对象、基本类型的包装对象（String、Boolean、Symbol、Number）等。它们是不能继续遍历的，或者说是“没有层级嵌套”的，因此再处理的时候需要拷贝一份一样的副本返回</li></ul><h5 id="1）类型判断函数"><a href="#1）类型判断函数" class="headerlink" title="1）类型判断函数"></a>1）类型判断函数</h5><p>为了更好地判断是引用数据类型还是基本数据类型，可以使用一个 <code>isObject</code> 函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isObject</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> o <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> o <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> o <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了更准确地判断具体是什么数据类型，可以使用一个 <code>getType</code> 函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getType</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// getType(1)      "Number"</span>
<span class="token comment" spellcheck="true">// getType(null)   "Null"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2）初始化函数"><a href="#2）初始化函数" class="headerlink" title="2）初始化函数"></a>2）初始化函数</h5><p>之前深拷贝对象字面量或者数组的时候，首先会将最终返回的结果 <code>cloneTarget</code> 初始化为 <code>[]</code> 或者 <code>{}</code>。同样地，对于 Set、Map 以及类数组对象，也需要进行相同的操作，所以最好用一个函数统一实现 <code>cloneTarget</code> 的初始化。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initCloneTarget</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">target<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过 <code>target.constructor</code> 可以获得传进来的实例的构造函数，利用这个构造函数新创建一个同类型的实例并返回。</p><h5 id="3）处理可以继续遍历的引用类型：类数组对象、Set、Map"><a href="#3）处理可以继续遍历的引用类型：类数组对象、Set、Map" class="headerlink" title="3）处理可以继续遍历的引用类型：类数组对象、Set、Map"></a>3）处理可以继续遍历的引用类型：类数组对象、Set、Map</h5><p>类数组对象，其实和数组以及对象字面量的形式差不多，所以可以一块处理；处理 Set 和 Map 的流程也基本一样，但是不能采用直接赋值的方式，而要使用 <code>add</code> 方法或者 <code>set</code> 方法，所以稍微改进一下。</p><p>代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果是基本类型，直接返回即可</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> target   

    <span class="token comment" spellcheck="true">// 初始化返回结果</span>
    <span class="token keyword">let</span> type <span class="token operator">=</span> <span class="token function">getType</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">let</span> cloneTarget <span class="token operator">=</span> <span class="token function">initCloneTarget</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// 处理循环引用</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>cloneTarget<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// 处理 Set    </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'Set'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        target<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            cloneTarget<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">deepClone</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 处理 Map</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'Map'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        target<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            cloneTarget<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token function">deepClone</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 处理对象字面量、数组、类数组对象</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'Object'</span> <span class="token operator">||</span> type <span class="token operator">===</span> <span class="token string">'Array'</span> <span class="token operator">||</span> type <span class="token operator">===</span> <span class="token string">'Arguments'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            cloneTarget<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>map<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> cloneTarget
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4）处理不能继续遍历的引用类型"><a href="#4）处理不能继续遍历的引用类型" class="headerlink" title="4）处理不能继续遍历的引用类型"></a>4）处理不能继续遍历的引用类型</h5><p>现在来处理不能继续遍历的引用类型。对于这样的目标，我们不能像基本数据类型那样直接返回，因为它们本质上也是对象，直接返回将返回相同的引用，并没有达到拷贝的目的。正确的做法，应该是拷贝一份副本再返回。</p><p>如何拷贝呢？这里又分为两种情况。其中，String、Boolean、Number、错误对象、日期对象都可以通过 new 的方式返回一个实例副本；而 Symbol、函数、正则对象的拷贝则无法通过简单的 new 拷贝副本，需要单独处理。</p><p><strong>拷贝 Symbol</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">cloneSymbol</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">Object</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    
    <span class="token comment" spellcheck="true">// 或者</span>
    <span class="token keyword">return</span> <span class="token function">Object</span><span class="token punctuation">(</span>Symbol<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>valueOf<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 或者</span>
    <span class="token keyword">return</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token function">Symbol</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PS：这里的 <code>target</code> 是 Symbol 基本类型的包装类型，调用 <code>valueOf</code> 可以获得它对应的拆箱结果，再把这个拆箱结果传给 Object，就可以构造原包装类型的副本了；为了保险起见，可以通过 Symbol 的原型调用 <code>valueOf</code>；可以通过 <code>.description</code> 获得 symbol 的描述符，基于此也可以构造原包装类型的副本。</p><p><strong>拷贝正则对象（参考 lodash 的做法）</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">cloneReg</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> reFlags <span class="token operator">=</span> <span class="token regex">/\w*$/</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>source<span class="token punctuation">,</span> reFlags<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span>lastIndex <span class="token operator">=</span> target<span class="token punctuation">.</span>lastIndex<span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>拷贝函数（实际上函数没有必要拷贝）</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">cloneFunction</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 或者</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`return (</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)()`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PS：传给 new Function 的参数声明了新创建的函数实例的函数体内容</p><p>接下来，用一个 <code>directCloneTarget</code> 函数处理以上所有情况：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">directCloneTarget</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> _constructor <span class="token operator">=</span> target<span class="token punctuation">.</span>constructor
    <span class="token keyword">switch</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">case</span> <span class="token string">'String'</span><span class="token punctuation">:</span>
        <span class="token keyword">case</span> <span class="token string">'Boolean'</span><span class="token punctuation">:</span>
        <span class="token keyword">case</span> <span class="token string">'Number'</span><span class="token punctuation">:</span>
        <span class="token keyword">case</span> <span class="token string">'Error'</span><span class="token punctuation">:</span>
        <span class="token keyword">case</span> <span class="token string">'Date'</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">_constructor</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 或者</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span>_constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>valueOf<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">case</span> <span class="token string">'RegExp'</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token function">cloneReg</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>        
        <span class="token keyword">case</span> <span class="token string">'Symbol'</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token function">cloneSymbol</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>        
        <span class="token keyword">case</span> <span class="token string">'Function'</span><span class="token punctuation">:</span>            
            <span class="token keyword">return</span> <span class="token function">cloneFunction</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> 
        <span class="token keyword">default</span><span class="token punctuation">:</span>            
            <span class="token keyword">return</span> <span class="token keyword">null</span>        
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PS：注意这里有一些坑。</p><ul><li>为什么使用 <code>return new _constructor(target.valueOf())</code> 而不是 <code>return new _constructor(target)</code> 呢？因为如果传进来的 <code>target</code> 是 <code>new Boolean(false)</code>，那么最终返回的实际上是 <code>new Boolean(new Boolean(false))</code> ，由于参数并非空对象，因此它的值对应的不是期望的 false，而是 true。所以，最好使用 <code>valueOf</code> 获得包装类型对应的真实值。</li><li>也可以不使用基本类型对应的构造函数 <code>_constructor</code>，而是直接 <code>new Object(target.valueOf())</code> 对基本类型进行包装</li><li>考虑到 valueOf 可能被重写，为了保险起见，可以通过基本类型对应的构造函数 <code>_constructor</code> 去调用 valueOf 方法</li></ul><h4 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h4><p>最后的代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> objectToInit <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Object'</span><span class="token punctuation">,</span><span class="token string">'Array'</span><span class="token punctuation">,</span><span class="token string">'Set'</span><span class="token punctuation">,</span><span class="token string">'Map'</span><span class="token punctuation">,</span><span class="token string">'Arguments'</span><span class="token punctuation">]</span>

<span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isObject</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> target    
    <span class="token comment" spellcheck="true">// 初始化</span>
    <span class="token keyword">let</span> type <span class="token operator">=</span> <span class="token function">getType</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token keyword">let</span> cloneTarget
    <span class="token keyword">if</span><span class="token punctuation">(</span>objectToInit<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        cloneTarget <span class="token operator">=</span> <span class="token function">initCloneTarget</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">directCloneTarget</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>type<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
     <span class="token comment" spellcheck="true">// 解决循环引用   </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
    map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>cloneTarget<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 拷贝 Set</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'Set'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        target<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            cloneTarget<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">deepClone</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 拷贝 Map</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'Map'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        target<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            cloneTarget<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token function">deepClone</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 拷贝对象字面量、数组、类数组对象</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">===</span> <span class="token string">'Object'</span> <span class="token operator">||</span> type <span class="token operator">===</span> <span class="token string">'Array'</span> <span class="token operator">||</span> type <span class="token operator">===</span> <span class="token string">'Arguments'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
            cloneTarget<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span>map<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> cloneTarget
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="post-nav"><div class="post-nav-prev"></div><div class="post-nav-next"><a href="/2021/07/08/F-JS%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20JSON.stringify()%EF%BC%9F/" rel="next" title="JS 原生方法原理探究（八）：如何实现 JSON.stringify()？">JS 原生方法原理探究（八）：如何实现 JSON.stringify()？&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现浅拷贝"><span class="toc-text">实现浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是浅拷贝？"><span class="toc-text">什么是浅拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何实现浅拷贝？"><span class="toc-text">如何实现浅拷贝？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现对象深拷贝"><span class="toc-text">实现对象深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是深拷贝？"><span class="toc-text">什么是深拷贝？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何实现深拷贝？"><span class="toc-text">如何实现深拷贝？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基础版本"><span class="toc-text">基础版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决循环引用导致的爆栈问题"><span class="toc-text">解决循环引用导致的爆栈问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理其它数据类型"><span class="toc-text">处理其它数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1）类型判断函数"><span class="toc-text">1）类型判断函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2）初始化函数"><span class="toc-text">2）初始化函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3）处理可以继续遍历的引用类型：类数组对象、Set、Map"><span class="toc-text">3）处理可以继续遍历的引用类型：类数组对象、Set、Map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4）处理不能继续遍历的引用类型"><span class="toc-text">4）处理不能继续遍历的引用类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最终版本"><span class="toc-text">最终版本</span></a></li></ol></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->