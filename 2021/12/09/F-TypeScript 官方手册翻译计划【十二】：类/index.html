<!-- build time:Fri Dec 10 2021 20:28:05 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/prism.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">TypeScript 官方手册翻译计划【十二】：类</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-12-09&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp34 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/TypeScript/">TypeScript</a> <a href="/tags/documentation/">documentation</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/TypeScript%20%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/banner.jpeg" alt=""></p><span id="more"></span><blockquote><ul><li><strong>说明</strong>：目前网上没有 TypeScript 最新官方文档的中文翻译，所以有了这么一个翻译计划。因为我也是 TypeScript 的初学者，所以无法保证翻译百分之百准确，若有错误，欢迎评论区指出；</li><li><strong>翻译内容</strong>：暂定翻译内容为 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/intro.html">TypeScript Handbook</a>，后续有空会补充翻译文档的其它部分；</li><li><strong>项目地址</strong>：<a target="_blank" rel="noopener" href="https://github.com/Chorer/TypeScript-Doc-Zh">TypeScript-Doc-Zh</a>，如果对你有帮助，可以点一个 star ~</li></ul></blockquote><p>本章节官方文档地址：<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/classes.html">Classes</a></p><blockquote><p>背景导读：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">类（MDN）</a></p></blockquote><h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2><p>TypeScript 为 ES2015 引入的 <code>class</code> 关键字提供了全面的支持。</p><p>就像其它的 JavaScript 语言特性一样，TypeScript 也为类提供了类型注解和其它语法，以帮助开发者表示类和其它类型之间的关系。</p><h3 id="类成员"><a class="markdownIt-Anchor" href="#类成员"></a> 类成员</h3><p>这是一个最基本的类 —— 它是空的：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Point &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个类目前没有什么用，所以我们给它添加一些成员吧。</p><h4 id="字段"><a class="markdownIt-Anchor" href="#字段"></a> 字段</h4><p>声明字段相当于是给类添加了一个公共的、可写的属性：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Point &#123;
    x: number;
    y: number;
&#125;
const pt &#x3D; new Point()
pt.x &#x3D; 0;
pt.y &#x3D; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和其它特性一样，这里的类型注解也是可选的，但如果没有指定类型，则会隐式采用 <code>any</code> 类型。</p><p>字段也可以进行初始化，初始化过程会在类实例化的时候自动进行：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Point &#123;
  x &#x3D; 0;
  y &#x3D; 0;
&#125;
 
const pt &#x3D; new Point();
&#x2F;&#x2F; 打印 0, 0
console.log(&#96;$&#123;pt.x&#125;, $&#123;pt.y&#125;&#96;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就像使用 <code>const</code>、<code>let</code> 和 <code>var</code> 一样，类属性的初始化语句也会被用于进行类型推断：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const pt &#x3D; new Point();
pt.x &#x3D; &quot;0&quot;;
&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="strictpropertyinitialization"><a class="markdownIt-Anchor" href="#strictpropertyinitialization"></a> –strictPropertyInitialization</h5><p>配置项 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictPropertyInitialization">strictPropertyInitialization</a> 用于控制类的字段是否需要在构造器中进行初始化。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class BadGreeter &#123;
  name: string;
    ^
&#x2F;&#x2F; Property &#39;name&#39; has no initializer and is not definitely assigned in the constructor.
&#125;
class GoodGreeter &#123;
  name: string;
 
  constructor() &#123;
    this.name &#x3D; &quot;hello&quot;;
  &#125;
&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，字段需要在构造器自身内部进行初始化。TypeScript 不会分析在构造器中调用的方法以检测初始化语句，因为派生类可能会重写这些方法，导致初始化成员失败。</p><p>如果你坚持要使用除了构造器之外的方法（比如使用一个外部库填充类的内容）去初始化一个字段，那么你可以使用确定赋值断言运算符 <code>！</code>：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class OKGreeter &#123;
  &#x2F;&#x2F; 没有初始化，但不会报错
  name!: string;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="readonly"><a class="markdownIt-Anchor" href="#readonly"></a> <code>readonly</code></h4><p>字段可以加上 <code>readonly</code> 修饰符作为前缀，以防止在构造器外面对字段进行赋值。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Greeter &#123;
  readonly name: string &#x3D; &quot;world&quot;;
 
  constructor(otherName?: string) &#123;
    if (otherName !&#x3D;&#x3D; undefined) &#123;
      this.name &#x3D; otherName;
    &#125;
  &#125;
 
  err() &#123;
    this.name &#x3D; &quot;not ok&quot;;
      	   ^
&#x2F;&#x2F; Cannot assign to &#39;name&#39; because it is a read-only property.
  &#125;
&#125;
const g &#x3D; new Greeter();
g.name &#x3D; &quot;also not ok&quot;;
    ^
&#x2F;&#x2F; Cannot assign to &#39;name&#39; because it is a read-only property.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="构造器"><a class="markdownIt-Anchor" href="#构造器"></a> 构造器</h4><p>类的构造器和函数很像，你可以给它的参数添加类型注解，可以使用参数默认值或者是函数重载：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Point &#123;
    x: number;
    y: number;
    &#x2F;&#x2F; 使用了参数默认值的正常签名
    constructor(x &#x3D; 0, y &#x3D; 0) &#123;
        this.x &#x3D; x;
        this.y &#x3D; y;
    &#125;
&#125;
class Point &#123;
  &#x2F;&#x2F; 使用重载
  constructor(x: number, y: string);
  constructor(s: string);
  constructor(xs: any, y?: any) &#123;
    &#x2F;&#x2F; TBD
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类的构造器签名和函数签名只有一点区别：</p><ul><li>构造器不能使用类型参数 —— 类型参数属于类声明的部分，稍后我们会进行学习</li><li>构造器不能给返回值添加类型注解 —— 它返回的类型始终是类实例的类型</li></ul><h5 id="super-调用"><a class="markdownIt-Anchor" href="#super-调用"></a> <code>super</code> 调用</h5><p>和 JavaScript 一样，如果你有一个基类和一个派生类，那么在派生类中使用 <code>this.</code> 访问类成员之前，必须先在构造器中调用 <code>super();</code>：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;
  k &#x3D; 4;
&#125;
 
class Derived extends Base &#123;
  constructor() &#123;
    &#x2F;&#x2F; ES5 下打印出错误的值，ES6 下报错
    console.log(this.k);
                  ^
&#x2F;&#x2F; &#39;super&#39; must be called before accessing &#39;this&#39; in the constructor of a derived class.
    super();
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 JavaScript 中，忘记调用 <code>super</code> 是一个常见的错误，但 TypeScript 会在必要时给你提醒。</p><h4 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h4><p>类的属性可能是一个函数，这时候我们称其为方法。方法和函数以及构造器一样，也可以使用各种类型注解：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Point &#123;
  x &#x3D; 10;
  y &#x3D; 10;
 
  scale(n: number): void &#123;
    this.x *&#x3D; n;
    this.y *&#x3D; n;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了标准的类型注解之外，TypeScript 没有给方法添加什么新的东西。</p><p>注意，在方法体中，必须通过 <code>this.</code> 才能访问到类的字段和其它方法。在方法体中使用不合规的名字，将会被视为是在访问邻近作用域中的变量：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let x: number &#x3D; 0;
 
class C &#123;
  x: string &#x3D; &quot;hello&quot;;
 
  m() &#123;
    &#x2F;&#x2F; 下面这句是在试图修改第一行的 x，而不是类的属性
    x &#x3D; &quot;world&quot;;
    ^  
&#x2F;&#x2F; Type &#39;string&#39; is not assignable to type &#39;number&#39;.
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="getterssetters"><a class="markdownIt-Anchor" href="#getterssetters"></a> Getters/Setters</h4><p>类也可以有访问器：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class C &#123;
    _length &#x3D; 0;
    get length()&#123;
        return this._length;
    &#125;
    set length(value)&#123;
        this._length &#x3D; value;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：在 JavaScript 中，一个没有额外逻辑的 get/set 对是没有什么作用的。如果在执行 get/set 操作的时候不需要添加额外的逻辑，那么只需要将字段暴露为公共字段即可。</p></blockquote><p>对于访问器，TypeScript 有一些特殊的推断规则：</p><ul><li>如果 <code>get</code> 存在而 <code>set</code> 不存在，那么属性会自动成为只读属性</li><li>如果没有指定 setter 参数的类型，那么会基于 getter 返回值的类型去推断参数类型</li><li>getter 和 setter 必须具备相同的<a href="#%E6%88%90%E5%91%98%E5%8F%AF%E8%A7%81%E6%80%A7">成员可见性</a>。</li></ul><p>从 <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/">TypeScript 4.3</a> 开始，访问器的 getter 和 setter 可以使用不同的类型。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Thing &#123;
  _size &#x3D; 0;
 
  get size(): number &#123;
    return this._size;
  &#125;
 
  set size(value: string | number | boolean) &#123;
    let num &#x3D; Number(value);
 
    &#x2F;&#x2F; 不允许使用 NaN、Infinity 等
 
    if (!Number.isFinite(num)) &#123;
      this._size &#x3D; 0;
      return;
    &#125;
 
    this._size &#x3D; num;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="索引签名"><a class="markdownIt-Anchor" href="#索引签名"></a> 索引签名</h4><p>类可以声明索引签名，其工作方式和<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures">其它对象类型的索引签名</a>一样：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;
    [s: string]: boolean | ((s: string) &#x3D;&gt; boolean);
    check(s: string) &#123;
        return this[s] as boolean;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为索引签名类型也需要捕获方法的类型，所以要有效地使用这些类型并不容易。通常情况下，最好将索引数据存储在另一个位置，而不是类实例本身。</p><h3 id="类继承"><a class="markdownIt-Anchor" href="#类继承"></a> 类继承</h3><p>和其它面向对象语言一样，JavaScript 中的类可以继承自基类。</p><h4 id="implements-子句"><a class="markdownIt-Anchor" href="#implements-子句"></a> <code>implements</code> 子句</h4><p>你可以使用一个 <code>implements</code> 子句去检查类是否符合某个特定的接口。如果类没有正确地实现这个接口，那么就会抛出一个错误：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Pingable &#123;
  ping(): void;
&#125;
 
class Sonar implements Pingable &#123;
  ping() &#123;
    console.log(&quot;ping!&quot;);
  &#125;
&#125;
 
class Ball implements Pingable &#123;
        ^
&#x2F;*
Class &#39;Ball&#39; incorrectly implements interface &#39;Pingable&#39;.
  Property &#39;ping&#39; is missing in type &#39;Ball&#39; but required in type &#39;Pingable&#39;.
*&#x2F;  
  pong() &#123;
    console.log(&quot;pong!&quot;);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类可以实现多个接口，比如 <code>class C implements A,B &#123;</code>。</p><h5 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h5><p>有个要点需要理解，那就是 <code>implements</code> 子句只是用于检查类是否可以被视为某个接口类型，它完全不会改变类的类型或者它的方法。常见的错误是认为 <code>implements</code> 子句会改变类的类型 —— 实际上是不会的！</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Checkable &#123;
  check(name: string): boolean;
&#125;
 
class NameChecker implements Checkable &#123;
  check(s) &#123;
        ^
&#x2F;&#x2F;Parameter &#39;s&#39; implicitly has an &#39;any&#39; type.
    &#x2F;&#x2F; 注意这里不会抛出错误
    return s.toLowercse() &#x3D;&#x3D;&#x3D; &quot;ok&quot;;
                 ^
              &#x2F;&#x2F; any
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们可能会认为 <code>s</code> 的类型会受到接口中 <code>check</code> 的 <code>name: string</code> 参数的影响。但实际上不会 —— <code>implements</code> 子句不会对类内容体的检查以及类型推断产生任何影响。</p><p>同理，实现一个带有可选属性的接口，并不会创建该属性：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface A &#123;
  x: number;
  y?: number;
&#125;
class C implements A &#123;
  x &#x3D; 0;
&#125;
const c &#x3D; new C();
c.y &#x3D; 10;
  ^
&#x2F;&#x2F; Property &#39;y&#39; does not exist on type &#39;C&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="extends-子句"><a class="markdownIt-Anchor" href="#extends-子句"></a> <code>extends</code> 子句</h4><p>类可以继承自某个基类。派生类拥有基类的所有属性和方法，同时也可以定义额外的成员。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Animal &#123;
  move() &#123;
    console.log(&quot;Moving along!&quot;);
  &#125;
&#125;
 
class Dog extends Animal &#123;
  woof(times: number) &#123;
    for (let i &#x3D; 0; i &lt; times; i++) &#123;
      console.log(&quot;woof!&quot;);
    &#125;
  &#125;
&#125;
 
const d &#x3D; new Dog();
&#x2F;&#x2F; 基类方法
d.move();
&#x2F;&#x2F; 派生类方法
d.woof(3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="重写方法"><a class="markdownIt-Anchor" href="#重写方法"></a> 重写方法</h5><p>派生类也可以重写基类的字段或者属性。你可以使用 <code>super.</code> 语法访问基类的方法。注意，由于 JavaScript 的类只是一个简单的查找对象，所以不存在“父类字段”的概念。</p><p>TypeScript 强制认为派生类总是基类的一个子类。</p><p>比如，下面是一个合法的重写方法的例子：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;
  greet() &#123;
    console.log(&quot;Hello, world!&quot;);
  &#125;
&#125;
 
class Derived extends Base &#123;
  greet(name?: string) &#123;
    if (name &#x3D;&#x3D;&#x3D; undefined) &#123;
      super.greet();
    &#125; else &#123;
      console.log(&#96;Hello, $&#123;name.toUpperCase()&#125;&#96;);
    &#125;
  &#125;
&#125;
 
const d &#x3D; new Derived();
d.greet();
d.greet(&quot;reader&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很重要的一点是，派生类会遵循基类的约束。通过一个基类引用去引用一个派生类，是很常见（并且总是合法的！）的一种做法：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 通过一个基类引用去命名一个派生类实例
const b: Base &#x3D; d;
&#x2F;&#x2F; 没有问题
b.greet();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果派生类 <code>Derived</code> 没有遵循基类 <code>Base</code> 的约束，会怎么样呢？</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;
  greet() &#123;
    console.log(&quot;Hello, world!&quot;);
  &#125;
&#125;
 
class Derived extends Base &#123;
  &#x2F;&#x2F; 让这个参数成为必选参数
  greet(name: string) &#123;
    ^  
&#x2F;*
Property &#39;greet&#39; in type &#39;Derived&#39; is not assignable to the same property in base type &#39;Base&#39;.
  Type &#39;(name: string) &#x3D;&gt; void&#39; is not assignable to type &#39;() &#x3D;&gt; void&#39;.
*&#x2F;  
    console.log(&#96;Hello, $&#123;name.toUpperCase()&#125;&#96;);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果无视错误并编译代码，那么下面的代码执行后会报错：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const b: Base &#x3D; new Derived();
&#x2F;&#x2F; 因为 name 是 undefined，所以报错
b.greet();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="初始化顺序"><a class="markdownIt-Anchor" href="#初始化顺序"></a> 初始化顺序</h5><p>JavaScript 类的初始化顺序在某些情况下可能会让你感到意外。我们看看下面的代码：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;
  name &#x3D; &quot;base&quot;;
  constructor() &#123;
    console.log(&quot;My name is &quot; + this.name);
  &#125;
&#125;
 
class Derived extends Base &#123;
  name &#x3D; &quot;derived&quot;;
&#125;
 
&#x2F;&#x2F; 打印 base 而不是 derived
const d &#x3D; new Derived();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里发生了什么事呢？</p><p>根据 JavaScript 的定义，类初始化的顺序是：</p><ul><li>初始化基类的字段</li><li>执行基类的构造器</li><li>初始化派生类的字段</li><li>执行派生类的构造器</li></ul><p>这意味着，因为基类构造器执行的时候派生类的字段尚未进行初始化，所以基类构造器只能看到自己的 <code>name</code> 值。</p><h5 id="继承内置类型"><a class="markdownIt-Anchor" href="#继承内置类型"></a> 继承内置类型</h5><blockquote><p>注意：如果你不打算继承诸如 Array、Error、Map 等内置类型，或者你的编译目标显式设置为 ES6/ES2015 或者更高的版本，那么你可以跳过这部分的内容。</p></blockquote><p>在 ES2015 中，返回实例对象的构造器会隐式地将 <code>this</code> 的值替换为 <code>super(...)</code> 的任意调用者。有必要让生成的构造器代码捕获 <code>super(...)</code> 的任意潜在的返回值，并用 <code>this</code> 替换它。</p><p>因此，<code>Error</code>、<code>Array</code> 等的子类可能无法如预期那样生效。这是因为诸如 <code>Error</code>、<code>Array</code> 这样的构造函数使用了 ES6 的 <code>new.target</code> 去调整原型链，但是，在 ES5 中调用构造器函数的时候，没有类似的方法可以确保 <code>new.target</code> 的值。默认情况下，其它底层编译器通常也具有相同的限制。</p><p>对于一个像下面这样的子类：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MsgError extends Error &#123;
  constructor(m: string) &#123;
    super(m);
  &#125;
  sayHello() &#123;
    return &quot;hello &quot; + this.message;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可能会发现：</p><ul><li>调用子类之后返回的实例对象，其方法可能是 <code>undefined</code>，所以调用 <code>sayHello</code> 将会抛出错误</li><li>子类实例和子类之间的 <code>instanceof</code> 可能被破坏，所以 <code>(new MsgError()) instanceof MsgError</code> 将会返回 <code>false</code>。</li></ul><p>推荐的做法是，在任意的 <code>super(...)</code> 调用后面手动地调整原型链：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MsgError extends Error &#123;
  constructor(m: string) &#123;
    super(m);
    &#x2F;&#x2F; 显式设置原型链
    Object.setPrototypeOf(this, MsgError.prototype);
  &#125;
 
  sayHello() &#123;
    return &quot;hello &quot; + this.message;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过，<code>MsgError</code> 的任意子类也需要手动设置原型。对于不支持 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf</a> 的运行时，你可以改用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>__proto__</code></a>。</p><p>糟糕的是，<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx">这些变通方法在 IE10 或者更旧的版本上无法使用</a>。你可以手动将原型上的方法复制到实例上（比如将 <code>MsgError.prototype</code> 的方法复制给 <code>this</code>），但原型链本身无法被修复。</p><h3 id="成员可见性"><a class="markdownIt-Anchor" href="#成员可见性"></a> 成员可见性</h3><p>你可以使用 TypeScript 控制特定的方法或属性是否在类的外面可见。</p><h4 id="public"><a class="markdownIt-Anchor" href="#public"></a> <code>public</code></h4><p>类成员的默认可见性是公有的（<code>public</code>）。公有成员随处可以访问：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Greeter &#123;
    public greet()&#123;
        console.log(&#39;hi!&#39;);
    &#125;
&#125;
const g &#x3D; new Greeter();
g.greet();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于成员的可见性默认就是公有的，所以你不需要在类成员前面进行显式声明，但出于代码规范或者可读性的考虑，你也可以这么做。</p><h4 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> <code>protected</code></h4><p>受保护（<code>protected</code>）成员只在类的子类中可见。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Greeter &#123;
  public greet() &#123;
    console.log(&quot;Hello, &quot; + this.getName());
  &#125;
  protected getName() &#123;
    return &quot;hi&quot;;
  &#125;
&#125;
 
class SpecialGreeter extends Greeter &#123;
  public howdy() &#123;
    &#x2F;&#x2F; 这里可以访问受保护成员
    console.log(&quot;Howdy, &quot; + this.getName());
  &#125;
&#125;
const g &#x3D; new SpecialGreeter();
g.greet(); &#x2F;&#x2F; OK
g.getName();
	^
&#x2F;&#x2F; Property &#39;getName&#39; is protected and only accessible within class &#39;Greeter&#39; and its subclasses.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="公开受保护成员"><a class="markdownIt-Anchor" href="#公开受保护成员"></a> 公开受保护成员</h5><p>派生类需要遵循其基类的约束，但可以选择公开具有更多功能的基类的子类。这包括了让受保护成员变成公有成员：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;
    protected m &#x3D; 10;
&#125;
class Derived extends Base &#123;
    &#x2F;&#x2F; 没有修饰符，所以默认可见性是公有的
    m &#x3D; 15;
&#125;
const d &#x3D; new Dervied();
console.log(d.m);  &#x2F;&#x2F; OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意 <code>Dervied</code> 已经可以自由读写成员 <code>m</code> 了，所以这么写并不会改变这种情况的“安全性”。这里需要注意的要点是，在派生类中，如果我们无意公开其成员，那么需要添加 <code>protected</code> 修饰符。</p><h5 id="跨层级访问受保护成员"><a class="markdownIt-Anchor" href="#跨层级访问受保护成员"></a> 跨层级访问受保护成员</h5><p>对于通过一个基类引用访问受保护成员是否合法，不同的 OOP 语言之间存在争议：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;
    protected x: number &#x3D; 1;
&#125;
class Derived1 extends Base &#123;
    protected x: number &#x3D; 5;
&#125;
class Derived2 extends Base &#123;
    f1(other: Derived2) &#123;
        other.x &#x3D; 10;
    &#125;
    f2(other: Base) &#123;
        other.x &#x3D; 10;
        	  ^
&#x2F;&#x2F; Property &#39;x&#39; is protected and only accessible through an instance of class &#39;Derived2&#39;. This is an instance of class &#39;Base&#39;.                  
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子，Java 认为上述代码是合法的，但 C# 和 C++ 则认为上述代码是不合法的。</p><p>TypeScript 也认为这是不合法的，因为只有在 <code>Derived2</code> 的子类中访问 <code>Derived2</code> 的 <code>x</code> 才是合法的，但 <code>Derived1</code> 并不是 <code>Derived2</code> 的子类。而且，如果通过 <code>Derived1</code> 引用访问 <code>x</code> 就已经是不合法的了（这确实应该是不合法的！），那么通过基类引用访问它也同样应该是不合法的。</p><p>关于 C# 为什么会认为这段代码是不合法的，可以阅读这篇文章了解更多信息：<a target="_blank" rel="noopener" href="https://blogs.msdn.microsoft.com/ericlippert/2005/11/09/why-cant-i-access-a-protected-member-from-a-derived-class/">为什么我无法在一个派生类中去访问一个受保护成员？</a></p><h4 id="private"><a class="markdownIt-Anchor" href="#private"></a> <code>private</code></h4><p><code>private</code> 和 <code>protected</code> 一样，但声明了 <code>private</code> 的私有成员即使在子类中也无法被访问到：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;
    private x &#x3D; 0;
&#125;
const b &#x3D; new Base();
&#x2F;&#x2F; 无法在类外面访问
console.log(b.x);
&#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;Base&#39;.
class Derived extends Base &#123;
  showX() &#123;
    &#x2F;&#x2F; 无法在子类中访问
    console.log(this.x);
      			    ^	
&#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;Base&#39;.
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于私有成员对派生类不可见，所以派生类无法提高其可见性：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;
    private x &#x3D; 0;
&#125;
class Dervied extends Base &#123;
&#x2F;*
Class &#39;Derived&#39; incorrectly extends base class &#39;Base&#39;.
  Property &#39;x&#39; is private in type &#39;Base&#39; but not in type &#39;Derived&#39;.    
*&#x2F;  
    x &#x3D; 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="跨实例访问私有成员"><a class="markdownIt-Anchor" href="#跨实例访问私有成员"></a> 跨实例访问私有成员</h5><p>对于同一个类的不同实例互相访问对方的私有成员是否合法，不同的 OOP 语言之间存在争议。Java、C#、C++、Swift 和 PHP 允许这么做，但 Ruby 则认为这样做是不合法的。</p><p>TypeScript 允许跨实例访问私有成员：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class A &#123;
    private x &#x3D; 10;
    public sameAs(other: A) &#123;
        &#x2F;&#x2F; 不会报错
        return other.x &#x3D;&#x3D;&#x3D; this.x;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意事项-2"><a class="markdownIt-Anchor" href="#注意事项-2"></a> 注意事项</h5><p>和 TypeScript 类型系统中的其它东西一样，<code>private</code> 和 <code>protected</code> <a href="https://www.typescriptlang.org/play?removeComments=true&amp;target=99&amp;ts=4.3.4#code/PTAEGMBsEMGddAEQPYHNQBMCmVoCcsEAHPASwDdoAXLUAM1K0gwQFdZSA7dAKWkoDK4MkSoByBAGJQJLAwAeAWABQIUH0HDSoiTLKUaoUggAW+DHorUsAOlABJcQlhUy4KpACeoLJzrI8cCwMGxU1ABVPIiwhESpMZEJQTmR4lxFQaQxWMm4IZABbIlIYKlJkTlDlXHgkNFAAbxVQTIAjfABrAEEC5FZOeIBeUAAGAG5mmSw8WAroSFIqb2GAIjMiIk8VieVJ8Ar01ncAgAoASkaAXxVr3dUwGoQAYWpMHBgCYn1rekZmNg4eUi0Vi2icoBWJCsNBWoA6WE8AHcAiEwmBgTEtDovtDaMZQLM6PEoQZbA5wSk0q5SO4vD4-AEghZoJwLGYEIRwNBoqAzFRwCZCFUIlFMXECdSiAhId8YZgclx0PsiiVqOVOAAaUAFLAsxWgKiC35MFigfC0FKgSAVVDTSyk+W5dB4fplHVVR6gF7xJrKFotEk-HXIRE9PoDUDDcaTAPTWaceaLZYQlmoPBbHYx-KcQ7HPDnK43FQqfY5+IMDDISPJLCIuqoc47UsuUCofAME3Vzi1r3URvF5QV5A2STtPDdXqunZDgDaYlHnTDrrEAF0dm28B3mDZg6HJwN1+2-hg57ulwNV2NQGoZbjYfNrYiENBwEFaojFiZQK08C-4fFKTVCozWfTgfFgLkeT5AUqiAA">只在类型检查期间生效</a>。</p><p>这意味着 JavaScript 运行时的一些操作，诸如 <code>in</code> 或者简单的属性查找仍然可以访问私有成员或者受保护成员：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MySafe &#123;
    private serectKey &#x3D; 123345;
&#125;
&#x2F;&#x2F; 在 JavaScript 文件中会打印 12345
const s &#x3D; new MySafe();
console.log(s.secretKey);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而即使是在类型检查期间，我们也可以通过方括号语法去访问私有成员。因此，在进行诸如单元测试这样的操作时，访问私有字段会比较容易，但缺点就是这些字段是“弱私有的”，无法保证严格意义上的私有性。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MySafe &#123;
  private secretKey &#x3D; 12345;
&#125;
 
const s &#x3D; new MySafe();
 
&#x2F;&#x2F; 在类型检查期间，不允许这样访问私有成员
console.log(s.secretKey);
				^
&#x2F;&#x2F; Property &#39;secretKey&#39; is private and only accessible within class &#39;MySafe&#39;.
 
&#x2F;&#x2F; 但是可以通过方括号语法访问
console.log(s[&quot;secretKey&quot;]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和 TypeScript 用 <code>private</code> 声明的私有成员不同，JavaScript 用 <code>#</code> 声明的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields">私有字段</a>在编译之后也仍然是私有的，并且没有提供像上面那样的方括号语法用于访问私有成员，所以 JavaScript 的私有成员是“强私有的”。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Dog &#123;
    #barkAmount &#x3D; 0;
    personality &#x3D; &#39;happy&#39;;
    
    constructor() &#123;&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下面这段 TypeScript 代码为例：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&quot;use strict&quot;;
class Dog &#123;
    #barkAmount &#x3D; 0;
    personality &#x3D; &quot;happy&quot;;
    constructor() &#123; &#125;
&#125;
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把它编译为 ES2021 或者更低版本的代码之后，TypeScript 会使用 WeakMap 代替 <code>#</code>。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&quot;use strict&quot;;
var _Dog_barkAmount;
class Dog &#123;
    constructor() &#123;
        _Dog_barkAmount.set(this, 0);
        this.personality &#x3D; &quot;happy&quot;;
    &#125;
&#125;
_Dog_barkAmount &#x3D; new WeakMap();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你需要保护类中的值不被恶意修改，那么你应该使用提供了运行时私有性保障的机制，比如闭包、WeakMap 或者私有字段等。注意，这些在运行时添加的私有性检查可能会影响性能。</p><h3 id="静态成员"><a class="markdownIt-Anchor" href="#静态成员"></a> 静态成员</h3><blockquote><p>背景导读：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static">静态成员（MDN）</a></p></blockquote><p>类可以拥有静态（<code>static</code>）成员。这些成员和类的特定实例无关，我们可以通过类构造器对象本身访问到它们：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;
    static x &#x3D; 0;
    static printX()&#123;
        console.log(MyClass.x);
    &#125;
&#125;
console.log(MyClass.x);
MyClass.printX();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态成员也可以使用 <code>public</code>、<code>protected</code> 和 <code>private</code> 等可见性修饰符：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;
    private static x &#x3D; 0;
&#125;
console.log(MyClass.x);
				  ^
&#x2F;&#x2F; Property &#39;x&#39; is private and only accessible within class &#39;MyClass&#39;.           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态成员也可以被继承：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Base &#123;
  static getGreeting() &#123;
    return &quot;Hello world&quot;;
  &#125;
&#125;
class Derived extends Base &#123;
  myGreeting &#x3D; Derived.getGreeting();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特殊的静态成员名字"><a class="markdownIt-Anchor" href="#特殊的静态成员名字"></a> 特殊的静态成员名字</h4><p>重写 <code>Function</code> 原型的属性通常是不安全/不可能的。因为类本身也是一个可以通过 <code>new</code> 调用的函数，所以无法使用一些特定的静态成员名字。诸如 <code>name</code>、<code>length</code> 和 <code>call</code> 这样的函数属性无法作为静态成员的名字：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class S &#123;
    static name &#x3D; &#39;S!&#39;;
    		^
&#x2F;&#x2F; Static property &#39;name&#39; conflicts with built-in property &#39;Function.name&#39; of constructor function &#39;S&#39;.                
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="为什么没有静态类"><a class="markdownIt-Anchor" href="#为什么没有静态类"></a> 为什么没有静态类？</h4><p>TypeScript（和 JavaScript）并没有像 C# 和 Java 那样提供静态类这种结构。</p><p>C# 和 Java 之所以需要静态类，是因为这些语言要求所有的数据和函数必须放在一个类中。因为在 TypeScirpt 中不存在这个限制，所以也就不需要静态类。只拥有单个实例的类在 JavaScript/TypeScirpt 中通常用一个普通对象表示。</p><p>举个例子，在 TypeScript 中我们不需要“静态类”语法，因为一个常规的对象（甚至是顶层函数）也可以完成相同的工作：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 不必要的静态类
class MyStaticClass &#123;
    static doSomething() &#123;&#125;
&#125;
&#x2F;&#x2F; 首选（方案一）
function doSomething() &#123;&#125;

&#x2F;&#x2F; 首选（方案二）
const MyHelperObject &#x3D; &#123;
  dosomething() &#123;&#125;,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类中的静态块"><a class="markdownIt-Anchor" href="#类中的静态块"></a> 类中的静态块</h3><p>静态块允许你编写一系列声明语句，它们拥有自己的作用域，并且可以访问包含类中的私有字段。这意味着我们能够编写初始化代码，这些代码包含了声明语句，不会有变量泄漏的问题，并且完全可以访问类的内部。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Foo &#123;
    static #count &#x3D; 0;
	get count()&#123;
        return Foo.#count;
    &#125;
	static &#123;
        try &#123;
            const lastInstances &#x3D; loadLastInstances();
            Foo.#count +&#x3D; lastInstances.length;
        &#125;
        catch &#123;&#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型类"><a class="markdownIt-Anchor" href="#泛型类"></a> 泛型类</h3><p>类和接口一样，也可以使用泛型。当用 <code>new</code> 实例化一个泛型类的时候，它的类型参数就像在函数调用中那样被推断出来：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box&lt;Type&gt; &#123;
    contents: Type;
    constructor(value: Type)&#123;
        this.contents &#x3D; value;
    &#125;
&#125;
const b &#x3D; new Box(&#39;hello!&#39;);
	  ^	
    &#x2F;&#x2F; const b: Box&lt;string&gt;      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类可以像接口那样使用泛型约束和默认值。</p><h4 id="静态成员中的类型参数"><a class="markdownIt-Anchor" href="#静态成员中的类型参数"></a> 静态成员中的类型参数</h4><p>下面的代码是不合法的，但原因可能不那么明显：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box&lt;Type&gt; &#123;
    static defaultValue: Type;
    					^
&#x2F;&#x2F;  Static members cannot reference class type parameters.                       
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>记住，类型在编译后总是会被完全抹除的！在运行时，只有一个 <code>Box.defaultValue</code> 属性插槽。这意味着设置 <code>Box&lt;string&gt;.defaultValue</code>（如果可以设置的话）也会改变 <code>Box&lt;number&gt;.defaultValue</code> —— 这是不行的。泛型类的静态成员永远都不能引用类的类型参数。</p><h3 id="类的运行时-this"><a class="markdownIt-Anchor" href="#类的运行时-this"></a> 类的运行时 <code>this</code></h3><p>有个要点需要记住，那就是 TypeScript 不会改变 JavaScript 的运行时行为。而众所周知，JavaScript 拥有一些特殊的运行时行为。</p><p>JavaScript 对于 <code>this</code> 的处理确实是很不寻常：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;
  name &#x3D; &quot;MyClass&quot;;
  getName() &#123;
    return this.name;
  &#125;
&#125;
const c &#x3D; new MyClass();
const obj &#x3D; &#123;
  name: &quot;obj&quot;,
  getName: c.getName,
&#125;;
 
&#x2F;&#x2F; 打印 &quot;obj&quot; 而不是 &quot;MyClass&quot;
console.log(obj.getName());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>长话短说，默认情况下，函数中 <code>this</code> 的值取决于<strong>函数是如何被调用的</strong>。在这个例子中，由于我们通过 <code>obj</code> 引用去调用函数，所以它的 <code>this</code> 的值是 <code>obj</code>，而不是类实例。</p><p>这通常不是我们期望的结果！TypeScript 提供了一些方法让我们可以减少或者防止这种错误的发生。</p><h4 id="箭头函数"><a class="markdownIt-Anchor" href="#箭头函数"></a> 箭头函数</h4><p>如果你的函数在被调用的时候经常会丢失 <code>this</code> 上下文，那么最好使用箭头函数属性，而不是方法定义：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;
    name &#x3D; &#39;MyClass&#39;;
    getName &#x3D; () &#x3D;&gt; &#123;
        return this.name;
    &#125;;
&#125;
const c &#x3D; new MyClass();
const g &#x3D; c.getName;
&#x2F;&#x2F; 打印 MyClass 
console.log(g());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法有一些利弊权衡：</p><ul><li>在运行时可以保证 <code>this</code> 的值是正确的，即使对于那些没有使用 TypeScript 进行检查的代码也是如此</li><li>这样会占用更多内存，因为以这种方式定义的函数，会导致每个类实例都有一份函数副本</li><li>你无法在派生类中使用 <code>super.getName</code>，因为在原型链上没有入口可以去获取基类的方法</li></ul><h4 id="this-参数"><a class="markdownIt-Anchor" href="#this-参数"></a> <code>this</code> 参数</h4><p>在 TypeScript 的方法或者函数定义中，第一个参数的名字如果是 <code>this</code>，那么它有特殊的含义。这样的参数在编译期间会被抹除：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; TypeScript 接受 this 参数
function fn(this: SomeType, x: number) &#123;
    &#x2F;* ... *&#x2F;
&#125;
&#x2F;&#x2F; 输出得 JavaScript 
function fn(x) &#123;
    &#x2F;* ... *&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TypeScript 会检查传入 <code>this</code> 参数的函数调用是否位于正确的上下文中。这里我们没有使用箭头函数，而是给方法定义添加了一个 <code>this</code> 参数，以静态的方式确保方法可以被正确调用：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class MyClass &#123;
  name &#x3D; &quot;MyClass&quot;;
  getName(this: MyClass) &#123;
    return this.name;
  &#125;
&#125;
const c &#x3D; new MyClass();
&#x2F;&#x2F; OK
c.getName();
 
&#x2F;&#x2F; 报错
const g &#x3D; c.getName;
console.log(g());
&#x2F;&#x2F; The &#39;this&#39; context of type &#39;void&#39; is not assignable to method&#39;s &#39;this&#39; of type &#39;MyClass&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方法的利弊权衡和上面使用箭头函数的方法相反：</p><ul><li>JavaScript 的调用方可能仍然会在没有意识的情况下错误地调用类方法</li><li>只会给每个类定义分配一个函数，而不是给每个类实例分配一个函数</li><li>仍然可以通过 <code>super</code> 调用基类定义的方法</li></ul><h3 id="this-类型"><a class="markdownIt-Anchor" href="#this-类型"></a> <code>this</code> 类型</h3><p>在类中，名为 <code>this</code> 的特殊类型可以动态地引用当前类的类型。我们看一下它是怎么发挥作用的：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box &#123;
    contents: string &#x3D; &quot;&quot;;
    set(value: string)&#123;
     ^
    &#x2F;&#x2F; (method) Box.set(value: string): this
         this.contents &#x3D; value;
        return this;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，TypeScript 将 <code>set</code> 的返回值类型推断为 <code>this</code>，而不是 <code>Box</code>。现在我们来创建一个 <code>Box</code> 的子类：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class ClearableBox extends Box &#123;
    clear() &#123;
        this.contents &#x3D; &quot;&quot;;
    &#125;
&#125;
const a &#x3D; new ClearableBox();
const b &#x3D; a.set(&quot;hello&quot;);
      ^
&#x2F;&#x2F; const b: ClearableBox<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以在参数的类型注解中使用 <code>this</code>：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box &#123;
  content: string &#x3D; &quot;&quot;;
  sameAs(other: this) &#123;
    return other.content &#x3D;&#x3D;&#x3D; this.content;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这和使用 <code>other: Box</code> 是不一样的 —— 如果你有一个派生类，那么它的 <code>sameAs</code> 方法将只会接受该派生类的其它实例：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box &#123;
  content: string &#x3D; &quot;&quot;;
  sameAs(other: this) &#123;
    return other.content &#x3D;&#x3D;&#x3D; this.content;
  &#125;
&#125;
 
class DerivedBox extends Box &#123;
  otherContent: string &#x3D; &quot;?&quot;;
&#125;
 
const base &#x3D; new Box();
const derived &#x3D; new DerivedBox();
derived.sameAs(base);
			    ^
&#x2F;*
Argument of type &#39;Box&#39; is not assignable to parameter of type &#39;DerivedBox&#39;.
  Property &#39;otherContent&#39; is missing in type &#39;Box&#39; but required in type &#39;DerivedBox&#39;.
*&#x2F;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基于-this-的类型保护"><a class="markdownIt-Anchor" href="#基于-this-的类型保护"></a> 基于 <code>this</code> 的类型保护</h4><p>你可以在类和接口的方法的返回值类型注解处使用 <code>this is Type</code>。该语句和类型收缩（比如说 <code>if</code> 语句）一起使用的时候，目标对象的类型会被收缩为指定的 <code>Type</code>。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class FileSystemObject &#123;
  isFile(): this is FileRep &#123;
    return this instanceof FileRep;
  &#125;
  isDirectory(): this is Directory &#123;
    return this instanceof Directory;
  &#125;
  isNetworked(): this is Networked &amp; this &#123;
    return this.networked;
  &#125;
  constructor(public path: string, private networked: boolean) &#123;&#125;
&#125;
 
class FileRep extends FileSystemObject &#123;
  constructor(path: string, public content: string) &#123;
    super(path, false);
  &#125;
&#125;
 
class Directory extends FileSystemObject &#123;
  children: FileSystemObject[];
&#125;
 
interface Networked &#123;
  host: string;
&#125;
 
const fso: FileSystemObject &#x3D; new FileRep(&quot;foo&#x2F;bar.txt&quot;, &quot;foo&quot;);
 
if (fso.isFile()) &#123;
  fso.content;
   ^
 &#x2F;&#x2F; const fso: FileRep
&#125; else if (fso.isDirectory()) &#123;
  fso.children;
   ^ 
 &#x2F;&#x2F; const fso: Directory
&#125; else if (fso.isNetworked()) &#123;
  fso.host;
   ^ 
 &#x2F;&#x2F; const fso: Networked &amp; FileSystemObject
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于 <code>this</code> 的类型保护的常见用例是允许特定字段的延迟验证。以下面的代码为例，当 <code>hasValue</code> 被验证为 true 的时候，可以移除 <code>Box</code> 中为 <code>undefined</code> 的 <code>value</code> 值：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Box&lt;T&gt; &#123;
  value?: T;
 
  hasValue(): this is &#123; value: T &#125; &#123;
    return this.value !&#x3D;&#x3D; undefined;
  &#125;
&#125;
 
const box &#x3D; new Box();
box.value &#x3D; &quot;Gameboy&quot;;
 
box.value;
      ^
    &#x2F;&#x2F; (property) Box&lt;unknown&gt;.value?: unknown
 
if (box.hasValue()) &#123;
  box.value;
        ^   
   &#x2F;&#x2F; (property) value: unknown
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数属性"><a class="markdownIt-Anchor" href="#参数属性"></a> 参数属性</h3><p>TypeScript 提供了一种特殊的语法，可以将构造器参数转化为具有相同名字和值的类属性。这种语法叫做参数属性，实现方式是在构造器参数前面加上 <code>public</code>、<code>private</code>、<code>protected</code> 或者 <code>readonly</code> 等其中一种可见性修饰符作为前缀。最终的字段将会获得这些修饰符：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Params &#123;
    constructor(
        public readonly x: number,
        protected y: number,
        private z: number    
    ) &#123;
        &#x2F;&#x2F; 没有必要编写构造器的函数体     
    &#125;    
&#125;
const a &#x3D; new Params(1,2,3);
console.log(a.x);
			 ^
            &#x2F;&#x2F; (property) Params.x: number
console.log(a.z);
			 ^
&#x2F;&#x2F; Property &#39;z&#39; is private and only accessible within class &#39;Params&#39;.           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类表达式"><a class="markdownIt-Anchor" href="#类表达式"></a> 类表达式</h3><blockquote><p>背景导读：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class">类表达式（MDN）</a></p></blockquote><p>类表达式和类声明非常相似。唯一的不同在于，类表达式不需要名字，但我们仍然可以通过任意绑定给类表达式的标识符去引用它们：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const someClass &#x3D; class&lt;Type&gt; &#123;
    content: Type;
    constructor(value: Type) &#123;
        this.content &#x3D; value;
    &#125;
&#125;;

const m &#x3D; new someClass(&quot;Hello, world&quot;);
	  ^
    &#x2F;&#x2F; const m: someClass&lt;string&gt;      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象类和成员"><a class="markdownIt-Anchor" href="#抽象类和成员"></a> 抽象类和成员</h3><p>在 TypeScript 中，类、方法和字段可能是抽象的。</p><p>抽象方法或者抽象字段在类中没有对应的实现。这些成员必须存在于一个无法直接被实例化的抽象类中。</p><p>抽象类的角色是充当一个基类，让其子类去实现所有的抽象成员。当一个类没有任何抽象成员的时候，我们就说它是具体的。</p><p>来看一个例子：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">abstract class Base &#123;
    abstract getName(): string;
    printName()&#123;
        console.log(&quot;Hello, &quot; + this.getName());
    &#125;
&#125;

const b &#x3D; new Base();
&#x2F;&#x2F; Cannot create an instance of an abstract class.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 <code>Base</code> 是一个抽象类，所以我们不能使用 <code>new</code> 去实例化它。相反地，我们需要创建一个派生类，让它去实现抽象成员：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Derived extends Base &#123;
    getName() &#123;
        rteurn &quot;world&quot;;
    &#125;
&#125;

const d &#x3D; new Derived();
d.printName();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，如果我们忘记实现基类的抽象成员，那么会抛出一个错误：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Derived extends Base &#123;
    	^
&#x2F;&#x2F; Non-abstract class &#39;Derived&#39; does not implement inherited abstract member &#39;getName&#39; from class &#39;Base&#39;.
  &#x2F;&#x2F; 忘记实现抽象成员
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="抽象构造签名"><a class="markdownIt-Anchor" href="#抽象构造签名"></a> 抽象构造签名</h4><p>有时候你想要接受一个类构造器函数作为参数，让它产生某个类的实例，并且这个类是从某个抽象类派生过来的。</p><p>举个例子，你可能想要编写下面这样的代码：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet(ctor: typeof Base) &#123;
  const instance &#x3D; new ctor();
&#x2F;&#x2F; Cannot create an instance of an abstract class.
  instance.printName();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TypeScript 会正确地告诉你，你正试图实例化一个抽象类。毕竟，根据 <code>greet</code> 的定义，编写这样的代码理应是完全合法的，它最终会构造一个抽象类的实例：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 不行！
greet(Base);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但它实际上会报错。所以，你编写的函数所接受的参数应该带有一个构造签名：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function greet(ctor: new () &#x3D;&gt; Base) &#123;
  const instance &#x3D; new ctor();
  instance.printName();
&#125;
greet(Derived);
greet(Base);
	   ^	
&#x2F;*
Argument of type &#39;typeof Base&#39; is not assignable to parameter of type &#39;new () &#x3D;&gt; Base&#39;.
  Cannot assign an abstract constructor type to a non-abstract constructor type.
*&#x2F;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在 TypeScript 可以正确地告知你哪个类构造器函数可以被调用了 —— <code>Derived</code> 可以被调用，因为它是一个具体类，而 <code>Base</code> 不能被调用，因为它是一个抽象类。</p><h3 id="类之间的联系"><a class="markdownIt-Anchor" href="#类之间的联系"></a> 类之间的联系</h3><p>在大多数情况下，TypeScript 中的类是在结构上进行比较的，就跟其它类型一样。</p><p>举个例子，下面这两个类可以互相替代对方，因为它们在结构上是一模一样的：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Point1 &#123;
  x &#x3D; 0;
  y &#x3D; 0;
&#125;
 
class Point2 &#123;
  x &#x3D; 0;
  y &#x3D; 0;
&#125;
 
&#x2F;&#x2F; OK
const p: Point1 &#x3D; new Point2();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类似地，即使没有显式声明继承关系，类和类之间也可以存在子类联系：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Person &#123;
  name: string;
  age: number;
&#125;
 
class Employee &#123;
  name: string;
  age: number;
  salary: number;
&#125;
 
&#x2F;&#x2F; OK
const p: Person &#x3D; new Employee();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这听起来很简单易懂，但还有一些情况会比较奇怪。</p><p>空类没有成员。在一个结构化的类型系统中，一个没有成员的类型通常是任何其它类型的超类。所以如果你编写了一个空类（不要这么做！），那么你可以用任何类型去替代它：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">class Empty &#123;&#125;

function fn(x: Empty) &#123;
    &#x2F;&#x2F; 无法对 x 执行任何操作，所以不建议这么写
&#125;

&#x2F;&#x2F; 这些参数都是可以传入的！
fn(window);
fn(&#123;&#125;);
fn(fn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="post-nav"><div class="post-nav-prev"><a href="/2021/12/10/F-TypeScript%20%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92%E3%80%90%E5%8D%81%E4%B8%89%E3%80%91%EF%BC%9A%E6%A8%A1%E5%9D%97/" rel="prev" title="TypeScript 官方手册翻译计划【十三】：模块"><i class="fa fa-angle-double-left"></i>&nbspTypeScript 官方手册翻译计划【十三】：模块</a></div><div class="post-nav-next"><a href="/2021/12/04/F-TypeScript%20%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92%E3%80%90%E5%8D%81%E4%B8%80%E3%80%91%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%93%8D%E6%8E%A7-%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B/" rel="next" title="TypeScript 官方手册翻译计划【十一】：类型操控-模板字面量类型">TypeScript 官方手册翻译计划【十一】：类型操控-模板字面量类型&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-text">类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5"><span class="toc-text">字段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#strictpropertyinitialization"><span class="toc-text">–strictPropertyInitialization</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly"><span class="toc-text">readonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#super-%E8%B0%83%E7%94%A8"><span class="toc-text">super 调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getterssetters"><span class="toc-text">Getters&#x2F;Setters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-text">索引签名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-text">类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#implements-%E5%AD%90%E5%8F%A5"><span class="toc-text">implements 子句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extends-%E5%AD%90%E5%8F%A5"><span class="toc-text">extends 子句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95"><span class="toc-text">重写方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-text">初始化顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">继承内置类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">成员可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#public"><span class="toc-text">public</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#protected"><span class="toc-text">protected</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%BC%80%E5%8F%97%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98"><span class="toc-text">公开受保护成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%A8%E5%B1%82%E7%BA%A7%E8%AE%BF%E9%97%AE%E5%8F%97%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98"><span class="toc-text">跨层级访问受保护成员</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#private"><span class="toc-text">private</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%A8%E5%AE%9E%E4%BE%8B%E8%AE%BF%E9%97%AE%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-text">跨实例访问私有成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-text">静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%90%8D%E5%AD%97"><span class="toc-text">特殊的静态成员名字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-text">为什么没有静态类？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%9D%97"><span class="toc-text">类中的静态块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">泛型类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-text">静态成员中的类型参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6-this"><span class="toc-text">类的运行时 this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-%E5%8F%82%E6%95%B0"><span class="toc-text">this 参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E7%B1%BB%E5%9E%8B"><span class="toc-text">this 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-this-%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4"><span class="toc-text">基于 this 的类型保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-text">参数属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">类表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98"><span class="toc-text">抽象类和成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-text">抽象构造签名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-text">类之间的联系</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>function send_valine_Server(){var e="desp=",t=document.title,n=t.indexOf("|"),a=(t.substring(0,n),document.URL),s=new Date,l=document.getElementsByClassName("vnick vinput")[0].value||"Anonymous",i=(document.getElementsByClassName("vmail vinput")[0].value,document.getElementsByClassName("vlink vinput")[0].value,document.getElementsByClassName("veditor vinput")[0].value),o=e+"文章："+a+"\n\n昵称："+l+"\n\n留言："+i+"\n\n时间："+s.toLocaleString(),v=new XMLHttpRequest;v.open("POST","https://sc.ftqq.com/"+SCKEY_Server+".send",!0),v.setRequestHeader("Content-type","application/x-www-form-urlencoded"),v.send(title1+"&"+o)}new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0});var title1="text=你的博客有新的评论",SCKEY_Server="SCT99005TwWJDrDKdBwQGK0YmcPRAsr4B",ValineButton=document.getElementsByClassName("vsubmit vbtn")[0];ValineButton.onclick=send_valine_Server</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/prism.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:150,height:300,vOffset:-120,hOffset:-5},mobile:{show:!1},react:{opacityDefault:1e3,opacityOnHover:1e3},log:!1})</script></body></html><!-- rebuild by neat -->