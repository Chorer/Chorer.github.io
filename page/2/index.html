<!-- build time:Sat May 29 2021 15:32:39 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><span class="local-search local-search-plugin"><i class="fa fa-search"></i> <input type="search" placeholder="Search here......" id="local-search-input" class="local-search-input-cls"> <span class="local-search-border"></span><div id="local-search-result" class="local-search-result-cls"></div></span><div id="blog-down-reach"></div><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/21/F-JS原生方法原理探究（一）：如何实现call、apply 和 bind？/">JS 原生方法原理探究（一）：如何实现 call、apply 和 bind？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-21&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp11 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/21/F-JS原生方法原理探究（一）：如何实现call、apply 和 bind？/"><p>这是 JS 原生方法原理探究系列的第一篇文章。本文会介绍如何实现 call、apply 和 bind 方法。关于这几个方法的具体用法，MDN 已经描述得很清楚了，这里不再赘述。</p><h2 id="手写实现-call"><a href="#手写实现-call" class="headerlink" title="手写实现 call"></a>手写实现 call</h2><h3 id="ES3-版本"><a href="#ES3-版本" class="headerlink" title="ES3 版本"></a>ES3 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
     <span class="token keyword">if</span><span class="token punctuation">(</span>thisArg <span class="token operator">===</span> undefined <span class="token operator">||</span> thisArg <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> globalThis
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>   
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'arguments['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'thisArg.fn('</span> <span class="token operator">+</span> args <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ES6-版本"><a href="#ES6-版本" class="headerlink" title="ES6 版本"></a>ES6 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'The caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>thisArg <span class="token operator">===</span> undefined <span class="token operator">||</span> thisArg <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> globalThis
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> thisArg<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>call</code> 调用函数的时候，可以通过传给 <code>call</code> 的 thisArg 指定函数中的 this。而只要使得函数是通过 thisArg 调用的，就能实现这一点，这就是我们的主要目标。</p><h3 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h3><ol><li>最终是通过函数去调用 <code>myCall</code> 的，所以 <code>myCall</code> 和 <code>call</code> 一样挂载在函数原型上。同时，也正因为是通过函数去调用 <code>myCall</code> 的，所以在 <code>myCall</code> 内部我们可以通过 this 拿到 <code>myCall</code>的调用者，也就是实际执行的那个函数。</li><li>按理说，<code>myCall</code> 是挂载在函数原型上，当我们通过一个非函数去调用 <code>myCall</code> 的时候，肯定会抛出错误，那么为什么还要在 <code>myCall</code> 中检查调用者的类型，并自定义一个错误呢？这是因为，当一个调用者 <code>obj = {}</code> 是一个对象，但是继承自 <code>Function</code> 的时候（<code>obj.__proto__ = Function.prototype</code>），它作为一个非函数实际上也是可以调用 <code>myCall</code> 方法的，这时候如果不进行类型检查以确保它是个函数，那么后面直接将它当作函数调用的时候，就会抛出错误了</li><li>传给 <code>call</code> 的 thisArg 如果是 null 或者 undefined，那么 thisArg 实际上会指向全局对象；如果 thisArg 是一个基本类型，那么可以使用 <code>Object()</code> 做一个装箱操作，将其转化为一个对象 —— 主要是为了确保后续可以以方法调用的方式去执行函数。那么可不可以写成 <code>thisArg = thisArg ? Object(thisArg) : globalThis</code> 呢？其实是不可以的，如果 thisArg 是布尔值 false，那么会导致 thisArg 最终等于 globalThis，但实际上它应该等于 <code>Boolean {false}</code>。</li><li>前面说过，可以在 <code>myCall</code> 里通过 this 拿到实际执行的那个函数，所以 <code>thisArg.fn = this</code> 相当于将这个函数作为 thisArg 的一个方法，后面我们就可以通过 thisArg 对象去调用这个函数了。</li><li><code>thisArg.fn = this</code> 相当于是给 thisArg 增加了一个 fn 属性，所以返回执行结果之前要 delete 这个属性。此外，为了避免覆盖 thisArg 上可能存在的同名属性 fn，这里也可以使用 <code>const fn = Symbol(&#39;fn&#39;)</code> 构造一个唯一属性，然后 <code>thisArg[fn] = this</code>。</li><li>ES3 版本和 ES6 版本主要的区别在于参数的传递以及函数的执行上：<ol><li>ES6 因为引入了剩余参数，所以不管实际执行函数的时候传入了多少个参数，都可以通过 args 数组拿到这些参数，同时因为引入了展开运算符，所以可以展开 args 参数数组，把参数一个个传递给函数执行</li><li>但在 ES3 中没有剩余参数这个东西，所以在定义 <code>myCall</code> 的时候只接收一个 thisArg 参数，然后在函数体中通过 arguments 类数组拿到所有参数。我们需要的是 arguments 中除第一个元素（thisArg）之外的所有元素，怎么做呢？如果是 ES6，直接<code>[...arguments].slice(1)</code>就可以了，但这是 ES3，于是我们只能从索引 1 开始遍历 arguments，然后 push 到一个 args 数组中了。而且还要注意的是，这里 push 进去的是字符串形式的参数，这主要是为了方便后续通过 eval 执行函数的时候，将参数一个一个传递给函数。</li><li>为什么必须通过 eval 才能执行函数呢？因为我们不知道函数实际上要接收多少个参数，况且也用不了展开运算符，所以只能构造一个可执行的字符串表达式，显式地传入函数的所有参数。</li></ol></li></ol><h2 id="手写实现-apply"><a href="#手写实现-apply" class="headerlink" title="手写实现 apply"></a>手写实现 apply</h2><p>apply 的用法和 call 很类似，因此实现也很类似。需要注意的区别是，call 在接受一个 thisArg 参数之后还可以接收多个参数（即接受的是参数列表），而 apply 在接收一个 thisArg 参数之后，通常第二个参数是一个数组或者类数组对象：</p><pre class="line-numbers language-js"><code class="language-js">fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">)</span>
fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span><span class="token punctuation">[</span>arg1<span class="token punctuation">,</span>arg2<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果第二个参数传的是 null 或者 undefined，那么相当于是整体只传了 thisArg 参数。</p><h3 id="ES3-版本-1"><a href="#ES3-版本-1" class="headerlink" title="ES3 版本"></a>ES3 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myApply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">if</span><span class="token punctuation">(</span>thisArg <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> thisArg <span class="token operator">===</span> undefined<span class="token punctuation">)</span><span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> globalThis
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>args <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> args <span class="token operator">===</span> undefined<span class="token punctuation">)</span><span class="token punctuation">{</span>
        args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'CreateListFromArrayLike called on non-object'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> _args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i <span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        _args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'args['</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> _args<span class="token punctuation">.</span>length <span class="token operator">?</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'thisArg.fn('</span> <span class="token operator">+</span> _args <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>thisArg<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ES6-版本-1"><a href="#ES6-版本-1" class="headerlink" title="ES6 版本"></a>ES6 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myApply <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> thisArg <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> 
    <span class="token keyword">if</span><span class="token punctuation">(</span>thisArg <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> thisArg <span class="token operator">===</span> undefined<span class="token punctuation">)</span><span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> globalThis
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        thisArg <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>args <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> args <span class="token operator">===</span> undefined<span class="token punctuation">)</span><span class="token punctuation">{</span>
        args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span> 
    <span class="token comment" spellcheck="true">// 如果传入的不是数组，仿照 apply 抛出错误</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'CreateListFromArrayLike called on non-object'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> thisArg<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现要点-1"><a href="#实现要点-1" class="headerlink" title="实现要点"></a>实现要点</h3><p>基本上和 call 的实现是差不多的，只是我们需要检查第二个参数的类型。</p><h2 id="手写实现-bind"><a href="#手写实现-bind" class="headerlink" title="手写实现 bind"></a>手写实现 bind</h2><p><code>bind</code> 也可以像 <code>call</code> 和 <code>apply</code> 那样给函数绑定一个 this，但是有一些不同的要点需要注意：</p><ul><li><code>bind</code> 不是指定完 this 之后直接调用原函数，而是基于原函数返回一个内部完成了 this 绑定的新函数</li><li>原函数的参数可以分批次传递，第一批可以在调用 <code>bind</code> 的时候作为第二个参数传入，第二批可以在调用新函数的时候传入，这两批参数最终会合并在一起，一次传递给新函数去执行</li><li>新函数如果是通过 new 方式调用的，那么函数内部的 this 会指向实例，而不是当初调用 <code>bind</code> 的时候传入的 thisArg。换句话说，这种情况下的 <code>bind</code> 相当于是无效的</li></ul><h3 id="ES3-版本-2"><a href="#ES3-版本-2" class="headerlink" title="ES3 版本"></a>ES3 版本</h3><p>这个版本更接近 MDN 上的 polyfill 版本。</p><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myBind <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> fnToBind <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">var</span> args1 <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> fnBound <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果是通过 new 调用</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fnBound</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> fnToBind<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> args2 <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
            <span class="token keyword">return</span> fnToBind<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span>args1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>args2<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 实例继承</span>
    <span class="token keyword">var</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    Fn<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype
    fnBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> fnBound
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ES6-版本-2"><a href="#ES6-版本-2" class="headerlink" title="ES6 版本"></a>ES6 版本</h3><pre class="line-numbers language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myBind <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span><span class="token operator">...</span>args1<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'the caller must be a function'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> fnToBind <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">fnBound</span><span class="token punctuation">(</span><span class="token operator">...</span>args2<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果是通过 new 调用的</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fnBound</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">fnToBind</span><span class="token punctuation">(</span><span class="token operator">...</span>args1<span class="token punctuation">,</span><span class="token operator">...</span>args2<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> fnToBind<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">...</span>args1<span class="token punctuation">,</span><span class="token operator">...</span>args2<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现要点-2"><a href="#实现要点-2" class="headerlink" title="实现要点"></a>实现要点</h3><ol><li><p><code>bind</code> 实现内部 this 绑定，需要借助于 <code>apply</code>，这里假设我们可以直接使用 <code>apply</code> 方法</p></li><li><p>先看比较简单的 ES6 版本:</p><ol><li><strong>参数获取</strong>：因为 ES6 可以使用剩余参数，所以很容易就可以获取执行原函数所需要的参数，而且也可以用展开运算符轻松合并数组。</li><li><strong>调用方式</strong>：前面说过，如果返回的新函数 fnBound 是通过 new 调用的，那么其内部的 this 会是 fnBound 构造函数的实例，而不是当初我们指定的 thisArg，因此 <code>this instanceof fnBound</code>会返回 true，这种情况下，相当于我们指定的 thisArg 是无效的，new 返回的新函数等价于 new 原来的旧函数，即 new fnBound 等价于 new fnToBind，所以我们返回一个 new fnToBind 即可；反之，如果 fnBound 是普通调用，则通过 apply 完成 thisArg 的绑定，再返回最终结果。从这里可以看出，bind 的 this 绑定，本质上是通过 apply 完成的。</li></ol></li><li><p>再来看比较麻烦一点的 ES3 版本：</p><ol><li><p><strong>参数获取</strong>：现在我们用不了剩余参数了，所以只能在函数体内部通过 arguments 获取所有参数。对于 <code>myBind</code>，我们实际上需要的是除开第一个传入的 thisArg 参数之外的剩余所有参数构成的数组，所以这里可以通过 <code>Array.prototype.slice.call</code> 借用数组的 slice 方法（arguments 是类数组，无法直接调用 slice），这里的借用有两个目的：一是除去 arguments 中的第一个参数，二是将除去第一个参数之后的 arguments 转化为数组（slice 本身的返回值就是一个数组，这也是类数组转化为数组的一种常用方法）。同样地，返回的新函数 fnBound 后面调用的时候也可能传入参数，再次借用 slice 将 arguments 转化为数组</p></li><li><p><strong>调用方式</strong>：同样，这里也要判断 fnBound 是 new 调用还是普通调用。在 ES6 版本的实现中，如果是 new 调用 fnBound，那么直接返回 <code>new fnToBind()</code>，这实际上是最简单也最容易理解的方式，我们在访问实例属性的时候，天然就是按照 <code>实例 =&gt; 实例.__proto__ = fnToBind.prototype</code> 这样的原型链来寻找的，可以确保实例成功访问其构造函数 fnToBInd 的原型上面的属性；但在 ES3 的实现中（或者在网上部分 bind 方法的实现中），我们的做法是返回一个 <code>fnToBind.apply(this)</code>，实际上相当于返回一个 undefined 的函数执行结果，根据 new 的原理，我们没有在构造函数中自定义一个返回对象，因此 new 的结果就是返回实例本身，这点是不受影响的。这个返回语句的问题在于，它的作用仅仅只是确保 fnToBind 中的 this 指向 new fnBound 之后返回的实例，而并没有确保这个实例可以访问 fnToBind 的原型上面的属性。实际上，它确实不能访问，因为它的构造函数是 fnBound 而不是 fnToBind，所以我们要想办法在 fnBound 和 fnToBind 之间建立一个原型链关系。这里有几种我们可能会使用的方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 这里的 this 指的是 fnToBind</span>
fnBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样只是拷贝了原型引用，如果修改 <code>fnBound.prototype</code>，则会影响到 <code>fnToBind.prototype</code>，所以不能用这种方法</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// this 指的是 fnToBind</span>
fnBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过 <code>Object.create</code> 可以创建一个 <code>__proto__</code> 指向 <code>this.prototype</code> 的实例对象，之后再让 <code>fnBound.prototype</code> 指向这个对象，则可以在 fnToBind 和 fnBound 之间建立原型关系。但由于 <code>Object.create</code> 是 ES6 的方法，所以无法在我们的 ES3 代码中使用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// this 指的是 fnToBind</span>
<span class="token keyword">const</span> Fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
Fn<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype
fnBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是上面代码采用的方法：通过空构造函数 Fn 在 fnToBind 和 fnBound 之间建立了一个联系。如果要通过实例去访问 fnToBind 的原型上面的属性，可以沿着如下原型链查找：</p><p><code>实例 =&gt; 实例.__proto__ = fnBound.prototype = new Fn() =&gt; new Fn().__proto__ = Fn.prototype = fnToBind.prototype</code></p></li></ol></li></ol><p>​</p><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/09/Trs-1984 年的苹果麦金塔电脑长什么样呢？/">「译」1984 年的苹果麦金塔电脑长什么样呢？</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-09&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.2k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/09/Trs-1984 年的苹果麦金塔电脑长什么样呢？/"><blockquote><ul><li>原文链接：<a href="https://uxdesign.cc/the-1984-apple-macintosh-how-does-it-look-today-d08dde79da05" target="_blank" rel="noopener">https://uxdesign.cc/the-1984-apple-macintosh-how-does-it-look-today-d08dde79da05</a></li><li>原作者：Dmitrii Eliuseev</li><li>译者：Chor</li></ul></blockquote><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><p>1984 年的苹果公司在市场上早就不是初出茅庐的小白了。彼时，苹果二代已经销售了好几年。其采用的是原始的基于 BASIC 语言的操作系统，同时还有一定的处理磁盘文件的能力，但售价比竞争对手要便宜得多。和 CP/M 机不同，它还可以显示图像。下一代的 Apple Lisa 价格则非常高昂（1983 年售价 9995 美元，相当于现在的 25811 美元）。Apple Lias 并没有风靡世界，但它的推出使得苹果的设计师可以改进新的基于图形的 UI。最终，在 1984 年，咱们这篇文章的主角，苹果麦金塔电脑横空出世了。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_wcTD0gmBma_mlxTDmvbCiQ.png" alt=""></p><p>麦金塔电脑售价 2495 美元（相当于现在的 6140 美元），配置如下：</p><ul><li><p>7.8 MHz 的摩托罗拉 68000 型 CPU</p></li><li><p>128 KB 的 RAM（后面增加到 512 KB）</p></li><li>9” 512x342 的单色显示</li></ul><p>现在的工作环境中，几乎不可能再看到麦金塔电脑，但好在我们可以通过模拟器体验一把。我强烈推荐各位读者通过真正的系统去安装磁盘镜像，比起单纯看视频或者看我的文章，动手体验的感觉一定会更好。</p><h1 id="模拟安装"><a href="#模拟安装" class="headerlink" title="模拟安装"></a>模拟安装</h1><p>有很多种方式可以在你的电脑上模拟麦金塔的使用体验。最简单的方式就是直接在浏览器中打开<a href="https://jamesfriend.com.au/pce-js/" target="_blank" rel="noopener">在线模拟器</a>进行体验，但由于运行环境是浏览器，所以我们无法安装软件。对于那些想要追求更真实体验的读者，我建议你们使用更成熟的直接在系统上运行的模拟器。这种模拟器很多，我觉得最好用的是 <strong>Mini vMac</strong>。上手之前，你得先下载这些东西：</p><ul><li><a href="https://www.gryphel.com/c/minivmac/dnld_std.html" target="_blank" rel="noopener">模拟器本体</a></li><li>苹果麦金塔的 ROM 镜像（名字是 vmac.rom，大小大概 128 KB）。出于法律原因考虑，模拟器的作者并没有直接将镜像集成到模拟器本体中，所以我们需要自己下载（很容易找到）。之后，把镜像文件和模拟器放在同一个目录下</li><li>启动磁盘镜像文件（我使用的是从<a href="https://sites.google.com/site/minivmacapplicationsv6/systems-os" target="_blank" rel="noopener">这个页面</a>下载的 system 5.0 和 system 7.0 版本）</li></ul><p>之后启动模拟器，点击磁盘图标：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_sl36jUjtkMeRieil6Hoj2g.png" alt=""></p><p>我们的“麦金塔电脑”只差一步就可以正式运行了 —— 目前他还找不到系统磁盘。在文件菜单中，我们选择“打开磁盘镜像”，并选中之前下载好的启动磁盘镜像文件，之后就可以正式使用了。</p><p>此外，你也可以从网上下载使用其它的磁盘镜像，使用方法不变。</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>启动之后看到的主屏幕是这样的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_4OGfwuXbmQQo1XqPK_2Osw.png" alt=""></p><p>这个界面的改进非常大，要知道，之前的苹果二代仅支持使用基于文本的控制台界面：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_lU5s1W-BAQ6vwLkHiJpBEw.png" alt=""></p><p>可能苹果并不是从 0 开始打造这个新 UI 的，他们或许在设计上参考了 <a href="https://en.wikipedia.org/wiki/Xerox_Alto" target="_blank" rel="noopener">Xerox Alto</a>。具体情况我们无法 100% 确定，但无论如何，从用户的角度来说，这个界面可以说是有着翻天覆地的变化了。</p><p>上面的第一张图片是 5.0 版本的操作系统，起初它的功能有一定的限制，但后面陆续新增了一些很好用的功能。举个例子，用户可以在程序之间切换（我不确定程序是否真的在后台运行，也不确定是否可能只在程序之间切换），此外，我可以在图片编辑器上绘画，也可以在另一个程序上打开文本文件：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_blCjqut0krjyK1iE30a35A.png" alt=""></p><p>一些 UI 组件，比如苹果的 logo，Finder app 图标以及回收站图标等，在现代的 OS X 上依然可以看到。但麦金塔电脑不支持使用命令行，操作文件和文件夹也非常困难（在我看来，即使是今天的 iPhone 也有这个毛病）。同时，不存在右键点击这种操作，第一代苹果鼠标只有一个按钮：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_EEQfVpd35-GHQDeUCxR4eQ.png" alt=""></p><p>最后，能看到一个带有复杂 UI 的系统在一台仅有 512KB RAM 的电脑上运行，实在是一件很有意思的事情。要知道，现在光是打开一个窗口计算器就需要占用 20MB 内存，而我用来撰写本文的 Chrome 浏览器则直接占用了将近 2GB 的内存。</p><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>当然，第一台麦金塔电脑发布的时候，由于系统还比较新颖，相应的软件数量也很有限。</p><p>有意思的是，微软很热衷开发适配麦金塔的软件。Microsoft Excel 的第一个版本就是为麦金塔打造的，连微软自家的 MS-DOS 都没有这样的待遇：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_XyqSPJvpl_wKZnHVpegsXQ.png" alt=""></p><p>文本编辑也发生了彻底的改变，那时候出现的复制粘贴功能一直沿用至今。我可以在图片编辑器中绘画：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_4X2phIz9TWv6N98_sP3OWw.png" alt=""></p><p>之后复制图片，粘贴到另一个程序中：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_aNcDbNPvfvheVECzVesKeg.png" alt=""></p><p>有意思的是，Adobe Photoshop 的 UI 将近 40 年都没有发生特别大的变化：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_-bQRcUQXg2l0tyMtVTQ3Cg.png" alt=""></p><p>当时的 PS 不支持图层，但大部分的命令和菜单和今天的 PS 都很像：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_FEKMc1KUfowxE0UhzwqYGQ.png" alt=""></p><p>支持的格式比现在的 PS 要少很多：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_1d7r3bW1TT9n-SY67A6FyQ.png" alt=""></p><p>当时 PNG 和 JPEG 还没有登上了历史舞台，但 TIFF 和 GIF 已经出现了。</p><h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p>在系统启动后，BASIC 命令行就不可用了。不过我们可以将其作为独立的程序安装并运行。</p><p>比如打印 1 到 1000 中的所有质数：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_uyEc1dLPUKiPmWI4fBqMAg.png" alt=""></p><p>这并不是一个很成熟的 IDE，但看起来比之前好多了。彼时还有一个很流行的编程语言，那就是 Pascal：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_a4trhQj3UlZFgKkd-zlaTg.png" alt=""></p><p>代码中出现了大量的 begin-end 语句，一股久远的年代感扑面而来。另外，解释器（我觉得当时可能还没有编译器）有一点小 bug，我必须使用 r 变量存储范围，因为语句 <code>for p:=2 to (x-1)</code> 无法正常执行。还有一个问题是，只要使用 break 跳出循环，就会报错。</p><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><p>最后，我们来玩一玩游戏。我不认为那时候的人们会用麦金塔来打游戏，毕竟 2500 美元的价格可不低。不过，确实有一些针对麦金塔开发的游戏。</p><p>这并不是一个 3D 游戏，但画面看起来还行。比较可惜的是，模拟器无法正常游玩这个游戏，所以我搞不清楚自己需要操控角色做什么：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_Ut7PhVMeFmCCEsP3pfIUQg.png" alt=""></p><p>下面这个游戏比较奇怪，我觉得它有点像是很火的 Arkanoid，但是砖块却是出现在对面：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_Mxs7TV5nRv0Xuh4943N-aQ.png" alt=""></p><p>下面这个游戏是纯文本形式的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_gBAb9HgoOqiZ8AoLCscgtg.png" alt=""></p><p>这个跳棋游戏看起来还不错：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_O2HApWFgkP7pfLlipLKn1g.png" alt=""></p><p>用大炮击落目标，看起来早在愤怒的小鸟出现之前，就有这种游戏形式了：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_Y439jAos88zLUTTfoeemkQ.png" alt=""></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>对我来说，能够操控苹果麦金塔电脑是一种很有趣的体验。但有个问题我至今仍然想不明白，那就是为什么这个系统在当时并没有流行开来 —— 要知道，它的 UI 和软件在当时已经领先了 5 到 10 年。举个例子，MS-DOS 的用户一直到了 Windows 95 版本才能使用长文件名，而 Mac 用户在当时就已经可以做到了：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/1984%E5%B9%B4%E7%9A%84%E9%BA%A6%E9%87%91%E5%A1%94%E7%94%B5%E8%84%91/1_8LosKP9RcXOEYCw3xCUk1Q.png" alt=""></p><p>为什么麦金塔电脑没有成为主流呢？事实上，我也不知道答案，各位读者可以自己想一想。我能猜到的是，上世纪 80 年代的 IBM PC 机（1500 美元）要比苹果的（2500 美元）更加便宜，此外，麦金塔是单色显示，这在 80 年代可能已经过时了。另外还需要注意的是，麦金塔的硬件在当时是超前的，可以多开窗口。在 4K 大屏幕上操作多个窗口固然是一种很棒的体验，但在 512*342 分辨率的屏幕上打开多个窗口，可能体验并不是那么好。事实上，在当时很少有多开任务的需求。无论如何，我可以确定，苹果的 UI 对计算机行业有着重大的影响，并且鼓舞了开发者在其它平台上进行改进。</p><p>感谢你的阅读。如果你对计算机历史感兴趣，还可以阅读下面的文章：</p><ol><li><a href="https://medium.com/dev-genius/how-to-write-a-program-for-altair-8800-computer-3a4583fe601e" target="_blank" rel="noopener">Altair 8800</a> (1975)</li><li><a href="https://dmitryelj.medium.com/the-1979-cp-m-os-how-does-it-look-like-today-be7caf13da6c" target="_blank" rel="noopener">CP/M</a> (1979)</li><li><a href="https://medium.com/swlh/the-1979-apple-ii-how-does-it-look-today-741f5180282d" target="_blank" rel="noopener">Apple II</a> (1979)</li><li><a href="/windows-1-0-2-0-and-3-0-how-does-it-look-today-12c2231db21f">Windows 1.0, 2.0 and 3.0</a> (1985–1990)</li><li><a href="https://blog.usejournal.com/windows-95-how-does-it-look-today-feda837922d9" target="_blank" rel="noopener">Windows 95 (1995)</a></li><li><a href="/palm-os-how-does-it-look-today-f1c3c29f2240">Palm OS (1996)</a></li><li><a href="/android-1-0-how-does-it-look-today-476cbe74616a">Android (2008)</a></li></ol><p>此外，你还可以阅读<a href="https://dmitryelj.medium.com/radio-gadgets-and-electronics-100-years-of-histor-f92a6ae2ecef" target="_blank" rel="noopener">这篇文章</a>了解过去一百年间电子产品的发展历程。</p><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/05/09/Trs-Emoji之旅：从情绪表达工具到“百万美元商机”/">「译」Emoji之旅：从情绪表达工具到“百万美元商机”</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-05-09&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.5k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp8 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/05/09/Trs-Emoji之旅：从情绪表达工具到“百万美元商机”/"><blockquote><ul><li>原文链接：<a href="https://uxdesign.cc/emojis-journey-from-a-form-of-easier-self-expression-to-a-multi-million-dollar-business-822d3b17b07a" target="_blank" rel="noopener">https://uxdesign.cc/emojis-journey-from-a-form-of-easier-self-expression-to-a-multi-million-dollar-business-822d3b17b07a</a></li><li>原作者：Brinda Koushik</li></ul></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/emoji%E4%B9%8B%E6%97%85/1_lJHVN_d9FCSItIxMsTqLVA.png" alt=""></p><p>Emoji 是千禧一代和新的 Z 世代进行交流的一种方式。很多时候，我们很难单纯用文字表达自己的情绪，这时候 Emoji 就派上用场了。Emoji 就像人类的表情一样，是一种通用的交流方式，可以打破所有的语言壁垒。你可能单纯是 Emoji 的粉丝 😍 ，或者非常地喜欢 Emoji ❤️，你还可能很讨厌 Emoji 👎 ，或者对它没什么感觉🙄，但当在聊天中提到朋友的生日时，你可能会不自觉地使用这些表情： 🎂🍰🥳🎉🎈 。同样的，在情人节到来的那天，你还可能使用这些表情： 💞😘。</p><p>从第一个笑脸表情被设计出来，到今天我们已经可以自己创建一些头像，Emoji 的发展经历了一段相当有趣的历史。</p><h2 id="笑脸表情-🙂-的由来"><a href="#笑脸表情-🙂-的由来" class="headerlink" title="笑脸表情 🙂 的由来"></a>笑脸表情 🙂 的由来</h2><p>这个笑脸表情我们至少用过一次，你是否想过，是谁设计了第一个笑脸表情呢？他又是在什么场景下设计的呢？</p><p>最初的笑脸表情是由哈维·鲍尔在 1963 年设计的。彼时，马萨诸塞州伍斯特市有一家互助人寿保险公司（现在的汉诺威保险公司）正面临合并和收购，保险公司因此聘用了图形设计师哈维·鲍尔，让他设计一些东西来鼓舞员工低迷的士气。哈维仅用了不到 10 分钟和 45 美元，就设计出了现在我们使用的标志性笑脸表情 🙂 的原型。最初的笑脸表情有一大一小的椭圆形眼睛，笑容也不是标准的曲线，如图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/emoji%E4%B9%8B%E6%97%85/1_wUFuUBpmMCDV9a1rfnZ8eA.jpeg" alt=""></p><p>保险公司为 100 多位员工制作了带有这个笑脸表情的别针，让人出乎意料的是，客户竟然也喜欢上了这个东西。接下来的十年，这个笑脸表情迅速风靡，而保险公司也没有费心去纠结版权相关的事情。于是，它以各种方式出现在人们的生活中，包括按钮、海报、路标和贺卡等。</p><p>在上世纪 70 年代初，这些笑脸表情也在一定程度上鼓舞了陷入战争中的越南士兵和人民。1971 年，伯纳德和默里兄弟俩在费城一家商店注意到了这个笑脸表情，他们在笑脸下面添加了一句话“祝你有愉快的一天”，并进一步地设计出了自己的笑脸产品。到这一年的年底，他们的销售额达到了将近五千万。</p><p>查理·鲍尔是现在的<a href="https://www.worldsmile.org/" target="_blank" rel="noopener">世界微笑基金会</a>的负责人，这是一个非盈利的基层慈善基金会，创始人正是他已故的父亲 —— 哈维·鲍尔。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/emoji%E4%B9%8B%E6%97%85/1_nBJ-7Pw5rK-fV7flb-3lwg.jpeg" alt="Harvey Ball Musem Image"></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/emoji%E4%B9%8B%E6%97%85/1_kIgdLs2BRX-huLQsPeE1uA.png" alt="Harvey Ball Museum display exhibit"></p><p>曾在法国晚报工作的记者富兰克林·卢夫拉尼经常会在报纸中使用笑脸表情报道一些好新闻。在 1972 年，他将笑脸表情注册为商用，后面又成立了 Smiley 公司，并设计了大量以笑脸为主题的产品。</p><h2 id="早期互联网时代的笑脸表情和-Emoji"><a href="#早期互联网时代的笑脸表情和-Emoji" class="headerlink" title="早期互联网时代的笑脸表情和 Emoji"></a>早期互联网时代的笑脸表情和 Emoji</h2><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/emoji%E4%B9%8B%E6%97%85/1_q2O4A4EJDD3wTHpKB2NP_w.jpeg" alt="Yahoo messenger screenshot"></p><p>还记得雅虎聊天室里的 Emoji 表情吗？我觉得它们可比现在的表情生动多了。而这已经是上世纪 80 年代的东西。我还记得那些有趣的聊天室，切换不同窗口和来自各个地方的人聊天，以及年少时家附近的网吧，总是有成群结队的小孩子在屏幕前红着脸（当然还有不少是大叔）。雅虎聊天室始于 1998 年 3 月，但不幸的是，时过境迁的它已不再受欢迎，最终在 2018 年 7 月被关停了。</p><p>术语 <strong>emoji</strong> 来源于日本，翻译过来也就是所谓的象形文字。最初是由在电信公司 NTT DOCOMO 任职的日本设计师栗田穰崇及其团队创建的。当时的他必须要在限定的 12*12 的网格中设计图形。</p><p>NTT 设计了一款针对青少年用户的寻呼机，可以发送带有心形符号的短信。这款寻呼机一经面世就迅速风靡，此后也加入了更多可以出现在短信中的符号。</p><p>这家公司的产品还支持发送 250 字的短邮件，所以他们引入了 emoji，这样用户就可以使用表情表达更多的信息。但是，最常用的表情却不是栗田设计的第一批总计 176 个表情，而是其它信息量更充足的表情，比如月亮、太阳、汽车和天气等。</p><h2 id="为什么笑脸表情总是黄色的？"><a href="#为什么笑脸表情总是黄色的？" class="headerlink" title="为什么笑脸表情总是黄色的？"></a>为什么笑脸表情总是黄色的？</h2><p>为什么笑脸表情总是黄色的，还是一个秃头呢？有很多种解释。有人说使用黄色背景，看起来才比较悦目。想象一下，如果我们使用的是红色、绿色或者橙色的笑脸表情，你受的了？🤷‍♀️</p><p>至于为什么它是秃头，这主要是为了让我们把目光聚焦到表情本身。还有一种流行的说法是，这种黄色且秃头的 emoji 是受到了哈维·鲍尔最初设计的笑脸的影响。</p><h2 id="现代的-Emoji"><a href="#现代的-Emoji" class="headerlink" title="现代的 Emoji"></a>现代的 Emoji</h2><p>在 21 世纪初，我们可用的编码工具有 100 多种，但它们互相之间是无法通用的。即便是到了 2015 年，从安卓手机发送出去的 emoji 在 iPhone 手机上显示出来的也经常是 <code>???</code> 这样的乱码；同理，iPhone 发送给安卓的 emoji 则经常是 <code>𓂺𓂺𓂺𓂺𓂺</code>。因此，有必要让 emoji 能够不受基础语言和键盘支持的限制，实现跨平台兼容。</p><p>我们不仅要在 Whatsapp 上使用 emoji，还要再 Facebook、Slack 甚至是最近大火的 Clubhouse 中使用，所以有必要创建一个标准的 emoji 集合，从而实现无障碍地沟通和交流。</p><p>最终，emoji 出现了一个统一化管理的方案，这让它得以在各个平台使用。</p><p>作为一个非盈利组织，Unicode 联盟担当重任，负责审查并通过提交的 emoji。所有 emoji 都是由该联盟更新、修改和维护。现在，操作系统开发者终于有了一个地方可以将所有支持的 emoji 导出到他们的平台中并随处使用了。</p><p>Unicode 联盟有一个技术审查委员会，该委员会会决定是否通过新增的编码字符。目前，委员会的成员包括 <a href="https://en.wikipedia.org/wiki/Adobe_Inc." target="_blank" rel="noopener">Adobe</a>、<a href="https://en.wikipedia.org/wiki/Apple_Inc." target="_blank" rel="noopener">Apple</a>、 <a href="https://en.wikipedia.org/wiki/Facebook_Inc." target="_blank" rel="noopener">Facebook</a>、 <a href="https://en.wikipedia.org/wiki/Google" target="_blank" rel="noopener">Google</a>、 <a href="https://en.wikipedia.org/wiki/IBM" target="_blank" rel="noopener">IBM</a>、 <a href="https://en.wikipedia.org/wiki/Microsoft" target="_blank" rel="noopener">Microsoft</a>、 <a href="https://en.wikipedia.org/wiki/Netflix" target="_blank" rel="noopener">Netflix</a>、 <a href="https://en.wikipedia.org/wiki/SAP_SE" target="_blank" rel="noopener">SAP SE</a> 等。</p><h2 id="你知道最常用的-emoji-是什么吗？"><a href="#你知道最常用的-emoji-是什么吗？" class="headerlink" title="你知道最常用的 emoji 是什么吗？"></a>你知道最常用的 emoji 是什么吗？</h2><p>😂 和 ❤️ 位列最常用 emoji 表情的榜首， 😍 和 🤣 位居第二，紧跟着的则是 😊 🙏 💕 😭 😘。</p><p>在 emoji 的标准分类中，除了常用的笑脸等表情之外，还有手势和各种身体部位、衣服和配饰、动植物、食物和饮料、运动、旅行和景点、符号、非 emoji 符号等。</p><p>今天的 emoji 也更加地“包容”，我们可以看到新增了很多不同“肤色”的 emoji。肤色包括了白色、黑色、棕色和黄色等。</p><p>Unicode 联盟建议我们可以查看<a href="https://emojipedia.org/" target="_blank" rel="noopener">Emojipedia</a>、 <a href="http://emojitracker.com/" target="_blank" rel="noopener">Emojitracker</a>和 <a href="http://www.emojination.org/" target="_blank" rel="noopener">Emojination</a> 了解更多和 emoji 相关的故事。</p><p>关于 emoji 你有自己的想法吗？Unicode 联盟允许任何人提交 emoji 表情提案 —— 虽然有一定的门槛，需要经历审查。不过，受到疫情的影响，联盟曾暂停接收提案，直到今年四月份才恢复正常。</p><h2 id="Emoji-已经成为我们生活的一部分"><a href="#Emoji-已经成为我们生活的一部分" class="headerlink" title="Emoji 已经成为我们生活的一部分"></a>Emoji 已经成为我们生活的一部分</h2><ul><li>在群聊中，可能会有人向你发一堆 emoji 表情，并让你猜是哪一部电影。我记得好几年前就有这种小游戏了，只不过最近好像又火了起来。</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/emoji%E4%B9%8B%E6%97%85/1_2Z0JTHhHpLftCd3VkJnazQ.png" alt="Whatsapp image showing emoji puzzle"></p><ul><li>在参加一些活动的时候，可能会免费赠送一些带有笑脸表情的礼品</li><li>2018 有专家研究发现，在邮件标题中使用 emoji 可以提高大约 56% 的邮件打开率。Return Path 最近也发布了相关的报告，研究了在不同节日的促销广告邮件中使用 emoji 的效果</li><li>现在很多人都会在博客、推特、脸书和 Ins 中使用 emoji</li><li>有没有想过在销售页中使用 emoji 呢？现在也很流行这种做法。如果你使用的是电子设备，最简单的在页面中引入 emoji 的方式就是从 <a href="https://emojipedia.org/search/" target="_blank" rel="noopener">Emojipedia</a> 这个网站复制粘贴，这也是 Unicode 联盟推荐的做法</li><li>下面这些 emoji 表情可以大大提高邮件打开率，并且经常用于许多博客网站中： 🎁⭐✈️😃💗<a href="https://emojipedia.org/clinking-glasses/" target="_blank" rel="noopener">🥂</a> 🎉</li><li>有成千上万的商店和网站使用了包括笑脸在内的 emoji 表情</li></ul><h2 id="Bitmoji、Memoji-和-Avatars"><a href="#Bitmoji、Memoji-和-Avatars" class="headerlink" title="Bitmoji、Memoji 和 Avatars"></a>Bitmoji、Memoji 和 Avatars</h2><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/emoji%E4%B9%8B%E6%97%85/1_il9yciIg_pwE1eeiMFihvA.jpeg" alt="Bitmoji images screenshot.”Bitmoji classroom backgrounds (3)” by elizabethcasscundari"></p><p>emoji 本身的形式也正在经历变化。你可能已经习惯了使用 Whatsapp 的 Sticker，Snapchat 的 Bitmoji，苹果的 Memoji 或者是 Facebook 在 2020 年推出的 avatar。它们提供了发型选择、服装选择、肤色选择等功能，让我们在网络中的形象更加个性化。</p><p>有些人认为 emoji 是一种有趣的表达自我的方式，也有的人认为它只是一股科技潮流，而有商业眼光的人已经通过开发 emoji app 赚到了几百万美元。下一个流行的趋势可能和当初雅虎聊天室的 emoji 表情非常类似，即带有动画的 emoji 表情。不过出乎我们意料的是，GIF 虽然流行，但是没有完全取代 emoji。</p><p>emoji 和 avatar 是我们情绪的虚拟化表达，也许在未来的某一天，它们能够实时模拟表现出我们真实的情感呢？毕竟，未来谁说得准呢？</p><div class="default">阅读全文......</div></a></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/04/07/CN-浅谈网络协议：HTTP篇/">浅谈网络协议：HTTP 篇</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-04-07&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.7k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp13 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/04/07/CN-浅谈网络协议：HTTP篇/"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-3.png" alt=""></p><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/HTTP/">HTTP</a></span></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/04/07/CN-浅谈网络协议：HTTPS篇/">浅谈网络协议：HTTPS 篇</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-04-07&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp11 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/04/07/CN-浅谈网络协议：HTTPS篇/"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-4.png" alt=""></p><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/HTTPS/">HTTPS</a></span></div></article><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2021/04/07/CN-浅谈网络协议：Web 安全篇/">浅谈网络协议：Web 安全篇</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-04-07&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp5.4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp20 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2021/04/07/CN-浅谈网络协议：Web 安全篇/"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-5.png" alt=""></p><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/网络安全/">网络安全</a></span></div></article></section><nav class="pager-nav"><a class="extend prev" rel="prev" href="/">« Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/3/">Next »</a></nav></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->