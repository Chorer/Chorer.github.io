<!-- build time:Sun Sep 05 2021 14:32:51 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">关于 Git 的那些事</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-05-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp5.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp20 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/工具/">工具</a> <a href="/tags/多人协作/">多人协作</a></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg"></div><span id="more"></span><blockquote><p>主要记录学习 Git 过程中的一些坑。重点在于各种 Git 操作，但也不限于此，一些和 Git 相关的东西都会记录一下。</p></blockquote><p>本文的思维导图如下：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.png"></div><h3 id="git-安装和升级">1. Git 安装和升级</h3><p>安装应该不用多说了，主要讲一下升级。Linux 和 Mac 都有包管理器，升级是很方便的，关键是 windows 并没有这类东西，那么怎么升级呢？</p><p>这里首先要通过 <code>git version</code> 查看你当前的 Git 版本是多少，如果版本：</p><ul><li><code>&lt;= 2.14.1</code> ：不要多想，老老实实卸载旧版本，安装新版本吧。。。</li><li><code>2.14.2 ~ 2.16.1</code> ：直接 <code>git update</code> 升级</li><li><code>&gt;= 2.16.1(2)</code>：直接 <code>git update-git-for-windows</code> 升级</li></ul><p>通过命令升级的时候可能半天没反应，最后提示你 <code>using proxy as per lookup</code>，如图所示：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png"></div><p>那么不要犹豫了，梯子开起来，否则速度绝对让你崩溃。如果没有梯子，那也只能卸载再安装了，不过官网下载的速度也是相当之慢......</p><h3 id="git-乱码问题解决方案">2. Git 乱码问题解决方案</h3><p>以下操作基于 win10。</p><p>这个问题有点奇怪，直接使用 <code>Git Bash</code> 是不会出现乱码的，但是使用 <code>windows terminal</code> 后，在 <code>git log</code> 的时候中文会显示为八进制。你的问题可能和我不一样，也许是 <code>git commit</code> 或者 <code>git status</code> 的时候乱码。总之，我们可以统一设置：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> config --global gui.encoding utf-8
<span class="fu">git</span> config --global core.quotepath false
<span class="fu">git</span> config --global i18n.commitencoding utf-8
<span class="fu">git</span> config --global i18n.logoutputencoding utf-8</code></pre></div><p>最后执行：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="bu">export</span> <span class="va">LESSCHARSET=</span>utf-8</code></pre></div><p>然后新建一个环境变量，键名 <code>LESSCHARSET</code>，键值 <code>utf-8</code>。（这一步很关键，否则你新开窗口还是会乱码的）</p><p>注意：具体的设置可能因为系统（我是 win10）或默认编码不同而不同。我在解决这个问题的时候查看了很多博客，有的地方会说 <code>git config --global i18n.logoutputencoding utf-8</code> 这一步应该是设置为 <code>gbk</code>，不过我这样设置之后连 <code>Git bash</code> 也乱码了......（尽管 win10 的默认编码应该是 <code>gbk</code> 没错），所以在设置上还是得看你自己系统的情况，可能得多试几次。</p><blockquote><p>2020-05-27 更</p></blockquote><p>这个 <code>windows terminal</code> 果然不让人省心，今天发现 <code>ls</code> 指令也会有乱码的情况，而且目录不会高亮。最后在这个 <a target="_blank" rel="noopener" href="https://github.com/microsoft/terminal/issues/5227">issue</a> 下找到了答案，两种解决方法：</p><p>① 编辑 <code>git/etc/bash/bashrc</code> 文件，末尾添加：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">export</span> LANG<span class="op">=</span><span class="st">&quot;zh_CN.UTF-8&quot;</span>
<span class="im">export</span> LC_ALL<span class="op">=</span><span class="st">&quot;zh_CN.UTF-8&quot;</span></code></pre></div><p>② 编辑 <code>windows terminal</code> 的 <code>setting.json</code> 文件：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&quot;commandline&quot;</span><span class="op">:</span> <span class="st">&quot;D:</span><span class="sc">\\</span><span class="st">Git</span><span class="sc">\\</span><span class="st">bin</span><span class="sc">\\</span><span class="st">bash.exe&quot;</span>
<span class="co">// 改为 </span>
<span class="st">&quot;commandline&quot;</span><span class="op">:</span> <span class="st">&quot;D:</span><span class="sc">\\</span><span class="st">Git</span><span class="sc">\\</span><span class="st">bin</span><span class="sc">\\</span><span class="st">bash.exe -li&quot;</span></code></pre></div><p><code>-li</code> 参数可以让 <code>git bash</code> 以正确的配置启动。估计前面所有问题都和这个有关，因为我的 <code>git</code> 没有安装在默认路径，可能导致某些配置读取不了，出现各种奇葩的问题。</p><h3 id="初始配置">3. 初始配置</h3><p>显示配置：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> config -l/--list
<span class="fu">git</span> config --global -l/--list</code></pre></div><p>进行配置：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> config --global username <span class="st">&#39;xxx&#39;</span>
<span class="fu">git</span> config --global useremail <span class="st">&#39;xxx&#39;</span></code></pre></div><p>这里的参数可以是 <code>local</code>（对本仓库生效），<code>global</code>（对登录用户的所有仓库生效） 或 <code>system</code>（对所有用户的所有仓库生效），在优先级上依次递减。</p><h3 id="本地仓库操作">4. 本地仓库操作</h3><h4 id="工作区相关">4.1 工作区相关</h4><p>生成项目文件夹（本地仓库），同时生成记录重要信息的隐藏文件夹 <code>.git</code>：</p><pre class="shell"><code>git init project</code></pre><p>查看项目文件状态，红色表示文件还在工作区，绿色表示文件还在暂存区，不显示表示都到了历史区：</p><pre class="shell"><code>git status</code></pre><p>撤销本地文件的修改，使之回退到最近一次 <code>git add</code> 的状态：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> checkout -- <span class="op">&lt;</span>file<span class="op">&gt;</span></code></pre></div><blockquote><p>上面这个命令和切换分支非常像（多了 <code>--</code>），容易混淆。为此，<code>git 2.23</code> 之后引入了专门的回退命令和切换分支命令，用来分离 <code>git checkout</code> 的职责。</p></blockquote><p>我们可以用下面命令进行工作区文件的回退：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> restore <span class="op">&lt;</span>file<span class="op">&gt;</span></code></pre></div><p>有时候我们在工作区做一些修改的时候，可能临时接手了其它更紧急的任务，那么这时候就得把当前所做的更改做一个状态保存：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> stash</code></pre></div><p>在任务完成后，想要恢复之前保存的状态，则可以：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> stash apply
<span class="ex">//</span> 或者
<span class="fu">git</span> stash pop</code></pre></div><h4 id="暂存区相关">4.2 暂存区相关</h4><h5 id="提交文件到暂存区">提交文件到暂存区</h5><pre class="shell"><code>git add &lt;file&gt;
git add .
git add -A </code></pre><h5 id="删除暂存区的文件">删除暂存区的文件</h5><pre class="shell"><code>git rm --cached &lt;file&gt;
git rm --cached -r .
git rm &lt;file&gt;     // 删除工作区和暂存区的文件 </code></pre><h5 id="修改工作区和暂存区的文件名">修改工作区和暂存区的文件名</h5><pre class="shell"><code>git mv &lt;file1&gt; &lt;file2&gt;
git commit -m&#39;Change the file name&#39;</code></pre><h5 id="撤销对暂存区的文件提交">撤销对暂存区的文件提交</h5><p>当我们修改文件并进行了 <code>git add</code> 之后，就不能再通过 <code>git restore &lt;file&gt;</code> 直接撤销本地文件的修改了。但可以先通过 <code>git reset HEAD &lt;file&gt;</code> 撤销对暂存区的文件提交（某个文件不提交了），再 <code>git restore &lt;file&gt;</code> 。</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> reset HEAD <span class="op">&lt;</span>file<span class="op">&gt;</span></code></pre></div><p>同样的，我们可以用新命令代替：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> restore --staged <span class="op">&lt;</span>file<span class="op">&gt;</span></code></pre></div><p>这两个命令借助于 <code>HEAD</code> 进行恢复，因此运行在“至少提交了一次”的前提下（若没有提交则不存在 <code>HEAD</code>，使用命令是会报错的）。不过忘了也没关系，Git 会根据操作给我们相关提示的。</p><p>当我们不加 <code>&lt;file&gt;</code> 参数的时候，会撤销暂存区所有的文件提交（所有文件都不提交了），其实相当于恢复到了最近一次 <code>commit</code> 的状态：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> diff HEAD</code></pre></div><h5 id="比对差异">比对差异</h5><p>在急着将工作区的文件提交到暂存区之前，可以先比对两个区的差异：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> diff</code></pre></div><p>如果目标是具体文件，也可以加上参数：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> diff --<span class="op">&lt;</span>file<span class="op">&gt;</span></code></pre></div><p>同样，在急着将暂存区的文件提交到历史区之前，可能需要先将暂存区与最近一次 <code>commit</code> 进行比对，看看修改了什么东西（<code>--cached</code> 表示暂存区）：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> diff --cached</code></pre></div><h4 id="历史区相关">4.3 历史区相关</h4><h5 id="提交文件到历史区">提交文件到历史区</h5><pre class="shell"><code>git commit -m&#39;xxxxx&#39;
git commit</code></pre><h5 id="查看-commit-信息">查看 <code>commit</code> 信息</h5><pre class="shell"><code>git log
git log --oneline   // 查看简略的提交信息
git log --graph   // 查看图示提交信息
git log --n4        // 查看最近四次的提交信息
git log --all      // 查看所有分支上的提交信息
git reflog         // 查看包含回退在内的提交信息</code></pre><h5 id="修改最近一次-commit-信息">修改最近一次 <code>commit</code> 信息</h5><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> commit --amend</code></pre></div><h5 id="修改以前的-commit-信息">修改以前的 <code>commit</code> 信息</h5><p>如果要修改以前的 <code>commit</code> 信息，就需要变基（<code>rebase</code>）了。找到要修改的 <code>commit</code> 的前一次 <code>commit id</code> ：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> rebase -i <span class="op">&lt;</span>commit id<span class="op">&gt;</span></code></pre></div><p>我们要修改的是 <code>3291b88</code> 这个 <code>commit</code> 的信息，将前面的 <code>pick</code> 指令改为 <code>reword</code> 指令，并保存：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/15.png"></div><p>来到另一个界面，在这里进行修改，之后保存退出即可：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/16.png"></div><h5 id="合并多个连续-commit">合并多个连续 <code>commit</code>：</h5><p>假设想要合并中间的多个连续 <code>commit</code>（2.txt 到 6.txt）：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17-0.png" style="zoom:80%"></p><p>基于这几个 <code>commit</code> 的前一次 <code>commit id</code> 进行变基：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> rebase -i ec7eeb3</code></pre></div><p>在这里会列出第一个 <code>commit</code> 往后的所有 <code>commit</code>，将想要合并的 <code>commit</code> 前面的指令改为 <code>squash</code> 指令，并保存：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/17.png"></div><p>编辑 <code>commit</code> 信息，这个信息会成为合并后的总 <code>commit</code> 信息，保存退出：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/18.png"></div><p>可以看到，<code>commit</code> 合并成功了：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/18-1.png" style="zoom:80%"></p><h5 id="合并多个非连续-commit">合并多个非连续 <code>commit</code>：</h5><p>针对上面合并之后的结果，如果我们想要合并第一个和最后一个 <code>commit</code>，那么可以基于第一个 <code>commit</code> 进行变基：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> rebase -i ec7eeb3</code></pre></div><p>在 <code>rebase</code> 的交互式界面中，只会显示第一个 <code>commit</code> 往后的 <code>commit</code>，但是我们这里需要用到第一个 <code>commit</code>，所以手动写入一个 <code>pick ec7eeb3</code>，并把第三个 <code>commit</code> 调整放到它后面，squash 有压入、塞入的意思，这里可以理解为把第三个 <code>commit</code> 塞入第一个中：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/19.png"></p><p>保存后会弹出一些提示，通过 <code>git rebase --continue</code> 再次回到交互式界面中。后面的步骤就和之前一样了：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.png" style="zoom:80%"></p><p>再来打印看看，发现合并成功了：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/21.png"></div><h5 id="版本回退">版本回退</h5><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> reset --hard HEAD^ / HEAD~n
<span class="fu">git</span> reset --hard <span class="op">&lt;</span>commit id<span class="op">&gt;</span></code></pre></div><h5 id="比对版本差异">比对版本差异</h5><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> diff <span class="op">&lt;</span>commit id1<span class="op">&gt;</span> <span class="op">&lt;</span>commit id2<span class="op">&gt;</span></code></pre></div><h4 id="分支相关">4.4 分支相关</h4><p>在介绍具体的指令之前，首先要搞清楚 <code>HEAD</code>，<code>master</code> 和 <code>dev</code> 三个指针的作用（不考虑版本回退的情况）：</p><ul><li>在一开始，默认只有 <code>master</code> 分支（主分支），<code>master</code> 指针始终指向主分支的最近一次 <code>commit</code>，并在每次出现新的 <code>commit</code> 时向前推进；</li><li>如果新建分支，则会出现 <code>dev</code> 指针，它始终指向子分支的最近一次 <code>commit</code>，并在每次出现新的 <code>commit</code> 时向前推进；</li><li>不管当前处于哪个分支，<code>HEAD</code> 指针都指向该分支的最近一次 <code>commit</code></li></ul><p>假设最初只有一个主分支，第一次 <code>commit</code> 新建文本文件，第二次 <code>commit</code> 修改文件内容。下面结合例子和示意图介绍指令。</p><h5 id="查看所有分支">查看所有分支</h5><pre class="shell"><code>git branch -av</code></pre><p>此时只有一个主分支，<code>HEAD</code> 和 <code>master</code> 指针都指向最近一次 <code>commit</code>：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" style="zoom:67%"></p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11-1.png"></div><p>PS：这里一定要注意，判断当前处于哪个分支看右边括号的内容即可，<code>HEAD -&gt; master</code> 表示的并不是 <code>HEAD</code> 指针指向主分支，而是像示意图那样。</p><p>参数 <code>-a</code> 代表查看本地和远程所有分支，<code>-v</code> 代表查看分支的同时显示最后一次 <code>commit</code> 的相关信息。如果只想查看本地分支，可以：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> branch -v</code></pre></div><h5 id="基于当前分支的最近一次-commit-创建并切换分支">基于当前分支的最近一次 <code>commit</code> 创建并切换分支</h5><pre class="shell"><code>git branch new_branch
git checkout new_branch
/* 或者 */
git checkout -b new_branch </code></pre><p>此时有了子分支，由于它是基于主分支的最近一次 <code>commit</code> 创建的，所以三个指针指向同一个东西，即 <code>HEAD -&gt; new_branch,master</code></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.png" style="zoom:67%"></p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12-1.png"></div><h5 id="基于某次-commit-创建并切换分支">基于某次 <code>commit</code> 创建并切换分支</h5><pre class="shell"><code>git branch new_branch &lt;commit id&gt;
git checkout new_branch 
/* 或者 */
git checkout -b new_branch &lt;commit id&gt;</code></pre><p>如果我们是基于第一次 <code>commit</code> 创建分支的，则指针的变动如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13.png" style="zoom:67%"></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/13-1.png" style="zoom:90%"></p><h5 id="基于某个分支创建并切换分支">基于某个分支创建并切换分支</h5><pre class="shell"><code>git checkout -b new_branch old_branch</code></pre><h5 id="切换分支">切换分支</h5><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> switch new_branch</code></pre></div><p>在 <code>git 2.23</code> 之后有了专门的切换分支命令。</p><h5 id="合并分支">合并分支</h5><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> merge new_branch</code></pre></div><h5 id="删除分支">删除分支</h5><p>直接删除指定分支：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> branch -D new_branch</code></pre></div><p>删除前会先让用户确定分支是否已经合并：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> branch -d new_branch</code></pre></div><h5 id="比对分支差异">比对分支差异</h5><p>假设当前提交情况如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/23.png" style="zoom:80%"></p><p>要比较两个分支的差异，自然而然想到：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> diff master new_branch</code></pre></div><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/24.png" style="zoom:80%"></p><p>不过，前面我们知道，<code>master</code> 指针指向主分支最近一次 <code>commit</code>，<code>dev</code> 指向子分支最近一次 <code>commit</code>，正是这两个指针不同才得以将分支区别开来，而指针又是指向 <code>commit</code>，因此其实可以通过比对两个分支最近一次 <code>commit</code> 的差异，进而比对两个分支的差异：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/25.png" style="zoom:80%"></p><p>可以看到，虽然两次 <code>diff</code> 的参数不同，但是结果是一样，这是因为<strong>比对分支的差异，在本质上就是比对 <code>commit</code> 的差异</strong>。</p><h5 id="基于某次-commit-切换到分离头指针状态">基于某次 <code>commit</code> 切换到“分离头指针”状态</h5><pre class="shell"><code>git checkout &lt;commit id&gt;</code></pre><p>此时，我们会到达某次 <code>commit</code> 之后的状态，我们可以从此次 <code>commit</code> 的状态出发，进行一些试探性的修改。由于处在 <code>'detached HEAD' state</code>（“分离头指针”状态），所以修改不是基于任何具体分支的，一旦切换到某个具体分支，所有的修改都会消失。这适用于实验性的修改，可以避免影响其它任何分支。</p><p>其实，Git 给出的文字提示也很清楚。我们还可以注意括号里的内容，一开始是 <code>master</code> 分支，后来直接变成了某一次 的 <code>commit id</code>。同时可以看到，<code>HEAD</code> 不再像此前一样指向某个指针，而是<strong>分离了</strong>：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14.png" style="zoom:67%"></p><p>对应的示意图如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/14-1.png" style="zoom:90%"></p><p>当然，我们可以执行下面指令：</p><pre class="shell"><code>git checkout -b new_branch</code></pre><p>此时就会真正创建一个分支，我们的修改得以保留。实际上就和之前的 <code>git checkout -b new_branch &lt;commit id&gt;</code> 效果一样。</p><h4 id="git-的三个重要对象committreeblob">4.5 Git 的三个重要对象（commit、tree、blob）</h4><p>① 每一次提交会形成一个 <code>commit</code> 对象，根据 id 查看该 <code>commit</code> 对象的类型和内容：</p><pre class="shell"><code>git cat-file -t &#39;xxxxxx&#39;   
git cat-file -p &#39;xxxxxx&#39;</code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" style="zoom:67%"></p><p>② 该 <code>commit</code> 对象的 <code>tree</code> 对象是一棵文件结构树，它记录了提交时的文件结构快照（有哪些文件夹、哪些文件），根据 id 查看该 <code>tree</code> 对象的类型和内容：</p><pre class="shell"><code>git cat-file -t &#39;xxxxxx&#39;    // tree
git cat-file -p &#39;xxxxxx&#39;</code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" style="zoom:67%"></p><p>③<code>tree</code> 对象包含了 <code>tree</code> 对象和 <code>blob</code> 对象，分别指代文件夹和文件，我们可以进一步查看其类型和内容：</p><pre class="shell"><code>git cat-file -t &#39;xxxxxx&#39;    // tree or blob
git cat-file -p &#39;xxxxxx&#39;</code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.png" style="zoom:67%"></p><p><strong>注意最外层、最初始的 <code>tree</code> 是文件结构树，此后的 <code>tree</code> 是文件夹树</strong>。比方拿下面这张图来看，第一棵树是文件结构树，内容是各个文件夹和文件，文件直接指代 <code>blob</code> 对象，而文件夹则指代另一棵树/ <code>tree</code> 对象。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" style="zoom:50%"></p><h3 id="远程仓库操作">5. 远程仓库操作</h3><h4 id="公私钥配置">5.1 公私钥配置</h4><p>查看本地公私钥配置情况：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">ls</span> -al ~/.ssh</code></pre></div><p>生成公私钥：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">ssh-keygen</span> -t rsa -b 4096 -C <span class="st">&#39;your_email@example.com&#39;</span></code></pre></div><p>之后本地保存私钥，并在 GitHub 个人设置里配置公钥。</p><h4 id="新建项目">5.2 新建项目</h4><p>第一步，先到 GitHub 创建一个远程仓库，拿到仓库对应的 <code>ssh</code> 或者 <code>http</code> 地址</p><p>第二步，创建本地仓库：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> init                          // 初始化当前文件夹为本地仓库
<span class="fu">git</span> remote add origin <span class="op">&lt;</span>Address<span class="op">&gt;</span>  // 本地仓库与远程仓库建立关联
<span class="fu">git</span> remote -v                   // 查看与本地仓库关联的远程仓库</code></pre></div><p>最后，本地提交一些修改，并推送到远程：</p><pre class="shell"><code>git add -A  
git commit -m&#39;xxxx&#39;    
git push origin master   </code></pre><p>PS：注意，如果之前建立远程仓库的时候勾选新建 <code>README.md</code> 文件，并且后来采用的不是 <code>git clone</code> 的方法，那么在这里是不能直接推送到远程的，因为本地与远程内容不一样（本地没有 <code>README.md</code> 文件），直接推送的话会报错。必须得先 <code>git pull</code> 把远程的东西拉下来同步，之后再 <code>git push</code>。</p><h4 id="克隆项目">5.3 克隆项目</h4><p>在前面的第二步，可以直接 <code>git clone</code> ，这样就不需要手动初始化本地仓库、建立远程连接以及同步等：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> clone <span class="op">&lt;</span>Address<span class="op">&gt;</span></code></pre></div><p>不过，这只会克隆远程仓库的 master 分支。<strong>以后</strong>如果我们想要克隆远程的其它分支，可以：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span>  branch  remote_branch_name  origin/remote_branch_name</code></pre></div><p>或者是直接切换到其它分支，Git 默认会帮我们建立一个追踪（track）远程仓库对应分支的分支：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> switch remote_branch_name</code></pre></div><p>如果一开始就只想要克隆某个分支，可以：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> clone -b remote_branch_name <span class="op">&lt;</span>Address<span class="op">&gt;</span></code></pre></div><p>还有一种情况是，我们直接在本地建立了一个分支，忘记将它和对应的远程分支建立关联，这时候怎么办呢？可以这样：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> branch --set-upstream-to=origin/remote_branch  remote_branch </code></pre></div><h3 id="多人开发">6. 多人开发</h3><p>假设老大（项目负责人）新建远程仓库 X，并添加 AB 两人作为仓库的 contributor，那么 AB 就可以各自 clone 形成一个本地仓库，在做一些修改之后直接 push 到 X 仓库。</p><h4 id="修改不同文件同一文件不同区域">6.1 修改不同文件/同一文件不同区域</h4><p>A 和 B 在同一个分支 <code>remote_branch</code> 上进行开发，A 修改 a 文件，B 修改 b 文件。在 A <code>push</code> 之后，B 是不能直接 <code>push</code> 的，因为本地仓库与远程仓库对应分支的内容还没进行同步。必须先执行下面的操作进行同步：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> pull origin/remote_branch</code></pre></div><p>这个指令其实做了两件事，第一件事是把远程已被 A 更新的 <code>remote_branch</code> 分支拉到本地：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> fetch origin/remote_branch</code></pre></div><p>第二件事是将这个目前最新的分支与本地 B 自己的分支进行合并：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> merge remote_branch origin/remote_branch</code></pre></div><p>最后再进行 <code>push</code> 就不会再报错了。</p><p>还有一种情况是修改同一文件的不同区域，因为修改的地方不一样，Git 还是可以帮我们进行 <code>merge</code> 的。</p><h4 id="修改同一文件同一区域">6.2 修改同一文件同一区域</h4><p>因为上面的修改都是针对不同区域的修改，所以不存在冲突，Git 可以帮我们进行 <code>merge</code>。但是当修改同一文件的同一地方时，情况就不一样了：比如说 A 修改了 a 文件的某个地方，之后 push；B 同时也修改了 a 文件的这个地方，进行 <code>push</code>，之后报错，所以 B 选择先 <code>fetch --&gt; merge</code> 再 <code>push</code>，但是在 <code>merge</code> 的时候还会报错（Auto merged failed）。</p><p>这是因为 A 和 B 都修改了同一个地方，Git 并不知道以谁的修改为准，因此 Git 无法帮我们做合并的工作。此时，就需要 B 手动去处理冲突，之后再 <code>add --&gt; commit --&gt; push</code> 才行。</p><h4 id="修改同一文件的文件名">6.3 修改同一文件的文件名</h4><p>假设现在的场景是：A 修改 a 文件的文件名为 a1，之后 <code>push</code>；B 修改 a 文件的文件名为 a2，也想要 <code>push</code>，因为本地和远程不同步，根据之前解释的，到这里自然会报错，所以 B 决定先 <code>pull</code> 再 <code>push</code>，但实际上，在 <code>pull</code> 这一步的时候会再报一个错，提示无法进行 <code>merge</code>。</p><p>这和 6.2 其实是一样的情况，A 和 B 都想要修改同一个东西，Git 不知道应该以谁为准。假设 AB 经过协商，最终决定修改为 a2，那么对于 B 来说，他可以把本地的 <code>a</code> 和 <code>a1</code> 删除，再对 <code>a2</code> 进行 <code>add --&gt; commit --&gt; push</code> 的操作。（为什么会有 <code>a1</code>，是因为 <code>pull</code> 操作的 <code>fetch</code> 这一步是没问题的，远程拉下来之后本地会多出此前 A 更新的 <code>a1</code> 文件）</p><h4 id="localorigin-和-upstream">6.4 local，origin 和 upstream</h4><p>在前面，我们是单人开发或者团队开发，可能只涉及到本地仓库和远程仓库，即 local 和 origin。假设 A 发现了某个第三方开源项目 <code>ThirdParty/project</code> 存在一些 bug，他想要进行修复，那么他就需要 fork 别人的仓库，形成自己的远程仓库 <code>A/project</code>，再克隆这个仓库形成本地仓库。那么，对于本地仓库来说，<code>A/project</code> 就是 origin，而 <code>ThirdParty/project</code> 就是 upstream。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/26.png" style="zoom:67%"></p><h5 id="local-和-origin-的同步">local 和 origin 的同步</h5><p>这个就是之前讲的情形，origin 是 A 自己的远程仓库，A 具有自由读写的权限，可以直接 <code>pull</code> 和 <code>push</code>。</p><h5 id="local-和-upstream-的同步">local 和 upstream 的同步</h5><p>如果本地仓库想要与原始仓库同步，第一步是先设置上游：</p><p><code>git bash git remote add upstream &lt;remoteAddress&gt;</code></p><p>查看当前配置的远程仓库（将包括 origin 和 upstream）：</p><p><code>git bash git remote -v</code></p><p>之后就可以与原始仓库进行同步了：</p><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"> <span class="fu">git</span> pull upstream master</code></pre></div><p>不过这里要注意，A 不是项目参与者，对原始仓库是没有写入权限的，因此无法直接进行 <code>git push</code> 操作。那么 A 怎么做呢？他可以先在本地把 bug 修复好，之后先 push 到 orgin 上去，再对原始仓库发起 pull request，等待项目负责人进行 merge。</p><h5 id="origin-和-upstream-的同步">origin 和 upstream 的同步</h5><p>设置上游之后，本地可以与原始仓库保持同步，那么 origin 怎么与原始仓库同步呢？我们需要反向 pull request。这里可以以<strong>掘金翻译计划</strong>这个项目为例。在我们自己的仓库点击 pull request 来到这个界面：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/29.png"></div><p>注意这里的 head 和 base，一开始是 origin 指向 upstream，表示我这边更新了东西，想要原始仓库去合并；不过现在的情况是反过来的，我们可以看作是原始仓库更新了东西，想要我们去合并。所以将 head 和 base 改为从 upstream 指向 origin：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/28.png"></div><p>可以看到，因为有很长一段时间没有同步更新了，所以多出了整整 800 多个 commit。到了这个界面，就可以正式创建 pr，然后我们自己来 merge 了。这样，origin 和 upstream 就保持了同步。</p><h4 id="合并">6.5 合并</h4><ol style="list-style-type:decimal"><li><code>git clone</code> 仓库，默认只 clone <code>master</code> 分支</li><li><code>git checkout -t origin/分支1</code>，在本地新建 分支1 并与远程 分支1 建立连接，并拉取 分支1 代码（也可以先新建本地分支，后面再建立与远程分支的连接）</li><li><code>git checkout -t origin/分支2</code>，同理得到 分支2</li><li>假设甲在 分支1 开发，我们需要合并他的代码到自己分支上，那么首先切换到他的分支，通过 <code>git pull</code> 更新最新代码，再切换到自己分支，通过 <code>git merge 分支1</code>合并他的代码到自己的分支上。</li><li>最后再 <code>git push</code> 完成自己的提交。</li></ol><p>参考：</p><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/course/intro/100021601">玩转 Git 三剑客</a></p><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰 Git 教程</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/06/29/F-%E6%89%93%E5%BC%80Devtools%E5%89%8D%E5%90%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/" rel="prev" title="打开DevTools前后，对象的打印有什么区别？"><i class="fa fa-angle-double-left"></i>&nbsp打开DevTools前后，对象的打印有什么区别？</a></div><div class="post-nav-next"><a href="/2020/05/13/F-%E8%AE%B0%E4%B8%A4%E9%81%93%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%A2%98/" rel="next" title="记两道关于事件循环的题">记两道关于事件循环的题&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#git-%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%87%E7%BA%A7"><span class="toc-text">1. Git 安装和升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">2. Git 乱码问题解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E9%85%8D%E7%BD%AE"><span class="toc-text">3. 初始配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-text">4. 本地仓库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%9B%B8%E5%85%B3"><span class="toc-text">4.1 工作区相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9B%B8%E5%85%B3"><span class="toc-text">4.2 暂存区相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA"><span class="toc-text">提交文件到暂存区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-text">删除暂存区的文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-text">修改工作区和暂存区的文件名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%AF%B9%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%90%E4%BA%A4"><span class="toc-text">撤销对暂存区的文件提交</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E5%AF%B9%E5%B7%AE%E5%BC%82"><span class="toc-text">比对差异</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E5%8C%BA%E7%9B%B8%E5%85%B3"><span class="toc-text">4.3 历史区相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E5%88%B0%E5%8E%86%E5%8F%B2%E5%8C%BA"><span class="toc-text">提交文件到历史区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-commit-%E4%BF%A1%E6%81%AF"><span class="toc-text">查看 commit 信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1-commit-%E4%BF%A1%E6%81%AF"><span class="toc-text">修改最近一次 commit 信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%BB%A5%E5%89%8D%E7%9A%84-commit-%E4%BF%A1%E6%81%AF"><span class="toc-text">修改以前的 commit 信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E8%BF%9E%E7%BB%AD-commit"><span class="toc-text">合并多个连续 commit：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E9%9D%9E%E8%BF%9E%E7%BB%AD-commit"><span class="toc-text">合并多个非连续 commit：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80"><span class="toc-text">版本回退</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E5%AF%B9%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82"><span class="toc-text">比对版本差异</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3"><span class="toc-text">4.4 分支相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E5%88%86%E6%94%AF"><span class="toc-text">查看所有分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E7%9A%84%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1-commit-%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF"><span class="toc-text">基于当前分支的最近一次 commit 创建并切换分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9F%90%E6%AC%A1-commit-%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF"><span class="toc-text">基于某次 commit 创建并切换分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF"><span class="toc-text">基于某个分支创建并切换分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF"><span class="toc-text">切换分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"><span class="toc-text">合并分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><span class="toc-text">删除分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E5%AF%B9%E5%88%86%E6%94%AF%E5%B7%AE%E5%BC%82"><span class="toc-text">比对分支差异</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9F%90%E6%AC%A1-commit-%E5%88%87%E6%8D%A2%E5%88%B0%E5%88%86%E7%A6%BB%E5%A4%B4%E6%8C%87%E9%92%88%E7%8A%B6%E6%80%81"><span class="toc-text">基于某次 commit 切换到“分离头指针”状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#git-%E7%9A%84%E4%B8%89%E4%B8%AA%E9%87%8D%E8%A6%81%E5%AF%B9%E8%B1%A1committreeblob"><span class="toc-text">4.5 Git 的三个重要对象（commit、tree、blob）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-text">5. 远程仓库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E7%A7%81%E9%92%A5%E9%85%8D%E7%BD%AE"><span class="toc-text">5.1 公私钥配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-text">5.2 新建项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%9A%86%E9%A1%B9%E7%9B%AE"><span class="toc-text">5.3 克隆项目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91"><span class="toc-text">6. 多人开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F"><span class="toc-text">6.1 修改不同文件&#x2F;同一文件不同区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E5%90%8C%E4%B8%80%E5%8C%BA%E5%9F%9F"><span class="toc-text">6.2 修改同一文件同一区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-text">6.3 修改同一文件的文件名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#localorigin-%E5%92%8C-upstream"><span class="toc-text">6.4 local，origin 和 upstream</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#local-%E5%92%8C-origin-%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">local 和 origin 的同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#local-%E5%92%8C-upstream-%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">local 和 upstream 的同步</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#origin-%E5%92%8C-upstream-%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">origin 和 upstream 的同步</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6"><span class="toc-text">6.5 合并</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->