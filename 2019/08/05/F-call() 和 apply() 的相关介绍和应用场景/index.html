<!-- build time:Mon Jan 03 2022 16:31:30 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/prism.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">call() 和 apply() 的相关介绍和应用场景</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-08-05&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.7k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp6 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/this/">this</a></div></div><div class="post-content"><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/callapplybind.jpg" alt=""></p><span id="more"></span><h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">fun</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token function">fun</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> <span class="token punctuation">[</span>param1<span class="token punctuation">,</span>param2<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">fun</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h2><p><code>call()</code> 和 <code>apply()</code> 返回函数应该返回的值，<code>bind()</code> 返回一个经过硬绑定的新函数。</p><h2 id="参数介绍"><a class="markdownIt-Anchor" href="#参数介绍"></a> 参数介绍</h2><p>第一个参数为 thisArg，其取值有以下几种情况：</p><ul><li><p>不传/ 传null/ 传undefined：非严格模式下，this 指向 window 对象；严格模式下指向 undefined；</p></li><li><p>传递基本类型：this 指向其对应的包装对象，如 String、Number、Boolean</p></li><li><p>传递一个对象：函数中的 this 指向这个对象</p></li></ul><p>第二个参数有以下几种情况：</p><ul><li>不传/ 传null/ 传undefined：表示不需要传入任何参数</li><li><code>call()</code> 和 <code>bind()</code> 的第二个参数都是参数列表，而 <code>apply()</code> 则是参数数组（或者类数组）—— 尽管如此，在这些参数传递给调用函数时，仍然是以参数列表的形式传递的（这一点很重要）。</li></ul><h2 id="执行"><a class="markdownIt-Anchor" href="#执行"></a> 执行</h2><p><code>call()</code> 和 <code>apply()</code> 一经调用则立即执行函数，而 <code>bind()</code> 则只是完成了函数的 this 绑定。因为函数不会立刻执行，所以适合在事件绑定函数中使用 <code>bind()</code> ，这样既完成了绑定，也确保了<strong>仅当事件触发时</strong>才执行函数。</p><h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h2><p>在<a href="">这篇文章</a>说过，<code>call()</code>，<code>apply()</code> 和 <code>bind()</code> 都可以改变 this 的指向，什么时候需要改变 this 的指向呢？大部分时候其实是为了<strong>借用方法</strong>，即在对象上调用其自身不具备的方法。看一下下面的例子：</p><h3 id="1-方法借用判断数据类型"><a class="markdownIt-Anchor" href="#1-方法借用判断数据类型"></a> 1. 方法借用：判断数据类型</h3><p>利用 <code>Object.prototype.toString.call()</code> 可以准确地判断数据类型，如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"[object String]"</span> <span class="token comment">//true</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"[object Array]"</span>  <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原理就是：在任何值上调用 <strong>Object 原生的 toString() 方法</strong>，都会返回一个格式为 [object NativeconstructorName] 的字符串。据此可以准确判断任何值的数据类型。<br>既然 Array 和 Function 都继承了 Object 的该方法，为什么不直接在它们身上调用？这是因为 <code>toString()</code> 被重写过了，<strong>不是原生方法</strong>，因此这里改为调用 Object 的该方法，并将 this 绑定给对应的值。</p><h3 id="2-方法借用类数组使用数组方法"><a class="markdownIt-Anchor" href="#2-方法借用类数组使用数组方法"></a> 2. 方法借用：类数组使用数组方法</h3><p>例如 arguments 是类数组，并不具备数组的 <code>forEach()</code> 方法，那么我们可以通过 <code>call()</code> 调用数组的该方法，同时将方法里面的 this 绑定到 arguments 上：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>类数组借用数组的方法，还可以将类数组转化为数组：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>   <span class="token comment">// slice 本身会返回一个数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然还有其它转化方法：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span>
Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-模拟浅拷贝"><a class="markdownIt-Anchor" href="#3-模拟浅拷贝"></a> 3. 模拟浅拷贝</h3><p>模拟浅拷贝的过程中，需要剔除原型链上的属性，考虑到源对象可能基于 <code>Object.create()</code> 创建，而这样的对象是没有 <code>hasOwnProperty()</code> 方法的，因此我们不在源对象身上直接调用该方法，而是通过 <code>Object.prototype.hasOwnProperty.call()</code> 的方式去调用，因为 Object 一定是有这个方法的，我们可以借用一下。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>nextSource<span class="token punctuation">,</span> nextKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    to<span class="token punctuation">[</span>nextKey<span class="token punctuation">]</span> <span class="token operator">=</span> nextSource<span class="token punctuation">[</span>nextKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-增强子类实例"><a class="markdownIt-Anchor" href="#4-增强子类实例"></a> 4. 增强子类实例</h3><p>JavaScript 的几种继承方式中，有一种就是借用构造函数：<br>假设有子构造函数 <code>Son</code> 和父构造函数 <code>Parent</code>。对于 <code>Son</code> 而言，其内部的 this 将指向稍后实例化的对象，利用这一点，我们在 <code>Son</code> 的内部通过 <code>call()</code> 或者 <code>apply()</code> 调用 <code>Parent</code>，同时传参 this，这样就可以增强子类实例。</p><h3 id="5-求数组的最值"><a class="markdownIt-Anchor" href="#5-求数组的最值"></a> 5. 求数组的最值</h3><p><code>apply()</code> 可用于展开数组，即传进去的第二个参数是一个参数数组，但实际执行的时候会被转化为一个参数列表。利用这一点，我们可以求一个数组的最大值 —— 虽然 Math 对象有 <code>max()</code> 方法，但该方法只接受参数列表。那么这时候，我们可以将该方法以 <code>apply()</code> 的方式去调用，从而展开数组：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 
Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6-延迟执行函数的-this-绑定"><a class="markdownIt-Anchor" href="#6-延迟执行函数的-this-绑定"></a> 6. 延迟执行函数的 this 绑定</h3><p><code>bind</code> 和 <code>call</code> / <code>apply</code>的一个重要区别就在于，它只是对原函数提前做了一个 this 绑定，并没有马上去执行函数。因此对于那些延迟执行但又容易发生 this 丢失的函数（比如定时器的回调函数），我们可以在声明的时候先通过 bind 绑定一个 this。比如：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    value <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>    
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> 
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>像这样直接调用会发生 this 丢失的问题，因为 setTimeout 本质上还是通过 window 调用的，所以 this 会指向 window。而这个回调函数我们又不想马上执行，只是想它在执行的时候绑定一个正确的 this，因此我们可以使用 bind：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    value <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>    
        <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> 
obj<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-实现柯里化包装函数"><a class="markdownIt-Anchor" href="#7-实现柯里化包装函数"></a> 7. 实现柯里化包装函数</h3><p>比如说现在有一个 add 函数：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b 
<span class="token punctuation">&#125;</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要让 add 函数做到类似 <code>add(1)(2)</code> 这样的分批次接收参数，且最终执行结果是一样的，应该怎么办呢？可以将 add 改写如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是参数是灵活的，我们更希望实现一个通用的柯里化包装函数，传进去的函数经过包装之后，会返回一个原函数的柯里化版本。这里就可以使用 bind 来实现了：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> fn<span class="token punctuation">.</span>length
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">fnCurried</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token function">fnCurried</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> curryAdd <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span>
<span class="token function">curryAdd</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment">// 3</span>
<span class="token function">curryAdd</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>几个要点：</p><ul><li>将目标函数 fn 传给包装函数 curry 之后，会返回一个柯里化版本的函数 fnCurried。对于 fnCurried，我们在调用的时候，可以选择一次性传完所有参数，也可以选择分批次传参数，那么如何判断呢？如果是分批次传参的话，传的参数个数 <code>arguments.length</code> 一定会小于 fn 实际应该接受的参数 <code>fn.length</code>，反之则是一次性传所有参数</li><li>如果是一次性传所有参数，那就比较简单了，直接返回原函数 fn 的调用结果就行（注意要展开 arguments）</li><li>如果是分批次传参数，那么就重复返回相同的函数以供下次进行同样的调用。这里我们使用 bind 并不是为了修改 this 指向，所以传一个 null 就行，我们只是为了利用 <strong>bind 可以分批次传参</strong>这个特点来收集每次调用得到的参数而已。</li></ul><p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/p/6034307.html">https://www.cnblogs.com/onepixel/p/6034307.html</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5d469e0851882544b85c32ef">https://juejin.im/post/5d469e0851882544b85c32ef</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/08/06/F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/" rel="prev" title="数据类型判断"><i class="fa fa-angle-double-left"></i>&nbsp数据类型判断</a></div><div class="post-nav-next"><a href="/2019/07/11/F-%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="next" title="解析赋值、浅拷贝和深拷贝">解析赋值、浅拷贝和深拷贝&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-text">参数介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-text">执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E5%80%9F%E7%94%A8%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 方法借用：判断数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E5%80%9F%E7%94%A8%E7%B1%BB%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-text">2. 方法借用：类数组使用数组方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E6%8B%9F%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">3. 模拟浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A2%9E%E5%BC%BA%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B"><span class="toc-text">4. 增强子类实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B1%82%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%80%BC"><span class="toc-text">5. 求数组的最值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E7%9A%84-this-%E7%BB%91%E5%AE%9A"><span class="toc-text">6. 延迟执行函数的 this 绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E5%8C%85%E8%A3%85%E5%87%BD%E6%95%B0"><span class="toc-text">7. 实现柯里化包装函数</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>function send_valine_Server(){var e="desp=",t=document.title,n=t.indexOf("|"),a=(t.substring(0,n),document.URL),s=new Date,l=document.getElementsByClassName("vnick vinput")[0].value||"Anonymous",i=(document.getElementsByClassName("vmail vinput")[0].value,document.getElementsByClassName("vlink vinput")[0].value,document.getElementsByClassName("veditor vinput")[0].value),o=e+"文章："+a+"\n\n昵称："+l+"\n\n留言："+i+"\n\n时间："+s.toLocaleString(),v=new XMLHttpRequest;v.open("POST","https://sc.ftqq.com/"+SCKEY_Server+".send",!0),v.setRequestHeader("Content-type","application/x-www-form-urlencoded"),v.send(title1+"&"+o)}new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0});var title1="text=你的博客有新的评论",SCKEY_Server="SCT99005TwWJDrDKdBwQGK0YmcPRAsr4B",ValineButton=document.getElementsByClassName("vsubmit vbtn")[0];ValineButton.onclick=send_valine_Server</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2022</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/prism.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:150,height:300,vOffset:-120,hOffset:-5},mobile:{show:!1},react:{opacityDefault:1e3,opacityOnHover:1e3},log:!1})</script></body></html><!-- rebuild by neat -->