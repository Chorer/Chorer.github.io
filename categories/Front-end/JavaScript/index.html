<!-- build time:Sun Sep 05 2021 14:32:53 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><div class="category-page-container"><div class="category-page-title"><span class="category_title">JavaScript</span></div><div class="category-page-cards"><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/08/06/F-数据类型判断/">数据类型判断</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-08-06&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp840&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp3 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/08/06/F-数据类型判断/"><span id="more"></span><h2 id="typeof"><code>typeof</code></h2><p><code>typeof</code> 操作符返回一个表示数据类型的字符串，它可以应付常规场景下的数据类型判断。对基本数据类型 <code>undefined</code>, <code>boolean</code>, <code>string</code>, <code>number</code> 和引用数据类型 <code>function</code> 都可以正确判断，但是对 null，数组，对象则统一返回 &quot;object&quot;。也就是说，<code>typeof</code> 不适合用来判断引用数据类型。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">1</span>
<span class="kw">typeof</span> a <span class="co">// &quot;number&quot;</span>
<span class="kw">var</span> b <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]
<span class="kw">typeof</span> b <span class="co">// &quot;object&quot;</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="op">&#123;&#125;</span>
<span class="kw">typeof</span> c <span class="co">// &quot;object&quot;</span></code></pre></div><h2 id="instanceof"><code>instanceof</code></h2><p><code>instanceof</code> 解决了上述问题，它的原理就是判断右操作数（通常是构造函数）的原型对象是否出现在左操作数（通常是实例）的原型链上，如果在则返回 <code>true</code>。据此可以判断引用数据类型具体是哪种类型。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> b <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]
b <span class="kw">instanceof</span> Array <span class="co">// true</span>
<span class="kw">var</span> c <span class="op">=</span> <span class="op">&#123;&#125;</span>
c <span class="kw">instanceof</span> Object <span class="co">// true</span></code></pre></div><p>需要注意的是，<code>instanceof</code> 对于不是通过 new 创建的基本数据类型无法做出正确的判断：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">1</span>
a <span class="kw">instanceof</span> Number <span class="co">// false</span></code></pre></div><p>这是因为此时的 a 仅仅是一个基本类型的值，而不是实例对象，如果我们通过 new 创建 a，那么就能正确判断</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="kw">new</span> <span class="at">Number</span>(<span class="dv">1</span>)<span class="op">;</span>
a <span class="kw">instanceof</span> Number <span class="co">// true</span></code></pre></div><p>结合 <code>instanceof</code> 的原理其实就很好理解其中原因了。</p><p><code>&gt;&gt;</code> 另外要注意，<code>instanceof</code> 这个方法并非百试百灵 —— 假定脚本中有多个全局环境，例如 html 中有多个子 iframe，那么对于每一个全局环境而言，它都有自己版本的构造函数，进而有自己版本的原型链。<code>instanceof</code> 左右两边的操作数来自于不同全局环境时，即使实例和构造函数对应，也只会返回 false。</p><h2 id="object.getprototypeof"><code>Object.getPrototypeOf()</code></h2><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span>]<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">Object</span>.<span class="at">getPrototypeOf</span>(arr) <span class="op">===</span> <span class="va">Array</span>.<span class="at">prototype</span>)<span class="op">;</span> <span class="co">// true</span></code></pre></div><p>利用原型链。存在同上问题。</p><h2 id="isprototypeof"><code>isPrototypeOf()</code></h2><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span>，<span class="dv">2</span>]<span class="op">;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">Array</span>.<span class="va">prototype</span>.<span class="at">isPrototypeOf</span>(arr))<span class="op">;</span> <span class="co">// true</span></code></pre></div><p>利用原型链。存在同上问题。</p><h2 id="object.prototype.tostring.call"><code>Object.prototype.toString.call()</code></h2><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span>，<span class="dv">2</span>]<span class="op">;</span>
<span class="vs">`Object.prototype.toString.call(arr)`</span><span class="op">;</span> <span class="co">//&quot;[object Array]&quot;</span></code></pre></div><p>这个方法基本很完善，原理就是：在任何值上调用 <strong>Object 原生的 toString() 方法</strong>，都会返回一个格式为 [object NativeconstructorName] 的字符串。据此可以准确判断任何值的数据类型。</p><p>这里注意几个点：</p><ol style="list-style-type:decimal"><li><p>arr 作为对象，也是 Object 的一个实例，为什么不直接使用 <code>arr.toString()</code>？这是因为它的这个方法被重写了，即 <code>Array.prototype.toString()</code>。在使用 <code>arr.toString()</code> 的时候，它优先在原型链上找到并调用了重写的方法，最后输出的是 <code>&quot;1,2&quot;</code>。</p></li><li><p>对象字面量调用 <code>toString()</code> 的时候则依然输出 <code>&quot;[object Object]&quot;</code>，这是因为它没有重写这个方法，所以找到的是 <code>Object.prototype</code> 的该方法。</p></li><li><p>同样的，函数对象的 <code>toString()</code> 方法也被重写了，即 <code>Function.prototype.toString()</code>。调用的时候返回一个表示当前函数源代码的字符串。当对内置函数对象调用该方法时，返回如下格式的字符串：</p></li></ol><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Object</span>.<span class="at">toString</span>()<span class="op">;</span>

<span class="co">// &quot;function Object() &#123;</span>
<span class="co">//    [native code]</span>
<span class="co">// &#125;&quot;</span>

<span class="va">Array</span>.<span class="at">toString</span>()<span class="op">;</span> 
<span class="co">// &quot;function Array() &#123; </span>
<span class="co">//    [native code] </span>
<span class="co">// &#125;&quot;</span></code></pre></div><p>实际上，这里的 Object 是构造函数，既然是函数，就可以看作是 Function 构造函数实例化的对象，因此这里相当于函数对象调用了 <code>toString()</code> 方法，也就是调用的 <code>Function.prototype.toString()</code> 方法。</p><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/数据类型/">数据类型</a></span></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/08/05/F-call() 和 apply() 的相关介绍和应用场景/">call() 和 apply() 的相关介绍和应用场景</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-08-05&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.7k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp6 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/08/05/F-call() 和 apply() 的相关介绍和应用场景/"><div class="figure"><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/callapplybind.jpg"></div><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/this/">this</a></span></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/07/11/F-解析赋值、浅拷贝和深拷贝/">解析赋值、浅拷贝和深拷贝</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-07-11&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp15 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/07/11/F-解析赋值、浅拷贝和深拷贝/"><div class="figure"><embed src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-1.webp"></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/05/30/F-DOM 和 BOM 中的各种宽高属性/">DOM 和 BOM 中的各种宽高属性</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-05-30&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.5k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp5 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/05/30/F-DOM 和 BOM 中的各种宽高属性/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7-1.png"></div><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/05/24/F-ES6 参数作用域/">ES6 参数默认值引起的中间作用域</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-05-24&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp6 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/05/24/F-ES6 参数作用域/"><p>ES6 参数默认值的问题，其实之前在<a href="https://chorer.github.io/2019/05/02/Trs-ES6%EF%BC%9A%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/">这篇文章</a>中已经有涉及，之所以再谈起这个问题，是在阅读《ES6 标准入门》时产生的一个疑惑。阮老师的代码是：</p><div class="default">阅读全文......</div></a></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/04/17/F-深入理解this绑定/">深入理解this绑定</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-04-17&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp16 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/04/17/F-深入理解this绑定/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A-0.jpg"></div><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/this/">this</a> <a href="/tags/调用栈/">调用栈</a></span></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/04/10/F-深入理解变量对象、作用域链和闭包/">深入理解变量对象、作用域链和闭包</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-04-10&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp16 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/04/10/F-深入理解变量对象、作用域链和闭包/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85-00.png"></div><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/闭包/">闭包</a> <a href="/tags/变量对象/">变量对象</a> <a href="/tags/作用域链/">作用域链</a></span></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/04/08/F-深入理解执行上下文和执行栈/">深入理解执行上下文和执行栈</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-04-08&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp10 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/04/08/F-深入理解执行上下文和执行栈/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-1.jpg"></div><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/执行上下文/">执行上下文</a> <a href="/tags/词法环境/">词法环境</a></span></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/03/31/F-深入理解原型和继承/">深入理解原型和继承</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-03-31&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp17 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/03/31/F-深入理解原型和继承/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-1.png"></div><div class="default">阅读全文......</div></a></div><div class="post-sub_container"><span class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/继承/">继承</a> <a href="/tags/原型/">原型</a> <a href="/tags/对象/">对象</a></span></div></article></section><section class="posts"><article class="post_full post_except"><h1 class="post-title"><a class="post-title-link" href="/2019/03/17/F-原型式继承和类式继承/">原型式继承和类式继承</a></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-03-17&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span></div><div class="post-content"><a href="/2019/03/17/F-原型式继承和类式继承/"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/java-vs-javascript.jpg"></div><div class="default">阅读全文......</div></a></div></article></section></div><nav class="pager-nav"><span class="page-number current">1</span><a class="page-number" href="/categories/Front-end/JavaScript/page/2/">2</a><a class="page-number" href="/categories/Front-end/JavaScript/page/3/">3</a><a class="extend next" rel="next" href="/categories/Front-end/JavaScript/page/2/">Next »</a></nav></div></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->