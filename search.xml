<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《如何成为优秀的用户体验设计师》</title>
      <link href="/2019/10/26/T-%E3%80%8A%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E5%B8%88%E3%80%8B/"/>
      <url>/2019/10/26/T-%E3%80%8A%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E5%B8%88%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E5%B8%88/T-%E3%80%8A%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%9A%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E5%B8%88%E3%80%8B-1.jpg" alt=""></p><a id="more"></a><p>首先检讨一番自己，在之前的计划里说过这学期要阅读一些用户体验相关的书籍，但目前为止（10月26号）这是我正式读完的第一本。虽然努力挤出时间了，但是每次要静下心来阅读一本书还是有难度。</p><p>和用户打交道更多的是 UI 设计师，但是前端去了解用户体验相关的知识也是很有必要的。在图书馆借了一本魏慎初老师写的 《如何成为优秀的用户体验设计师》，花了几星期陆陆续续看完了。读完之后的感想：</p><ul><li>借书是有期限的，这个限制能够推动你去进行更加积极主动的阅读。虽然可以借几个月，但手头的书毕竟不是自己的，就好像一个任务悬挂在队列里，不完成内心可能就不是很痛快。这种情况下比阅读自己买的书效率要快很多。</li><li>再说回书本身，作为一个看书甚少的人，我只能粗略地写写自己的感想了。总体上是本很不错的书，结构和思路很清晰，有理论的部分，但是很好地结合了大量案例去进行阐述，读者能够在实际业务场景中去体会作者要传达的意思。即使只是通读，读完也大概会有一个思维脉络了。</li></ul><p>下面是阅读过程做的一些笔记（小声bb一句，typora 真香，用来排版太爽了）：</p><h3 id="基础思维"><a href="#基础思维" class="headerlink" title="基础思维"></a>基础思维</h3><ul><li><p>好的设计，不仅仅是满足用户的基本需求（这只是最低要求），最主要的是带领、引导用户，也就是设计策划所有用户能够感知到的东西。</p></li><li><p>一些术语：</p><ul><li>UI ，即 user interface，用户界面</li><li>UED， 即 user experience design，用户体验设计</li><li>IxD，即 interaction design，交互设计，强调互动和信息交换</li><li>UX/UE，即用户体验，其实也包括使用前和使用后</li></ul></li><li><p>用户体验设计是产品的升级，不建议在产品未跑通的情况下过早介入，容易影响大局观。</p></li><li><p>用户体验中心的两个核心业务，一个是<strong>视觉设计</strong>，一个是<strong>交互设计</strong>，当然，前者是基础</p></li><li><p><em>站在用户的角度思考问题</em>：</p><p>不断训练自己的同理心，学会聆听和接纳</p><ul><li><p><strong>用户画像</strong>：确定用户群体是哪些人、基本信息、偏好</p><p>！！！切忌主观臆测。<strong>数据调查</strong>才是王道，而且也要确保是一手信息</p></li><li><p><strong>用户使用数据分析</strong>：PV，UV，访问深度、停留时间、浏览轨迹等</p><p>分析原因、反省初期设计</p></li><li><p><strong>同理心亲身体验</strong>：我就是目标用户。</p><ul><li>忘记所有设计内容：朋友帮忙测试/娱乐环境中测试</li><li>用用户的思维去思考：放下成见、融入生活</li></ul></li></ul></li><li><p><em>挖掘用户的真实需求</em></p><ul><li>表面需求的本质是真实需求。一定要思考用户需求的背后是什么？</li></ul></li><li>引领用户的需求：<ul><li>提前为为用户做出他们下一阶段的需求引导</li><li>变化会让人类有新鲜感</li></ul></li><li>有必要学习和了解<strong>艺术</strong>和艺术史，以及设计史。培养自己对艺术的修养</li><li><strong>理性和感性</strong>是相互依存的，<strong>功能性和艺术性</strong>分别是这两者的表达方式</li></ul><h3 id="基础技能"><a href="#基础技能" class="headerlink" title="基础技能"></a>基础技能</h3><ul><li><p>顺畅和跳跃：</p><ul><li><p>顺畅：统一感。最底层的要求</p></li><li><p>跳跃：很多时候在避免。但跳跃其实能给人一种深刻的印象，继而起到突出重点的 作用。</p><p>频繁的顺畅未必是好事，偶尔的跳跃可能有奇效。</p><ul><li>比如文字高亮强调，用户的跳跃感不是来源于颜色的显眼，而是来源于它的稀少，如果高亮部分过多，那么就会导致 <strong>跳跃感 ——&gt; 流畅感</strong> 的转化。</li><li>比如 <code>ok</code> 和 <code>cancel</code> 按钮的互换，用户在习惯了“<code>ok</code>总是出现在右边”这一点之后，对于一些重要的选择页面，可以把 <code>ok</code> 放在左边，这种反习惯的设计比起二次确认，可以更好地防止用户的误操作。</li></ul></li></ul></li><li><p>节奏：</p><p>要把握好顺畅和跳跃的节奏，做好起承转合。</p><p>基于用户的常规浏览顺序去把控节奏：</p><ul><li>面积大的元素、色彩反差强烈的元素、上到下（边界弱化现象）、左到右（边界弱化现象）、具象图形、符号化图形、文字（文字其实也是图形化的一种）</li></ul><p>一个重点+两个次重点就够了。所有都突出 = 0 突出</p><p>在交互上：</p><ul><li>横划交互的流失量高于下划交互，点击也会流失，因为点击需要精准性（手眼调动）</li><li>3秒定理 —— 不要让我等待超过3秒。可以考虑设置加载动画</li><li>用户相应预期，避免让他们觉得莫名其妙</li></ul></li><li><p>孟塞尔色彩体系：</p><ul><li><p>每一种颜色都可以用色相、明度、饱和度表示（HVC）</p><ul><li>色相：5种基本色相（RYGBP），每两个色相夹着一个中间色相，共计十个。一个色相分为10个等级、4个色阶，前面所说的10个色相都位于等级5，也就是第二个色阶。</li><li>明度：亮与暗</li><li>饱和度：颜色的鲜艳程度</li></ul></li><li><p>调和与对比</p></li><li><p>色彩的节奏：</p><p>有一个整体调子/调性</p><p>颜色控制方式：</p><ul><li>高级灰</li><li>降低饱和度</li><li>冷暖调子</li></ul></li><li><p><strong>best practice</strong>：</p><ul><li>有限考虑色彩感情</li><li>整体调和</li><li>对比重点</li></ul></li></ul></li><li><p>欲望、时间与能量的权衡：</p><ul><li>欲望 = 时间 x 能量 = 具有满足感并引起关注和兴趣</li><li>欲望 = 时间 x 能量 = 用户厌恶或者流失</li><li>欲望 = 时间 x 能量 = 用户可能丢失信息</li></ul><p>用户习惯是随着科技发展在变化的，但是不变的是消耗能量与欲望之间的关系</p></li></ul><h3 id="战术思想"><a href="#战术思想" class="headerlink" title="战术思想"></a>战术思想</h3><p>​ 马斯洛需求层次：</p><ul><li><p>生理需求：经济能力、打折优惠</p></li><li><p>安全需求：消费者保障、信誉</p></li><li>爱与归属感需求：情怀、人情味、针对某一群体的产品</li><li>尊重需求：自我尊重和外界尊重。<ul><li>为什么社交产品大多只设置了“点赞”，很少设置“踩”？这是为了确保社交网络的整体尊重性，当然有的网站还是有“踩”的，这是功能上的需要。</li><li>16年开始，互联网进入了以<strong>内容为王</strong>的时代，在这个大环境下，内容产出者比以往更加重视尊重需求</li></ul></li><li>自我实现需求</li></ul><p>这些需求是有一个从下到上的顺序的，也就是说，满足了下层需求，才会去考虑上层需求。</p><p>数据：</p><ul><li>如何看待数据：<ul><li>大数据只是提供一个方向，需要针对具体的小数据进行深入分析</li><li>重视数据之间的权重</li><li>反馈的真实性？</li></ul></li><li>数据指标：<ul><li>核心数据：PV，UV，独立 IP</li><li>参考数据：访问深度，访问时长，用户轨迹，点击率，退出率</li><li>目标数据：转化率，日活量</li></ul></li></ul><h3 id="工作理念"><a href="#工作理念" class="headerlink" title="工作理念"></a>工作理念</h3><h4 id="5W2H："><a href="#5W2H：" class="headerlink" title="5W2H："></a>5W2H：</h4><ul><li>对外：<ul><li>when：上线时间、用户发现时间</li><li>where：上线位置、环境媒体</li><li>who：预期用户、实际用户可能有哪些？</li><li>what：做的是什么性质的产品？是要干嘛的？</li><li>why：用户为什么会对xxx感到xxx？</li><li>how：用户如何看到页面？</li><li>how much：用户和公司投入的成本</li></ul></li><li>对内：<ul><li>when：阶段性的时间点、进度控制</li><li>where：技术开发平台</li><li>who：经手人、需求人、开发者是谁？</li><li>what：工作性质，日常/临时？</li><li>why：需求人提出需求的动机</li><li>how：技术实现</li><li>how much：开发人员工作量</li></ul></li></ul><h4 id="黄金圈法则："><a href="#黄金圈法则：" class="headerlink" title="黄金圈法则："></a>黄金圈法则：</h4><p>why ——&gt; how ——&gt; what，<strong>由内到外</strong>，而不是由外到内。</p><p>做一个产品，不是以结果为出发点，而是以动机为出发点。产品的出现都是为了解决某一个问题，那么解决问题本身就是我们的动机，基于动机我们去采取某些措施，在这些措施的推动下诞生了我们的产品。</p><p>Tip：不仅是产品设计本身，日常工作和沟通也是可以使用这个法则的。</p><h4 id="用户心态："><a href="#用户心态：" class="headerlink" title="用户心态："></a>用户心态：</h4><ul><li><p>主流人群主流需求：</p><p>要尽可能考虑更多的群体，但是不要因为小众群体影响大众群体的主流需求。满足所有人的需求是不可能的。</p></li><li><p>培养同理心：</p><ul><li>放弃成见，对不熟悉的东西保持宽容心和好奇心</li><li>爱好对爱好。不要直接去对比，而是用自己对爱好的热情代入用户对他自己爱好的热情</li><li>深入用户喜好。日常有意地去了解一些大众群体的喜好</li><li>平行换位思考</li><li>挖掘用户欲望。难度很高，往往是可遇不可求。</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 用户体验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Vue 脚手架搭建项目</title>
      <link href="/2019/10/26/F-%E4%BD%BF%E7%94%A8Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/10/26/F-%E4%BD%BF%E7%94%A8Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vuecli-9.jpg" alt=""></p><a id="more"></a><p>vue-cli 也是一个 npm 包，可以帮助我们快速搭建起 vue 项目的脚手架。</p><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>win10 / <a href="mailto:node.js@10.15.0" target="_blank" rel="noopener">node.js@10.15.0</a> / vue-cli @3.2.1</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先全局安装 vue-cli 3.x （这里以 3.2.1 版本为准）：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm install  @vue/cli@3.2.1 -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了对比 3.x 和 2.x 在项目创建上的区别，执行下面命令：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm install @vue/cli-init@3.2.0 -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样，我们可以通过 <code>vue init</code> 搭建 2.x 的项目结构，通过 <code>vue create</code> 搭建 3.x 的项目结构。</p><h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><h3 id="1-2-x-版本"><a href="#1-2-x-版本" class="headerlink" title="1) 2.x 版本"></a>1) 2.x 版本</h3><p>创建以 vuecli2test 命名的项目文件夹（注意不要用大写字母）：</p><pre class="line-numbers language-cmd"><code class="language-cmd">vue init webpack vuecli2test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行项目配置：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vuecli-1.png" alt=""></p><p>这里的 <code>author</code> 会自动读取以前全局配置的 <code>gitconfig</code> 文件的信息。</p><p>现在的项目文件夹结构是这样的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vuecli-2.png" alt=""></p><p>跑一下项目看看：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vuecli-2.5.png" alt=""></p><h3 id="2-3-x-版本"><a href="#2-3-x-版本" class="headerlink" title="2) 3.x 版本"></a>2) 3.x 版本</h3><p>创建以 vuecli3test 命名的项目文件夹：</p><pre class="line-numbers language-cmd"><code class="language-cmd">vue create vuecli3test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行项目配置：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vuecli-3.png" alt=""></p><p>现在的项目文件夹结构是这样的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vuecli-4.png" alt=""></p><p>和 vue-cli 2 进行对比：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vuecli-5.png" alt=""></p><p>可以发现，相比 2.x 版本，3.x 精简了不少。首先是将 <code>static</code> 文件夹换成 <code>public</code>，原来根目录下的 <code>index.html</code> 也存放到了 <code>public</code> 里面，并且还移除了之前用来配置 webpack 的 <code>build</code> 和 <code>config</code> 文件夹（实际上在 <code>no_modules</code> 文件夹里）。</p><p>跑一下项目看看：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm run serve<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>vue-cli 3.x 为我们提供了可视化配置的方式，可以通过下面的方式启动配置服务器：</p><pre class="line-numbers language-cmd"><code class="language-cmd">vue ui<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后导入项目文件夹，即可进入该项目对应的配置界面</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/vuecli-6.png" alt=""></p><p>另外，我们也可以在项目根目录下创建一个 <code>vue.config.js</code> 文件，自定义配置，这个文件之后会和 <code>node_modules</code> 中的配置文件进行合并。（就像是 sublime text 里面 <code>settings-default</code> 和 <code>settings-user</code> 的关系）</p><h2 id="runtime-compiler-版本和-runtime-only-版本"><a href="#runtime-compiler-版本和-runtime-only-版本" class="headerlink" title="runtime+compiler 版本和 runtime-only 版本"></a>runtime+compiler 版本和 runtime-only 版本</h2><p>创建项目的时候会让我们选择 runtime+compiler 版本或者 runtime-only 版本，那么这两个有什么区别呢？</p><ul><li><p>runtime+compile （运行时编译）版本允许我们正常使用 <code>template</code>，但是相对的，需要经历 <strong><em>template —&gt; ast —&gt; render function —&gt; vdom —&gt; dom</em></strong> 等一系列过程才能将模板最终转化为真实 dom；</p></li><li><p>runtime-only 版本（运行时）只允许在 .vue 文件中使用 <code>template</code>，其它地方要使用 render 函数，但是相对的，只需要经历 <strong><em>render function —&gt; vdom —&gt; dom</em></strong> 就能将模板最终转化为真实 dom。另外，引入组件的时候，.vue 中的 <code>template</code> 其实已经借助 vue-compile-template 编译成 render 函数了。</p></li></ul><p>在 runtime+compile 版本中，new Vue 是这样的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>    template<span class="token punctuation">:</span><span class="token operator">&lt;</span>App<span class="token operator">/</span><span class="token operator">></span>    components<span class="token punctuation">:</span><span class="token punctuation">{</span> App <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 runtime-only 版本中，new Vue 则是这样的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>    render<span class="token punctuation">:</span>h <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>render 函数接受 <code>h</code> 参数 ，这个 <code>h</code> 实际上就是 <code>createElement</code> 函数了， 它在这里接受一个组件对象 <code>App</code> 。</p><p>实际开发中用的更多的是 runtime-only 版本。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue-cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack（三）：使用 plugin 以及本地服务器搭建</title>
      <link href="/2019/10/22/F-Webpack%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/10/22/F-Webpack%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA-0-1.png" alt=""></p><a id="more"></a><h2 id="使用-Plugin"><a href="#使用-Plugin" class="headerlink" title="使用 Plugin"></a>使用 Plugin</h2><h3 id="banner-plugin"><a href="#banner-plugin" class="headerlink" title="banner-plugin"></a>banner-plugin</h3><p>webpack 自带 BannerPlugin，我们只需要在 <code>webpack.config.js</code> 中配置即可：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//引入</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token operator">...</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    resolve<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>BannerPlugin</span><span class="token punctuation">(</span><span class="token string">'Created by xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>之前我们的 <code>index.html</code> 都是在项目的根目录下的，这个文件最后也要打包到 <code>dist</code> 文件夹中。</p><p>HtmlWebpackPlugin 可以自动生成一个 已经引入<code>bundle.js</code> 的<code>index.html</code> 到 <code>dist</code> 文件夹中。</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm install html-webpack-plugin --save -dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过这个生成的文件默认是没有模板的（只有引入的 js），所以我们要配置一下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 引入</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token operator">...</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    modules<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    resolve<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            template<span class="token punctuation">:</span><span class="token string">'./index.html'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这之后，webpack 将会去 <code>webpack.config.js</code> 所在的文件夹寻找 <code>index.html</code>文件（最初的入口文件），并将其 html 结构作为新 <code>index.html</code> 的模板。也就是说，最初的入口文件仅提供一个模板。</p><p><strong>Note</strong>：</p><p>另外还要注意，前面我们说过，webpack 认为 <code>index.html</code> 位于 <code>dist</code> 中，所以导致了路径出错，我们是通过配置 <code>output.publicPath</code> 或者 <code>url-loader.options.publicPath</code> 来修正这个问题的。但是现在 <code>index.html</code> 确实位于 <code>dist</code> 中了，所以我们也可以把这两个配置改回来了。</p><h3 id="uglifyjs-webpack-plugin"><a href="#uglifyjs-webpack-plugin" class="headerlink" title="uglifyjs-webpack-plugin"></a>uglifyjs-webpack-plugin</h3><p>压缩 js 文件：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm install uglifyjs-webpack-plugin@1 --save -dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行配置：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> UglifyjsWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'uglifyjs-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//引入</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token operator">...</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    modules<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    resolve<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">UglifyWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里又因为版本不匹配的问题报错了，原因是 webpack@3 对应的 plugin 版本是 @1，所以如果 npm 安装的时候不指定版本，默认会安装最新的 @2 版本，后面打包就会报错了。</p><h2 id="Webapck-搭建本地服务器"><a href="#Webapck-搭建本地服务器" class="headerlink" title="Webapck 搭建本地服务器"></a>Webapck 搭建本地服务器</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Webpack 提供了一个可选的本地开发服务器，基于 node.js 搭建，内部使用 express 框架，可以实现热更新。</p><p>文件暂缓到内存中，内存中读取速度要比磁盘快很多，之后执行打包命令的时候才输出到磁盘。</p><p>首先安装一下：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm install webpack-dev-server@2.9.3 --save -dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Note：这里也要注意和 webpack 的版本对应。</p><p>之后配置一下：</p><pre class="line-numbers language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token operator">...</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    modules<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    resolve<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>           contentBase<span class="token punctuation">:</span><span class="token string">'./dist'</span> <span class="token comment" spellcheck="true">// 为哪个文件夹提供本地服务</span>        inline<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 开启热更新</span>        port<span class="token punctuation">:</span>  <span class="token number">8080</span>           <span class="token comment" spellcheck="true">// 默认8080端口号</span>        open<span class="token punctuation">:</span><span class="token boolean">true</span>            <span class="token comment" spellcheck="true">// 开启服务器后自动打开浏览器</span>        historyApiFallback<span class="token punctuation">:</span><span class="token operator">...</span>    <span class="token comment" spellcheck="true">// 在 SPA 页面中依赖 HTML5 的 history 模式     </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="处理报错"><a href="#处理报错" class="headerlink" title="处理报错"></a>处理报错</h3><p>这时候直接运行 <code>webpack-dev-server</code> ，会报错：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA-1.png" alt=""></p><p>这里的操作，其实是试图在项目根目录下执行 <code>webpack-dev-server.cmd</code>，但当前目录并没有这个这个东西，所以报错了。这时候可能会有如下思路：</p><p><strong>（1）</strong></p><p>首先，<code>webpack-dev-server.cmd</code> 其实就位于 <code>node_modules/.bin</code> 文件夹中，我可以选择直接执行 <code>node_modules/.bin/webpack-dev-server</code> 或者是 cd 进目录后执行，如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA-2-1.jpg" alt=""></p><p>这个思路应该是没问题的，但是我实际这么做的时候报错了：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA-3.png" alt=""></p><p>经过苦苦思索。。。好吧，犯了一个很傻逼的错误：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E4%BD%BF%E7%94%A8%20plugin%20%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA-4.png" alt=""></p><p>注意看上图！！！路径是用 <code>\</code> 而不是<code>/</code>。。。改用 <code>\</code>之后就正常了。当然，是看到这个贴子 <a href="https://www.cnblogs.com/mqfblog/p/6444753.html" target="_blank" rel="noopener">https://www.cnblogs.com/mqfblog/p/6444753.html</a> 突然想到的。</p><p><strong>（2）</strong></p><p>第二个方法，全局安装 <code>webpack-dev-server</code>。这个当然没问题了，这样的话我不管在哪个路径下运行指令，这个指令总能被找到。<strong>但是这个方法不推荐，因为有版本冲突问题</strong>。</p><p><strong>（3）</strong></p><p>第三个方法就是来到 <code>package.json</code>配置一下命令：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"test"</span><span class="token operator">:</span> <span class="token string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="token punctuation">,</span>    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"webpack"</span><span class="token punctuation">,</span>    <span class="token property">"dev"</span><span class="token operator">:</span><span class="token string">"webpack-dev-server"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这之后执行 <code>npm run dev</code> ，那么 npm script 的底层其实会做一些相应处理，自动到 <code>node_modules/.bin</code> 文件夹下寻找对应的 cmd 并执行。</p><h3 id="更新缓慢"><a href="#更新缓慢" class="headerlink" title="更新缓慢"></a>更新缓慢</h3><p>开启本地服务器，修改代码之后会发现可以自动刷新了。不过。。。</p><p>我进行到这一步的时候发现刷新大概需要 4 到 5 秒，对比使用 live server 时那种即时刷新的感觉，完全不是一个量级的好吗！然后把前面安装的 <code>uglifyjs-webpack-plugin</code> 去掉就正常了，看来是被这个插件影响到了。</p><p>这里也可以发现，实际上我们是在<strong>开发完成后</strong>才需要用到这个插件去压缩代码；相反地，<code>webpack-dev-server</code>则是在<strong>开发过程中</strong>要用到，也就是说，这两个东西的使用情境是不同的。那么，有没有方法可以依照使用情境把它们进行分离呢？</p><h2 id="配置分离"><a href="#配置分离" class="headerlink" title="配置分离"></a>配置分离</h2><ul><li>抽取公共配置</li><li>分离开发环境配置和生产环境配置</li></ul><p>在我们前面安装的 plugin 里，<code>webpack-dev-server</code> 只有开发的时候用得到，<code>uglifyjs-webpack-plugin</code>只有开发后用得到，其他的则是开发/生产时都要用到的，据此，我们可以在根目录新建 <code>build</code> 文件夹，并将这些配置分别写进三种类型的文件里：</p><p><code>dev.config.js / prod.config.js / base.config.js</code></p><p>形式上分离后，我们管理起来就方便了，之后借助插件进行配置的合并：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm install webpack-merge --save -dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>dev.config.js</code>:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> webpackMerge <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpackMerge'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> baseConfig <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./base.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">webpackMerge</span><span class="token punctuation">(</span>baseConfig<span class="token punctuation">,</span><span class="token punctuation">{</span>  devServer<span class="token punctuation">:</span><span class="token punctuation">{</span>    contentBase<span class="token punctuation">:</span><span class="token string">'./dist'</span><span class="token punctuation">,</span>    inline<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>    open<span class="token punctuation">:</span><span class="token boolean">true</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>prod.config.js</code>:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> UglifyjsWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'uglifyjs-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> webpackMerge <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-merge'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> baseConfig <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./base.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">webpackMerge</span><span class="token punctuation">(</span>baseConfig<span class="token punctuation">,</span><span class="token punctuation">{</span>  plugins<span class="token punctuation">:</span><span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">UglifyjsWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>base.config.js</code>:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token operator">...</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>       resolve<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这之后我们要解决两个问题：</p><p>首先，现在的 config 文件已经分离了，所以原先的 <code>webpack.config.js</code>可以删掉了，这里会发现删掉之后，原先配置的 npm script 指令失效了，所以来到 <code>package.json</code>配置一下：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"test"</span><span class="token operator">:</span> <span class="token string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="token punctuation">,</span>    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"webpack   --config ./build/base.config.js"</span><span class="token punctuation">,</span>    <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"webpack-dev-server  --config ./build/base.config.js"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加上 <code>--config ./build/base.config.js</code>，也就是现在以 <code>base.config.js</code> 这个配置文件为准。</p><p>第二个问题，如果我们直接打包，会发现在 <code>build</code> 下输出了 <code>dist</code> 文件夹，这是因为我们之前是这样配置 <code>output.path</code> 的：</p><pre class="line-numbers language-js"><code class="language-js">output<span class="token punctuation">:</span><span class="token punctuation">{</span>    path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span><span class="token string">'bundle.js'</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之前， <code>__dirname</code> 指向 <code>webpack.config.js</code>所在的目录，即根目录，后面跟着 <code>dist</code>，意思是打包到根目录下的 <code>dist</code> 文件夹。而现在，<code>__dirname</code> 指向的是 <code>base.config.js</code>所在的目录，即 <code>build</code> 文件夹，后面跟着 <code>dist</code>，意思是打包到 <code>build</code>下的 <code>dist</code> 文件夹。</p><p>所以要修正一下路径，改为 ：</p><pre class="line-numbers language-js"><code class="language-js">output<span class="token punctuation">:</span><span class="token punctuation">{</span>    path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'../dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    filename<span class="token punctuation">:</span><span class="token string">'bundle.js'</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之后就可以正常打包了。当然，对于小型项目的话，一个配置文件也完全足够了。</p><blockquote><p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=188s4s5t1gb7g" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=188s4s5t1gb7g</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Webpack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack（二）：使用 loader</title>
      <link href="/2019/10/20/F-Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20loader/"/>
      <url>/2019/10/20/F-Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20loader/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20loader/Webpack%EF%BC%9Aloader-0.png" alt=""></p><a id="more"></a><p>Webpack 提倡一切皆模块，所有类型的文件（css、图片等）都可以经过 loader 处理变成我们可加载的模块。</p><h2 id="1-loader-安装和配置"><a href="#1-loader-安装和配置" class="headerlink" title="1. loader 安装和配置"></a>1. loader 安装和配置</h2><p>安装 loader 统一方式是 <code>npm insatll xxx-loader --save -dev</code></p><p><code>-dev</code> 表示开发时依赖。</p><p><code>webpack.config.js</code> 基本配置方式：</p><pre class="line-numbers language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token operator">...</span><span class="token punctuation">,</span>  output<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  module<span class="token punctuation">:</span><span class="token punctuation">{</span>    rules<span class="token punctuation">:</span><span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token operator">...</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'xxx-loader'</span><span class="token punctuation">,</span><span class="token string">'xxx-loader'</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-样式处理"><a href="#2-样式处理" class="headerlink" title="2. 样式处理"></a>2. 样式处理</h2><h3 id="2-1-css-loader-和-style-loader"><a href="#2-1-css-loader-和-style-loader" class="headerlink" title="2.1 css-loader 和 style-loader"></a>2.1 css-loader 和 style-loader</h3><p>css-loader 通过 npm 安装，但是要把样式真正挂载到 dom 上，还需要安装 style-loader</p><p>通过 <code>webpack.conifg.js</code> 配置 css-loader 和 style-loader。注意 webpack 是从右向左读取的，书写顺序有要求。</p><pre class="line-numbers language-js"><code class="language-js">module<span class="token punctuation">:</span><span class="token punctuation">{</span>  rules<span class="token punctuation">:</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span>      test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>      use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span><span class="token string">'css-loader'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-less-loader"><a href="#2-1-less-loader" class="headerlink" title="2.1 less-loader"></a>2.1 less-loader</h3><p>同样的，还可以使用 less-loader：</p><pre class="line-numbers language-js"><code class="language-js">module<span class="token punctuation">:</span><span class="token punctuation">{</span>  rules<span class="token punctuation">:</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span>      test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>      use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span><span class="token string">'css-loader'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      test<span class="token punctuation">:</span><span class="token regex">/\.less$/</span><span class="token punctuation">,</span>      use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>        loader<span class="token punctuation">:</span><span class="token string">"style-loader"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>        loader<span class="token punctuation">:</span><span class="token string">"css-loader"</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>        loader<span class="token punctuation">:</span><span class="token string">"less-loader"</span>      <span class="token punctuation">}</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 npm 3.x 开始，less 不会再随着 less-loader 的安装而自动给你安装，所以我们需要手动安装 less，也就是完整命令：<code>npm install less less-loader --save -dev</code>，否则后续打包会报错。</p><h2 id="3-图片打包"><a href="#3-图片打包" class="headerlink" title="3. 图片打包"></a>3. 图片打包</h2><p>和图片打包相关的两个 loader ，一个是 url-loader，一个是 file-loader。</p><p>如果图片较多，会发送很多 http 请求，降低页面性能。因此，url-loader 会将引入的图片编码，生成 base64 的 dataURL —— 相当于把图片数据翻译成一串字符，再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。</p><p>当然，如果图片较大，编码会消耗性能，打包文件体积也会变大，因此 url-loader 提供了一个 <code>limit</code> 参数（一般是8kb），小于 <code>limit</code> 的图片依然被转为 DataURL；大于 <code>limit</code> 的图片则调用 file-loader 进行copy，并输出到 dist 文件夹中。 虽说 url-loader 封装了 file-loader，但实测如果不额外安装 file-loader 的话，在图片体积较大时打包还是会报错的，因此两个都要安装。</p><p>下面通过例子说明在 CSS 或者 JS 中使用图片时，loader 是如何处理的。</p><h3 id="2-1-css-引用"><a href="#2-1-css-引用" class="headerlink" title="2.1 css 引用"></a>2.1 css 引用</h3><p>这里我们在 src 下新建 img 文件夹，里面放 test1.jpg 和 tets2.jpg，一张大于8kb，一张小于8kb。在前面的 <code>index.css</code>文件中，我们像往常一样使用图片作为背景：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span><span class="token url">url("../img/test1.jpg")</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后打包发现报错，所以我们安装 url-loader，再次打包。浏览器查看：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20loader/Webpack%EF%BC%9Aloader-1.png" alt=""></p><p>会发现图片可以正常引用了，而且是以 dataURL 的形式引用的。</p><p>接着测试大于8kb的图片（修改上面代码为 test2.jpg ）。这时，如果直接打包会报错提示缺少 file-loader，所以我们这里安装一下 file-loader。</p><p>再次打包，虽说这次不报错了，但是我们发现浏览器里图片没有显示出来。看一下控制台：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20loader/Webpack%EF%BC%9Aloader-2.png" alt=""></p><p>可以看到，路径是直接引用的图片名字，同时会看到 dist 文件夹下输出了原始图片的副本。也就是说，其实这时候 webpack 认为我们的 <code>index.html</code>文件在 dist 文件夹中，所以选择了这样的路径引用，但其实我们的 <code>index.html</code>文件在外层。同时，我们也不希望直接输出在 dist 文件夹下，最好是里面还有一个 img 文件夹，所以我们先来 <code>webpack.config.js</code> 配置一下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpg|gif|jpeg)$/</span><span class="token punctuation">,</span>  use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>    loader<span class="token punctuation">:</span><span class="token string">"url-loader"</span><span class="token punctuation">,</span>    options<span class="token punctuation">:</span><span class="token punctuation">{</span>      limit<span class="token punctuation">:</span><span class="token number">8192</span><span class="token punctuation">,</span>      outputPath<span class="token punctuation">:</span><span class="token string">'img'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就设置了图片的输出路径，另外，图片默认以 32 位 hash 命名，这样太长了，而且也不知道具体是哪张图片，所以我们顺便配置一下图片命名规则：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpg|gif|jpeg)$/</span><span class="token punctuation">,</span>  use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>    loader<span class="token punctuation">:</span><span class="token string">"url-loader"</span><span class="token punctuation">,</span>    options<span class="token punctuation">:</span><span class="token punctuation">{</span>      limit<span class="token punctuation">:</span><span class="token number">8192</span><span class="token punctuation">,</span>      outputPath<span class="token punctuation">:</span><span class="token string">'img'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span><span class="token string">'[name].[hash:8].[ext]'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次打包，打开控制台：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20loader/Webpack%EF%BC%9Aloader-3.png" alt=""></p><p>可以看到，命名正确了，文件输出方式也正确了（dist 下多出一个 img 文件夹），但是图片路径还是错的，所以不显示图片。我们接着来配置一下图片路径。<br>我们前面说过，webpack 认为 <code>index.html</code> 在 dist 文件夹中，所以才会直接通过图片名字引用图片。那么 <code>index.html</code> 实际上是在 dist 文件夹外面的，对于 <code>index.html</code> 来说，它就要通过 <code>./dist/img</code> 才能顺利找到图片，也就是说，我们可以在原本路径（图片名）的基础上加一个固定前缀（./dist/img），使之正确指向图片位置（./dist/img/图片名）。</p><p>而 <code>publicPath</code> 正是可以用来做这件事的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpg|gif|jpeg)$/</span><span class="token punctuation">,</span>  use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>    loader<span class="token punctuation">:</span><span class="token string">"url-loader"</span><span class="token punctuation">,</span>    options<span class="token punctuation">:</span><span class="token punctuation">{</span>      limit<span class="token punctuation">:</span><span class="token number">8192</span><span class="token punctuation">,</span>      outputPath<span class="token punctuation">:</span><span class="token string">'img'</span><span class="token punctuation">,</span>      publicPath<span class="token punctuation">:</span><span class="token string">'./dist/img'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span><span class="token string">'[name].[hash:8].[ext]'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>publicPath</code> 会给使用了相对路径引用的图片加上统一前缀。比如我们的图片路径一开始是 <code>img/test2.95a05a82.jpg</code>，那么使用了 <code>publicPath</code> 后，图片路径就变成 <code>./dist/img/test2.95a05a82.jpg</code>。通常可以给 <code>publicPath</code> 配置一个 cdn 地址前缀，比如 <code>https://xxx.cdn.com</code>，上线的时候图片就都统一使用 cdn 地址了。</p><p>那么配置好后再次打包，浏览器查看：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20loader/Webpack%EF%BC%9Aloader-4.png" alt=""></p><p>路径正常，而且图片也正常显示了。</p><p>另外，我们也可以选择给 <code>output.publicPath</code> 配置 <code>./dist/</code>，这样的话不止是图片，所有使用相对路径引用的静态资源都会加上这个前缀了。不过要注意，这个前缀需要加一个 <code>/</code>，而图片的 <code>publicPath</code> 是不需要的。</p><h3 id="2-2-js-引用"><a href="#2-2-js-引用" class="headerlink" title="2.2 js 引用"></a>2.2 js 引用</h3><p>js 中引用图片需要使用 require，举个例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module2.js</span><span class="token comment" spellcheck="true">// require 拿到图片路径字符串</span><span class="token keyword">var</span> img <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../img/test2.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 模板字符串构建 img 标签</span><span class="token keyword">export</span> <span class="token keyword">var</span> demo <span class="token operator">=</span> <span class="token template-string"><span class="token string">`&lt;img src="</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>img<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"/>`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// main.js</span><span class="token keyword">import</span> demo <span class="token keyword">from</span> <span class="token string">'./js/module2.js'</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> demo<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>只管根据图片和 <code>module2.js</code> 的路径关系正常引入图片即可，后面路径会被正确替换。<br>如果我们之前没有配置 <code>publicPath</code> 的话，会发现打包后的路径是 <code>img/test2.95a05a82.jpg</code>，也即 <code>index.html</code> 依然被当作是位于 dist 文件夹下的。因为我们前面配置了，所以这里路径是正确的，最后可以正常显示图片：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%20loader/Webpack%EF%BC%9Aloader-5.png" alt=""></p><h2 id="4-Babel-转译"><a href="#4-Babel-转译" class="headerlink" title="4. Babel 转译"></a>4. Babel 转译</h2><p>命令行安装：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm install --save -dev babel-loader@7 babel-core babel-preset-es2015<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置 <code>webpack.config.js</code>：</p><pre class="line-numbers language-js"><code class="language-js">module<span class="token punctuation">:</span><span class="token punctuation">{</span>    rules<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            test<span class="token punctuation">:</span><span class="token regex">/\.js$/</span><span class="token punctuation">,</span>            exclude<span class="token punctuation">:</span><span class="token regex">/(node_modules|bower_components)/</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span><span class="token punctuation">{</span>                loader<span class="token punctuation">:</span><span class="token string">'babel-loader'</span><span class="token punctuation">,</span>                options<span class="token punctuation">:</span><span class="token punctuation">{</span>                    presets<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'es2015'</span><span class="token punctuation">]</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>exclude:/(node_modules|bower_components)/</code> 表示不转译 <code>node_modules</code> 文件夹中的 js 。</p><p><strong>babel-loader 的预设：</strong></p><ul><li><code>babel-preset-es2015</code>， <code>babel-preset-es2016</code> 等：支持不同版本的ECMAScript规范；</li><li><code>babel-preset-latest</code>： 支持现有所有 ECMAScript 版本的新特性，包括处于stage 4里的特性（已经确定的规范，将被添加到下个年度的）。</li><li><code>babel-preset-env</code>：但很多时候我们需要更灵活的 preset —— 比如大部分浏览器已经支持了 ES6 的某个特性，那么对于这个特性我们其实是不必去转译的，但前面所说的那些 preset 会一概转译。所以这里还提供了 <code>babel-preset-env</code>，它可以根据我们指定的目标环境（比如某个版本的浏览器）来选择它不支持的特性进行转译。</li></ul><h2 id="5-集成-Vue"><a href="#5-集成-Vue" class="headerlink" title="5. 集成 Vue"></a>5. 集成 Vue</h2><p>注意这不是一个开发时依赖：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm install vue@2.5.21 --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果遇到这个报错：</p><p><code>You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</code></p><p>这是因为 Vue 有两个版本：</p><ul><li>runtime-only</li><li>runtime-compiler</li></ul><p>其中，runtime-only 版本无法编译模板，要么用 render 函数，要么修改 <code>webpack.config.js</code> 配置改用其它版本。这里我们先选择后者：</p><pre class="line-numbers language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span> <span class="token operator">...</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    resolve<span class="token punctuation">:</span><span class="token punctuation">{</span>        alias<span class="token punctuation">:</span><span class="token punctuation">{</span>             <span class="token string">'vue$'</span><span class="token punctuation">:</span><span class="token string">'vue/dist/vue.esm.js'</span>  <span class="token comment" spellcheck="true">// 指定版本</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，webpack 还需要分别借助 vue-loader 和 vue-template-compiler 去加载和解析 .vue 文件：</p><pre class="line-numbers language-cmd"><code class="language-cmd">npm install vue-loader@13.0.0 vue-template-compiler@2.5.21 --save -dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后我们就可以编写单文件组件了（ 使用 vscode 的话强烈建议安装 vetur 插件）。</p><p><strong>Note</strong>：</p><p>因为我们安装的 vue 版本是 <a href="mailto:vue@2.5.21" target="_blank" rel="noopener">vue@2.5.21</a>，所以这里的 vue-loader 和 vue-template-compiler 要注意版本对应问题，总之报错信息也写得很清楚了。</p><p>（要说为什么用这么低版本的 vue，因为视频里的项目也是用低版本 Vue 构建的，所以暂时先跟着讲师的步伐吧 =。=）</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Webpack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack（一）：安装和基础配置</title>
      <link href="/2019/10/19/F-Webpack%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/10/19/F-Webpack%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/webpack%E5%AD%A6%E4%B9%A0-0-1.png" alt=""></p><a id="more"></a><p>记录 webpack 安装和配置的过程，以及即将遇到的各种坑. :)</p><p>环境：win10，<a href="mailto:webpack@3.6.0" target="_blank" rel="noopener">webpack@3.6.0</a></p><h2 id="1-webpack-安装"><a href="#1-webpack-安装" class="headerlink" title="1. webpack 安装"></a>1. webpack 安装</h2><h3 id="1-1-安装过程"><a href="#1-1-安装过程" class="headerlink" title="1.1 安装过程"></a>1.1 安装过程</h3><ol><li><p>在安装 webpack 之前，需要先安装 Nodejs（这个过程会自动帮你安装好 npm）。路径的话默认是 C 盘，因为强迫症，我把它安装在了 D 盘。</p></li><li><p>安装好 Nodejs 后，在 cmd 命令行里可以通过 <code>node -v</code> 和 <code>npm -v</code> 分别查看版本信息，一般这里没啥问题。</p></li><li>之后一定不要忘记配置 Nodejs 的环境变量（具体步骤看1.2）</li><li>接着就是安装 webpack 了，因为练手的项目用的是 4.x 之前的版本，我这里用 <code>npm install webpack@3.6.0 -g</code> 进行全局安装。</li><li><code>webpack -v</code> 查看版本信息，没毛病</li></ol><h3 id="1-2-Nodejs-环境变量配置"><a href="#1-2-Nodejs-环境变量配置" class="headerlink" title="1.2 Nodejs 环境变量配置"></a>1.2 Nodejs 环境变量配置</h3><p>之前急着搭建博客，所以 Nodejs 安装好后就没管了，今天 <code>webpack -v</code> 命令死活用不了（提示“webpack 不是内部命令”），才发现是因为当时忘记配置环境变量了。</p><p>分两步：</p><p><strong>（1） 修改全局安装位置</strong></p><p>默认情况下，Nodejs 会给系统环境创建两个环境变量：</p><ul><li>用户变量 PATH： C:\Users\Admin\AppData\Roaming\npm</li><li>系统变量 PATH：D:\Nodejs</li></ul><p>第一个变量指定了全局安装的东西默认存放的位置，因为我实在不想放在 C 盘，于是得改一下这个默认配置，具体做法：</p><ul><li><p>首先在 Nodejs 文件夹中新建 node_global 和 node_cache 文件夹，分别用于存放全局安装包和临时缓存位置；</p></li><li><p>接着 cmd 里设置全局安装路径和全局缓存路径（也就是刚才那两个）：</p></li></ul><pre class="line-numbers language-cmd"><code class="language-cmd">npm config set prefix "D:\Nodejs\node_global"npm config set cache "D:\Nodejs\node_cache"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>之后可以用 <code>npm root -g</code> 查看一下</p><p>这之后再次安装 webpack，不出意外它就会出现在 Nodejs/node_global 文件夹下了。不过我们还是查看不了版本，因为环境变量还没修改。</p><p><strong>（2）修改环境变量</strong></p><p>我的电脑——右键属性——高级系统设置——高级———环境变量：</p><ul><li>用户变量：修改 <code>PATH</code> 为 <code>D:\Node.js\node_global</code></li><li>系统变量：新增 <code>NODE_PATH</code> ，设置值为 <code>D:\Node.js\node_global</code></li></ul><p>PS：第二个貌似也可以设置为 <code>D:\Node.js\node_global\node_modules</code></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/webpack%E5%AD%A6%E4%B9%A0-1.png" alt=""></p><p>之后重启 cmd （一定要重启，不然是不生效的），再次 <code>webpack -v</code>，这次就可以正常使用了。</p><h2 id="2-基本结构搭建"><a href="#2-基本结构搭建" class="headerlink" title="2. 基本结构搭建"></a>2. 基本结构搭建</h2><p><strong>1.</strong>练手的话先新建一个项目，然后 cd 进去：</p><pre class="line-numbers language-cmd"><code class="language-cmd">mkdir webpack-learningcd webpack-learning<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以后就是在这个文件夹里搞事情了。</p><p><strong>2.</strong>创建 <code>index.html</code> 文件和 <code>src</code> 文件夹，后者存放打包前的文件</p><p><strong>3.</strong>通过 <code>npm init</code> 生成 <code>package.json</code> 文件，这个文件用来描述项目信息以及依赖配置等。这里基本一路回车就好。</p><p><strong>4.</strong>通过 <code>npm install webpack@3.6.0 --save -dev</code>本地安装 webpack。本地安装可以让每个项目拥有独立的包，不受全局包的影响，方便项目的移动、复制、打包等 。</p><p><strong>5.</strong>手动创建 <code>webpack.config.js</code> 文件，这个文件用来配置 webpack 的运行方式</p><p>那么，现在项目结构看起来大概如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/webpack%E5%AD%A6%E4%B9%A0-2.png" alt=""></p><h2 id="3-配置-webpack-config-js-和-package-json"><a href="#3-配置-webpack-config-js-和-package-json" class="headerlink" title="3. 配置 webpack.config.js 和 package.json"></a>3. 配置 webpack.config.js 和 package.json</h2><p>先简单配置一下 <code>webpack.config.js</code>:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    entry<span class="token punctuation">:</span><span class="token string">'./src/main.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span><span class="token punctuation">{</span>        path<span class="token punctuation">:</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        filename<span class="token punctuation">:</span><span class="token string">'bundle.js'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里定义了入口和出口。 入口(entry) 指示 webpack 应该使用哪个模块文件来作为构建内部依赖的开始，进入入口起点后，webpack 会找出有哪些模块和库是入口 js 依赖的；<br>出口(output) 是告诉 webpack 在什么地方输出它所创建的 bundles，以及如何命名这些打包文件。</p><p>我们新建几个文件来简单测试下。首先是<code>module.js</code> :</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token punctuation">{</span>num<span class="token punctuation">,</span>add<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>main.js</code> 作为入口文件：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>num<span class="token punctuation">,</span>add<span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将 <code>main.js</code> 进行打包：</p><pre class="line-numbers language-cmd"><code class="language-cmd">$ webpack ./src/main.js ./dist/bundle.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会发现项目文件夹下多出来一个<code>dist</code>文件夹，里面有一个打包生成的 <code>bundle.js</code>文件：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Webpack%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/webpack%E5%AD%A6%E4%B9%A0-3.png" alt=""></p><p>之后在 <code>index.html</code> 中直接引用该文件：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./dist/bundle.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器跑一下，没毛病。</p><p>不过，之前的打包命令太麻烦了，所以我们配置一下 <code>package.json</code>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="token punctuation">,</span>    <span class="token string">"build"</span><span class="token punctuation">:</span> <span class="token string">"webpack"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之后可以直接通过 <code>npm run build</code> 执行打包。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Webpack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端模块化</title>
      <link href="/2019/10/18/F-%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2019/10/18/F-%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96-1-1.png" alt=""></p><a id="more"></a><h2 id="为什么需要模块化？"><a href="#为什么需要模块化？" class="headerlink" title="为什么需要模块化？"></a>为什么需要模块化？</h2><p>早期的开发没有模块化，会有两个灾难性的问题：即 <strong>全局污染</strong> 以及 <strong>依赖管理混乱</strong>。</p><p><strong>1. 全局污染：</strong></p><p>A 引入 a.js，B 引入 b.js，这些代码最后都是存在于全局作用域里，难保不会出现变量命名冲突的问题。</p><p><strong>2. 依赖管理混乱：</strong></p><p>js 文件之间存在依赖关系，那么被依赖项必须出现在前面，也就是说要遵守一定的顺序。要是有几十个文件，那么就得先确定好互相之间的依赖关系，然后手动排序，累觉不爱。</p><h2 id="早期解决方案："><a href="#早期解决方案：" class="headerlink" title="早期解决方案："></a>早期解决方案：</h2><h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>每个 js 文件中都用一个匿名自执行函数来封装数据。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    num<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// b.js</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    num<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nice，这样子 a.js 和 b.js 都有各自的 num，互不影响了。但是，我在全局作用域下好像拿不到函数里的东西？？？</p><h3 id="IIFE-增强版"><a href="#IIFE-增强版" class="headerlink" title="IIFE 增强版"></a>IIFE 增强版</h3><p>让 IIFE 返回一个对象，暴露给全局作用域</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// a.js</span><span class="token keyword">var</span> moduleA <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    gain<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    add<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，全局可以通过 <code>moduleA</code> 拿到函数里的变量。不过，要是 b.js 不小心脑袋抽筋，也将 IIFE 返回给一个叫做 <code>moduleA</code> 的变量呢？命名冲突的问题还是没解决。</p><p>这之后提出了<strong>模块化</strong>的概念。</p><h2 id="模块化解决方案："><a href="#模块化解决方案：" class="headerlink" title="模块化解决方案："></a>模块化解决方案：</h2><p>那么，模块化到底需要解决什么问题呢？我们先设想一下可能有以下几点：</p><ul><li>安全地包装一个模块的代码，避免全局污染</li><li>唯一标识一个模块</li><li>优雅地将模块 api 暴露出去</li><li>方便地使用模块</li><li>…….</li></ul><h3 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h3><p><strong>1.1 介绍：</strong></p><p>CommonJS 的一个模块就是一个脚本文件，通过执行该文件来加载模块<br>。CommonJS 规范规定，每个模块内部，<code>module</code> 变量代表当前模块。这个变量是一个对象，它的 <code>exports</code> 属性（即 <code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的 <code>module.exports</code> 属性。</p><p><strong>1.2 导出模块：</strong></p><p>Node.js 是 CommonJS 规范的实现。为了方便，Node.js 为每个模块提供一个 <code>exports</code> 变量，指向 <code>module.exports</code>。这等同在每个模块头部，有一行这样的命令：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> exports <span class="token operator">=</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以，我们有两种导出模块的方式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    num<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 方式1</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>    num<span class="token punctuation">,</span>    print<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 方式2</span>exports<span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>exports<span class="token punctuation">.</span>print <span class="token operator">=</span> print<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3 加载模块：</strong></p><p>另外，我们也有两种加载模块的方式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// main.js</span><span class="token comment" spellcheck="true">// 方式1</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方式2（解构赋值）</span><span class="token keyword">var</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>print <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CommonJS 的特点是：</p><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>CommonJS 是针对服务端的模块化解决方案，为何它不能用于前端呢？因为 CommonJS 是同步而不是异步的，在我们 require 模块的时候，如果迟迟没有返回结果，那么就会阻塞后面代码的执行，甚至会阻止页面的渲染。</p><p>所以这时候有了 AMD 规范，即<strong>异步模块加载规范</strong>。<br>AMD 与 CommonJS 的主要区别就是异步模块加载 —— 即使 require 的模块还没有获取到，也不会影响后面代码的执行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><p>RequireJS 实现了这个规范。</p><p>当然，后面还出现了 CMD、UMD。</p><h3 id="3-ES6-Module"><a href="#3-ES6-Module" class="headerlink" title="3. ES6 Module"></a>3. ES6 Module</h3><p><strong>3.1 介绍：</strong></p><p>ES6 在语言规格层面上实现了模块功能，完全可以取代现有的 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p><strong>3.2 导出模块</strong></p><p>有三种方式可以导出模块：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span><span class="token comment" spellcheck="true">// 方式一（声明的同时导出）</span><span class="token keyword">export</span> <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 方式二（统一导出。推荐）</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>add <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 方式三（允许重命名，次数不限）</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token punctuation">{</span>  num <span class="token keyword">as</span> new_num<span class="token punctuation">;</span>  add <span class="token keyword">as</span> new_add<span class="token punctuation">;</span>  add <span class="token keyword">as</span> newer_add<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.3 加载模块</strong></p><p>同样的，加载模块也有多种方式。其中，整体加载会把之前导出的变量和函数挂载在一个对象上。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// main.js</span><span class="token comment" spellcheck="true">// 方式一：</span><span class="token keyword">import</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>add <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./module.js'</span><span class="token comment" spellcheck="true">// 方式二（允许重命名）：</span><span class="token keyword">import</span> <span class="token punctuation">{</span>  num <span class="token keyword">as</span> new_num<span class="token punctuation">;</span>  add <span class="token keyword">as</span> new_add<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./module.js'</span><span class="token comment" spellcheck="true">// 方式三（整体加载）：</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> obj <span class="token keyword">from</span> <span class="token string">'./module.js'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.4 export default</strong></p><p><code>export default</code> 其实用得更多。<code>import</code> 在非整体加载的时候要求我们事先知道导出的变量或者函数的名字，但是如果使用 <code>export default</code> 导出，那么后续加载模块的时候，名字可以任取，也就是说，我们并不需要知道原模块中变量或者函数的名字。例如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// main.js</span><span class="token keyword">import</span> func <span class="token keyword">from</span> <span class="token string">'./module.js'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，要注意两点：</p><ul><li><p><code>export default</code> 实际上是把后面跟着的东西赋值给 <code>default</code> 变量，所以后面不能是变量的声明</p></li><li><p>因为 <code>export default</code> 是指定的<strong>默认输出</strong>，这意味着一个模块文件中只能有一条 <code>export default</code> 语句（当然，可以与 <code>export</code> 一起用），也因为这样，<code>import</code> 后面不需要大括号，因为它只可能接受一个项。</p></li></ul><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><ul><li><p>CommonJS 模块输出的是值的拷贝，ES6 模块输出的是值的引用</p></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</p></li></ul><h3 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h3><p>CommonJS 模块输出的是值的拷贝：</p><p>也就是说，输出之后，原模块内部该值怎么变化，都不会影响到导出去的那个值，两者在内存中有各自的空间。</p><p>关于这点，很多文章会用类似下面的方式去证明：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>add <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// main.js</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">console</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 1</span>obj<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为这里是拷贝了 <code>num</code>，所以 <code>add</code> 操作后只是 <code>module.js</code> 中的 <code>num</code> 加一（词法作用域），<code>main.js</code> 中拷贝得到的 <code>num</code> 不变。</p><p>这个证明方法其实有问题。因为 <code>module.exports</code> 对象中的 <code>num</code> 属性本来就有值的拷贝了，此方法并不能证明值的拷贝是由 CommonJS 的底层实现的。，而且，把上面代码改为对应的 es6 module 版本(此时本来应该是引用)，会发现得到同样的结果，更证明了这一点。详情看:</p><p><a href="https://www.jianshu.com/p/1cfc5673e61d" target="_blank" rel="noopener">如何正确证明 CommonJS 模块导出是值的拷贝，而 ES module 是值的引用？</a></p><p>ES6 模块输出的是值的引用：</p><p>JS 引擎对脚本静态分析的时候，遇到模块加载命令 <code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。<br>这意味着，原模块中值的改变会动态映射到 <code>main.js</code> 中</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// module.js</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token punctuation">{</span> num<span class="token punctuation">.</span>add <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// main.js</span><span class="token keyword">import</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>add <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./module.js'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这个引用是动态变化的。</p><p>另外，原模块导出的变量在 <code>main.js</code> 中表现为一个只读常量，也就是说我们不能在 <code>main.js</code> 中对它重新赋值，这会报错：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span>obj <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./module.js'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>num<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// TypeError: Assignment to constant variable</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// {.......}</span>obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Sam"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 没毛病</span>obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// TypeError: Assignment to constant variable </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于引用类型，可以给它添加属性，但赋值同样是不行的。</p><h3 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h3><p>运行时加载：</p><p>CommonJS 是运行时加载的。也就是说，在 require 时，先执行整个模块（加载里面所有的方法），生成一个对象，然后再从这个对象上面读取实际要用到的方法，这种加载称为“运行时加载”。</p><p>编译时加载:</p><p>ES6 模块是运行时加载的。也就是说，其设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量（只加载需要的方法）。这种加载称为“编译时加载”。<br>import 有提升现象，因为这是在编译阶段就执行的。</p><p>以这段代码为例：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//ES6模块</span><span class="token keyword">import</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'module.js'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//CommonJS 模块</span><span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'module.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>对于 CommonJS，当 require 模块时，原模块会运行一遍，并返回一个包含所有 api 的对象，并将这个对象缓存起来。此后，无论多少次加载这个模块都是取这个缓存的值，也就是第一次运行的结果，除非手动清除。</p></li><li><p>对于 ES6，在编译阶段遇到 import 时，不会像 CommonJS 一样去执行模块，而是生成一个动态的只读引用，当真正需要的时候再到模块里去取值，所以 ES6模块是动态引用，并且不会缓存值。</p></li></ul><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/41568986" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41568986</a><br><a href="https://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/module</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>file 协议导致的跨域问题以及解决方案</title>
      <link href="/2019/10/13/F-file%20%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/10/13/F-file%20%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/file%20%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/file%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-0.webp" alt=""></p><a id="more"></a><p>问题复现：<br>学习 ES6 模块化的时候，写了这段代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aaa.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./bbb.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aaa2.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果跑到 chrome 下面一看，报错了：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/file%20%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/file%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-1.png" alt=""></p><p>看起来是跨域问题，也就是只支持 <code>http</code>，<code>https</code> 等这种类型的跨域请求，不支持 <code>file</code> 协议类型的（直接本地打开文件）。解决方案如下：</p><p>1.给 chrome 快捷方式添加参数：<br><code>–allow-file-access-from-files</code><br>实测无效。貌似还得重启电脑，太麻烦了，遂放弃。</p><p>2.换浏览器。经过测试，Edge 可以正常显示，但 FireFox 还是报跨域错误：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/file%20%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/file%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-2.png" alt=""></p><p>3.用 IDE。像 Webstrom 这类型的 IDE 是内置 http 服务器的，这样可以不通过 <code>file</code> 协议打开文件，不过这个还是有点麻烦，我没尝试。</p><p>4.使用热更新插件。刚好想起编辑器里安装了 live server 这个插件，这个其实是做同步刷新用的，但是由于它可以在本地开启一个服务器，所以可以利用这一点（localhost 访问）。尝试之后发现确实不报错了。</p><p>5.Node 开一个服务器</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// server.js</span><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>express<span class="token punctuation">.</span><span class="token keyword">static</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'./index.html'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>root<span class="token punctuation">:</span>__dirname<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8203</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题是解决了，但总觉得心里不踏实，所以开始了艰苦的 google 之旅，最后算是找到了问题的根源。但我还是想从同源策略开始解释：</p><blockquote><p>同源策略（Same origin policy），是出于安全而诞生的一种约定，规定了只能在本域内进行资源访问。所谓同源是指”协议+域名+端口”三者相同。</p></blockquote><p>不同源之间进行资源访问，就需要跨域。特殊地，有三个标签默认是允许跨域加载资源的：</p><ul><li><code>&lt;img src=&quot;xxx&quot;&gt;</code></li><li><code>&lt;link href=&quot;xxx&quot;&gt;</code></li><li><code>&lt;script src=&quot;xxx&quot;&gt;</code></li></ul><p>关键来了，ES6 使用模块的时候要在标签中声明 <code>type=&quot;module&quot;</code>，而这类<strong>使用了模块的 <code>script</code> 是受限于同源策略的</strong>。我们尝试改动之前的代码如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aaa.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">defer</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>defer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./bbb.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">defer</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>defer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./ccc.js<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">defer</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>defer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/file%20%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/file%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-3.png" alt=""></p><p>可以看到，前面两个 <code>script</code> 使用了模块，<code>Sec-Fetch-Mode</code> 都是 <code>cors</code>，而最后一个就是常规的引入脚本，不受同源策略影响，因此是 <code>no-cors</code>。</p><p>我们可以理解为前两个 <code>scirpt</code> 发送了 Cors 跨域资源请求，而这种请求要求 request header 的 origin 必须合法 —— 也就是必须带有 <code>http</code>，<code>https</code> 等，以用来表明请求源。</p><p>但是别忘了，我们现在是在本地打开文件，使用的不是 <code>http</code> 协议，而是 <code>file</code> 协议，它根本就没有跨域请求需要的 <code>origin</code>（注意看上图，<code>origin</code> 是空的）。所以，这种情况就要报错了。其实从报错信息中也能读出这一点。</p><p>那么，我们现在用 live server 在本地开启服务器，再看一下控制台：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/file%20%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/file%E5%8D%8F%E8%AE%AE%E5%AF%BC%E8%87%B4%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-4.png" alt=""></p><p>可以看到，因为这次不是用 <code>file</code> 协议访问了，所以一切正常。</p><p>参考：<br><a href="https://www.sitepoint.com/understanding-es6-modules/" target="_blank" rel="noopener">Understanding ES6 Modules</a><br><a href="https://stackoverflow.com/questions/46992463/es6-module-support-in-chrome-62-chrome-canary-64-does-not-work-locally-cors-er" target="_blank" rel="noopener">ES6 module support in Chrome 62/Chrome Canary 64, does not work locally, CORS error</a><br><a href="https://stackoverflow.com/questions/41965066/access-to-image-from-origin-null-has-been-blocked-by-cors-policy" target="_blank" rel="noopener">Access to Image from origin ‘null’ has been blocked by CORS policy</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」一个案例搞懂 Vue.js 的作用域插槽</title>
      <link href="/2019/10/10/Trs-%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/"/>
      <url>/2019/10/10/Trs-%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD-1.webp" alt=""></p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://vuejsdevelopers.com/2017/10/02/vue-js-scoped-slots/" target="_blank" rel="noopener">Getting Your Head Around Vue.js Scoped Slots</a></li><li>原文作者：Anthony Gore</li><li>译者：Chor</li></ul></blockquote><p>作用域插槽是 Vue.js 中一个很有用的特性，可以显著提高组件的通用性和可复用性。问题在于，它实在不太好理解。尝试搞清楚父子作用域之间错综复杂的关系，其痛苦程度不亚于求解一个棘手的数学方程。</p><p>当你无法理解一个东西的时候，最好的办法就是在解决问题的过程中体会它的应用。本文将向你展示如何使用作用域插槽构建一个可复用的列表组件。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD-2.png" alt=""></p><blockquote><p>注意: 完整代码可以去 <a href="https://codepen.io/anthonygore/pen/zExPZX" target="_blank" rel="noopener">Codepen</a> 查看</p></blockquote><h2 id="最基础的组件"><a href="#最基础的组件" class="headerlink" title="最基础的组件"></a>最基础的组件</h2><p>我们即将构建的组件叫做 <code>my-list</code> ，用来展示一系列的项目。它的特别之处就在于，你可以在每次使用组件的时候自定义列表项目的渲染方式。</p><p>我们先从最简单的单个列表开始：一个包含几何图形名字和边数的数组。</p><p><em>app.js</em></p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-list'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'#my-list'</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      title<span class="token punctuation">:</span> <span class="token string">'Shapes'</span><span class="token punctuation">,</span>      shapes<span class="token punctuation">:</span> <span class="token punctuation">[</span>         <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Square'</span><span class="token punctuation">,</span> sides<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Hexagon'</span><span class="token punctuation">,</span> sides<span class="token punctuation">:</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Triangle'</span><span class="token punctuation">,</span> sides<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>index.html</em></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-list</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-list</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/x-template<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my-list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"my-list"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"title"</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> title <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list-item"</span> v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"shape in shapes"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> shape<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">&lt;</span>small<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">{</span> shape<span class="token punctuation">.</span>sides <span class="token punctuation">}</span><span class="token punctuation">}</span> sides<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>small<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在加上一点样式，大概就会是下图这个样子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD-3.png" alt=""></p><h2 id="更通用的-my-list"><a href="#更通用的-my-list" class="headerlink" title="更通用的 my-list"></a>更通用的 <code>my-list</code></h2><p>现在我们想要让 <code>my-list</code> 更加通用，可以渲染任何类型的列表。这次我们展示的是一堆颜色的名字以及对应的颜色方块。</p><p>为此，我们需要将上例列表独有的数据进行抽象化。由于列表中的项目可能有不同的结构，我们将会给 <code>my-list</code> 一个插槽，让父组件来定义列表的展示方式。</p><p><em>app.js</em></p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-list'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'#my-list'</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'title'</span> <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>index.html</em></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/x-template<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my-list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"my-list"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"title"</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> title <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>slot<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们在根实例中创建 <code>my-list</code> 组件的两个实例，分别展示两个测试用例列表：lists:</p><p><em>app.js</em></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    shapes<span class="token punctuation">:</span> <span class="token punctuation">[</span>       <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Square'</span><span class="token punctuation">,</span> sides<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>       <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Hexagon'</span><span class="token punctuation">,</span> sides<span class="token punctuation">:</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>       <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Triangle'</span><span class="token punctuation">,</span> sides<span class="token punctuation">:</span> <span class="token number">3</span> <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    colors<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Yellow'</span><span class="token punctuation">,</span> hex<span class="token punctuation">:</span> <span class="token string">'#F4D03F'</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Green'</span><span class="token punctuation">,</span> hex<span class="token punctuation">:</span> <span class="token string">'#229954'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Purple'</span><span class="token punctuation">,</span> hex<span class="token punctuation">:</span> <span class="token string">'#9B59B6'</span> <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-list</span> <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Shapes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list-item<span class="token punctuation">"</span></span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in shapes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{ shape.name }} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>small</span><span class="token punctuation">></span></span>({{ shape.sides }} sides)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>small</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-list</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-list</span> <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Colors<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list-item<span class="token punctuation">"</span></span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>color in colors<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>swatch<span class="token punctuation">"</span></span> <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token punctuation">{</span> <span class="token property">background</span><span class="token punctuation">:</span> color<span class="token number">.</span>hex <span class="token punctuation">}</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        {{ color.name }}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-list</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD-4.png" alt=""></p><h2 id="大材小用的组件"><a href="#大材小用的组件" class="headerlink" title="大材小用的组件"></a>大材小用的组件</h2><p>我们刚才创建的组件确实符合要求，但那段代码算不上很好。<code>my-list</code> 本来应该是一个展示列表的组件，但我们却把渲染列表需要的逻辑部分抽象到了父组件中，这样一来，子组件在这里只不过是用来包裹列表而已，未免显得大材小用了。</p><p>更糟糕的是，在两个组件的声明中存在着大量重复代码（例如，<code>&lt;div class=&quot;list-item&quot; v-for=&quot;item in ...&quot;&gt;</code>）。如果我们能够在子组件中编写这些代码，那么子组件就不再是“打酱油的角色”了。</p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>普通插槽无法满足我们的需求，这时候，<strong>作用域插槽</strong>就派上用场了。作用域插槽允许你传递一个模板而不是已经渲染好的元素给插槽。之所以叫做”作用域“插槽，是因为模板虽然是在父级作用域中渲染的，却能拿到子组件的数据。</p><p>例如，带有作用域插槽的组件 <code>child</code> 大概是下面这个样子：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">my-prop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Hello from child<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用这个组件的父组件将会在插槽中声明一个 <code>template</code> 元素。这个模板元素会有一个 <code>scope</code> （译者注：Vue 2.6 后改为 <code>v-slot</code> 属性）属性指向一个对象，任何添加到插槽（位于子组件模板）中的属性都会作为这个对象的属性。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>props<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>Hello from parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>{{ props.my-prop }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将会渲染成：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>Hello from parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>Hello from child<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在-my-list-中使用作用域插槽"><a href="#在-my-list-中使用作用域插槽" class="headerlink" title="在 my-list 中使用作用域插槽"></a>在 <code>my-list</code> 中使用作用域插槽</h2><p>我们将两个列表数组通过 <code>props</code> 传递给 <code>my-list</code>。之后将普通插槽替换为作用域插槽，这样，<code>my-list</code> 就能够负责迭代列表项目，同时父组件依然能够定义每个项目具体的展示方式。</p><p><em>index.html</em></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-list</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Shapes<span class="token punctuation">"</span></span> <span class="token attr-name">:items</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shapes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--在这里书写 template--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-list</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-list</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Colors<span class="token punctuation">"</span></span> <span class="token attr-name">:items</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>colors<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--在这里书写 template--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-list</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着我们让 <code>my-list</code> 迭代项目。在 <code>v-for</code> 循环中，<code>item</code> 是当前迭代项目的别名。我们可以创建一个插槽并通过 <code>v-bind=&quot;item&quot;</code> 将那个项目绑定到插槽中。</p><p><em>app.js</em></p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-list'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token string">'#my-list'</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'items'</span> <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>index.html</em></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/x-template<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my-list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"my-list"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"title"</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> title <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in items"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>slot v<span class="token operator">-</span>bind<span class="token operator">=</span><span class="token string">"item"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：也许你之前没见过不带参数的 <code>v-bind</code> 用法。这种用法将会把整个对象的所以属性都绑定到当前元素上。在涉及作用域插槽时，这种用法很常见，因为绑定的对象可能有很多属性，而一一将它们列举出来并手动绑定显然太麻烦了。</p></blockquote><p>现在，回到根实例这里来，在 <code>my-list</code> 的插槽中声明一个模板。首先看一下几何图形列表（第一个例子中的列表），我们声明的模板必须带有一个 <code>scope</code> 属性，这里将其赋值为 <code>shape</code>。<code>shape</code> 这个别名可以让我们访问作用域插槽。在模板中，我们可以继续沿用最初例子中的标记来展示项目。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-list</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Shapes<span class="token punctuation">"</span></span> <span class="token attr-name">:items</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shapes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shape<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{ shape.name }} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>small</span><span class="token punctuation">></span></span>({{ shape.sides }} sides)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>small</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-list</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个模板大概是下面这样：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-list</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Shapes<span class="token punctuation">"</span></span> <span class="token attr-name">:items</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shapes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shape<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{ shape.name }} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>small</span><span class="token punctuation">></span></span>({{ shape.sides }} sides)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>small</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-list</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-list</span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Colors<span class="token punctuation">"</span></span> <span class="token attr-name">:items</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>colors<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>swatch<span class="token punctuation">"</span></span> <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token punctuation">{</span> <span class="token property">background</span><span class="token punctuation">:</span> color<span class="token number">.</span>hex <span class="token punctuation">}</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        {{ color.name }}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-list</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然用上作用域插槽之后，代码量并未减少，但是我们将通用的功能都交由子组件负责，这显著提高了代码的健壮性。</p><p>完整代码的 Codepen 在这里：</p><p><a href="https://codepen.io/anthonygore/pen/zExPZX" target="_blank" rel="noopener">https://codepen.io/anthonygore/pen/zExPZX</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件（四）：组件插槽</title>
      <link href="/2019/10/08/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/"/>
      <url>/2019/10/08/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-1.png" alt=""></p><a id="more"></a><p>今天刚学到作用域插槽的概念，结果跑到官网文档一看：</p><blockquote><p>在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除且仍在文档中的特性。</p></blockquote><p>看到这里，突然有了一点想法。<br>为什么知识越学越多，因为学习的速度很难赶上技术迭代的速度，而且你越晚学习越会有这种感觉。Vue 3.0 的源码在前几天公布（国庆期间）了，根据群里大佬的说法，明年第一季度很可能就正式发布 3.0，似乎暗示着又一波学习热潮即将到来。工作以后和业务打交道，其实很少有时间可以学习了，所以现在 —— 大学的时间真的很宝贵，得好好珍惜。</p><h2 id="为什么需要插槽？"><a href="#为什么需要插槽？" class="headerlink" title="为什么需要插槽？"></a>为什么需要插槽？</h2><p>我们先来看下这幅图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-2.png" alt=""></p><p>可以看到，每个页面都有对应的 <code>nav-bar</code>，所以这应该是一个可以复用的组件。问题是怎么复用呢？统一封装成一个组件肯定不行，因为这些 <code>nav-bar</code> 结构和内容并不完全相同；针对每个页面都封装一个组件也不行，因为它们有相同的结构和内容，这不利于复用。</p><p>所以我们需要的其实是一个足够灵活的组件，其内容可以更进一步地自定义，就像是积木一样，对于同一个位置 C，我们可以安插 A ，也可以安插 B。而<strong>插槽(slot)</strong> 就是用来实现这种灵活性的。</p><p>插槽是子组件暴露的一个让父组件传入自定义内容的接口。我们可以形象地把它理解成电脑的各种接口，提供了各种扩展。</p><h2 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h2><pre class="line-numbers language-html"><code class="language-html">// 子组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>// 父组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是父组件传给子组件插槽的内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&lt;slot&gt;&lt;/slot&gt;</code> 相当于一个空缺，等待父组件给它填充内容。当然也可以给 <code>&lt;slot&gt;&lt;/slot&gt;</code> 指定默认值，例如 <code>&lt;slot&gt;我是默认值&lt;/slot&gt;</code>，这种情况下，其将在父组件未传入内容时（即 <code>&lt;cpn&gt;&lt;/cpn&gt;</code>）得到应用。</p><p>子组件可有多个 <code>slot</code>，这些 <code>slot</code> 都将使用父组件传入的内容。</p><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>大部分时候，我们需要给特定的插槽传入特定的内容，所以每个插槽必须得有一个名字作为标识，这时候就要使用具名插槽了。具体来说，就是给 <code>slot</code> 添加 <code>name</code> 属性，之后在父组件中真正传入内容的时候，将内容包裹在有 <code>slot=&quot;name&quot;</code> 属性的元素中。<br>假设我们要用同一个组件实现下面三种不同效果：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-3.png" alt=""></p><p>那么，首先会想到给这个子组件三个插槽，由于特定的插槽要传入特定的内容，所以我们这里使用具名插槽。代码如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--父组件模板--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--子组件模板--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>我是子组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果为：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-4.png" alt=""></p><p>_注意_：</p><ul><li>Vue 2.6.0 之后改 <code>slot</code> 为 <code>v-slot</code>，且必须绑定在一个 <code>template</code> 元素上。例如上面的 <code>&lt;span slot=&quot;right&quot;&gt;5&lt;/span&gt;</code> 应该是 <code>&lt;template v-slot:right&gt;&lt;span&gt;5&lt;/span&gt;&lt;/template&gt;</code></li><li>另外，我们可以将 <code>v-slot:right</code> 直接缩写为 <code>#right</code>，注意这仅适用于 <code>v-slot</code> 有参数的情况，例如 <code>v-slot=&quot;xxx&quot;</code> 是不能缩写的。</li></ul><h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>关于编译作用域，只需要记住一条规则：</p><blockquote><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p></blockquote><p>来看一个例子：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--HTML--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// JS</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    cpn<span class="token punctuation">:</span><span class="token punctuation">{</span>      template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          isShow<span class="token punctuation">:</span><span class="token boolean">true</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>    isShow<span class="token punctuation">:</span><span class="token boolean">false</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于这个例子，组件最后到底会不会显示（渲染）呢？<br>答案是不会。尽管父组件和子组件都有 <code>isShow</code> 这个变量，且后者为 <code>true</code>，但子组件是存在于父级模板中的，其内容是在父级作用域中编译的，只能识别父级作用域中为 <code>false</code> 的那个 <code>isShow</code>。</p><p>在这里，我们知道父模板无法直接访问子组件中的数据，但是有了<strong>作用域插槽</strong>之后，又不一样了。</p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>我们先来设想一种情况。假定子组件中有数据：<br><code>languages:[&quot;Java&quot;,&quot;C&quot;,&quot;Python&quot;,&quot;Swift&quot;]</code></p><p>然后，现在要求在父组件中以不同的形式将这些数据进行展示，可能是列表，也可能是互相之间以斜杆分隔。如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-6.png" alt=""></p><p>首先，数据的呈现方式不同，也即 HTML 结构不同，因此不能直接在子组件模板中书写结构，这时候想到了应该给子组件一个插槽，后面在父组件模板中再定义结构。但这样一来，父组件无可避免地要使用子组件的数据，而前面说过编译作用域的问题，所以这里的父组件实际上是无法拿到子组件数据的。怎么办呢？</p><p>这时候，作用域插槽就派上用场了。作用域插槽可以理解为是带数据的插槽，它允许我们<strong>在父组件模板中访问子组件的数据</strong>。两步：</p><ul><li>将子组件数据绑定给 <code>slot</code> 上的属性（成为 <code>插槽 prop</code>）</li><li>父组件模板中通过 <code>slot-scope</code> 拿到 <code>slot</code> 对象（准确地说是包含所有 <code>插槽prop</code> 的对象）并进行属性访问</li></ul><p>以这道题为例：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// JS</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    cpn<span class="token punctuation">:</span><span class="token punctuation">{</span>      template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>      <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>          languages<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"Java"</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">,</span><span class="token string">"Python"</span><span class="token punctuation">,</span><span class="token string">"Swift"</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们通过 <code>:lang=&quot;languages&quot;</code> 将 子组件的 <code>languages</code> 绑定到 <code>slot</code> 的 <code>lang</code> 属性中。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--子组件模板--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>展示方式：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">:lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>languages<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，父组件模板中给插槽传入 <code>template</code>，这个 <code>template</code> 带有 <code>slot-scope=&quot;obj&quot;</code>，使得我们可以通过 <code>obj.lang</code> 访问到子组件数据。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--展示方式一--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>obj<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in obj.lang<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--展示方式二--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>obj<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        {{obj.lang.join(' / ')}}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--展示方式三--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>obj<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        {{obj.lang.join('----')}}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终实现我们想要的效果。<br>当然，关于作用域插槽还有一些地方需要注意：</p><ul><li><p>如果数据过多，不可能一一绑定，这时候直接 <code>v-bind</code> 到一个属性就行，这个操作等同于手动绑定所有数据，方便了我们的访问。上例如果是<br><code>&lt;slot v-bind:obj&gt;&lt;/slot&gt;</code><br>后面直接 <code>obj.languages</code> 就能拿到数据了</p></li><li><p>Vue 2.6.0 之后，改 <code>slot-scope</code> 为 <code>v-slot</code>，对于像上面一样的匿名插槽，只需要使用 <code>v-slot=&quot;obj&quot;</code>；对于具名插槽，则使用 <code>v-slot:name=&quot;obj&quot;</code>。当然，<code>v-slot:name</code> 依然是表示具名插槽。</p></li><li><p>正如前面所说，<code>v-slot:name=&quot;obj&quot;</code> 也可以缩写为 <code>#name=&quot;obj&quot;</code></p></li><li><p>另外，还有解构插槽、动态插槽名等，具体可以看<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">文档</a>。</p></li></ul><p>关于作用域插槽的应用，还有一个不错的案例，具体可以看下我之前翻译的一篇<a href="https://juejin.im/post/5d9f200d6fb9a04e19505221" target="_blank" rel="noopener">文章</a>。我觉得里面有句话说得很有道理：</p><blockquote><p>A good approach when you can’t understand something easily is to try put it to use in solving a problem.</p></blockquote><p>大意是：当知识难以理解的时候，最好的办法就是拿它去解决问题。</p><p>我在这篇文章中其实也是尽量按照这个思路布局的，首先是刻意制造了一个问题，按照常规的思路没办法解决，接着引出相关概念，在实际情境中体会它的应用，这时候会有一种“噢，原来xxx可以解决这类型问题”的感觉，我觉得这或许是一种不错的学习方式，毕竟很多东西是为了解决问题而存在的，若能从最初问题产生的源头开始思考，兴许我们可以更好地理解它。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件（三）：关于单向数据流的简单理解</title>
      <link href="/2019/10/04/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
      <url>/2019/10/04/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/Vue%20%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3-0.png" alt=""></p><a id="more"></a><h2 id="单向绑定和双向绑定"><a href="#单向绑定和双向绑定" class="headerlink" title="单向绑定和双向绑定"></a>单向绑定和双向绑定</h2><blockquote><p>单双向绑定，指的是 view层和 model 层之间的映射关系</p></blockquote><p>Vue 在数据操作上支持单向绑定和双向绑定：</p><ul><li>单向绑定：例如 Mustache 插值语法，<code>v-bind</code> 等；</li><li>双向绑定：即表单的 <code>v-model</code>。它实际上是一个语法糖，背后包括两步操作：<ul><li><code>v-bind:value</code>：model 层的更改同步到 view 层</li><li><code>v-on:input</code>：view 层的更改同步到 model 层</li></ul></li></ul><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><blockquote><p>数据流，指的是组件之间的数据流动</p></blockquote><p>虽然 <code>v-model</code> 是双向绑定，但 Vue 实际上是单向数据流。我们看一个例子：<br>假设现在想要用子组件的 <code>prop</code> 做一个双向绑定，那么我们的代码可能会这么写：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>{{value2}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"value2"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">const</span> app  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>    value<span class="token punctuation">:</span><span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    cpn  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会发现 model 层的确随着 view 层同步改变了，但是控制台里会报错：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/Vue%20%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3-1.png" alt=""></p><p>实际上，<code>prop</code> 就应该是父组件传过来的原始数据，但是我们试图通过子组件的 <code>v-model</code> 去改变这个 <code>prop</code>，也就是试图通过子组件<strong>直接</strong>去改变父组件的数据（而不是通过发送事件的方式），这是不允许的，因为 Vue 是单向数据流 —— 也就是说，<strong>数据总是从父组件传到子组件</strong>，子组件没有权利修改父组件传过来的数据，<strong>只能请求</strong>父组件对原始数据进行修改。</p><p>这实际上是为了更好的解耦。在开发中可能有多个子组件依赖于父组件的某个数据，万一子组件真的可以直接修改父组件数据，那么一个子组件变化将会引发所有依赖这个数据的子组件发生变化，所以 Vue 不推荐子组件修改父组件的数据，直接修改 <code>prop</code> 会抛出警告。</p><p>官方文档也有针对这个问题的解释：</p><blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p></blockquote><p>但是，很多时候我们又确实要操作这个数据，那么应该怎么办呢？<br>有两种方法：</p><ul><li>定义一个局部变量，并用 <code>prop</code> 的值初始化它：</li></ul><pre class="line-numbers language-js"><code class="language-js">props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'initialCounter'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>data<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    counter<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>initialCounter  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义一个计算属性，处理 <code>prop</code> 的值并返回：</li></ul><pre class="line-numbers language-js"><code class="language-js">props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'size'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>  normalizedSize<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个方法相当于创建了原始 <code>prop</code> 的副本了，之后怎么操作数据都是操作的子组件数据，不会影响到父组件数据；第二个方法，注意 <code>trim()</code> 会返回一个处理完成后的新字符串，同样不会影响到父组件数据（原字符串）。之后如果父组件确实要用到这个处理后的值，就通过 <code>$emit</code> 的方式传给父组件即可。</p><p>拿前面的例子来说，我们想要利用 <code>prop</code> 这个数据实现双向绑定，可以这么写：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>value3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>{{value3}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"value2"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>    value3<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>value2  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> app  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>    value<span class="token punctuation">:</span><span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    cpn  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样子就不会报错了，因为现在我们操作的是子组件自己的数据，和 <code>prop</code> 无关。</p><p>还要注意一个问题：</p><blockquote><p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。</p></blockquote><p>比如下面这段代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>父组件数据：{{parent}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>obj1</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>子组件数据：{{son}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>son.age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"obj1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      son<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj1    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> app  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>    parent<span class="token punctuation">:</span><span class="token punctuation">{</span>age<span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    cpn  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>this.obj1</code> 是引用，赋值给了 <code>son</code>，所以 <code>son</code> 实际上还是指向了父组件的数据，对 <code>son.age</code> 的修改依然会影响到父组件，如图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/Vue%20%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3-2.png" alt=""></p><p>所以，我们实际上需要的是一个对象副本。因为对象属性都是基本类型，这里只用浅拷贝即可（如果对象属性还是对象，就得用深拷贝）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"obj1"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// son:this.obj1</span>      son<span class="token punctuation">:</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj1<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后会发现，子组件的数据操作不再影响到父组件：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/Vue%20%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3-3.png" alt=""></p><p>参考：<br><a href="https://cn.vuejs.org/v2/guide/components-props.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/components-props.html</a><br><a href="https://juejin.im/entry/59e8b8a8518825579d131e51" target="_blank" rel="noopener">https://juejin.im/entry/59e8b8a8518825579d131e51</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件（二）：父子组件通信</title>
      <link href="/2019/10/03/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/10/03/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-0.png" alt=""><br><a id="more"></a></p><p>子组件是不能直接访问父组件中的数据的，但有时候父子组件之间需要进行数据交互，这就涉及到了父子组件通信的问题。简单来说，父组件向子组件通信是通过 <strong><code>props</code></strong> 进行的，而子组件向父组件通信则是通过<strong>自定义事件</strong>进行的。</p><p>我们用一个简易的 todolist 案例来理解这两个过程。</p><h2 id="1-todolist-案例"><a href="#1-todolist-案例" class="headerlink" title="1.todolist 案例"></a>1.todolist 案例</h2><h3 id="1-1-父传子"><a href="#1-1-父传子" class="headerlink" title="1.1 父传子"></a>1.1 父传子</h3><p>假定我们现在有一个需求：在输入框中输入待办事项，点击添加按钮可以将事项展现在页面上。如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-1.gif" alt=""></p><p>分析：页面分为两个部分，一部分是操作区，一部分是展示区。展示区可以用 <code>li</code>，那么这些 <code>li</code> 就可以看作是可复用的子组件，而其它部分则看作是父组件，我们在父组件中操作，结果却是在子组件中显示的，所以这里是父组件向子组件通信的问题。</p><p>首先将根实例作为父组件，然后注册一个子组件，写好大概的结构：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--父组件模板--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>newvalue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击添加<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--子组件模板--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">}</span><span class="token keyword">const</span> app  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>    newvalue<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span>    list<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">addItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>newvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>newvalue <span class="token operator">=</span> <span class="token string">''</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    cpn  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表单元素需要双向数据绑定，所以我们这里使用 <code>v-model=&quot;newvalue&quot;</code>，<code>newvalue</code> 初始化的时候是空字符串，后面就代表我们输入的待办事项，监听按钮的点击事件并把它 <code>push</code> 到空数组中，之后为了用户操作方便（不需要手动删除输入框内容），我们再把 <code>newvalue</code> 置空。这时候，父组件的操作已经完成了，接下来要把数据传递给子组件并显示出来。</p><p><code>list</code> 是要传递的数据，首先把它交付给自定义属性 <code>list2</code>，对于子组件，它需要通过 <code>props</code> （可以是数组或者对象）去接收。之后，我们在子组件模板中进行列表的遍历，遍历的对象就是 list2 数组。</p><p>代码如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--父组件模板--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>newvalue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击添加<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>list2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--子组件模板--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item,index) in list2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{item}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"list2"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">const</span> app  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>    newvalue<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span>    list<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">addItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>newvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>newvalue <span class="token operator">=</span> <span class="token string">''</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    cpn  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p></blockquote><h3 id="1-2-子传父"><a href="#1-2-子传父" class="headerlink" title="1.2 子传父"></a>1.2 子传父</h3><p>作为一个 todolist，除了添加之外应该还可以删除，所以接下来的需求是点击待办事项可以进行删除。如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%9A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-2.1.gif" alt=""></p><p>分析：因为这里子组件只负责点击操作，实际的删除需要父组件自己去操作数据（类似于子组件打个电话告诉父组件该删除哪个东西了），所以这里涉及到了子组件向父组件通信的问题。</p><p>这里首先还是监听待办事项的点击事件，点击后调用函数，之后执行函数中的 <code>this.$emit(&#39;eventName&#39;,args)</code>，作用是由实例向外触发一个自定义事件（参数可选），之后父组件再监听这个自定义事件，一旦监听到事件就调用父组件（即根实例）下挂载的方法，来删除待办事项。</p><p>代码如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>newvalue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击添加<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 3.父组件监听到自定义事件 receive 后，调用 deleteItem --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>list2</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">@receive</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>deleteItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!--1.监听点击事件--></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item,index) in list2<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>remove(index)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        {{item}}      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"list2"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">remove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"receive"</span><span class="token punctuation">,</span>index<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 2.向外触发自定义事件 receive</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> app  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>    newvalue<span class="token punctuation">:</span><span class="token string">''</span><span class="token punctuation">,</span>    list<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token function">addItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>newvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>newvalue <span class="token operator">=</span> <span class="token string">''</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 4.执行 deleteItem 删除数组元素</span>    <span class="token function">deleteItem</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    cpn  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-props"><a href="#2-props" class="headerlink" title="2. props"></a>2. <code>props</code></h2><p>前面使用的 <code>props</code> 是数组，实际开发中用的更多的其实是对象。作为对象的 <code>props</code> 可以配置高级选项，如类型检测、自定义校验和设置默认值等。</p><p>假定上面的子组件还接受了其它数据：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span><span class="token punctuation">{</span>    propA<span class="token punctuation">:</span>Array<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 接受的 propA 类型必须是数组。也可以指定自定义类型</span>    propB<span class="token punctuation">:</span><span class="token punctuation">{</span>String<span class="token punctuation">,</span>Number<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// propB 必须是字符串或者数字</span>    propC<span class="token punctuation">:</span><span class="token punctuation">{</span>      type<span class="token punctuation">:</span>String<span class="token punctuation">,</span>      required<span class="token punctuation">:</span><span class="token boolean">true</span>    <span class="token comment" spellcheck="true">// 必须接受 propC，否则报错</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    propD<span class="token punctuation">:</span><span class="token punctuation">{</span>      type<span class="token punctuation">:</span>String<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">:</span><span class="token string">"demo"</span>   <span class="token comment" spellcheck="true">// 没有接受到 propD 时使用这个默认值</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    propD<span class="token punctuation">:</span><span class="token punctuation">{</span>      type<span class="token punctuation">:</span>Object<span class="token punctuation">,</span>      <span class="token keyword">default</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 数组或对象指定默认值时必须是一个函数</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>message<span class="token punctuation">:</span><span class="token string">"Hello"</span><span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    propE<span class="token punctuation">:</span><span class="token punctuation">{</span>      <span class="token function">validator</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这个值必须匹配下列字符串中的一个</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">'aaa'</span><span class="token punctuation">,</span><span class="token string">'bbb'</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，还要注意一下 <code>prop</code> 的命名。引用官方文档的一段话：</p><blockquote><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p></blockquote><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'blog-post'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'postTitle'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 在 JavaScript 中是 camelCase 的</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;h3>{{ postTitle }}&lt;/h3>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 在 HTML 中是 kebab-case 的 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>blog-post</span> <span class="token attr-name">post-title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hello!<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>blog-post</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>重申一次，如果你使用<strong>字符串模板</strong>，那么这个限制就不存在了。</p></blockquote><h2 id="3-在组件中使用-v-model"><a href="#3-在组件中使用-v-model" class="headerlink" title="3. 在组件中使用 v-model"></a>3. 在组件中使用 <code>v-model</code></h2><h3 id="3-1-一般情况"><a href="#3-1-一般情况" class="headerlink" title="3.1 一般情况"></a>3.1 一般情况</h3><p>首先要弄清楚一件事：<code>v-model</code> 其实是语法糖，本质上是 <code>v-bind:value</code> 和 <code>v-on:input</code> 的结合，也就是说：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"test"</span><span class="token operator">></span><span class="token comment" spellcheck="true">// 等同于</span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token punctuation">:</span>value<span class="token operator">=</span><span class="token string">"test"</span> @input<span class="token operator">=</span><span class="token string">"test=$event.target.value"</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>根据这点，<code>v-model</code> 除了实现双向数据绑定之外，也可以用在组件中，更方便地书写父子组件通信。</p><p>假如我们现在想要实现：点击父组件按钮，数据 +1；反过来，点击子组件按钮，数据 -1。<br>代码如下：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>total<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>increase<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cpn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>{{value}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>decrease<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cpn <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token string">"#cpn"</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"value"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">decrease</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> app  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span><span class="token punctuation">{</span>    total<span class="token punctuation">:</span><span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>total<span class="token operator">++</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    cpn  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面我们说过，<code>v-model</code> 是语法糖，因此：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>total<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--相当于下面的--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cpn</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>total<span class="token punctuation">"</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>total<span class="token punctuation">=</span>arguments[0]<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cpn</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>分析：<br>我们把父组件数据直接绑定到 <code>value</code> 上（而不是自定义属性），之后子组件用 <code>prop</code> 接受。点击 -1 按钮后向外触发 <code>input</code> 事件（而不是自定义事件），同时传 -1 后的值，父组件监听到事件后调用函数完成赋值。<br>这里 <code>arguments[0]</code> 就是回调函数第一个参数，也就是前面 -1 后的值。</p><h3 id="3-2-model-选项自定义"><a href="#3-2-model-选项自定义" class="headerlink" title="3.2 model 选项自定义"></a>3.2 <code>model</code> 选项自定义</h3><p>不过，组件的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能不需要 <code>value</code>，需要的是 <code>checked</code>；不需要 <code>oninput</code> 事件，需要的是 <code>onchange</code> 事件。所以 Vue 提供了 <code>model</code> 选项让我们实现自定义：</p><p>假定父组件有一个数据 <code>lovingVue</code> 用于表示子组件的多选框是否勾选，那么可以这么写：</p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'base-checkbox'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  model<span class="token punctuation">:</span> <span class="token punctuation">{</span>    prop<span class="token punctuation">:</span> <span class="token string">'checked'</span><span class="token punctuation">,</span>    event<span class="token punctuation">:</span> <span class="token string">'change'</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  props<span class="token punctuation">:</span> <span class="token punctuation">{</span>    checked<span class="token punctuation">:</span> Boolean  <span class="token punctuation">}</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;input      type="checkbox"      v-bind:checked="checked"      v-on:change="$emit('change', $event.target.checked)"    >  `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base-checkbox</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lovingVue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>base-checkbox</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--相当于下面的--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base-checkbox</span> <span class="token attr-name">:checked</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lovingVue<span class="token punctuation">"</span></span> <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lovingVue<span class="token punctuation">=</span>arguments[0]<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>base-checkbox</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 <code>prop</code>。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 将会被更新。</p><p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 <code>prop</code>。</p><p><strong>Tip：</strong><br>上面这样写之后，看起来很像是子组件可以直接修改父组件数据，其实不是的，本质上还是 <code>prop</code> + <code>$emit</code> 的正常通信方式在，只是书写更加方便了而已。</p><p><strong>要记住 Vue 是单向数据流的</strong>。所以上面这个例子，如果 <code>this.value-1</code> 写成 <code>this.value--</code> ，实际上会报错，因为这样写是试图通过子组件直接修改 <code>prop</code> 的值，这是不允许的。详情可以看 <a href="https://chorer.github.io/2019/10/04/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/">Vue 组件（三）：关于单向数据流的简单理解</a>。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>到这里的话，父子组件之间的通信就已经结束了。使用 Vue 的时候应该避免直接去操作 dom，而是通过数据的改变让页面自动变化。</p><ul><li>父组件向子组件传值：在父组件中通过 <code>v-on</code> 绑定自定义属性以存储父组件数据，然后子组件通过 <code>props</code> 接收，这样就可以拿到父组件中的数据；</li><li>子组件向父组件通信：子组件监听到事件后，通过 <code>$emit</code> 向外触发自定义事件，父组件监听到该事件后操作数据。</li></ul><p>另外还要注意 v-model` 在组件中的使用。</p><p>参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI4OTc3NDgzNQ==&amp;mid=2247484841&amp;idx=1&amp;sn=e0da4a110702637a588e2841d789c047&amp;chksm=ec2b4835db5cc123d1d198ae0162602bc7c8e4b800c25df903786e0f6fcb268b6c5f95a7f106&amp;mpshare=1&amp;scene=1&amp;srcid=09308wnRwhQZFzAPgVuIEehY&amp;sharer_sharetime=1569850132732&amp;sharer_shareid=81500e217703532f9ee988933e5a0d57&amp;key=71a2e8417d7e834ec6296e870f0d6e86d5700587a4cff8c111c8a76851f8c3ca3a346c5c5f321e90241ac905f277a28d9a637eb1271ae02a5dadd74d1e53a4febeda441b7fabdecc8dedd3df8c4ae5fa&amp;ascene=1&amp;uin=MjM1NDgwNTkyMQ%3D%3D&amp;devicetype=Windows+10&amp;version=62070141&amp;lang=zh_CN&amp;pass_ticket=oSwdUFlqGo2g%2BmHS05Ck9%2FeoP289wm8ovqgJMZ4Tjf6qH8ivnnK7tY%2FHzDi5G4nB" target="_blank" rel="noopener">Vue.js中的组件以及父子组件间通信传值</a><br><a href="https://www.cnblogs.com/jiaoyu121/p/7078445.html" target="_blank" rel="noopener">Vue 进阶教程之：详解 v-model</a><br><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">Vue.js - 自定义事件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 组件（一）：组件的基本使用</title>
      <link href="/2019/10/02/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/10/02/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-8.png" alt=""><br><a id="more"></a></p><h2 id="1-组件化"><a href="#1-组件化" class="headerlink" title="1.组件化"></a>1.组件化</h2><p>组件实际上是可以复用的 Vue 实例，它们与 new Vue 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>methods</code> 以及生命周期钩子等。<br>何谓复用？如果把页面看作是组件的容器，那么导航栏、搜索框其实都是可以复用的组件。作为对可重用代码的封装，它们自身具有独立的数据和逻辑。</p><p>前端组件化的核心思路就是将一个巨大复杂的东西<strong>拆分</strong>成若干个小东西（组件），这些组件可以自由组合、替换和删除，同时不影响整个应用的运行，这就是组件化开发。</p><p>组件化的好处是：</p><ul><li>提高开发效率</li><li>方便重复使用，简化调试步骤，方便单元测试</li><li>提升整个项目的可维护性，方便团队成员的协同开发</li><li>高内聚（功能必须是完整的）、低耦合（解耦业务逻辑和数据）</li></ul><h2 id="2-创建组件"><a href="#2-创建组件" class="headerlink" title="2.创建组件"></a>2.创建组件</h2><h3 id="2-1-全局组件"><a href="#2-1-全局组件" class="headerlink" title="2.1 全局组件"></a>2.1 全局组件</h3><p>全局组件在 <code>new Vue</code> 之前创建，创建之后可用于所有根实例的模板中。<br>2.x 之前全局组件的创建过程如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*option*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 创建组件构造器对象</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span>TagName<span class="token punctuation">,</span>obj<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">// 注册组件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.x 之后语法糖的写法如下：</p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"TagName"</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*option*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 同时创建并注册组件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-局部组件"><a href="#2-2-局部组件" class="headerlink" title="2.2 局部组件"></a>2.2 局部组件</h3><p>更多的是创建局部组件，让其只能在当前所处的 Vue 实例的模板中使用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*option*/</span><span class="token punctuation">}</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token string">"aaa"</span><span class="token punctuation">:</span>obj  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要创建父子组件，那么可以这样写：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> son <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*option*/</span><span class="token punctuation">}</span><span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`&lt;div>&lt;h2>something&lt;/h2>&lt;bbb>&lt;/bbb>&lt;/div>`</span></span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token string">"bbb"</span><span class="token punctuation">:</span>son  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token string">"aaa"</span><span class="token punctuation">:</span>parent  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后在 dom 中书写 <code>&lt;aaa&gt;&lt;/aaa&gt;</code> ，会发现父子组件都可以渲染，但是单独书写 <code>&lt;bbb&gt;&lt;/bbb&gt;</code> 则无法渲染子组件，这是因为子组件是在父组件中注册的，因此它只能在父组件的模板中使用。</p><h3 id="2-3-模板抽离"><a href="#2-3-模板抽离" class="headerlink" title="2.3 模板抽离"></a>2.3 模板抽离</h3><p>上面的 <code>&lt;div&gt;&lt;h2&gt;something&lt;/h2&gt;&lt;bbb&gt;&lt;/bbb&gt;&lt;/div&gt;</code> 可以单独抽离出来放在一个有 id 的 <code>&lt;template&gt;&lt;/template&gt;</code> 中，之后直接 <code>#id</code> 引用该模板即可。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>template id<span class="token operator">=</span><span class="token string">"temp"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span>h2<span class="token operator">></span>something<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>    <span class="token operator">&lt;</span>bbb<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>bbb<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token comment" spellcheck="true">// 改写如下：</span><span class="token keyword">var</span> parent <span class="token operator">=</span> <span class="token punctuation">{</span>  template<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`&lt;div>&lt;h2>something&lt;/h2>&lt;bbb>&lt;/bbb>&lt;/div>`</span></span><span class="token punctuation">,</span>  components<span class="token punctuation">:</span><span class="token punctuation">{</span>    bbb<span class="token punctuation">:</span><span class="token string">"#temp"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<strong>每个组件都必须有且仅能有一个根元素</strong>，这意味着组件所有的内容必须包裹在一个最外层元素中。</p><h2 id="3-组件的命名"><a href="#3-组件的命名" class="headerlink" title="3. 组件的命名"></a>3. 组件的命名</h2><p>组件创建后，直接在 dom 中书写组件名即可使用组件。但是组件的命名有一定的规则。<br>定义组件名的方式有两种:</p><p><strong>(1)</strong> 使用 kebab-case(字母全小写+连字符)，例如：</p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-component'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*option*/</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用时也必须是 kebab-case。即 <code>&lt;my-component&gt;&lt;/my-component&gt;</code>，否则会报错。</p><p><strong>(2)</strong> 使用 PascalCase（帕斯卡），例如：</p><pre class="line-numbers language-js"><code class="language-js">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'MyComponent'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* option*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是在<strong>父组件模板</strong>（模板没有抽离到 HTML 中的）中使用，则允许 kebab-case 和 PascalCase 两种方式，即 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 或者 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 都是允许的；但是如果直接在 DOM （非字符串的模板）中，则只能使用相应的 kebab-case，否则会报错。</p><p>我们来看一个例子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1.png" alt=""></p><p>上图中我们创建了父子组件，其中子组件采用 PascalCase 命名，之后在父组件模板中引用子组件时，发现不管是 kebab-case 命名还是 PascalCase 命名都是可以成功渲染的。</p><p>再来看第二张图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-2.png" alt=""></p><p>我们创建了 <code>HisCpn</code> 组件，之后直接在 DOM 中引用（没有转换为 kebab-case 命名），结果报错了；同样的，我们创建了 <code>cpn1</code> 和 <code>MyCpn</code> 父子组件，之后直接在 DOM 中引用，发现转换为 kebab-case 命名<br>的子组件可以正常渲染，而仍然采用 PascalCase 命名的子组件则报错了，因为前面我们说过：如果直接在 DOM （非字符串的模板）中，则只能使用相应的 kebab-case，否则会报错。</p><blockquote><p>注意： PascalCase 每个单词首字母都大写，而 camelCase 即驼峰式命名第一个单词首字母不大写。</p></blockquote><h2 id="4-为什么组件的-data-必须是函数？"><a href="#4-为什么组件的-data-必须是函数？" class="headerlink" title="4. 为什么组件的 data 必须是函数？"></a>4. 为什么组件的 <code>data</code> 必须是函数？</h2><p>另外还有一个需要注意的地方是，根实例的 <code>data</code> 是对象，但是组件的 <code>data</code> 却是函数。<br>这是因为组件是可复用的，每次使用一次 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 就会创建一个组件实例，如果定义组件时 <code>data</code> 依然返回的是对象，那么一个组件数据的更改将会同步影响到其它组件，因为<strong>它们共享一个 <code>data</code> 对象</strong>。如下图所示，我们只操作了一个组件，但三个组件数据都同步改变：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-6.png" alt=""></p><p>相反，如果 <code>data</code> 是函数，那么每次函数执行时都会开辟新的内存空间，创建并返回一个新的对象副本，这使得<strong>每个实例都有自己的 <code>data</code> 对象</strong>，实例互相之间不影响。如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/Vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-5.png" alt=""></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 :key 管理可复用元素</title>
      <link href="/2019/09/28/F-%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/"/>
      <url>/2019/09/28/F-%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-4.webp" alt=""><br><a id="more"></a></p><h2 id="input-中的-key"><a href="#input-中的-key" class="headerlink" title="input 中的 key"></a><code>input</code> 中的 <code>key</code></h2><p>我们先来看一个切换登录方式的例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"isUser"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>label<span class="token operator">></span>Login <span class="token keyword">with</span> account<span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> placeholder<span class="token operator">=</span><span class="token string">"Enter your account"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>div v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">></span>    <span class="token operator">&lt;</span>label<span class="token operator">></span>Login <span class="token keyword">with</span> email<span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">></span>    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> placeholder<span class="token operator">=</span><span class="token string">"Enter your email"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"isUser=!isUser"</span><span class="token operator">></span>click to toggle<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-4.png" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-6.png" alt=""></p><p>我们会发现，在点击按钮切换登录方式后，输入框中已有的内容<strong>没有被清除</strong>，这是为什么呢？</p><p>引用官方文档的原话：</p><blockquote><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。</p></blockquote><p>这里的 <code>input</code> 实际上复用了切换之前的 <code>input</code>。而类似 <code>&lt;input&gt;</code>，<code>&lt;select&gt;</code>，<code>&lt;textarea&gt;</code> 这样的表单元素都有一个 <code>internal state</code> 保存着元素的值，在元素复用时，这个值是会得到保留的。</p><p>如果我们希望切换的时候不保留这个值呢？我们可以给两个 <code>input</code> 添加不同的 <code>key</code>。因为 Vue 是将 <code>key</code> 作为唯一标识从而来识别复用的元素的，如果两个元素的 <code>key</code> 不同，那么就相当于告诉 Vue “这两个元素是完全独立的，你不能用其中一个来复用另一个”。</p><p>接着再来看一个利用 <code>v-for</code> 生成 <code>input</code> 的例子。<br>假如我们的代码为：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(item,index) in array<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        {{item}}: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span><span class="token punctuation">{</span>        array<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">,</span><span class="token string">"D"</span><span class="token punctuation">,</span><span class="token string">"E"</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后生成的 <code>input</code> 中我们填入字符串作为 <code>internal state</code>。如图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-1.png" alt=""></p><p>在没有使用 <code>key</code> 的情况下，我们通过 <code>app.array.splice(2,0,&quot;F&quot;)</code> 在 BC 之间插入 F，发现：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-2.png" alt=""></p><p>和之前一样，因为 Vue 采用的是 <code>就地复用</code> 策略，这意味着 ABCDE 在<strong>原地不动的情况下</strong>被复用了，CDE 都被重新渲染了一次，但先前的 <code>internal state</code> 仍然保留着。</p><p>出于性能考虑，有没有办法可以只移动个别元素，单独渲染要插入的那个新元素呢？有了前面的经验，我们会想到给每个 <code>input</code> 一个 <code>key</code> 值。</p><p>首先我们尝试将 <code>index</code> 作为 <code>key</code>，之后进行插入操作，发现：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-2.png" alt=""></p><p>问题依然存在。这是因为，我们将 <code>index</code> 作为复用的判断依据，相当于告诉 Vue：“只要这两个东西的 index 一样，就进行复用”。插入之前 C 的 index 是 2，插入之后 F 的 index 也是 2，于是 F 复用了 C，同理，DE 也被复用了，并因此重新渲染了一次。</p><p><code>index</code> 是会随着插入删除改变的值，所以它实际上并不适合作为 <code>key</code>。于是我们想：在进行插入或者删除操作的时候，有没有一种值始终不会改变呢？有的，我们可以给每个元素一个单独的 id。但更简单的方法是直接使用 <code>item</code>，即元素本身的值，毕竟这个值对每个元素来说也是独一无二的。</p><p>我们将 <code>item</code> 作为 <code>key</code> ，之后进行插入操作，发现：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-3.png" alt=""></p><p>这回正常了。可以很明显地看到，每个元素都复用了先前的对应元素，这是因为此时 <code>item</code> （即元素值）才是复用的判断依据，相当于告诉 Vue：“只要这两个东西的元素值一样，就进行复用”。例如对于 C 来说，它只会复用与自己的值一样的元素，显然这个元素就是 C 本身。同理，D 复用 D，E 复用 E，CDE 都不需要重新渲染了，只需要后移以方便 F 插入，这时候的性能显然要好很多。</p><h2 id="Virtual-DOM-的-Diff-算法"><a href="#Virtual-DOM-的-Diff-算法" class="headerlink" title="Virtual DOM 的 Diff 算法"></a>Virtual DOM 的 <code>Diff</code> 算法</h2><blockquote><p>下面大致从虚拟DOM的Diff算法实现的角度去解释一下。</p></blockquote><p>vue 和 react的虚拟 DOM 的 <code>Diff</code> 算法大致相同，其核心是基于两个简单的假设：</p><ul><li>两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。</li><li>同一层级的一组节点，他们可以通过唯一的id进行区分。基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。</li></ul><p>引用 <a href="https://calendar.perfplanet.com/2013/diff/" target="_blank" rel="noopener">React’s diff algorithm</a> 中的例子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-1.webp" alt=""></p><p>当某一层有很多相同的节点时，也就是列表节点时，Diff 算法的更新过程默认情况下也是遵循以上原则。 比如一下这个情况：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-2.webp" alt=""></p><p>我们希望可以在 B 和 C 之间加一个 F，Diff 算法默认执行起来是这样的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-3.webp" alt=""></p><p>即把 C 更新成 F，D 更新成 C，E 更新成 D，最后再插入 E，这样显然很没有效率。<br>所以我们需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%94%E8%AF%A5%E5%9C%A8%20v-for%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20key-4.webp" alt=""></p><p>所以 key 的作用主要是为了高效的更新虚拟 DOM。</p><p>参考：<br><a href="https://stackoverflow.com/questions/44077320/what-is-the-use-of-track-by-or-key-in-v-for-in-vue-js" target="_blank" rel="noopener">https://stackoverflow.com/questions/44077320/what-is-the-use-of-track-by-or-key-in-v-for-in-vue-js</a><br><a href="https://juejin.im/post/5aae19aa6fb9a028d4445d1a#comment" target="_blank" rel="noopener">https://juejin.im/post/5aae19aa6fb9a028d4445d1a#comment</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法笔记 cp2-2：线性表</title>
      <link href="/2019/09/23/CB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2-2/"/>
      <url>/2019/09/23/CB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2-2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-0.jpg" alt=""><br><a id="more"></a></p><h2 id="线性表的链式存储结构-链表"><a href="#线性表的链式存储结构-链表" class="headerlink" title="线性表的链式存储结构 / 链表"></a>线性表的链式存储结构 / 链表</h2><h3 id="1-1-定义："><a href="#1-1-定义：" class="headerlink" title="1.1 定义："></a>1.1 定义：</h3><blockquote><p>线性表的链式存储结构不限制数据元素的物理存储状态，也就是说，其数据元素的物理位置是随机的。</p></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-4.png" alt=""></p><p>对于每一个元素来说，它需要存储自身信息在<strong>数据域</strong>中，还需要存储直接后继的位置信息在<strong>指针域</strong>中，这两部分信息共同构成一个结点（Node）。n 个结点就<br>链结成一个<strong>链表</strong>，如果每一个结点只有一个指针域，那么它就是单链表。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-5.png" alt=""></p><p><strong>头指针</strong>：头指针保存第一个结点（首元结点）的存储位置，因为最后一个结点没有后继结点，所以它的指针域为空(<code>NULL</code> / <code>^</code>)。</p><p><strong>头结点</strong>：有时候，首元结点前还会设置一个头结点，有头结点的时候，头指针保存的是头结点的存储位置。对于头结点，其数据域不一定要包含信息，其指针域则保存的是首元结点的存储位置。如下图所示：</p><p>Tip: 设计头结点是为了操作的统一。</p><p>链表并不是<strong>随机存取结构</strong>，并不能根据一个给定元素就能马上找到另一个目标元素，而是只能从头指针开始顺链查找，这称为<strong>顺序存取结构</strong>。</p><h3 id="1-2-单链表："><a href="#1-2-单链表：" class="headerlink" title="1.2 单链表："></a>1.2 单链表：</h3><p>在开始之前，我们还是先定义单链表中每个结点的结构：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Link<span class="token punctuation">{</span>    <span class="token keyword">char</span> elem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据域</span>    <span class="token keyword">struct</span> Link <span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指针域</span><span class="token punctuation">}</span>link<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// link为结点名，每个结点都是一个 link 结构体</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Tip：因为指针也是指向一个结点，这里尤其要注意将指针类型声明为 <code>struct Link</code></p><p><strong>(1) 初始化空表：</strong></p><pre class="line-numbers language-c"><code class="language-c">link <span class="token operator">*</span> <span class="token function">initLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    link <span class="token operator">*</span> p<span class="token operator">=</span><span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个头结点</span>    link <span class="token operator">*</span> temp<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 声明头指针并指向头结点</span>    temp<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 头结点的指针域置空</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(2) 整表创建：</strong></p><p>例如，创建一个存储 {1,2,3,4} 且无头结点的链表：</p><pre class="line-numbers language-c"><code class="language-c">link <span class="token operator">*</span> <span class="token function">initLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    link <span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建首元结点</span>    link <span class="token operator">*</span> p <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建头指针并指向首元结点</span>    <span class="token comment" spellcheck="true">// 首元节点先初始化</span>    temp<span class="token operator">-></span>elem <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    temp<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从第二个节点开始创建</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 创建一个新节点并初始化</span>        link <span class="token operator">*</span>a<span class="token operator">=</span><span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token operator">-></span>elem<span class="token operator">=</span>i<span class="token punctuation">;</span>        a<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 将temp节点与新建立的a节点建立逻辑关系</span>        temp<span class="token operator">-></span>next<span class="token operator">=</span>a<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 指针temp每次都指向新链表的最后一个节点</span>        temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//返回建立的节点，只返回头指针 p 即可，通过头指针即可找到整个链表</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(3) 查找元素：</strong></p><pre class="line-numbers language-c"><code class="language-c">p 为原链表，elem 表示被查找的元素<span class="token keyword">int</span> <span class="token function">selectElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 新建一个指针，直接指向首元结点</span>    link <span class="token operator">*</span> t <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t <span class="token operator">&amp;&amp;</span> t<span class="token operator">-></span>elem<span class="token operator">!=</span> elem<span class="token punctuation">)</span><span class="token punctuation">{</span>        t<span class="token operator">=</span>t<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为存在头结点，所以这里首先获取首元结点，然后从首元结点开始依次往后面遍历，查找是否有符合的元素。如果查找成功，返回的 p 是元素的地址，查找失败则返回 NULL。</p><p><strong>(4) 修改元素：</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// add 表示更改结点在链表中的位置，newElem 为新的数据域的值</span>link <span class="token operator">*</span><span class="token function">amendElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">,</span><span class="token keyword">int</span> newElem<span class="token punctuation">)</span><span class="token punctuation">{</span>    link <span class="token operator">*</span> temp<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历到被删除结点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>add<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    temp<span class="token operator">-></span>elem<span class="token operator">=</span>newElem<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(5) 删除元素：</strong><br>包括两步，一个是摘除结点并改变连接，一个是释放被摘除结点的内存。关键代码是：</p><pre class="line-numbers language-c"><code class="language-c">temp<span class="token operator">-></span>next<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-6.png" alt=""></p><p>具体实现代码是：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//p为原链表，add为要删除元素的值</span>link <span class="token operator">*</span> <span class="token function">delElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// temp 首先指向首元结点</span>    link <span class="token operator">*</span> temp<span class="token operator">=</span>p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 先寻找被删除结点的上一个结点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>add<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    link <span class="token operator">*</span> del<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 单独设置一个指针指向被删除结点，后面方便释放其内存</span>    temp<span class="token operator">-></span>next<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 手动释放该结点，防止内存泄漏</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这是没有头结点的情况，如果有头结点，循环判断应该是 i&lt;add，因为这时候的 temp 指向的是头结点。</p><p><strong>(6) 插入元素：</strong><br>包括两步，一个是将插入位置后的结点作为新结点的 next，一个是将新结点作为插入位置前的结点的 next，也就是关键代码：</p><pre class="line-numbers language-c"><code class="language-c">new<span class="token operator">-></span>next<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>temp<span class="token operator">-></span>next<span class="token operator">=</span>new<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-7.png" alt=""></p><p>注意：这里顺序不能颠倒，如果是先确定插入位置前结点和新结点的连接，那么插入位置后结点将无法获取，因为其获取是依赖于插入位置前结点的next的，而这个next已经被覆盖。</p><p>具体代码为：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// p为原链表，elem表示新数据元素，add表示新元素插入的位置</span>link <span class="token operator">*</span> <span class="token function">insertElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{</span>    link <span class="token operator">*</span> temp<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建指向头结点的指针</span>    <span class="token comment" spellcheck="true">// 遍历寻找插入位置前的结点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>add<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"插入位置无效\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 创建新结点并初始化</span>    link <span class="token operator">*</span> c<span class="token operator">=</span><span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token operator">-></span>elem<span class="token operator">=</span>elem<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 改变连接关系</span>    c<span class="token operator">-></span>next<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    temp<span class="token operator">-></span>next<span class="token operator">=</span>c<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>if 语句用来判断 add 是否合法，因为如果 add 过大，那么一直遍历下去会得到一个 next 为 NULL 的temp，之后报错。</p><h3 id="1-3-循环链表："><a href="#1-3-循环链表：" class="headerlink" title="1.3 循环链表："></a>1.3 循环链表：</h3><p>当单链表中最后一个结点的指针域不为空，而是<strong>指向头结点</strong>的时候，就形成一个环，这叫循环链表。循环链表进行元素遍历的时候，循环终止条件不再是 <code>p-&gt;next=NULL</code>，而是 <code>p-&gt;next=L</code>。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-8.png" alt=""></p><p>如果使用尾指针，那么可以用O(1)的时间找到尾结点和首元结点，而且可以简化合并两个循环链表的过程：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-9.png" alt=""></p><p>对于上面这两个循环链表，合并的思路大概是：A表尾连B表头。所以这里要改变 rearA-&gt;next，事先要先保存一开始的 rearA-&gt;next，即A表的头结点，之后将B表的首元结点给 rearA-&gt;next；之后我们要将一开始保留的A表头结点作为 rearB-&gt;next，事先要先保存一开始的 rearA-&gt;next，即B表的头结点，方便最后释放内存。</p><p>用图片表示的思路是：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-10.png" alt=""></p><p>用代码表示的思路是：</p><pre class="line-numbers language-c"><code class="language-c">p<span class="token operator">=</span>rearA<span class="token operator">-></span>next<span class="token punctuation">;</span>rearA<span class="token operator">-></span>next<span class="token operator">=</span>rearB<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>reerB<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-双向链表"><a href="#1-4-双向链表" class="headerlink" title="1.4 双向链表"></a>1.4 双向链表</h3><p>单链表的每一个结点中，额外多出一个指向前驱结点的指针域，这时候就成了双向链表。双向链表的尾结点指针域指向头结点时，就成了双向循环链表，如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-11.png" alt=""></p><p><strong>插入操作</strong></p><p>插入操作一定要注意顺序，我们可以先处理新结点的前驱和后继，之后再依次处理后结点、前结点。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-12.png" alt=""></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 新结点的前驱后继</span>s<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 后结点</span>p<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 前结点</span>p<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除操作</strong></p><p>删除很简单，如下图把中间的p删除，那么对于后结点，我们要修复它的前驱指针；对于前结点，我们要修复它的后继指针，最后一步是释放被删除结点的内存</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-13.png" alt=""></p><pre class="line-numbers language-c"><code class="language-c">p<span class="token operator">-></span>prior<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>p<span class="token operator">-></span>next<span class="token operator">-</span>prior <span class="token operator">=</span> p<span class="token operator">-></span>prior<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Data Structures/Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法笔记 cp2-1：线性表</title>
      <link href="/2019/09/22/CB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2-1/"/>
      <url>/2019/09/22/CB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2-1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-0.jpg" alt=""><br><a id="more"></a></p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="1-1-定义："><a href="#1-1-定义：" class="headerlink" title="1.1 定义："></a>1.1 定义：</h3><p>List，由<strong>零个或多个</strong>数据特性相同的元素构成的<strong>有限</strong>序列。个数 n 称为线性表的长度，n=0 的时候称为空表。比如说，十二星座就是一个线性表，它的“第一个”和“最后一个”元素都是唯一的，并且中间的元素均只有一个前驱、一个后继。</p><h3 id="1-2-抽象数据类型"><a href="#1-2-抽象数据类型" class="headerlink" title="1.2 抽象数据类型"></a>1.2 抽象数据类型</h3><pre class="line-numbers language-c"><code class="language-c">ADT List<span class="token punctuation">{</span>    Data<span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    Operation<span class="token punctuation">:</span>        <span class="token function">InitList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span> 初始化，建立一个空的线性表L        <span class="token function">ClearList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span> 清空线性表L        <span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">:</span> 将L中第i个位置元素值返回给e        <span class="token function">LocateElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">:</span> 在L中查找与e相等的元素        <span class="token function">ListInsert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">:</span> 在L中第i个位置插入新元素e        <span class="token function">ListDelete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">:</span> 删除L中第i个位置元素，并用e返回其值        <span class="token function">ListLength</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span> 返回L长度<span class="token punctuation">}</span> ADT List<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线性表的顺序存储结构-顺序表"><a href="#线性表的顺序存储结构-顺序表" class="headerlink" title="线性表的顺序存储结构 / 顺序表"></a>线性表的顺序存储结构 / 顺序表</h2><h3 id="2-1-定义："><a href="#2-1-定义：" class="headerlink" title="2.1 定义："></a>2.1 定义：</h3><blockquote><p>指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-2.jpg" alt=""></p><p>各个元素的地址之间构成等差数列，因此，知道了某一个元素的地址，就可以随时推导出其它元素的地址，也就是说不管取出还是存入哪一个元素，花费的时间都一样，是一个常数(O(1))，这种特性的存储结构就叫<strong>随机存取结构</strong>。</p><p>一维数组可以实现线性表的顺序存储结构，不过要注意数组下标从0开始，而说线性表的时候说的是位序，是从1开始的。</p><h3 id="2-2-基本操作"><a href="#2-2-基本操作" class="headerlink" title="2.2 基本操作"></a>2.2 基本操作</h3><p><strong>(1) 初始化：</strong></p><p>首先定义线性表顺序存储结构：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Table<span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//声明了一个名为head的长度不确定的数组，也叫“动态数组”</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录当前顺序表的长度</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录顺序表分配的存储容量</span><span class="token punctuation">}</span>table<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个操作是初始化，包括：给head申请足够大小的物理空间；给size和length赋初值：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> Size 5 </span><span class="token comment" spellcheck="true">//对Size进行宏定义，表示顺序表申请空间的大小</span>table <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    table t<span class="token punctuation">;</span>    t<span class="token punctuation">.</span>head<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>Size<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//构造一个空的顺序表，动态申请存储空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果申请失败，作出提示并直接退出程序</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    t<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//空表的长度初始化为0</span>    t<span class="token punctuation">.</span>size<span class="token operator">=</span>Size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//空表的初始存储空间为Size</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(2) 取值：</strong><br>找某一个位序的元素，只需要判断位序的合法性，之后返回数组[位序-1]即可。</p><p><strong>(3) 查找/修改：</strong><br>遍历数组元素，与目标元素比较，相等则返回。如果要修改，重新赋值即可。</p><p><strong>(4) 删除：</strong><br>找到目标元素，让后续元素整体前移一个位置，之后长度减一即可。</p><pre class="line-numbers language-c"><code class="language-c">table <span class="token function">delTable</span><span class="token punctuation">(</span>table t<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>add<span class="token operator">></span>t<span class="token punctuation">.</span>length <span class="token operator">||</span> add<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"被删除元素的位置有误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除操作</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>add<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    t<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如说要删除5个元素中的第三个，那么 <code>add</code> 就是 3，而 <code>t.head[3]</code> 就是第四个元素，从这个元素开始依次向前移动并覆盖前面的元素。</p><p><strong>(5) 插入：</strong><br>找到目标位置，将该位置对应元素以及后续元素整体后移一个位置，之后长度加一即可。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置</span>table <span class="token function">addTable</span><span class="token punctuation">(</span>table t<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//判断插入本身是否存在问题</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>add<span class="token operator">></span>t<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token operator">||</span>add<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"插入位置有问题"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//线性表长度等于数组长度，没有多余空间容纳新插入的元素，此时需要申请</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>length<span class="token operator">==</span>t<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span>head<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>head<span class="token punctuation">,</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>size<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"存储分配失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        t<span class="token punctuation">.</span>size<span class="token operator">+</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>t<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">>=</span>add<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>add<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>elem<span class="token punctuation">;</span>    t<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-3.jpg" alt=""></p><ul><li>首先要注意范围的判断，add 作为目标位置，至少也得等于1，此时是插在最前面；同时，add 可以等于 length+1，此时是插在最后面，但不能比 length+1 更大了，否则会出现空隙。</li><li>接着要注意是从后往前遍历的，因为如果是从前往后的话就会发生覆盖。</li><li>可以不做“目标位置是否在表尾”的判断，这样会直接绕过for循环，执行赋值。</li></ul><p>这里可以发现，线性表的插入和删除元素操作往往需要移动大量的元素。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Data Structures/Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「译」提升 Web 开发效率的 VS Code 扩展</title>
      <link href="/2019/09/21/Trs-%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84vs%20code%20%E6%89%A9%E5%B1%95/"/>
      <url>/2019/09/21/Trs-%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84vs%20code%20%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="https://medium.com/better-programming/vs-code-extension-for-web-dev-productivity-fa541654161f" target="_blank" rel="noopener">VS Code Extensions For Web Dev Productivity</a></li><li>原文作者：Deepak Gupta</li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-1.png" alt=""></p><p>在我们开始之前，先看看你能否回答这个问题：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual studio Code</a> 和 <a href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener">Visual Studio</a> 的区别是什么？</p><p>怕有人不知道，我还是简单说明一下。Visual Studio 是一个功能全面且便捷的集成开发环境，而 VS Code 则是一个开源、跨平台的源码编辑器，在 web 开发群体中尤其出名。它不仅快速、可扩展、可自定义，而且还有大量功能。</p><p>我已经使用 VS Code 很久了，作为一名全栈开发者，我也尝试过各种扩展。本文将介绍一些对我的开发工作起到很大帮助的扩展，希望能对你有所帮助。</p><h1 id="让代码易于阅读和维护"><a href="#让代码易于阅读和维护" class="headerlink" title="让代码易于阅读和维护"></a>让代码易于阅读和维护</h1><p><a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2" target="_blank" rel="noopener"><strong>Bracket Pair Colorizer 2</strong></a>：可以让配对的括号显示相同的颜色。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-2.png" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow" target="_blank" rel="noopener"><strong>Indent Rainbow</strong></a>：为文本前面的缩进着色，每一个缩进都有 4 种可选颜色。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-3.png" alt=""></p><p>使用上面两个扩展后，你的编辑器就会铺满各种颜色，这可以让代码块更容易阅读，同时起到护目的效果。一旦你习惯了它们，VS Code 就不再平淡无奇了。</p><p><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag" target="_blank" rel="noopener"><strong>AutoClose Tag</strong></a> 和 <a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag" target="_blank" rel="noopener"><strong>Auto Rename Tag</strong></a>：手动输入标签对每一个 web 开发者来说都是一件痛苦的事情。我们需要一个可以快速简便生成标签以及子标签的工具。</p><p>AutoClose 可以在你输入开始标签的时候生成闭合标签。Auto Rename 则可以在你修改一半标签时，自动同步修改另一半标签。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-4.gif" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-5.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=SirTori.indenticator" target="_blank" rel="noopener"><strong>Indenticator</strong></a>： 高亮当前的缩进位置，当代码很长时可以派上用场。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-6.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=vscode-icons-team.vscode-icons" target="_blank" rel="noopener"><strong>VS Code Icons</strong></a>： 提供文件图标，可以提高编辑器的颜值</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-33.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=dracula-theme.theme-dracula" target="_blank" rel="noopener"><strong>Dracula</strong></a>：这是一直以来钟爱的一个主题</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-8.png" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener"><strong>Prettier</strong></a>：通过解析代码并根据自己的规则重新打印，从而实现一致的代码风格。Prettier 考虑了最大行长，并可以在必要的时候进行换行。尝试自己安装一下并领略它的魅力。</p><p><a href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" target="_blank" rel="noopener"><strong>Path Intellisense</strong></a>：这是最佳的自动补齐文件名的扩展</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-9.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener"><strong>ESlint</strong></a> 或者 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-tslint-plugin" target="_blank" rel="noopener"><strong>TSlint</strong></a>：想要让代码保持一致并且避免 bug，这些代码检查工具是必不可少的。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-10.png" alt=""></p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p><a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker" target="_blank" rel="noopener"><strong>Code Spell Checker</strong></a>：一个可以搭配驼峰式代码使用的拼写检查扩展。高度推荐。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-11.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker" target="_blank" rel="noopener"><strong>Change-case</strong></a>：改变当前所选词的大小写。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-12.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=chrmarti.regex" target="_blank" rel="noopener"><strong>Pegex Previewer</strong></a>：在并排的文档中高亮当前正则表达式的匹配项，通常用于添加验证检查。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-13.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=ryu1kn.partial-diff" target="_blank" rel="noopener"><strong>Partial Diff</strong></a>：可以让你比较一个文件中、文件之间或者剪贴板上的 <code>diff</code> 文本段。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-14.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=yassh.copy-with-line-numbers" target="_blank" rel="noopener"><strong>Copy With Line Number</strong></a>：复制选中的行以及行号和文件路径。这在协同编程以及向同事求助时很有用，可以让他们快速定位到代码位置。当然，对于编写文档也是很有帮助的。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-15.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image" target="_blank" rel="noopener"><strong>Paste Image</strong></a>：直接从剪贴板上粘贴图片到 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>，<a href="http://asciidoc.org/" target="_blank" rel="noopener">AsciiDoc</a> 或者其它文件。我习惯在 Git <code>README</code> 文件或者 Markdown 文档中使用这个扩展。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-16.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=andi1984.tinypng" target="_blank" rel="noopener"><strong>TinyPNG</strong></a><strong>:</strong> 可以无损压缩 jpg 和 png 图片文件</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-17.png" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=pnp.polacode" target="_blank" rel="noopener"><strong>Polacode</strong></a><strong>:</strong> 可以为你的代码块创建好看的截图。只需要安装扩展并启动，之后复制粘贴代码到 Polacode 即可。接着你就可以下载这个截图了。我很喜欢这个扩展。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-18.gif" alt=""></p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p><a href="https://marketplace.visualstudio.com/items?itemName=ChakrounAnas.turbo-console-log" target="_blank" rel="noopener"><strong>Turbo Console.log</strong></a><strong>:</strong> 这个扩展可以自动编写 log 信息打印语句，从而让调试更加简单。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-19.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome" target="_blank" rel="noopener"><strong>Debugger for Chrome</strong></a><strong>:</strong> 可以在 Chrome 浏览器中对 JavaScript 代码进行调试</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-32.png" alt=""></p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p><a href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens" target="_blank" rel="noopener"><strong>Git Lens</strong></a><strong>:</strong> GitLens 增强了内置的 Git，它包含了大量功能，例如通过 code lens 展示的 authorship，提交检索、历史记录以及 Gitlens 浏览器等。如果你进行的工作与 Git 相关，那么这个插件必不可少。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-21.gif" alt=""></p><p>和 GitLens 类似的扩展：</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory" target="_blank" rel="noopener">Git History</a>: 将提交历史等记录以漂亮的图表展示出来。</li><li><a href="https://marketplace.visualstudio.com/items?itemName=micnil.vscode-checkpoints" target="_blank" rel="noopener">Checkpoints</a>: 在各个提交之间保留正在进行的工作的本地短期历史纪录。</li><li><a href="https://marketplace.visualstudio.com/items?itemName=waderyan.gitblame" target="_blank" rel="noopener">Git Blame</a>: 可以在状态栏显示当前选中行的 Git Blame 信息。GitLens 也提供了类似的功能。</li><li><a href="https://marketplace.visualstudio.com/items?itemName=lamartire.git-indicators" target="_blank" rel="noopener">Git Indicators</a>: 可以在状态栏查看受影响的文件以及新增或者删减的行数。</li><li><a href="https://marketplace.visualstudio.com/items?itemName=ziyasal.vscode-open-in-github" target="_blank" rel="noopener">Open in GitHub/Bitbucket/Gitlab/VisualStudio.com</a>: 可以用单命令在浏览器中开启仓库。</li></ul><p><a href="https://marketplace.visualstudio.com/items?itemName=pflannery.vscode-versionlens" target="_blank" rel="noopener"><strong>Version Lens</strong></a><strong>:</strong> 在 <a href="https://github.com/microsoft/vscode" target="_blank" rel="noopener">Visual Studio Code</a> 编辑器中展示 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>， <a href="https://www.npmjs.com/package/jspm" target="_blank" rel="noopener">jspm</a>， <a href="https://code.dlang.org/" target="_blank" rel="noopener">DUB</a> 以及 <a href="https://dotnet.microsoft.com/download/dotnet-core" target="_blank" rel="noopener">Dotnet Core</a> 中安装包的版本信息。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-22.gif" alt=""></p><h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p><a href="https://marketplace.visualstudio.com/items?itemName=mdickin.markdown-shortcuts" target="_blank" rel="noopener"><strong>Markdown Shortcuts</strong></a><strong>:</strong> 快捷编写 Markdown.我一般用它来写 <code>README</code> 文件。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-23.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced" target="_blank" rel="noopener"><strong>Markdown Preview Enhanced</strong></a><strong>:</strong> 这个动态的预览扩展可以让你一边编写 markdown 文件，一边预览效果。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-24.png" alt=""></p><h1 id="衡量开发效率"><a href="#衡量开发效率" class="headerlink" title="衡量开发效率"></a>衡量开发效率</h1><p><a href="https://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatime" target="_blank" rel="noopener"><strong>WakaTime</strong></a> 或者 <a href="https://marketplace.visualstudio.com/items?itemName=softwaredotcom.swdc-vscode" target="_blank" rel="noopener"><strong>Code Time</strong></a><strong>:</strong> 通过编程活动自动生成的指标、统计以及时间追踪。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-25.png" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-26.gif" alt=""></p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p><a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener"><strong>Settings Sync</strong></a><strong>:</strong> 可以将你的 VS Code 配置同步到 Github 上，包括基础设置、热键和 VS Code 扩展。此后可以在任何打算用来编程的设备上将这些配置进行同步，而不需要在一台新设备的原生 VS Code 环境中进行编程，也不需要再重复配置。</p><p><a href="https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager" target="_blank" rel="noopener"><strong>Project Manager</strong></a><strong>:</strong> 可以直接在 VS Code 中打开指向某个 Git 仓库的新窗口。基本上，你现在可以在不离开 VS Code 界面的情况下打开任意一个仓库。</p><p><a href="https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode" target="_blank" rel="noopener"><strong>Quokka.js</strong></a><strong>:</strong> 在输入代码的时候即时运行代码，同时在编辑器中显示不同的执行结果。你可以自己尝试一下。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-27.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight" target="_blank" rel="noopener"><strong>TODO Highlighter</strong></a><strong>:</strong> 在将代码发布到生产环境之前，你可能会忘记 review 一下之前写的 TODOs。之前我一直都希望有一个扩展可以将这些 TODOs 高亮，并且提醒我还有一些未完成的工作。</p><p><a href="https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost" target="_blank" rel="noopener"><strong>Import Cost</strong></a><strong>:</strong> 这个扩展可以用在行内展示导入包的大小，它利用带有 <a href="https://www.npmjs.com/package/babili-webpack-plugin" target="_blank" rel="noopener">babili-webpack-plugin</a> 的 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> 来检测大小。</p><p><a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" target="_blank" rel="noopener"><strong>REST Client</strong></a><strong>:</strong> REST Client 允许你发送 HTTP 请求并在编辑器中直接查看响应结果。</p><p><a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer" target="_blank" rel="noopener"><strong>Live Server</strong></a><strong>:</strong> 开启一个本地服务器，可以为静态或者动态页面提供实时刷新功能。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-28.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener"><strong>Code Runner</strong></a><strong>:</strong> 在 VS Code 中运行代码，支持大部分编程语言。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-29.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare" target="_blank" rel="noopener"><strong>Live Share</strong></a><strong>:</strong> 允许你实时共享工作空间：实时编辑、固定并跟随用户指针、联合调试以及其它。这对远程工作或者异地协同工作很有用。</p><p><a href="https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype" target="_blank" rel="noopener"><strong>JSON to code</strong></a><strong>:</strong> 只需要一个命令就可以将 JSON 转换为可用于强类型语言的接口。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-30.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh" target="_blank" rel="noopener"><strong>Remote SSH</strong></a><strong>:</strong> 可以使用任何带有 SSH 服务器的远程计算机作为开发环境，从而在各种情况下极大地简化开发和故障排查的过程。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95/%E6%8F%90%E5%8D%87%20Web%20%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%20VS%20Code%20%E6%89%A9%E5%B1%95-31.gif" alt=""></p><p><a href="https://marketplace.visualstudio.com/items?itemName=EQuimper.react-native-react-redux" target="_blank" rel="noopener"><strong>React Native/React/Redux snippets for es6/es7</strong></a><strong>:</strong> 如果你使用 <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a> 、 <a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">React Native</a> 或者 JavaScript，那么这个扩展很有用。</p><p>我的工作决定我用哪些扩展，所以有的时候我会选择性地开启或者关闭一些扩展，从而节省内存使用量。</p><p>注意： 此外还有用于其它开发的各种扩展: HTML，CSS，React，React Native，<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node</a>，Python 等。每一个都有自己对应的扩展。你可以在 <a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">Visual Studio Marketplace</a> 查找各种相关扩展。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统cp2：定点数的表示和运算</title>
      <link href="/2019/09/20/CB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2/"/>
      <url>/2019/09/20/CB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-0.jpg" alt=""><br><a id="more"></a><br>在<a href="https://chorer.github.io/2019/09/16/CB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1/">深入理解计算机系统cp1：存储单位、数制、编码</a>中解释了字符编码，我们知道了计算机是怎么把字符转化为二进制的；本文将解释数字编码，介绍计算机如何把数字转化为二进制，以及相关的运算问题。</p><h1 id="1-定点数的表示"><a href="#1-定点数的表示" class="headerlink" title="1.定点数的表示"></a>1.定点数的表示</h1><h2 id="1-1-无符号数"><a href="#1-1-无符号数" class="headerlink" title="1.1 无符号数"></a>1.1 无符号数</h2><ul><li>定义：无符号数就是没有体现正负号的数（这意味着所有的无符号数实际上都是正数），整个机器字长的全部二进制位均为数值位，没有符号位。以<code>108D</code>为例，它对应的二进制数是 <code>1101100</code>，这实际上也就是它的无符号数，可以看到所有的位都是数值位。</li><li>表示范围：以八位二进制数为准，范围就是 <code>00000000</code> 到 <code>11111111</code>，也就是 0 到 255</li></ul><h2 id="1-2-有符号数"><a href="#1-2-有符号数" class="headerlink" title="1.2 有符号数"></a>1.2 有符号数</h2><ul><li><p>定义：有符号数就是有体现正负号的数，整个机器字长的全部二进制位中，最高位作为符号位，0 表示正数，1 表示负数，其余位则是数值位。依然以<code>108D</code>为例，它对应的二进制数是 <code>1101100</code>，而对应的有符号数则要在最前面加上符号位 0，即它的有符号数是 <code>01101100</code>.</p></li><li><p>表示范围：以八位二进制数为准，范围应该是从负数到正数，即从 <code>11111111</code> 到 <code>01111111</code>，也就是 -127 到 127</p></li></ul><h3 id="1-2-1-真值和机器数"><a href="#1-2-1-真值和机器数" class="headerlink" title="1.2.1.真值和机器数"></a>1.2.1.真值和机器数</h3><ul><li>真值：就是带有正负号的实际十进制数，比如上面例子中，<code>+108D</code>就是真值</li><li>机器数：机器数就是一个数在计算机中的二进制表示形式，注意<strong>机器数是由符号位和数值位</strong>构成的，比如上面例子中，<code>01101100</code> 就是机器数。</li></ul><p><code>-156D</code>（真值）= <code>110011100B</code>(机器数)</p><h3 id="1-2-2-原码、反码、补码和移码"><a href="#1-2-2-原码、反码、补码和移码" class="headerlink" title="1.2.2.原码、反码、补码和移码"></a>1.2.2.原码、反码、补码和移码</h3><h4 id="1-原码表示法"><a href="#1-原码表示法" class="headerlink" title="(1)原码表示法"></a>(1)原码表示法</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-1.png" alt=""></p><p>简单点理解，原码就是符号位加上真值（二进制）的绝对值，同时用逗号将符号位和数值位隔开。比如，+1 就是 <code>0,0000001</code>，-1 就是 <code>1,0000001</code>。</p><p>原码的特点是简单、直观，但是原码在进行加法运算的时候会出现问题。正数加正数或者负数加负数是正常的，但是正数加负数就会出错。比如我们现在想要计算 -1+3，我们心想：-1 是 <code>10000001</code>，+3 是 <code>00000011</code>，加起来得到的是 <code>10000100</code>，所以结果是 -4，但 -1+3 应该是等于 2，所以这个结果是错的。我们发现，本来应该做的是加法运算，但实际上变成了减法运算（-1-3=-4）。</p><p>我们首先想到，可以通过将“正数加负数”转化为“正数减正数”来手动纠正这个错误。上面的例子就变成 <code>00000011</code> 减 <code>00000001</code>，结果是 <code>00000010</code>，也就是 2，这个结果是正确的。</p><p>但是每次都这样手动转化，计算起来还是太麻烦了。于是我们接着想：有没有一种方法，可以让“正数加负数”中的<strong>负数等价于一个正数</strong>，从而确保始终进行的是相加操作呢？</p><p>于是这时候就引出了补码的概念。</p><h4 id="2-补码表示法"><a href="#2-补码表示法" class="headerlink" title="(2)补码表示法"></a>(2)补码表示法</h4><ul><li><p>补数和模：理解补码之前，我们先来理解两个概念：<strong>补数</strong>和<strong>模</strong>。<br>拿时钟举例，想要从10点拨到8点，有两种做法，一种是逆时针拨2个单位，记作-2；一种是顺时针拨10个单位，记作+10，这两种操作是等效的(有点<strong>负数等价于一个正数</strong>的意思)。这时候我们就说，-2 是 +10 以 12 为模的补数，记作<code>-2≡+10(mod 12)</code>，同理，-5 相当于 +7，-4 相当于 +8。</p></li><li><p>那么怎么基于补数和模的概念将“正数加负数”转化为“正数加正数” —— 即怎么令<strong>负数等价于一个正数</strong>呢？假设我们现在有一个寄存器可以存放四位二进制数（此时，模为16），我们想要让 <code>1011</code> 变成 <code>0000</code>，最容易想到的办法就是 <code>1011-1011=0000</code>，注意这里是正数加负数。想要变成正数加正数，就要找到等价于 <code>-1011</code> 的正数，<code>-1011</code> 就是 -11，-11 以 16 为模的补数就是 +5，+5 就是 <code>+0101</code>，这个正是我们要找的那个等价正数，因此这时候，<code>1011-1011</code> 变成了 <code>1011+0101</code>，其结果是 <code>10000</code>，不要忘了寄存器只能存放四位，所以结果其实是 <code>0000</code>，恰好与我们“正数加负数”时得到的结果无异。</p></li><li><p>接着引入补码的概念：</p><ul><li>对于正数：正数的补码和原码相同；</li><li>对于负数：负数的补码等于其原码在保持符号位不变的情况下，其余各位取反，末位加一（取反加一）。<strong>注意</strong>，补码的补码等于原码，这可以用来根据补码求原码。</li><li>也可以用下图方法计算补码：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-2.png" alt=""></li></ul></li></ul><p>还是上面的例子，<code>1011-1011</code>，也就是11-11，我们考虑+11和-11，+11的原码=补码=<code>01011</code>，-11的原码是<code>11011</code>，因此补码是<code>10101</code>，那么<code>01011+10101</code>就会等于<code>100000</code>，因为寄存器是五位的，把前面的1去掉，那么结果就是<code>00000</code>，也就是0，和上面的运算结果一致。</p><h4 id="3-反码表示法"><a href="#3-反码表示法" class="headerlink" title="(3)反码表示法"></a>(3)反码表示法</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-3.png" alt=""></p><p>反码很好理解：</p><ul><li>正数：反码等于原码等于补码；</li><li>负数：反码等于原码保持符号位不变的情况下其余各位取反。也就是说，补码=反码+1</li><li>反码的反码等于原码，这可以用来根据反码求原码。</li></ul><h4 id="4-移码表示法"><a href="#4-移码表示法" class="headerlink" title="(4)移码表示法"></a>(4)移码表示法</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-4.png" alt=""></p><p>补码存在的问题是，仅从补码本身来看，很难比较两个数的大小，为此引入了移码的概念。移码指的是在真值（二进制）的基础上加上一个偏移量，通常这个偏移量是2^n。其中，n是数值位的位数。例如，对于<code>-10101</code>，其移码是<code>2^7+(-10101)=10000000+(010101)=0,1101011</code>。<br>当然，我们有简单的方法可以计算一个数的移码：不管正数还是负数，其移码都等于补码的符号位取反。</p><h1 id="2-定点数的加减运算"><a href="#2-定点数的加减运算" class="headerlink" title="2.定点数的加减运算"></a>2.定点数的加减运算</h1><h2 id="2-1-补码的加减运算"><a href="#2-1-补码的加减运算" class="headerlink" title="2.1 补码的加减运算"></a>2.1 补码的加减运算</h2><p>定点数的加减运算实际上就是补码的加减运算。我们来看一个例子：</p><blockquote><p>假设机器字长为 8 位（含1位符号位），A=15，B=-24，现在求 A+B 和 A-B。</p></blockquote><p>A 的补码是 <code>0,0001111</code>，B 的补码是 <code>1,1101000</code>，那么 <code>0,0001111+1,1101000=1,1110111</code>，转化为原码，再转化为真值，得到 -9，这是正确的。同理，A-B 就是 A+(-B)，-B 的补码是 <code>0,0011000</code>，那么 <code>0,0001111+0,0011000=0,0100111</code>，最后转化为真值，得到 +39，这也是正确的。<br>我们再来看另一个例子：</p><blockquote><p>假设机器字长为 8 位（含1位符号位），A=15，B=-24，C=124，现在求 A+C 和 B-C。</p></blockquote><p>我们同样按照上面的流程来进行计算，最后得出：A+C 结果是 -117，B-C 结果是 +108，这两个都是错误的。为什么会出现这样的情况呢？</p><h2 id="2-2-溢出"><a href="#2-2-溢出" class="headerlink" title="2.2 溢出"></a>2.2 溢出</h2><p>这种情况就叫<strong>溢出</strong>。出现的原因，简单来说就是：运算结果太大了，或者运算结果太小了。就上面的题而言，8 位二进制数所能表示的数字的范围是有限的，当正数加正数的时候，结果可能过大，超出了最大值，此时称为<strong>上溢</strong>；当负数加负数的时候，结果可能过小，够不到最小值，此时称为<strong>下溢</strong>。如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-5.png" alt=""></p><p>我们拿 3 位二进制数来理解这个问题。假设 3 位二进制数可以表示的范围如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-6.png" alt=""></p><p>现在我们进行 2+2 操作，那么就是 <code>010+010</code>，结果就是 <code>100</code>，这已经超出了正数可以表示的最大范围，也就是发生了上溢。所以此时得到的是 -4，这是一个错误的结果。</p><h2 id="2-3-溢出的判断"><a href="#2-3-溢出的判断" class="headerlink" title="2.3 溢出的判断"></a>2.3 溢出的判断</h2><p>前面说过，溢出的原因要么是运算结果太大，要么是运算结果太小，其实从这句话我们可以看出，<strong>正数和负数相加是不会发生溢出的</strong>，因为其结果必然在可以表示的范围内，唯一可能会发生溢出的情况，要么是正数加正数，要么是负数加负数。那么，如何判断在这两种情况下是否会发生溢出呢？有三个方法：</p><h3 id="1-一位符号位：比较操作数符号位与结果数符号位"><a href="#1-一位符号位：比较操作数符号位与结果数符号位" class="headerlink" title="(1) 一位符号位：比较操作数符号位与结果数符号位"></a>(1) 一位符号位：比较操作数符号位与结果数符号位</h3><p>我们还是拿上面的第二个例子解释：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-7.png" alt=""></p><p>可以看到，A+C 中，两个操作数符号位都是 0，也就是都是正数，但结果数的符号位却是 1 ，也就是负数，那么很明显它发生了上溢；</p><p>同理，B-C 中，两个操作数符号位都是 1，也就是都是负数，但结果数的符号位却是 0，也就是正数，那么很明显它发生了下溢。</p><h3 id="2-一位符号位：看符号位与最高数值位的进位情况"><a href="#2-一位符号位：看符号位与最高数值位的进位情况" class="headerlink" title="(2) 一位符号位：看符号位与最高数值位的进位情况"></a>(2) 一位符号位：看符号位与最高数值位的进位情况</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-8.png" alt=""></p><p>看第一个式子，进行运算的时候，符号位没有产生进位，但是最高数值位向前产生了进位，这时候判断它发生了上溢；<br>看第二个式子，进行运算的时候，最高数值位没有产生进位，但是符号位向前产生了进位，这时候判断它发生了下溢。</p><h3 id="3-两位符号位："><a href="#3-两位符号位：" class="headerlink" title="(3) 两位符号位："></a>(3) 两位符号位：</h3><p>这种方法是将一位符号位改为两位符号位表示：正数符号为 <code>00</code>，负数符号为 <code>11</code>。那么前面的例子就会变为：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-9.png" alt=""></p><p>这时候，计算机<strong>只需要看结果数</strong>就能知道是否发生溢出 —— 只要结果数的两位符号位相异，那么就一定是发生了溢出。<br>同理，我们回过头看第一个没有溢出的例子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2%EF%BC%9A%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-10.png" alt=""></p><p>可以发现两次运算的结果数的两位符号位都是一样的，由此判断这两次运算都没有发生溢出。</p><p>参考：<br><a href="https://www.bilibili.com/video/av66952721" target="_blank" rel="noopener">https://www.bilibili.com/video/av66952721</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Computer System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统cp1：存储单位、数制、编码</title>
      <link href="/2019/09/16/CB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1/"/>
      <url>/2019/09/16/CB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%8E%E7%BC%96%E7%A0%81-1.png" alt=""><br><a id="more"></a></p><h2 id="1-存储单位"><a href="#1-存储单位" class="headerlink" title="1.存储单位"></a>1.存储单位</h2><ul><li>位：即 bit，表示二进制位，要么是 0 ，要么是 1。它是计算机内部数据存储的最小单位。比如 11010100 共有8个二进制位，是一个8位二进制数。</li><li>字节：即 byte，它由8个二进制位构成，即 1byte=8bit，是计算机内部计量的基本单位。一个英文字符占1个字节（8位），一个汉字占2个字节（16位）</li><li>字：即word，它由若干个字节构成，是计算机内部进行数据处理和运算的基本单位。字的总的位数称为字长，不同档次的计算机字长是不一样的，比如32位机，它的1个字由4个字节构成，字长为32位，也就是说其CPU一次操作处理的实际位数是32位。同理，64位机可以处理64位。由此可见，计算机的字长越大，其性能越优越。</li><li>KB，MB：1024byte = 1KB，1024KB = 1MB。往上还有GB，TB。</li></ul><p>PS：数据传输大多以 bit 为单位，比如我们常说的网速100M/s，M/s其实Mbit/s，也就是兆比特每秒，我们还可以写成100Mbps。</p><h2 id="2-数制"><a href="#2-数制" class="headerlink" title="2.数制"></a>2.数制</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>数制也叫进制/进位制，是人们规定的一种进位方法。对于任何一种进制 —— X 进制，就表示某一位置上的数运算时是逢 X 进一位。比如，十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x 进制就是逢 x 进位。</p><h3 id="2-2-常见制和相关概念"><a href="#2-2-常见制和相关概念" class="headerlink" title="2.2 常见制和相关概念"></a>2.2 常见制和相关概念</h3><table><thead><tr><th>进位制</th><th>二进制</th><th>八进制</th><th>十进制</th><th>十六进制</th></tr></thead><tbody><tr><td>进位规则</td><td>逢二进一</td><td>逢八进一</td><td>逢十进一</td><td>逢十六进一</td></tr><tr><td>基数</td><td>2</td><td>8</td><td>10</td><td>16</td></tr><tr><td>数码</td><td>0,1</td><td>0,1…7</td><td>0,1…9</td><td>0,1…9,A…F</td></tr><tr><td>位权</td><td>2^i</td><td>8^i</td><td>10^i</td><td>16^i</td></tr><tr><td>前缀</td><td>0b</td><td>0o</td><td>无</td><td>0x</td></tr><tr><td>后缀</td><td>B</td><td>O</td><td>D</td><td>H</td></tr></tbody></table><p>例如，16进制数101可以表示为101H、(101)下标16，或者0x101。</p><h3 id="2-3-数制之间的对应关系"><a href="#2-3-数制之间的对应关系" class="headerlink" title="2.3 数制之间的对应关系"></a>2.3 数制之间的对应关系</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81-1.png" alt=""></p><h3 id="2-4-数制之间的转换"><a href="#2-4-数制之间的转换" class="headerlink" title="2.4 数制之间的转换"></a>2.4 数制之间的转换</h3><ul><li>x 转十：<br>按权展开求和，比如二进制101对应十进制是1x2²+0x2¹+1x2º</li><li>十转 x：<ul><li>整数部分，除X取余，倒序；</li><li>小数部分，乘X取整，正序。</li></ul></li><li>二转八/十六：<br>以小数点为界，分别向左向右分成三位一组，不够三位补0，分组后对应成八进制数；二转十六同理，只是四位一组。</li><li>八/十六转二：<br>每一位八进制数转化为对应的三位二进制数；十六转二同理，只是四位二进制数。</li></ul><p>PS：八进制和十六进制之间不能直接转换，八进制需要先转成二进制或十进制，在由对应的二进制或十进制转成十六进制，反过来也一样。</p><h2 id="3-编码"><a href="#3-编码" class="headerlink" title="3.编码"></a>3.编码</h2><h3 id="3-1-数字编码"><a href="#3-1-数字编码" class="headerlink" title="3.1 数字编码"></a>3.1 数字编码</h3><p>数字编码在<a href="https://chorer.github.io/2019/09/16/CB-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp2/">深入理解计算机系统cp2：定点数的表示和运算</a>中再进行详细介绍。</p><h3 id="3-2-BCD码"><a href="#3-2-BCD码" class="headerlink" title="3.2 BCD码"></a>3.2 BCD码</h3><h4 id="3-2-1-什么是-BCD码？"><a href="#3-2-1-什么是-BCD码？" class="headerlink" title="3.2.1 什么是 BCD码？"></a>3.2.1 什么是 BCD码？</h4><blockquote><p>用四位二进制数来表示一位十进制数，称为二–十进制编码，简称 BCD（Binary Coded Decimal）码。</p></blockquote><h4 id="3-2-2-为什么需要-BCD码？"><a href="#3-2-2-为什么需要-BCD码？" class="headerlink" title="3.2.2 为什么需要 BCD码？"></a>3.2.2 为什么需要 BCD码？</h4><p>BCD 码其实是为了处理<strong>十进制转化为二进制</strong>的问题而存在的。<br>前面我们介绍了二进制与十进制之间的转换，但这种转换对计算密集型应用友好，对输入/输出密集型应用则不友好 —— 因此设计了 BCD码。拿 8421BCD码 举例，它将 0~9 一一映射为一个四位二进制数，从而做到快捷转换。比如， 321 的 8421BCD码 直接就是 0011 0010 0001，而无需再想之前那样乘2取余的麻烦运算。</p><h4 id="3-2-3-8421BCD码"><a href="#3-2-3-8421BCD码" class="headerlink" title="3.2.3 8421BCD码"></a>3.2.3 8421BCD码</h4><p>BCD码有很多，比如 8421BCD码，余三码等，这里我们只讲第一种。具体的对应关系如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81-2.png" alt=""></p><p>注意：8421BCD码 只有 0000～1001 共十个，而 1010、1011…等等不是8421BCD码。</p><h3 id="3-3-字符编码"><a href="#3-3-字符编码" class="headerlink" title="3.3 字符编码"></a>3.3 字符编码</h3><h4 id="3-3-1-为什么需要字符编码？"><a href="#3-3-1-为什么需要字符编码？" class="headerlink" title="3.3.1 为什么需要字符编码？"></a>3.3.1 为什么需要字符编码？</h4><ul><li>计算机只能理解0和1，无法理解英文、字母、汉字和其他特殊字符，这些字符需要经过编码才能成为计算机可以理解的二进制数。</li><li>由字符到二进制数称为编码，反过来则是解码。</li><li>从字符到二进制数，需要有一个一一对应的映射，这个映射通过编码规则来实现。</li><li>通常所说的编码其实包括编码+字符集（即字符的集合体），比如 Unicode 字符集，就有 UTF-8，UTF-16 等多种编码。</li></ul><h4 id="3-3-2-编码规则的演变"><a href="#3-3-2-编码规则的演变" class="headerlink" title="3.3.2 编码规则的演变"></a>3.3.2 编码规则的演变</h4><ul><li><p><span style="background-color:#fffa7d">ASCII</span>：<br>1) <code>/ˈæski/</code>，即 American Standard Code for Information Interchange，美国信息交换标准代码。本来一个字节有8位，每一位有0和1两种状态，则一个字节共有2^8=256种状态，可以表示256种字符。但是美国佬比较自私，觉得只要可以表示自己的字母和一些特殊字符就足够了，所以 ASCII 没有占用最高位（而是固定为0），实际只用到了后面7位，它可以表示 2^7=128 种状态，也就是表示128个字符。<br>2) 很显然，这用来表示字母是足够的，但要想表示其它语言的字符，128还是太少了。<br>PS：附送 ASCII 对照表一张：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%8E%E7%BC%96%E7%A0%81-2.png" alt=""></p></li><li><p><span style="background-color:#fffa7d">GB2312</span>：<br>1) 既然美国佬只解决了字母和特殊符号的编码问题，那么我们中国人只好实现自己的编码，从而来表示汉字了。所以这时候出现了 GB2312 编码（国标码）。<br>2) 问题：不幸的是，各个国家都是这么想的，所以小日本有了 Shift_JIS 编码，棒子有了 Euc-kr 编码…..一时之间各国都有了自己的标准，那么对于一个多语言混合的文本来说，存在着不同的编码规则，最终必然导致乱码。</p></li><li><p><span style="background-color:#fffa7d">Unicode</span>：<br>1) Unicode 解决了编码统一的问题。每种语言的每个字符在 Unicode 的规则下，都只有统一且唯一的对应二进制编码。它的表示方法是<code>U+[16进制数]</code>。例如，大写字母 A 编码为 <code>U+0041</code>，汉字“严”编码为 <code>U+4E25</code>。<br>2) 问题：Unicode 一般用2个字节（也就是16位）表示一个字符，这在表示 ASCII 字符的时候会出现问题。我们知道，ASCII 字符实际只需要一个字节就够了，并且最高位甚至都还不需要用到，但是 Unicode 又规定表示一个字符至少需要2个字节，那么一个 ASCII 字符前面就必须要补0以满足这个规则，例如字母 A 就需要用 <code>00000000 01000001</code> 表示，这些多余的0是一个极大的资源浪费。</p></li><li><p><span style="background-color:#fffa7d">UTF-8</span>：<br>1) UTF：实际传输过程中，基于不同的系统平台，对 Unicode 会有不不同的实现方式，其实现方式称为 Unicode Transformation Format，即 UTF。<br>2) 作为 Unicode 的一种实现方式，UTF-8 展现了一定的灵活性——它是一种变长编码，会根据具体字符来改变所需要的表示字节。其编码规则只有两条：</p><blockquote><p>i&gt;. 对于 128 个 ASCII 字符只需一个字节表示，字节的第一位补 0，后面 7 位为这个字符的 ASCII 二进制数。Unicode 范围为 U+0000 至U+007F。<br>ii&gt;. 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码二进制数。Unicode 范围由 U+0080 起。</p></blockquote></li></ul><p>也可以看下面这张图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E3%80%81%E6%95%B0%E5%88%B6%E3%80%81%E7%BC%96%E7%A0%81/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9Fcp1%EF%BC%9A%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E4%B8%8E%E7%BC%96%E7%A0%81-3.png" alt=""></p><p>以汉字“严”为例，演示如何实现 UTF-8 编码。<br>“严”的 Unicode 是 <code>U+4E25</code>（二进制数 100111000100101），据表，<code>U+4E25</code> 处在第三行的范围内（<code>U+0800</code> ~ <code>U+FFFF</code>），因此“严”的UTF-8 编码需要三个字节，即格式 <code>1110xxxx 10xxxxxx 10xxxxxx</code>。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的 x，多出的位补 0。这样就得到 UTF-8 编码（二进制）是 <code>11100100 10111000 10100101</code>，转换成十六进制就是 <code>E4B8A5</code>。</p><p>参考：<br><a href="https://segmentfault.com/a/1190000005936800" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005936800</a><br><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Computer System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法笔记cp1：基本概念</title>
      <link href="/2019/09/10/CB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp1/"/>
      <url>/2019/09/10/CB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp1-0.jpg" alt=""><br><a id="more"></a></p><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><h3 id="1-1-基本概念："><a href="#1-1-基本概念：" class="headerlink" title="1.1 基本概念："></a>1.1 基本概念：</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp1-1.png" alt=""></p><ul><li>数据元素：也称为记录，是数据的基本单位。比如把动物看作数据，那么数据元素指的就是牛、羊、马等。</li><li>数据项：这是数据的最小单位，多个数据项构成了一个数据元素。比如把牛看作数据元素，那么数据项指的就是牛的年龄、体态等。</li><li>数据对象：这是数据的子集，表示<strong>性质相同</strong>的数据元素的集合。所谓性质相同，指的是各数据元素之间有相同数目和类型的数据项。</li><li>数据结构：是相互之间存在<strong>一种或多种特定关系</strong>的数据元素的集合。结构，指的就是这些元素互相之间的关系，这是重点。</li></ul><h3 id="1-2-分类："><a href="#1-2-分类：" class="headerlink" title="1.2 分类："></a>1.2 分类：</h3><ul><li>逻辑结构（思路）：<br>从广义上分为线性结构和非线性结构。<ul><li>非线性结构：集合（同在一块）、树（一对多）、图（多对多）；</li><li>线性结构：表、栈、队列、串、数组</li></ul></li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp1-2.jpg" alt=""></p><ul><li>物理/存储结构（实现）：<ul><li>顺序存储结构</li><li>链接存储结构</li><li>索引存储结构</li><li>散列存储结构</li></ul></li></ul><h3 id="1-3-抽象数据类型-ADT"><a href="#1-3-抽象数据类型-ADT" class="headerlink" title="1.3 抽象数据类型 ADT"></a>1.3 抽象数据类型 ADT</h3><p>ADT 即 Abstract data type，抽象数据类型的三个主体是数据对象 + 关系 + 操作。<br>我们可以用下面的格式描述抽象数据类型：</p><pre class="line-numbers language-c"><code class="language-c">ADT 抽象数据类型名<span class="token punctuation">{</span>    数据对象：it is<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    数据关系：they are<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    基本操作：        操作<span class="token number">1</span>：done sth<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          初始条件：<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          操作结果：<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        操作<span class="token number">2</span>：done sth<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          初始条件：<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          操作结果：<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span> ADT 抽象数据类型名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h2><h3 id="2-1-基本特性："><a href="#2-1-基本特性：" class="headerlink" title="2.1 基本特性："></a>2.1 基本特性：</h3><p>有穷性（时间有穷、步骤有穷）、确定性（没有歧义）、可行性、输入、输出</p><h3 id="2-2-优劣标准："><a href="#2-2-优劣标准：" class="headerlink" title="2.2 优劣标准："></a>2.2 优劣标准：</h3><p>正确性（至少可以得到正确结果，对于非法输入也应有提示）、可读性、健壮性、高效性（时间 + 空间）</p><h3 id="2-3-时间复杂度"><a href="#2-3-时间复杂度" class="headerlink" title="2.3 时间复杂度"></a>2.3 时间复杂度</h3><ul><li>一个算法的执行总时间应该等于每条语句执行时间之和，假定执行时间都为单位 1，那么则等于语句总数，同时我们只考虑耗时长的操作语句 —— 即基本操作语句，那么基本操作语句的执行次数（语句频度）就可以在某种关系上反映算法的执行总时间。</li><li>大 O 表示法：<br>给定问题规模 n 以及关于 n 的函数 f(n)，其中，f(n) 代表基本语句执行次数。那么，时间复杂度 <code>T(n) = O(f(n))</code>，它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同。</li><li>大 O 阶推导（分析时间复杂度）：<ul><li>找出<strong>语句频度最高</strong>的基本语句；</li><li>基于该语句的频度推导出对应的 f(n)；</li><li>取 f(n) 的数量级得到最终的 f(n)。这意味着允许我们忽略低次幂和最高次幂的系数。</li></ul></li><li>经过大 O 阶推导，可以得到常数阶、平方阶、对数阶等。<strong>需要注意的是</strong>，当算法可以在常数时间内完成时（与问题规模无关），其时间复杂度依然是常数阶 O(1)。</li></ul><h3 id="2-4-空间复杂度"><a href="#2-4-空间复杂度" class="headerlink" title="2.4 空间复杂度"></a>2.4 空间复杂度</h3><ul><li><p>空间复杂度 <code>S(n)=O(f(n))</code>，其中，n 为问题规模，f(n) 表示关于 n 所占存储空间的函数。</p></li><li><p>若算法执行时所需的辅助空间相对于问题规模来说是一个常数，则称此算法为原地工作，空间复杂度为 O(1)。也就是说，不管我问题规模多大，所需要的辅助空间始终是固定的。比如下面两个算法：</p></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//算法1</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  t <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  a<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//算法2</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于算法1，不管问题规模多大，总是只需要一个临时变量 t 暂存值即可，因此其空间复杂度为 O(1)；对于算法2，采用的是逆序输出原数组到新数组中，之后再覆盖原数组，很显然，随着 n 的增大，新数组要求的存储空间也要增大，所以其空间复杂度为 O(n)。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Data Structures/Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 生命周期与钩子函数</title>
      <link href="/2019/09/08/F-Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/09/08/F-Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-1.jpg" alt=""><br><a id="more"></a></p><h2 id="1-Vue-生命周期"><a href="#1-Vue-生命周期" class="headerlink" title="1.Vue 生命周期"></a>1.Vue 生命周期</h2><blockquote><p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载 dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p></blockquote><h2 id="2-Vue-生命周期函数"><a href="#2-Vue-生命周期函数" class="headerlink" title="2.Vue 生命周期函数"></a>2.Vue 生命周期函数</h2><p>Vue 的生命周期共有 8 个阶段，即<strong>创建前/后, 载入前/后,更新前/后,销毁前/销毁后</strong>，并对应地有很多钩子函数，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p><h2 id="3-Vue-生命周期图"><a href="#3-Vue-生命周期图" class="headerlink" title="3.Vue 生命周期图"></a>3.Vue 生命周期图</h2><p><a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener">Vue 官网图片</a>：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-2.png" alt=""></p><h2 id="4-Vue-生命周期进程"><a href="#4-Vue-生命周期进程" class="headerlink" title="4. Vue 生命周期进程"></a>4. Vue 生命周期进程</h2><p>根据上面的图来分析 Vue 生命周期的进程：</p><p><strong>1.实例化 Vue（组件）对象，确定 this 指向 Vue 实例</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-3.png" alt=""></p><p><strong>2.初始化事件（events）和生命周期（cycle）</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-4.png" alt=""></p><p><strong>3.<span style="color:red">beforeCreate 函数</span></strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-5.png" alt=""><br>这一阶段，虽然 Vue 对象已经创建，但是它的属性还没有绑定，诸如 data、computed 这些属性还没有赋值。所以 $el,$data 以及 message 都是 undefined。</p><p><strong>4.初始化注入和响应</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-6.png" alt=""><br>这一阶段，Vue 对象的属性注入绑定，完成属性赋值。</p><p><strong>5.<span style="color:red">Created 函数</span></strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-7.png" alt=""><br>这一阶段可以访问数据，但是还没有挂载 dom，不能访问到 $el。因为这个原因，此时改变数据不会触发 updated 函数。</p><p><strong>6.两次判断</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-8.png" alt=""><br>这个阶段会进行两次判断：</p><ul><li>判断对象是否有 el 选项<br>如果有则继续向下编译；如果没有则停止编译，也即停止生命周期，直到在实例上再次调用 <code>vm.$mount(el)</code> 才会继续向下编译</li><li>判断 el 是否有 template 模板<br>如果有则将该模板编译为渲染函数，最后渲染出来；如果没有则直接调用 $el 的 <strong>outerHTML</strong> 进行渲染。另外，如果 Vue 对象中有渲染函数（render function），则它会优先于 template 进行渲染。<br>综上，优先级是：render function &gt; template &gt; outerHTML</li></ul><p><strong>7.<span style="color:red">beforeMount 函数</span></strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-9.png" alt=""><br>这个阶段，this.$el 有值，但是数据还没有挂载到页面上，`{{}}` 还没有被替换</p><p><strong>8.用vue对象的数据（属性）替换模板中的内容</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-10.png" alt=""></p><p><strong>9.<span style="color:red">mounted 函数</span></strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-11.png" alt=""><br>模板编译完成，数据挂载完毕，页面上已经能够看到正确的数据了。</p><p><strong>10.<span style="color:red">beforeUpdate 函数</span></strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-12.png" alt=""><br>数据更新后首先触发该函数，但更新的只是数据，innerHTML 尚未更新</p><p><strong>11.虚拟 dom 重新渲染并打补丁</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-13.png" alt=""></p><p><strong>12.<span style="color:red">updated 函数</span></strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-14.png" alt=""><br>这一阶段，innerHTML 已经得到更新。</p><p>PS：这里解释一个问题。在 beforeUpdate 函数中访问 <code>this.$el，innerHTML</code> 时得到的是旧数据，这是正常的;但访问 <code>this.$el</code> 的时候，得到的却是新数据，这是因为：1.console.log 是异步的，我们期望打印的时候是打印那一刻的快照，但实际上它不能做到这一点，所以在后面点击展开 this.$el 的内容时，实际上只能访问到最新更新的对象；2.this.$el 保存的是对象的引用。</p><p><strong>13.<span style="color:red">beforeDestroy 函数</span></strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-15.png" alt=""><br>这一阶段，实例还没有销毁，仍然完全可用</p><p><strong>14.销毁实例</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-16.png" alt=""></p><p><strong>14.<span style="color:red">destroyed 函数</span></strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-17.png" alt=""><br>实例销毁之后调用该函数，使 Vue 实例指示的所有东西解绑定，所有的监听器被移除，所有的子实例销毁。</p><h2 id="5-通过控制台观察生命周期的过程"><a href="#5-通过控制台观察生命周期的过程" class="headerlink" title="5.通过控制台观察生命周期的过程"></a>5.通过控制台观察生命周期的过程</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/vue/2.1.3/vue.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>     <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>    <span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>      message <span class="token punctuation">:</span> <span class="token string">"Vue"</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>  beforeCreate<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'beforeCreate 创建前状态===============》'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span> <span class="token punctuation">,</span> <span class="token string">"el     : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"data   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"message: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>  created<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'created 创建完毕状态===============》'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"el     : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"data   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"message: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>  beforeMount<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'beforeMount 挂载前状态===============》'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"el     : "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"data   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"message: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>  mounted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'mounted 挂载结束状态===============》'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"el     : "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"data   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"message: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>  beforeUpdate<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'beforeUpdate 更新前状态===============》'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"el     : "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"el.outerHTML   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>outerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"data   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"message: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>  updated<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'updated 更新完成状态===============》'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"el     : "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"el.outerHTML   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">.</span>outerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"data   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"message: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>  beforeDestroy<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'beforeDestroy 销毁前状态===============》'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"el     : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"data   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"message: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>  destroyed<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">'destroyed 销毁完成状态===============》'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"el     : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"data   : "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"%c%s"</span><span class="token punctuation">,</span> <span class="token string">"color:red"</span><span class="token punctuation">,</span><span class="token string">"message: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一次渲染，可以在控制台看到：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-18.png" alt=""></p><p>之后手动修改 message 的值为“Vue2”，可以在控制台看到：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-19.png" alt=""></p><p>这里注意之前提到的 log 异步的问题，看 outerHTML 可以知道 beforeUpdate 的时候视图实际上还没有重新渲染。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型判断</title>
      <link href="/2019/08/06/F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
      <url>/2019/08/06/F-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><code>typeof</code></h2><p><code>typeof</code> 操作符返回一个表示数据类型的字符串，它可以应付常规场景下的数据类型判断。对基本数据类型 <code>undefined</code>, <code>boolean</code>, <code>string</code>, <code>number</code> 和引用数据类型 <code>function</code> 都可以正确判断，但是对 null，数组，对象则统一返回 “object”。也就是说，<code>typeof</code> 不适合用来判断引用数据类型。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">typeof</span> a <span class="token comment" spellcheck="true">// "number"</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">typeof</span> b <span class="token comment" spellcheck="true">// "object"</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">typeof</span> c <span class="token comment" spellcheck="true">// "object"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p><code>instanceof</code> 解决了上述问题，它的原理就是判断右操作数（通常是构造函数）的原型对象是否出现在左操作数（通常是实例）的原型链上，如果在则返回 <code>true</code>。据此可以判断引用数据类型具体是哪种类型。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>b <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token comment" spellcheck="true">// true</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>c <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，<code>instanceof</code> 对于不是通过 new 创建的基本数据类型无法做出正确的判断：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Number</span> <span class="token comment" spellcheck="true">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是因为此时的 a 仅仅是一个基本类型的值，而不是实例对象，如果我们通过 new 创建 a，那么就能正确判断</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Number</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结合 <code>instanceof</code> 的原理其实就很好理解其中原因了。</p><p><code>&gt;&gt;</code> 另外要注意，<code>instanceof</code> 这个方法并非百试百灵 —— 假定脚本中有多个全局环境，例如 html 中有多个子 iframe，那么对于每一个全局环境而言，它都有自己版本的构造函数，进而有自己版本的原型链。<code>instanceof</code> 左右两边的操作数来自于不同全局环境时，即使实例和构造函数对应，也只会返回 false。</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a><code>Object.getPrototypeOf()</code></h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用原型链。存在同上问题。</p><h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a><code>isPrototypeOf()</code></h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">===</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用原型链。存在同上问题。</p><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a><code>Object.prototype.toString.call()</code></h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token template-string"><span class="token string">`Object.prototype.toString.call(arr)`</span></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"[object Array]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个方法基本很完善，原理就是：在任何值上调用 <strong>Object 原生的 toString() 方法</strong>，都会返回一个格式为 [object NativeconstructorName] 的字符串。据此可以准确判断任何值的数据类型。</p><p>这里注意几个点：</p><ol><li><p>arr 作为对象，也是 Object 的一个实例，为什么不直接使用 <code>arr.toString()</code>？这是因为它的这个方法被重写了，即 <code>Array.prototype.toString()</code>。在使用 <code>arr.toString()</code> 的时候，它优先在原型链上找到并调用了重写的方法，最后输出的是 <code>&quot;1,2&quot;</code>。</p></li><li><p>对象字面量调用 <code>toString()</code> 的时候则依然输出 <code>&quot;[object Object]&quot;</code>，这是因为它没有重写这个方法，所以找到的是 <code>Object.prototype</code> 的该方法。</p></li><li><p>同样的，函数对象的 <code>toString()</code> 方法也被重写了，即 <code>Function.prototype.toString()</code>。调用的时候返回一个表示当前函数源代码的字符串。当对内置函数对象调用该方法时，返回如下格式的字符串：</p></li></ol><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// "function Object() {</span><span class="token comment" spellcheck="true">//    [native code]</span><span class="token comment" spellcheck="true">// }"</span>Array<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "function Array() { </span><span class="token comment" spellcheck="true">//    [native code] </span><span class="token comment" spellcheck="true">// }"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上，这里的 Object 是构造函数，既然是函数，就可以看作是 Function 构造函数实例化的对象，因此这里相当于函数对象调用了 <code>toString()</code> 方法，也就是调用的 <code>Function.prototype.toString()</code> 方法。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call() 和 apply() 的相关介绍和应用场景</title>
      <link href="/2019/08/05/F-call,apply%E5%92%8Cbind/"/>
      <url>/2019/08/05/F-call,apply%E5%92%8Cbind/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/callapplybind.jpg" alt=""></p><a id="more"></a><h2 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h2><pre class="line-numbers language-js"><code class="language-js">fun<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> <span class="token punctuation">[</span>param1<span class="token punctuation">,</span>param2<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fun<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p><code>call()</code> 和 <code>apply()</code> 返回函数应该返回的值，<code>bind()</code> 返回一个经过硬绑定的新函数。</p><h2 id="参数介绍："><a href="#参数介绍：" class="headerlink" title="参数介绍："></a>参数介绍：</h2><p>第一个参数为 thisArg，其取值有以下几种情况：</p><ul><li><p>不传/ 传null/ 传undefined：非严格模式下，this 指向 window 对象；严格模式下指向 undefined；</p></li><li><p>传递基本类型：this 指向其对应的包装对象，如 String、Number、Boolean</p></li><li><p>传递一个对象：函数中的 this 指向这个对象</p></li></ul><p>第二个参数有以下几种情况：</p><ul><li>不传/ 传null/ 传undefined：表示不需要传入任何参数</li><li><code>call()</code> 和 <code>bind()</code> 的第二个参数都是参数列表，而 <code>apply()</code> 则是参数数组（或者类数组）—— 尽管如此，在这些参数传递给调用函数时，仍然是以参数列表的形式传递的（这一点很重要）。</li></ul><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p><code>call()</code> 和 <code>apply()</code> 一经调用则立即执行函数，而 <code>bind()</code> 则只是完成了函数的 this 绑定。因为函数不会立刻执行，所以适合在事件绑定函数中使用 <code>bind()</code> ，这样既完成了绑定，也确保了<strong>仅当事件触发时</strong>才执行函数。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在<a href="">这篇文章</a>说过，<code>call()</code>，<code>apply()</code> 和 <code>bind()</code> 都可以改变 this 的指向，什么时候需要改变 this 的指向呢？大部分时候其实是为了<strong>借用方法</strong>，即在对象上调用其自身不具备的方法。看一下下面的例子：</p><p><strong>1.判断数据类型</strong><br>利用 <code>Object.prototype.toString.call()</code> 可以准确地判断数据类型，如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"[object String]"</span> <span class="token comment" spellcheck="true">//true</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"[object Array]"</span>  <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原理就是：在任何值上调用 <strong>Object 原生的 toString() 方法</strong>，都会返回一个格式为 [object NativeconstructorName] 的字符串。据此可以准确判断任何值的数据类型。<br>既然 Array 和 Function 都继承了 Object 的该方法，为什么不直接在它们身上调用？这是因为 <code>toString()</code> 被重写过了，<strong>不是原生方法</strong>，因此这里改为调用 Object 的该方法，并将 this 绑定给对应的值。</p><p><strong>2.模拟浅拷贝</strong><br>模拟浅拷贝的过程中，需要剔除原型链上的属性，考虑到源对象可能基于 <code>Object.create()</code> 创建，而这样的对象是没有 <code>hasOwnProperty()</code> 方法的，因此我们不在源对象身上直接调用该方法，而是通过 <code>Object.prototype.hasOwnProperty.call()</code> 的方式去调用，因为 Object 一定是有这个方法的，我们可以借用一下。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>nextSource<span class="token punctuation">,</span> nextKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    to<span class="token punctuation">[</span>nextKey<span class="token punctuation">]</span> <span class="token operator">=</span> nextSource<span class="token punctuation">[</span>nextKey<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>3.继承</strong><br>JavaScript 的几种继承方式中，有一种就是借用构造函数：<br>假设有子构造函数 <code>Son</code> 和父构造函数 <code>Parent</code>。对于 <code>Son</code> 而言，其内部的 this 将指向稍后实例化的对象，利用这一点，我们在 <code>Son</code> 的内部通过 <code>call()</code> 或者 <code>apply()</code> 调用 <code>Parent</code>，同时传参 this，这样就可以增强子类实例。</p><p><strong>4.类数组借用数组的方法</strong><br>例如 arguments 是类数组，并不具备数组的 <code>forEach()</code> 方法，那么我们可以通过 <code>call()</code> 调用数组的该方法，同时将方法里面的 this 绑定到 arguments 上：</p><pre class="line-numbers language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>forEach<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>5.求数组的最值</strong><br>核心是 <code>apply()</code> 可用于展开数组，即我们前面说过的将参数数组转化为参数列表。<br>例如我们要求一个数组的最大值，虽然 Math 对象有 <code>max()</code> 方法，但该方法只接受参数列表。那么这时候，我们可以通过 <code>apply()</code> 去调用该方法，从而展开数组</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>Math<span class="token punctuation">.</span>max<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参考：<br><a href="https://www.cnblogs.com/onepixel/p/6034307.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/p/6034307.html</a><br><a href="https://juejin.im/post/5d469e0851882544b85c32ef" target="_blank" rel="noopener">https://juejin.im/post/5d469e0851882544b85c32ef</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《JavaScript 高级程序设计》阅读笔记 1：最佳实践</title>
      <link href="/2019/08/03/F-JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/08/03/F-JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><blockquote><p>可维护性包括：可理解性、直观性、可适应性、可扩展性和可调试性<br><a id="more"></a></p></blockquote><p><strong>代码约定：</strong></p><ul><li>可读性（缩进、注释）；</li><li>变量和函数命名（有意义的命名）；</li><li>变量类型透明（<code>var a =null</code> <code>var a = iSpeed</code>）</li></ul><p><strong>松散耦合：</strong></p><ul><li>HTML 或者 CSS 与 JavaScript 的解耦（如 CSS 仍然保留样式信息，通过改变类名来改变样式）；</li><li>事件监听器和应用逻辑的解耦（监听器只发挥监听作用，而将应用逻辑独立成可以复用的函数）</li></ul><p><strong>编程实践：</strong></p><ul><li>尊重对象所有权（尽量不要改动原生对象）；</li><li>尽量避免创建全局变量和函数；</li><li>避免与 null 比较</li><li>使用常量</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>优先使用局部变量。根据作用域链查找的原理，访问全局变量速度会较慢</li><li>避免 with 语句。会延长作用域链长度</li><li>避免多次的属性查找。属性查找涉及原型链的追溯，花费时间长</li><li>优化循环：减值迭代、简化终止条件、简化循环体、使用 <code>do...while...</code>、展开循环</li><li>使用数组字面量和对象字面量</li><li>最小化<strong>现场更新</strong>。对于已经加载出来的 dom 的直接操作（现场更新）会影响性能，可以考虑在新建的 <code>fragment</code> 文档片段中进行修改，之后只进行一次现场更新。</li><li><code>innnerHTML</code> 比普通的创建 dom 节点的方法更快</li><li>同胞节点有相同的事件时利用事件委托冒泡给父节点，父节点的事件监听器里结合 switch 进行 <code>event.target</code> 判断</li><li>访问 HTMLCollection 的属性或者方法时，都是在文档上进行查询，这个过程会有性能开销，应该最小化访问 HTMLCollection 的次数。例如可以将 for 循环的终止条件判断保存在一个值里，而不是每次都重新计算一次。</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解析赋值、浅拷贝和深拷贝</title>
      <link href="/2019/07/11/F-%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/07/11/F-%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-1.webp" alt=""></p><a id="more"></a><h2 id="1-相关数据结构"><a href="#1-相关数据结构" class="headerlink" title="1.相关数据结构"></a>1.相关数据结构</h2><p>堆（stack）和栈（heap）都是内存中划分出来用来存储的区域。</p><ul><li><p>栈数据结构<br>栈遵循后进先出（LIFO），执行上下文的基础结构就是栈。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-2.webp" alt=""></p></li><li><p>堆数据结构<br>堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的 key-value 可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。</p></li><li><p>队列数据结构<br>队列遵循先进先出（FIFO），事件循环的基础结构就是队列。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-3.webp" alt=""></p></li></ul><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h2><h3 id="2-1-基本数据类型："><a href="#2-1-基本数据类型：" class="headerlink" title="2.1 基本数据类型："></a>2.1 基本数据类型：</h3><ul><li>js 有 6 种基本数据类型：undefined，null，boolean，number，string，symbol</li><li>基本数据类型在内存中分别占有固定大小的空间，所以都是保存在<strong>栈内存</strong>中的（闭包的自由变量是例外，其保存在堆内存中，因此 context stack 销毁后依然存在）</li><li>基本数据类型是按值访问的</li><li>比较：值的比较</li></ul><h3 id="2-2-引用数据类型："><a href="#2-2-引用数据类型：" class="headerlink" title="2.2 引用数据类型："></a>2.2 引用数据类型：</h3><ul><li>一般指的是 object</li><li>对象在内存中的大小不固定，所以保存在<strong>堆内存</strong>中，又由于对象的地址大小固定，所以地址保存在栈内存中</li><li>引用数据类型是按引用访问的。访问对象时，先从栈中读取内存地址，然后再根据这个地址找到堆中的对象</li><li>比较：引用的比较</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-4.png" alt=""></p><h2 id="3-赋值、浅拷贝和深拷贝的区别"><a href="#3-赋值、浅拷贝和深拷贝的区别" class="headerlink" title="3.赋值、浅拷贝和深拷贝的区别"></a>3.赋值、浅拷贝和深拷贝的区别</h2><h3 id="3-1-赋值"><a href="#3-1-赋值" class="headerlink" title="3.1 赋值"></a>3.1 赋值</h3><p>赋值是将某一数值或对象赋给某个变量的过程，包括两种：</p><ul><li>基本数据类型：<br>就是简单的赋值。因为在内存中开辟了一块新的栈空间，所以赋值之后两个变量独立、互不影响</li><li>引用数据类型：<br>赋<strong>址</strong>。实际操作的是对象内存的地址，最后使两个变量具有相同的引用，都指向同一个对象，因此这两个变量相互之间有影响</li></ul><h3 id="3-2-浅拷贝"><a href="#3-2-浅拷贝" class="headerlink" title="3.2 浅拷贝"></a>3.2 浅拷贝</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>浅拷贝即 swallow copy，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是其内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。<br>简而言之，浅拷贝的“浅”在于它的拷贝只停留在一层，即：拷贝第一层的<strong>基本类型值</strong>，以及<strong>第一层的引用类型地址</strong>。如图：<br>拷贝第一层的基本类型值，以及第一层的引用类型地址。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-5.png" alt=""></p><h4 id="哪些地方是浅拷贝？"><a href="#哪些地方是浅拷贝？" class="headerlink" title="哪些地方是浅拷贝？"></a>哪些地方是浅拷贝？</h4><ul><li><code>Object.assign()</code></li></ul><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，最后再将目标对象返回。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    author<span class="token punctuation">:</span> <span class="token string">"Jack"</span><span class="token punctuation">,</span>    article<span class="token punctuation">:</span> <span class="token punctuation">{</span>        title<span class="token punctuation">:</span> <span class="token string">"Understanding event loop"</span><span class="token punctuation">,</span>        date<span class="token punctuation">:</span> <span class="token string">"2019-1-1"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> b <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* {    author: "Jack",    article: {        title: "Understanding event loop",        date: "2019-1-1"    }} */</span>a<span class="token punctuation">.</span>author <span class="token operator">=</span> <span class="token string">"Bob"</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span>article<span class="token punctuation">.</span>date <span class="token operator">=</span> <span class="token string">"2019.2.1"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* {    author: "Bob",    article: {        title: "Understanding event loop",        date: "2019-2-1"    }} */</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* {    author: "Jack",    article: {        title: "Understanding event loop",        date: "2019-2-1"    }} */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，因为 a 和 b 有各自的基本类型属性，所以对这种属性的修改是独立的；但是由于 a 和 b 的引用类型属性指向内存中的同一个对象，所以 a 对该对象的修改会反映到 b 上，这是浅拷贝的特点。</p><ul><li>展开语法<code>...</code></li></ul><blockquote><p>展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者字符串在语法层面展开；还可以在构造字面量对象时, 将对象表达式按 key-value 的方式展开。</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    author<span class="token punctuation">:</span> <span class="token string">"Jack"</span><span class="token punctuation">,</span>    article<span class="token punctuation">:</span> <span class="token punctuation">{</span>        title<span class="token punctuation">:</span> <span class="token string">"Understanding event loop"</span><span class="token punctuation">,</span>        date<span class="token punctuation">:</span> <span class="token string">"2019-1-1"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>a<span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* {    author: "Jack",    article: {        title: "Understanding event loop",        date: "2019-1-1"    }} */</span>a<span class="token punctuation">.</span>author <span class="token operator">=</span> <span class="token string">"Bob"</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span>article<span class="token punctuation">.</span>date <span class="token operator">=</span> <span class="token string">"2019.2.1"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* {    author: "Bob",    article: {        title: "Understanding event loop",        date: "2019-2-1"    }} */</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* {    author: "Jack",    article: {        title: "Understanding event loop",        date: "2019-2-1"    }} */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Array.prototype.slice()</code><blockquote><p><code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括 end ）决定的原数组的浅拷贝。原始数组不会被改变。</p></blockquote></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ["1", [2, 3]]</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"99"</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// [0, "99", [4, 3]]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//  ["1", [4, 3]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，因为 a 和 b 都有各自的基本类型属性，所以修改 a[1] 对 b 没有影响；但是由于 a 和 b 的引用类型属性指向内存中的同一个数组对象，所以对 <code>a[2][0]</code> 的修改会反映到 b 上。</p><h3 id="3-3-深拷贝"><a href="#3-3-深拷贝" class="headerlink" title="3.3 深拷贝"></a>3.3 深拷贝</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>深拷贝即 deep copy，它会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。<br>简而言之，深拷贝的“深”在于它的拷贝不仅仅停留在一层，而是连同里面的子对象也一同拷贝。如图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/%E8%A7%A3%E6%9E%90%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D-6666.png" alt=""></p><h4 id="哪些地方是深拷贝？"><a href="#哪些地方是深拷贝？" class="headerlink" title="哪些地方是深拷贝？"></a>哪些地方是深拷贝？</h4><ul><li><code>JSON.parse(JSON.stringify(object))</code></li></ul><p>对象（包括数组）的序列化和反序列化</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    author<span class="token punctuation">:</span> <span class="token string">"Jack"</span><span class="token punctuation">,</span>    article<span class="token punctuation">:</span> <span class="token punctuation">{</span>        title<span class="token punctuation">:</span> <span class="token string">"Understanding event loop"</span><span class="token punctuation">,</span>        date<span class="token punctuation">:</span> <span class="token string">"2019-1-1"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> b <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringfy</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* {    author: "Jack",    article: {        title: "Understanding event loop",        date: "2019-1-1"    }} */</span>a<span class="token punctuation">.</span>author <span class="token operator">=</span> <span class="token string">"Bob"</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span>article<span class="token punctuation">.</span>date <span class="token operator">=</span> <span class="token string">"2019.2.1"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* {    author: "Bob",    article: {        title: "Understanding event loop",        date: "2019-2-1"    }} */</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* {    author: "Jack",    article: {        title: "Understanding event loop",        date: "2019-1-1"    }} */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改变 <code>a.article.date</code> 之后对 b 没有影响，可见这是深拷贝，a 和 b 有各自的 <code>article</code> 对象。</p><p>不过，<code>JSON.parse(JSON.stringify(object))</code> 有以下几个问题：</p><p>1、会忽略 undefined</p><p>2、会忽略 symbol</p><p>3、会忽略函数（不能序列化函数）</p><p>4、不能解决循环引用的对象</p><p>5、不能正确处理 new Date()</p><p>6、不能处理正则</p><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><table><thead><tr><th>--</th><th>和原数据是否指向同一对象</th><th>第一层数据为基本数据类型</th><th>原数据中包含子对象</th></tr></thead><tbody><tr><td>赋值</td><td>是</td><td>改变会使原数据一同改变</td><td>改变会使原数据一同改变</td></tr><tr><td>浅拷贝</td><td>否</td><td>改变<strong>不</strong>会使原数据一同改变</td><td>改变会使原数据一同改变</td></tr><tr><td>深拷贝</td><td>否</td><td>改变<strong>不</strong>会使原数据一同改变</td><td>改变<strong>不</strong>会使原数据一同改变</td></tr></tbody></table><h2 id="4-模拟实现-Object-assign-的浅拷贝"><a href="#4-模拟实现-Object-assign-的浅拷贝" class="headerlink" title="4.模拟实现 Object.assign() 的浅拷贝"></a>4.模拟实现 <code>Object.assign()</code> 的浅拷贝</h2><h3 id="4-1-Object-assign-浅拷贝的特点："><a href="#4-1-Object-assign-浅拷贝的特点：" class="headerlink" title="4.1 Object.assign() 浅拷贝的特点："></a>4.1 <code>Object.assign() 浅拷贝的特点</code>：</h3><ul><li>如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后来的源对象的属性将类似地覆盖早先的属性；</li><li>string、symbol、null 和 undefined 类型的属性都会被拷贝</li></ul><h3 id="4-2-实现-Object-assign-的基本思路："><a href="#4-2-实现-Object-assign-的基本思路：" class="headerlink" title="4.2 实现 Object.assign() 的基本思路："></a>4.2 实现 <code>Object.assign()</code> 的基本思路：</h3><p>1、判断原生 Object 是否支持该函数，如果不存在的话创建一个 assign 函数，并使用 <code>Object.defineProperty</code> 将该函数绑定到 Object 上。</p><p>2、判断参数是否正确（目标对象不能为空，我们可以直接设置 <code>{}</code> 传递进去,但必须设置值）。</p><p>3、使用 <code>Object()</code> 转成对象，并保存为 <code>to</code>，最后返回这个对象 <code>to</code>。</p><p>4、使用 <code>for..in</code> 循环遍历出所有可枚举属性，配合 <code>hasOwnProperty</code> 获取所有可枚举自有（非原型链上的）属性，再复制给新的目标对象。</p><h3 id="4-3-具体实现代码："><a href="#4-3-具体实现代码：" class="headerlink" title="4.3 具体实现代码："></a>4.3 具体实现代码：</h3><p>下面是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">MDN</a> 上 <code>assign()</code> 的 polyfill（注意：此 polyfill 不支持 symbol 属性，因为 ES5 中根本没有 symbol）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Object<span class="token punctuation">.</span>assign <span class="token operator">!=</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Must be writable: true, enumerable: false, configurable: true</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>Object<span class="token punctuation">,</span> <span class="token string">"assign"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    value<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token function">assign</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> varArgs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// .length of function is 2</span>      <span class="token string">'use strict'</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// TypeError if undefined or null</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Cannot convert undefined or null to object'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">let</span> to <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> nextSource <span class="token operator">=</span> arguments<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextSource <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Skip over if undefined or null</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> nextKey <span class="token keyword">in</span> nextSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Avoid bugs when hasOwnProperty is shadowed</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>nextSource<span class="token punctuation">,</span> nextKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              to<span class="token punctuation">[</span>nextKey<span class="token punctuation">]</span> <span class="token operator">=</span> nextSource<span class="token punctuation">[</span>nextKey<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> to<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-重点注意"><a href="#4-4-重点注意" class="headerlink" title="4.4 重点注意"></a>4.4 重点注意</h3><p>经过测试，该模拟实现的 <code>assign()</code> 可以达到和原生 Object 的 <code>assign()</code> 一样的浅拷贝效果。下面说几个重点需要注意的地方：</p><ul><li>为什么使用 <code>Object。defineProperty()</code> 添加方法，而不是直接挂载？</li></ul><p>我们知道，<code>for...in</code> 可以遍历出自身以及原型链上的可枚举属性，而 <code>Object.keys()</code> 只能遍历出自身的可枚举属性</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 无输出</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> Object <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// []</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，Object 的属性默认都是不可枚举的，但是，直接挂载在 Object 上面的属性却是可枚举的：</p><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> Object<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 1 </span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> Object <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ["a"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，只有 <code>assign()</code> 确实是可枚举属性时，才可以将其直接挂载在 <code>assign()</code> 上。但是， <code>assign()</code> 实际上是不可枚举的。<br>我们可以使用 2 种方法查看 <code>assign()</code> 是否可枚举：</p><ul><li><code>Object.getOwnPropertyDescriptor()</code></li><li><code>Object.propertyIsEnumerable()</code><br>其中，后者会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 <code>enumerable: true</code>。</li></ul><p>具体用法如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 方法1</span>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>Object<span class="token punctuation">,</span> <span class="token string">"assign"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// {</span><span class="token comment" spellcheck="true">//     value: ƒ, </span><span class="token comment" spellcheck="true">//  writable: true,     // 可写</span><span class="token comment" spellcheck="true">//  enumerable: false,  // 不可枚举，注意这里是 false</span><span class="token comment" spellcheck="true">//  configurable: true    // 可配置</span><span class="token comment" spellcheck="true">// }</span><span class="token comment" spellcheck="true">// 方法2</span>Object<span class="token punctuation">.</span><span class="token function">propertyIsEnumerable</span><span class="token punctuation">(</span><span class="token string">"assign"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码说明 <code>Object.assign()</code> 是不可枚举的。因此，这里适合用<code>Object.defineProperty()</code> 给 Object 添加属性，用这个方法时也可以不显式指定 enumerable 为 false，因为它默认就是 false。</p><ul><li>参数判断：</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> undefined <span class="token operator">||</span> target <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Cannot convert undefined or null to object'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面这种参数判断也可以，但是由于 <code>null</code> 和 <code>undefined</code> 的相等性判断返回 true，所以实际上直接写 <code>if(target == null)</code> 即可</p><ul><li>为什么要用 <code>Obejct()</code> 将 target 参数包装成对象？</li></ul><p>正常情况下传入的参数应该是一个对象，但是模拟实现的时候需要考虑传入参数不一定为对象的情况。</p><p><strong>1.如果作为源对象的参数不是对象：</strong></p><p><code>null</code> 和 <code>undefined</code> 会被忽略；除了这两者之外的原始类型则将被包装成对象，在这种情况下，只有<strong>自身拥有可枚举属性</strong>的包装对象才会被拷贝，其它类型的包装对象会被忽略</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> v1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token keyword">var</span> v2 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">var</span> v3 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> v4 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> v1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [ '0', '1', '2' ]</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> v2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// []</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> v3 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// []</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> v4 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// []</span><span class="token comment" spellcheck="true">// 可以看到，只有字符串类型的包装对象，才有自身的可枚举属性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> undefined<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v3<span class="token punctuation">,</span> v4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 只有 v1 会被拷贝</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { "0": "a", "1": "b", "2": "c" }</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.如果作为目标对象的参数不是对象：</strong></p><p>同理，我们还要考虑 target 参数也可能不是对象的情况，所以在上面的 polyfill 中，要使用 <code>Object()</code> 将 target 参数包装成对象。</p><ul><li>为什么要用严格模式？<br>使用 <code>Object()</code> 对参数进行包装后，对于得到的包装对象而言，其既有属性的 writable 为 false，也就是说不能对其既有属性进行改写，否则会报错</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">"def"</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>assign()</code> 的内部实现中将 <code>str1</code> 和 <code>str2</code> 包装为对象，因此这两者在内部是这样的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// str1</span><span class="token punctuation">{</span>    <span class="token number">0</span><span class="token punctuation">:</span><span class="token string">"a"</span><span class="token punctuation">,</span>    <span class="token number">1</span><span class="token punctuation">:</span><span class="token string">"b"</span><span class="token punctuation">,</span>    <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">"c"</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// str2</span><span class="token punctuation">{</span>    <span class="token number">0</span><span class="token punctuation">:</span><span class="token string">"d"</span><span class="token punctuation">,</span>    <span class="token number">1</span><span class="token punctuation">:</span><span class="token string">"e"</span><span class="token punctuation">,</span>    <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">"f"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Object.assign(str1, str2)</code> 相当于用 <code>str2</code> 的同名属性依次覆盖 <code>str1</code> 的属性，从而实现拷贝。但是由于 <code>str1</code> 是用 <code>Object()</code> 进行包装的，所以这个拷贝是不生效的，会报错。<br>但是，如果在 <code>assign()</code> 的实现内部不使用严格模式，则不会报错：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// { </span><span class="token comment" spellcheck="true">//   value: 'a',</span><span class="token comment" spellcheck="true">//   writable: false, // 注意这里</span><span class="token comment" spellcheck="true">//   enumerable: true,</span><span class="token comment" spellcheck="true">//   configurable: false </span><span class="token comment" spellcheck="true">// }</span>myObject<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'d'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 'd'</span>myObject<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里并没有报错，原因在于 js 对于不可写的属性值的修改静默失败，只有在严格模式下才会提示错误。为了实现正常的报错，我们必须在内部使用严格模式。</p><ul><li>为什么要用 <code>Object.prototype.hasOwnProperty.call()</code>？</li></ul><p>通过 <code>for...in..</code> 得到的是源对象自身及其原型链上的可枚举属性，但浅拷贝只需要拷贝自身可枚举属性，所以需要用 <code>hasOwnProperty()</code> 筛选，但是直接调用这个方法是不行的。一方面，我们需要考虑到源对象可能重写了这个方法而导致其无法正常调用，另一方面还要考虑到源对象可能是基于 <code>Object.create(null)</code> 创建的，而这种方法创建的对象由于不具有与 Object 原型链的联系，因此不具有 <code>hasOwnProperty()</code> 方法，在调用的时候会报错。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> myObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>myObject<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span> <span class="token string">"b"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// TypeError: myObject.hasOwnProperty is not a function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，这里采用 <code>Object.prototype.hasOwnProperty.call()</code>，将 <code>hasOwnProperty()</code> 内部的 this 绑定到源对象上，也可以达到同样的效果。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> myObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>myObject<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<br><a href="https://github.com/yygmind/blog/issues/25" target="_blank" rel="noopener">https://github.com/yygmind/blog/issues/25</a><br><a href="https://github.com/yygmind/blog/issues/26" target="_blank" rel="noopener">https://github.com/yygmind/blog/issues/26</a><br><a href="https://juejin.im/post/59ac1c4ef265da248e75892b#heading-13" target="_blank" rel="noopener">https://juejin.im/post/59ac1c4ef265da248e75892b#heading-13</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大一下学期：The End</title>
      <link href="/2019/06/30/T-%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End/"/>
      <url>/2019/06/30/T-%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>本来应该是在年底做一些总结，然后写下明年的目标，但是我感觉这一年 —— 准确地说是这一学期过得太快，以至于给我一种好像 2019 年就要结束了的错觉。加上最近算是完成了一个阶段的学习，所以我想还是记录一下这个学期的事情。<br><a id="more"></a></p><h2 id="1-计划中的事完成得怎么样？"><a href="#1-计划中的事完成得怎么样？" class="headerlink" title="1.计划中的事完成得怎么样？"></a>1.计划中的事完成得怎么样？</h2><p>之前规划了<a href="https://chorer.github.io/%2F2019%2F03%2F23%2FT-%E5%A4%A7%E4%B8%80%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92%2F">这学期要做的事</a>，所以先来看这些事情对应的完成度和满意度：</p><table><thead><tr><th>计划</th><th>完成度</th><th>满意度</th></tr></thead><tbody><tr><td>全国大英竞赛</td><td>100%</td><td>不满意</td></tr><tr><td>信息素养比赛</td><td>100%</td><td>很满意</td></tr><tr><td>四级考试的准备</td><td>90%</td><td>还行</td></tr><tr><td>前端进阶系列文章</td><td>40%</td><td>还行</td></tr><tr><td>阅读《JavaScript 高级程序设计》</td><td>33%</td><td>挺满意</td></tr><tr><td>阅读《ES6 标准入门》</td><td>30%</td><td>还行</td></tr><tr><td>找一个小项目做</td><td>100%</td><td>很满意</td></tr><tr><td>完成 HTML5 和 CSS3 的学习</td><td>90%</td><td>挺满意</td></tr><tr><td>阅读两本历史相关书籍</td><td>0%</td><td>不满意</td></tr><tr><td>通关《巫师 3》</td><td>100%</td><td>很满意</td></tr></tbody></table><h2 id="2-有什么想法和感受？"><a href="#2-有什么想法和感受？" class="headerlink" title="2.有什么想法和感受？"></a>2.有什么想法和感受？</h2><p>其实这学期做的事情并不止上面那些。这里挑一些重要的说一下：</p><p><strong>比赛/考试：</strong></p><p><i class="fa fa-hand-o-right"></i> 大英竞赛是在上学期报的名，不过我并没有腾出时间做好充分的准备，所以最终的结果 —— 只是去打了一下酱油，没有获得任何奖项。这件事情让我觉得，对待一件事我应该更加慎重地做出选择。回想起来，我确实有很多次贸然地做出一些不合适的选择，而其中大部分仅是因为单纯的喜欢和一时的头脑发热，实际上很难确保自己可以百分百投入这件事。</p><center><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End/2019.6.9%20%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83-1.jpg"><br><p style="font-size:15px;color:#999;font-weight:700">打酱油证书</p><br></center><p><i class="fa fa-hand-o-right"></i> 信息素养比赛的体验很棒，多亏了给力的队友，合作过程很愉快。其实也是上学期的比赛了，那时候是初赛，天真的我们后来才意识到决赛需要找文献资料、需要做 PPT、需要演讲……我记得那段时间忙得不可开交，因为可供准备的时间真的不多。不过幸运的是，我们每个人各司其职，尽了自己最大的努力。本来想的是可以拿个三等奖就很棒了，最后拿了二等奖，所以还是蛮开心的（虽然奖金至今没有到账）。很多事情用心去做了，也许结果会比你想象的好很多。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End/2019.6.9%20%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83-2.jpg"></p><p><center style="font-size:15px;color:#999;font-weight:700">拿了二等奖，还不错</center><br><br></p><p><i class="fa fa-hand-o-right"></i> 四级考试的准备过程基本就是刷真题，不过也确实是太久没做题了，第一次做的时候手感很生疏。现在让我像高三那样两周刷 25 套题基本办不到了。成绩 8 月份出来，预测不会太高，毕竟作文和听力真挺悬的。<br><br></p><p><strong>前端：</strong></p><p><i class="fa fa-hand-o-right"></i> 学习内容：<br>这学期主要学 HTML5 和 CSS3（包括补充以前学习时遗漏的重点），同时继续钻研原生 JS 中的重难点（主要看<a href="https://github.com/yygmind/blog" target="_blank" rel="noopener">前端进阶系列文章</a>）以及 ES6 的新特性。这一块也确实不好啃，很多时候一个难点需要钻研几天，除了反复翻看国内外的博客，还需要向社区上的各位前辈请教，然后自己慢慢去理解和消化。虽然很耗时间，但我觉得这是值得的，因为学习本来就是要刨根问底，而不是浮于表面。</p><p><i class="fa fa-hand-o-right"></i> 社区：<br>在学习上得到了不少帮助，除了社区上的人，还有群里的小伙伴，真的很感谢他们。如果受助者能够反过来去帮助他人，那么就有可能形成一个良性循环，所以我选择加入了掘金翻译团队，并在平台（掘金/思否）上发布了一些译文。可能这些文章对于大佬们来说过于简单了，不过我依然希望能够帮到一些人，就像我之前从其他人的博客那里得到的帮助一样。</p><p>事实上，翻译带给我的好处远比想象得多。除了提高英文阅读能力（因为我发现我越来越能够理解那些作者想要表达的东西），还能够知道对于同样的概念和知识，老外是以什么样的方式去理解和阐述的，不同的思维值得我们去学习和借鉴。另外，通过翻译还有机会接触到新的东西，例如之前译的一篇关于 AST 的文章，其实对于抽象语法树我只停留在“听过”的阶段，但是翻译过后，自己也多多少少有了一些概念，我想这是一件好事。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End/2019.6.9%20%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83-3.jpg"></p><p><center style="font-size:15px;color:#999;font-weight:700">掘金社区的氛围超棒</center><br><br></p><p>虽然，也不乏一些冷嘲热讽的人：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End/2019.6.9%20%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83-6.png" alt=""><br>这让我想起了一年前给论坛汉化游戏的时候，底下也有评论说：“你汉化的这个东西辣鸡，没人用的，别浪费时间了”。在我看来，这都是一类人，他们看不惯一些东西，但是又没有能力去给作者提意见，所以只能就近找个分享者乱喷一通。但是仔细一看他们的话，其实漏洞百出，没有任何站得住脚的地方。而类似的事情在国外社区却从来没有遇到过（我只是说没遇到过，不是说没有），不管是在游戏领域还是在技术领域，很多老外都足够热心，尤其是那些领域的大牛，他们真的要谦逊多了。</p><p><i class="fa fa-hand-o-right"></i> 项目：<br>这学期最开心的事情就是终于有了自己的第一个开源项目，<a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">hexo-theme-PureBlue</a>，也就是现在这个博客的主题。刚 release 的时候其实只能算是个雏形，不过，经过几个月的不断打磨和修改（github 上 74 次 commit 和 3 次 release）之后，无论是外观还是功能都完善了不少。这回也算是体验了从 0 到 1 慢慢打磨一个作品的过程（因为这个主题不是魔改的），最重要的是学到了不少知识，因此这个项目带给我的意义很大。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End/2019.6.9%20%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83-4.jpg"></p><p><center style="font-size:15px;color:#999;font-weight:700">比较成熟的 2.0 版本</center><br><br><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End/2019.6.9%20%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83-5.jpg"></p><p><center style="font-size:15px;color:#999;font-weight:700">大部分的 contributions 来自于主题，也包括掘金翻译计划</center><br><br><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End/T-%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20End-1.png"></p><p><center style="font-size:15px;color:#999;font-weight:700">虽然只有一个 issue，但是自己做的东西有人用了，还是很开心（图中问题已修复hh）</center><br><br></p><p>需要反思的地方是，我花费太多时间去修缮博客了。我发现群里很多人也有这种情况 —— 花了很多时间去打造皮囊，但是忽略了最重要的内容。<br>所以，这里重要的事情说三遍：<br><i class="fa fa-warning"></i> 不要忘记写博客的目的<br><i class="fa fa-warning"></i> 不要忘记写博客的目的<br><i class="fa fa-warning"></i> 不要忘记写博客的目的<br>下半年会减少花费在这上面的时间，腾出更多时间学习新知识。后面有时间再考虑两件事：一是 vue 学得差不多之后移植到 vuepress 上；二是重构整个主题的代码，之前写得实在是太烂了，命名、结构、复用性等问题一大堆，现在维护很吃力，都和这些问题有关。<br><br></p><p><strong>阅读：</strong><br><i class="fa fa-hand-o-right"></i> 这学期读的书实在不多，仔细阅读过的就两本：高程 3 和 ES6，而且都还没看完。不过后来想了一下，或许看技术书籍的时候放慢速度也不是坏事，再加上中间各种各样的事情打断了阅读，所以这个结果也还能接受。高程 3 阅读起来还是很带劲的，因为作者思路很清晰，加上之前深入理解过一些难点，所以读的时候也少了很多迷茫；另一本是阮一峰老师的《ES6 标准入门》，ES6 多了很多新东西，虽然是语法糖，但是也有一定的学习成本。图书馆有这本书，不过只能续借两个月（还是三个月，忘了），而且不能批注，看起来实在不方便，所以后面会考虑买一本。</p><p><i class="fa fa-hand-o-right"></i> 寒假的时候看了《以色列》这本书，对以色列这个国家有了和从前不一样的看法。我认为这是历史的一个作用，历史帮助我们去理解一个国家的行为，以及这个国家现在发生的事情。<br>之后做了一份中东历史相关书单，本来打算这学期读一两本，但是心静不下来，于是作罢。至于说为什么心静不下来呢…这可能和我的焦虑有关。我大部分时候会脚踏实地地去学习，但依然会对前端知识体系的庞大和迭代速度之快（就像今年又出现了 Flutter 这个新东西）感到恐惧，这让我觉得每一分钟都很宝贵，不学则退。但是这种焦虑是好是坏呢？很难说。<br><br></p><p><strong>娱乐：</strong></p><p>这学期通关了三个游戏：<br><i class="fa fa-hand-o-right"></i> 第一个是《巫师 3》。精彩的故事 + 饱满的人物 + 高度的游戏性，就连 dlc 也是经过精心打磨的，这是我心目中的满分神作无疑了。而且和其它游戏不同的是，主角不是真正意义上的救世主，游戏的世界观设定里有很多远比他更强大的存在，很多时候玩家可以深刻感受到主角的无力。dlc《血与酒》的最后，杰洛特和雷吉斯在篝火旁畅饮，聊过去、谈人生，玩家的旅途也就此画上了圆满的句号。</p><p><i class="fa fa-hand-o-right"></i> 第二个是《刺客信条：大革命》。剧情其实早就知道，这次游玩单纯是为了回忆和弥补遗憾（之前由于电脑带不动，所以一直没玩），有很长一段时间没有接触这个系列了。玩下来觉得还可以，巴黎真的挺美的，跑酷也很爽，但是剧情中规中矩，没有让人眼前一亮。还有就是联机体验真心差，和几个基友玩的时候基本是连不上的。想起来还真的是很怀念二代和四代，那时候游戏里的一幕幕至今依然印象深刻。</p><p><i class="fa fa-hand-o-right"></i> 最后一个是《耻辱 2》，打折的时候入的。这个系列吸引我的就是其独特的蒸汽朋克风格和巧妙的关卡设计，真的很赞。作为一个潜入游戏，采用第一人称视角而且还做得这么成功的的确是只此一家。关卡设计在本作达到了巅峰：一个是[机关宅邸]，整座房子都是机动的，而玩家需要在其中周旋、寻找目标；另一个是[石板上的裂缝]，虽然身处相同的空间，但是却可以游走于不同的时间，通过回到过去清除障碍物，可以开辟现在的道路，甚至在被过去的敌人追杀时还可以选择回到现在躲避，这种巧妙的设计真的出现在游戏里时，不得不说很惊喜。剧情就是：上位 =&gt; 篡位 =&gt; 上位，是有点老套没错，不过不影响它是神作。另外感觉这个游戏塑造的世界真的挺叫人绝望的，第一部是鼠疫，这一部又是飞蝇，而且周围看起来一片民不聊生，可以说比巫师 3 的世界还惨了。</p><p>不过，我也能很明显地感到自己对游戏的热情没有以前那么大了。以前玩游戏没有节制，但是现在能够很轻松地脱身；以前会去折腾游戏汉化，钻研游戏玩法，甚至因为别人吐槽自己喜欢的游戏而撕逼一场，但现在真的没心思弄这些了，因为累，因为网络上大部分的交流没有任何意义（当然，不包括编程方面的）；偶尔还会关注有什么新游戏或者打折优惠，但说实在的，玩的欲望不大。<br>原本我以为对游戏的热爱会持续很久，不过现在看来并不是这样。大概随着人的成长，曾经热爱的事物反而会带来疲倦感吧。</p><h2 id="3-下半年要做什么？"><a href="#3-下半年要做什么？" class="headerlink" title="3.下半年要做什么？"></a>3.下半年要做什么？</h2><p>按照惯例，写下下半年的计划：</p><h3 id="3-1-输入："><a href="#3-1-输入：" class="headerlink" title="3.1.输入："></a>3.1.输入：</h3><p><i class="fa fa-hand-o-right"></i> <strong>前端：</strong></p><ul><li>熟练掌握各种效果的实现（CSS，JavaScript）</li><li>重点学习 vue 框架</li><li>跟着前端进阶系列，每周攻破一个 JavaScript 重难点</li><li>学习 Bootstrap</li><li>学习 stylus（可能会考虑翻译一下官方文档）</li></ul><p><i class="fa fa-hand-o-right"></i> <strong>技术书籍：</strong></p><ul><li>《JavaScript 高级程序设计》+ 读书笔记</li><li>《ES6 标准入门》</li><li>《你不知道的 JavaScript》上下卷（考虑英文版）</li><li>《深入理解 ES6》</li></ul><p><i class="fa fa-hand-o-right"></i> <strong>计算机基础：</strong><br>数据结构以及深入理解计算机系统。</p><blockquote><p>这两块说实话我一直是挺畏惧的，因为很难。但有一位大佬曾经说过：“当一个程序员对英语和底层感到恐惧的时候，他的生涯就已经到了尽头。”我对英语并不恐惧，所以我希望我也能成为一个对底层不恐惧的人，哪怕这是一个艰巨的挑战，但我想要去克服它。</p></blockquote><p><i class="fa fa-hand-o-right"></i> <strong>更加广泛的涉猎：</strong><br>阅读产品、历史以及个人软技能提高的相关书籍</p><h3 id="3-2-输出："><a href="#3-2-输出：" class="headerlink" title="3.2.输出："></a>3.2.输出：</h3><p><i class="fa fa-hand-o-right"></i> <strong>翻译：</strong> 每周保质保量，至少输出 1~2 篇翻译。</p><blockquote><p>输入源：国外博客网站以及 RSS；<br>输出源：个人博客、掘金、SegmentFault。</p></blockquote><p><i class="fa fa-hand-o-right"></i> <strong>项目和比赛：</strong></p><ul><li>开发一个小程序，不需要太复杂，只做练手</li><li>希望可以和小伙伴们参加一些比赛（感觉大一错失了很多机会）</li></ul><p><i class="fa fa-hand-o-right"></i> <strong>培训：</strong> 培训下一届的小伙伴们，希望可以找到真心热爱前端的人。</p><h2 id="4-喜欢的事就坚持下去吧"><a href="#4-喜欢的事就坚持下去吧" class="headerlink" title="4.喜欢的事就坚持下去吧"></a>4.喜欢的事就坚持下去吧</h2><p>喜欢的事就是你愿意投入 100% 精力去做的事，对于我来说就是前端。学习前端一年了，和很多这时候早已经学习了框架的人比较，我确实是在慢慢前行。</p><blockquote><p>“到底哪一种比较好？是快速上手，还是即使耗时耗力也不放过每一个疑惑的知识点？”</p></blockquote><p>这个问题我无数次地问过自己和别人，但是每一次都没有确切的答案。这是因为，这个问题只有提问者能够回答，而且需要在自学的过程中慢慢去寻找答案。我现在可以告诉自己：没有孰优孰劣，只有合不合适。很多人学东西很快，甚至什么都学，不管是天赋使然，还是浮躁使然，我都不喜欢这种方式。对我来说，最舒服的方式是彻底弄懂一个知识点，即使辗转反侧，但是这个过程充满探索性，充满各种求问和佐证，我很享受。而这些显然是速成和培训班不能带来的。所以一句话：对于喜欢的事，<strong>不要顾虑太多，不要陷入浮躁，有个明确的学习方向，然后脚踏实地坚持下去就可以了</strong>。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」编写更好的 JavaScript 条件式和匹配条件的技巧</title>
      <link href="/2019/06/24/Trs-%E6%9B%B4%E5%A5%BD%E7%9A%84JavaScript%E6%9D%A1%E4%BB%B6%E5%BC%8F%E5%92%8C%E5%8C%B9%E9%85%8D%E6%A0%87%E5%87%86%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/06/24/Trs-%E6%9B%B4%E5%A5%BD%E7%9A%84JavaScript%E6%9D%A1%E4%BB%B6%E5%BC%8F%E5%92%8C%E5%8C%B9%E9%85%8D%E6%A0%87%E5%87%86%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="https://devinduct.com/blogpost/35/tips-and-tricks-for-better-javascript-conditionals-and-match-criteria" target="_blank" rel="noopener">Tips and Tricks for Better JavaScript Conditionals and Match Criteria</a></li><li>原文作者：Milos Protic</li><li>译者：Chor<a id="more"></a></li></ul></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如果你像我一样乐于见到整洁的代码，那么你会尽可能地减少代码中的条件语句。通常情况下，面向对象编程让我们得以避免条件式，并代之以继承和多态。我认为我们应当尽可能地遵循这些原则。</p><p>正如我在另一篇文章 <a href="https://devinduct.com/blogpost/22/javascript-clean-code-best-practices" target="_blank" rel="noopener">JavaScript 整洁代码的最佳实践</a>里提到的，你写的代码不单单是给机器看的，还是给“<strong>未来的自己</strong>”以及“<strong>其他人</strong>”看的。</p><p>从另一方面来说，由于各式各样的原因，可能我们的代码最终还是会有条件式。也许是修复 bug 的时间很紧，也许是不使用条件语句会对我们的代码库造成大的改动，等等。本文将会解决这些问题，同时帮助你组织所用的条件语句。</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>以下是关于如何构造 <code>if...else</code> 语句以及如何用更少的代码实现更多功能的技巧。阅读愉快！</p><h3 id="1-要事第一。小细节，但很重要"><a href="#1-要事第一。小细节，但很重要" class="headerlink" title="1. 要事第一。小细节，但很重要"></a>1. 要事第一。小细节，但很重要</h3><p>不要使用否定条件式（这可能会让人感到疑惑）。同时，使用条件式简写来表示 <code>boolean</code> 值。这个无须再强调了，尤其是否定条件式，这不符合正常的思维方式。</p><p>不好的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> isEmailNotVerified <span class="token operator">=</span> <span class="token punctuation">(</span>email<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 实现</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmailNotVerified</span><span class="token punctuation">(</span>email<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 做一些事...</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isVerified <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 做一些事...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> isEmailVerified <span class="token operator">=</span> <span class="token punctuation">(</span>email<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 实现</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmailVerified</span><span class="token punctuation">(</span>email<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 做一些事...</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isVerified<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 做一些事...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，理清了上面的事情后，我们就可以开始了。</p><h3 id="2-对于多个条件，使用-Array-includes"><a href="#2-对于多个条件，使用-Array-includes" class="headerlink" title="2. 对于多个条件，使用 Array.includes"></a>2. 对于多个条件，使用 <code>Array.includes</code></h3><p>假设我们想要在函数中检查汽车模型是 <code>renault</code> 还是 <code>peugeot</code>。那么代码可能是这样的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> checkCarModel <span class="token operator">=</span> <span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>model <span class="token operator">===</span> <span class="token string">'renault'</span> <span class="token operator">||</span> model <span class="token operator">===</span> <span class="token string">'peugeot'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'model valid'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">checkCarModel</span><span class="token punctuation">(</span><span class="token string">'renault'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'model valid'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>考虑到我们只有两个模型，这么做似乎也还能接受，但如果我们还想要检查另一个或者是几个模型呢？如果我们增加更多 <code>or</code> 语句，那么代码将变得难以维护，且不够整洁。为了让它更加简洁，我们可以像这样重写函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> checkCarModel <span class="token operator">=</span> <span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'peugeot'</span><span class="token punctuation">,</span> <span class="token string">'renault'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'model valid'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">checkCarModel</span><span class="token punctuation">(</span><span class="token string">'renault'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'model valid'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码看起来已经很漂亮了。为了更进一步改善它，我们可以创建一个变量来存放汽车模型：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> checkCarModel <span class="token operator">=</span> <span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> models <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'peugeot'</span><span class="token punctuation">,</span> <span class="token string">'renault'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'model valid'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">checkCarModel</span><span class="token punctuation">(</span><span class="token string">'renault'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'model valid'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，如果我们想要检查更多模型，只需要添加一个新的数组元素即可。此外，如果它很重要的话，我们还可以将 <code>models</code> 变量定义在函数作用域外，并在需要的地方重用。这种方式可以让我们集中管理，并使维护变得轻而易举，因为我们只需在代码中更改一个位置。</p><h3 id="3-匹配所有条件，使用-Array-every-或者-Array-find"><a href="#3-匹配所有条件，使用-Array-every-或者-Array-find" class="headerlink" title="3. 匹配所有条件，使用 Array.every 或者 Array.find"></a>3. 匹配所有条件，使用 <code>Array.every</code> 或者 <code>Array.find</code></h3><p>在本例中，我们想要检查每个汽车模型是否都是传入函数的那一个。为了以更加命令式的方式实现，我们会这么做：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cars <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'renault'</span><span class="token punctuation">,</span> year<span class="token punctuation">:</span> <span class="token number">1956</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'peugeot'</span><span class="token punctuation">,</span> year<span class="token punctuation">:</span> <span class="token number">1968</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'ford'</span><span class="token punctuation">,</span> year<span class="token punctuation">:</span> <span class="token number">1977</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> checkEveryModel <span class="token operator">=</span> <span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> isValid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> car <span class="token keyword">of</span> cars<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    isValid <span class="token operator">=</span> car<span class="token punctuation">.</span>model <span class="token operator">===</span> model<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> isValid<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkEveryModel</span><span class="token punctuation">(</span><span class="token string">'renault'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你更喜欢以命令式的风格行事，上面的代码或许还不错。另一方面，如果你不关心其背后发生了什么，那么你可以重写上面的函数并使用 <code>Array.every</code> 或者 <code>Array.find</code> 来达到相同的结果。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> checkEveryModel <span class="token operator">=</span> <span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> cars<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span>car <span class="token operator">=</span><span class="token operator">></span> car<span class="token punctuation">.</span>model <span class="token operator">===</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkEveryModel</span><span class="token punctuation">(</span><span class="token string">'renault'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过使用 <code>Array.find</code> 并做轻微的调整，我们可以达到相同的结果。两者的表现是一致的，因为两个函数都为数组中的每一个元素执行了回调，并且在找到一个 <strong>falsy</strong> 项时立即返回 <code>false</code>。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> checkEveryModel <span class="token operator">=</span> <span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> cars<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>car <span class="token operator">=</span><span class="token operator">></span> car<span class="token punctuation">.</span>model <span class="token operator">!==</span> model<span class="token punctuation">)</span> <span class="token operator">===</span> undefined<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkEveryModel</span><span class="token punctuation">(</span><span class="token string">'renault'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-匹配部分条件，使用-Array-some"><a href="#4-匹配部分条件，使用-Array-some" class="headerlink" title="4. 匹配部分条件，使用 Array.some"></a>4. 匹配部分条件，使用 <code>Array.some</code></h3><p><code>Array.every</code> 匹配所有条件， <code>Array.some</code> 则可以轻松地检查我们的数组是否包含某一个或某几个元素。为此，我们需要提供一个回调并基于条件返回一个布尔值。</p><p>我们可以通过编写一个类似的 <code>for...loop</code> 语句来实现相同的结果，就像之前写的一样。但幸运的是，有很酷的 JavaScript 函数可以来帮助我们完成这件事。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cars <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'renault'</span><span class="token punctuation">,</span> year<span class="token punctuation">:</span> <span class="token number">1956</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'peugeot'</span><span class="token punctuation">,</span> year<span class="token punctuation">:</span> <span class="token number">1968</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'ford'</span><span class="token punctuation">,</span> year<span class="token punctuation">:</span> <span class="token number">1977</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> checkForAnyModel <span class="token operator">=</span> <span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> cars<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>car <span class="token operator">=</span><span class="token operator">></span> car<span class="token punctuation">.</span>model <span class="token operator">===</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkForAnyModel</span><span class="token punctuation">(</span><span class="token string">'renault'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-提前返回而不是使用-if-else-分支"><a href="#5-提前返回而不是使用-if-else-分支" class="headerlink" title="5. 提前返回而不是使用 if...else 分支"></a>5. 提前返回而不是使用 <code>if...else</code> 分支</h3><p>当我还是学生的时候，就有人教过我：一个函数应该只有一个返回语句，并且只从一个地方返回。如果细心处理，这个方法倒也还好。我这么说也就意味着，我们应该意识到它在某些情况下可能会引起条件式嵌套地狱。如果不受控制，多个分支和 <code>if...else</code> 嵌套将会让我们感到很痛苦。</p><p>另一方面，如果代码库很大且包含很多行代码，位于深层的一个返回语句可能会带来问题。现在我们都实行关注点分离和 SOLID 原则，因此，代码行过多这种情况挺罕见的。</p><p>举例来解释这个问题。假设我们想要显示所给车辆的模型和生产年份：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> checkModel <span class="token operator">=</span> <span class="token punctuation">(</span>car<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> result<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 首先，定义一个 result 变量</span>  <span class="token comment" spellcheck="true">// 检查是否有车</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>car<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 检查是否有车的模型</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>car<span class="token punctuation">.</span>model<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 检查是否有车的年份</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span>year<span class="token punctuation">)</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Car model: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>car<span class="token punctuation">.</span>model<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">; Manufacturing year: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>car<span class="token punctuation">.</span>year<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;`</span></span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> <span class="token string">'No car year'</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      result <span class="token operator">=</span> <span class="token string">'No car model'</span>    <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    result <span class="token operator">=</span> <span class="token string">'No car'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 我们的单独的返回语句</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'No car'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkModel</span><span class="token punctuation">(</span><span class="token punctuation">{</span> year<span class="token punctuation">:</span> <span class="token number">1988</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'No car model'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkModel</span><span class="token punctuation">(</span><span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'ford'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'No car year'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkModel</span><span class="token punctuation">(</span><span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'ford'</span><span class="token punctuation">,</span> year<span class="token punctuation">:</span> <span class="token number">1988</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'Car model: ford; Manufacturing year: 1988;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如你所看到的，即使本例的问题很简单，上面的代码也实在太长了。可以想象一下，如果我们有更加复杂的逻辑会发生什么事。大量的 <code>if...else</code> 语句。</p><p>我们可以重构上面的函数，分解成多个步骤并稍做改善。例如，使用三元操作符，包括 <code>&amp;&amp;</code> 条件式等。不过，这里我直接跳到最后，向你展示借助现代 JavaScript 特性和多个返回语句，代码可以有多简洁。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> checkModel <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>model<span class="token punctuation">,</span> year<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>model <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>year<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'No car'</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>model<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'No car model'</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>year<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'No car year'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这里可以任意操作模型或年份</span>  <span class="token comment" spellcheck="true">// 确保它们存在</span>  <span class="token comment" spellcheck="true">// 无需更多检查</span>  <span class="token comment" spellcheck="true">// doSomething(model);</span>  <span class="token comment" spellcheck="true">// doSomethingElse(year);</span>  <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Car model: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>model<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">; Manufacturing year: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>year<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;`</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'No car'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkModel</span><span class="token punctuation">(</span><span class="token punctuation">{</span> year<span class="token punctuation">:</span> <span class="token number">1988</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'No car model'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkModel</span><span class="token punctuation">(</span><span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'ford'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'No car year'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkModel</span><span class="token punctuation">(</span><span class="token punctuation">{</span> model<span class="token punctuation">:</span> <span class="token string">'ford'</span><span class="token punctuation">,</span> year<span class="token punctuation">:</span> <span class="token number">1988</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 'Car model: ford; Manufacturing year: 1988;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在重构版本中，我们包含了解构和默认参数。默认参数确保我们在传入 <code>undefined</code> 时有可用于解构的值。注意，如果传入 <code>null</code> ，函数将会抛出错误。这也是之前那个方法的优点所在，因为那个方法在传入 <code>null</code> 的时候会输出 <code>&#39;No car&#39;</code>。</p><p>对象解构确保函数只取所需。例如，如果我们在给定车辆对象中包含额外属性，则该属性在我们的函数中是无法获取的。</p><p>根据偏好，开发者会选择其中一种方式。实践中，编写的代码通常介于两者之间。很多人觉得 <code>if...else</code> 语句更容易理解，并且有助于他们更为轻松地遵循程序流程。</p><h3 id="6-使用索引或者映射，而不是-switch-语句"><a href="#6-使用索引或者映射，而不是-switch-语句" class="headerlink" title="6. 使用索引或者映射，而不是 switch 语句"></a>6. 使用索引或者映射，而不是 <code>switch</code> 语句</h3><p>假设我们想要基于给定的国家获取汽车模型。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> getCarsByState <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">'usa'</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'Ford'</span><span class="token punctuation">,</span> <span class="token string">'Dodge'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">'france'</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'Renault'</span><span class="token punctuation">,</span> <span class="token string">'Peugeot'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token string">'italy'</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'Fiat'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getCarsByState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 []</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getCarsByState</span><span class="token punctuation">(</span><span class="token string">'usa'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 ['Ford', 'Dodge']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getCarsByState</span><span class="token punctuation">(</span><span class="token string">'italy'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 ['Fiat']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上诉代码可以重构，完全去除 <code>switch</code> 语句。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cars <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'usa'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Ford'</span><span class="token punctuation">,</span> <span class="token string">'Dodge'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'france'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Renault'</span><span class="token punctuation">,</span> <span class="token string">'Peugeot'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'italy'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Fiat'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> getCarsByState <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> cars<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getCarsByState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 []</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getCarsByState</span><span class="token punctuation">(</span><span class="token string">'usa'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出 ['Ford', 'Dodge']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getCarsByState</span><span class="token punctuation">(</span><span class="token string">'italy'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 ['Fiat']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者，我们还可以为包含可用汽车列表的每个国家创建一个类，并在需要的时候使用。不过这个就是题外话了，本文的主题是关于条件句的。更恰当的修改是使用对象字面量。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> carState <span class="token operator">=</span> <span class="token punctuation">{</span>  usa<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Ford'</span><span class="token punctuation">,</span> <span class="token string">'Dodge'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  france<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Renault'</span><span class="token punctuation">,</span> <span class="token string">'Peugeot'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  italy<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Fiat'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> getCarsByState <span class="token operator">=</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> carState<span class="token punctuation">[</span>state<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getCarsByState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 []</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getCarsByState</span><span class="token punctuation">(</span><span class="token string">'usa'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 ['Ford', 'Dodge']</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">getCarsByState</span><span class="token punctuation">(</span><span class="token string">'france'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出 ['Renault', 'Peugeot']</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-使用自判断链接（optional-chaining）和空合并（nullish-coalescing）"><a href="#7-使用自判断链接（optional-chaining）和空合并（nullish-coalescing）" class="headerlink" title="7. 使用自判断链接（optional-chaining）和空合并（nullish-coalescing）"></a>7. 使用自判断链接（optional-chaining）和空合并（nullish-coalescing）</h3><p>到了这一小节，我终于可以说“<strong>最后</strong>”了。在我看来，这两个功能对于 JavaScript 语言来说是非常有用的。作为一个来自 C# 世界的人，可以说我经常使用它们。</p><p>在写这篇文章的时候，这些还没有得到完全的支持。因此，对于以这种方式编写的代码，你需要使用 Babel 进行编译。你可以在<a href="https://github.com/tc39/proposal-optional-chaining" target="_blank" rel="noopener">自判断链接</a>这里以及在<a href="https://github.com/tc39/proposal-nullish-coalescing" target="_blank" rel="noopener">空合并</a>这里查阅。</p><p>自判断链接允许我们在没有显式检查中间节点是否存在的时候处理树形结构，空合并可以确保节点不存在时会有一个默认值，配合自判断链接使用会有不错的效果。</p><p>让我们用一些例子来支撑上面的结论。一开始，我们还是用以前的老方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> car <span class="token operator">=</span> <span class="token punctuation">{</span>  model<span class="token punctuation">:</span> <span class="token string">'Fiesta'</span><span class="token punctuation">,</span>  manufacturer<span class="token punctuation">:</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'Ford'</span><span class="token punctuation">,</span>    address<span class="token punctuation">:</span> <span class="token punctuation">{</span>      street<span class="token punctuation">:</span> <span class="token string">'Some Street Name'</span><span class="token punctuation">,</span>      number<span class="token punctuation">:</span> <span class="token string">'5555'</span><span class="token punctuation">,</span>      state<span class="token punctuation">:</span> <span class="token string">'USA'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取汽车模型</span><span class="token keyword">const</span> model <span class="token operator">=</span> car <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>model <span class="token operator">||</span> <span class="token string">'default model'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取厂商地址</span><span class="token keyword">const</span> street <span class="token operator">=</span> car <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>manufacturer <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>manufacturer<span class="token punctuation">.</span>address <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>manufacturer<span class="token punctuation">.</span>address<span class="token punctuation">.</span>street <span class="token operator">||</span> <span class="token string">'default street'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 请求一个不存在的属性</span><span class="token keyword">const</span> phoneNumber <span class="token operator">=</span> car <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>manufacturer <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>manufacturer<span class="token punctuation">.</span>address <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>manufacturer<span class="token punctuation">.</span>phoneNumber<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出 'Fiesta'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>street<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出 'Some Street Name'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>phoneNumber<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出 undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，如果我们想要知道厂商是否来自 USA 并将结果打印，那么代码是这样的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> checkCarManufacturerState <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>car <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>manufacturer <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>manufacturer<span class="token punctuation">.</span>address <span class="token operator">&amp;&amp;</span> car<span class="token punctuation">.</span>manufacturer<span class="token punctuation">.</span>address<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'USA'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Is from USA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">checkCarManufacturerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 输出 'Is from USA'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我无需再赘述如果对象结构更加复杂的话，代码会多么混乱了。许多库，例如 lodash，有自己的函数作为替代方案。不过这不是我们想要的，我们想要的是在原生 js 中也能做同样的事。我们来看一下新的方法：</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token comment" spellcheck="true">// 获取汽车模型</span>    <span class="token keyword">const</span> model <span class="token operator">=</span> car<span class="token operator">?</span><span class="token punctuation">.</span>model <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">'default model'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取厂商地址</span>    <span class="token keyword">const</span> street <span class="token operator">=</span> car<span class="token operator">?</span><span class="token punctuation">.</span>manufacturer<span class="token operator">?</span><span class="token punctuation">.</span>address<span class="token operator">?</span><span class="token punctuation">.</span>street <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">'default street'</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 检查汽车厂商是否来自 USA</span>    <span class="token keyword">const</span> checkCarManufacturerState <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>car<span class="token operator">?</span><span class="token punctuation">.</span>manufacturer<span class="token operator">?</span><span class="token punctuation">.</span>address<span class="token operator">?</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'USA'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Is from USA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这看起来更加漂亮和简洁，对我来说，非常符合逻辑。如果你想知道为什么应该使用 <code>??</code> 而不是 <code>||</code> ，只需想一想什么值会被当做 <code>true</code> 或者 <code>false</code> 从而得到意料之外的输出。</p><p>顺便说句题外话。自判断链接同样支持 DOM API，这非常酷，意味着你可以这么做：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> value <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input#user-name'</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>好了，这就是全部内容了。如果你喜欢这篇文章的话，可以<a href="https://ko-fi.com/milosprotic" target="_blank" rel="noopener">送一杯咖啡给我</a>，让我提提神，还可以订阅文章或者在 <a href="https://twitter.com/protic_milos" target="_blank" rel="noopener">twitter</a> 上关注我。</p><p>感谢阅读，下篇文章见。</p><hr><p>译者注：<br>关于最后一个例子的空合并为什么使用 <code>??</code> 而不是 <code>||</code>，作者可能解释得不是很清楚，这里摘抄一下 <a href="https://github.com/tc39/proposal-nullish-coalescing" target="_blank" rel="noopener">tc39:proposal-nullish-coalescing</a> 的例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> headerText <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token operator">?</span><span class="token punctuation">.</span>headerText <span class="token operator">||</span> <span class="token string">'Hello, world!'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// '' 会被当作 false，输出： 'Hello, world!'</span><span class="token keyword">const</span> animationDuration <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token operator">?</span><span class="token punctuation">.</span>animationDuration <span class="token operator">||</span> <span class="token number">300</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0 会被当作 false，输出： 300</span><span class="token keyword">const</span> showSplashScreen <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token operator">?</span><span class="token punctuation">.</span>showSplashScreen <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// False 会被当作 false，输出： true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>照理来说，使用 <code>||</code> 是可以的，但是在上面代码中会有点小问题。比如我们想要获取的 animationDuration 的值为 0，那么由于 0 被当作 false，导致我们最后得到的是默认值 300，这显然不是我们想要的结果。而 <code>??</code> 就是用来解决这个问题的。<br>目前 optional-chaining 和 nullish-coalescing 还在 ecma 标准草案的 stage2 阶段，不过 babel 针对前者已有相关插件实现，更多相关文章可以看：<br><a href="https://segmentfault.com/a/1190000013409955" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013409955</a><br><a href="https://zhuanlan.zhihu.com/p/29296692" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29296692</a><br><a href="https://www.npmjs.com/package/babel-plugin-transform-optional-chaining" target="_blank" rel="noopener">https://www.npmjs.com/package/babel-plugin-transform-optional-chaining</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」前端项目中常见的 CSS 问题</title>
      <link href="/2019/06/18/Trs-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%20CSS%20%E9%97%AE%E9%A2%98/"/>
      <url>/2019/06/18/Trs-%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%20CSS%20%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="https://www.smashingmagazine.com/2018/12/common-css-issues-front-end-projects/" target="_blank" rel="noopener">Common CSS Issues For Front-End Projects</a></li><li>原文作者：Ahmad Shadeed</li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p>快速摘要：近年来，跨浏览器的渲染和交互已经愈加一致。不过，它仍然没有达到完全一致，有很多小问题会让你出错。除了这些问题之外，还有不同的屏幕尺寸、语言偏好和明显的人为错误等不确定因素，我们从中发现了许多会让开发者出错的小问题。</p><hr><p><strong>在浏览器中实现用户界面时，最好是</strong>尽可能地减小这些差异和问题，以便 UI 呈现出预测的样子。记住所有的这些差异是很困难的，所以我列举了一系列常见问题以及解决方案。当你在做一个新项目的时候，可以将其作为一份方便的参考指南。</p><p>我们开始吧。</p><h3 id="1-重置-button-和-input-元素的背景"><a href="#1-重置-button-和-input-元素的背景" class="headerlink" title="1. 重置 button 和 input 元素的背景"></a>1. 重置 <code>button</code> 和 <code>input</code> 元素的背景</h3><p>添加按钮时，重置它的背景，否则在跨浏览器时它的呈现会有所不同。下面的例子分别展示了 Chrome 和 Safari 中的同一个按钮，后者默认会有一个灰色背景。</p><center><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f61d43c4-6a6e-4d9f-8cdc-be1a519b9ee3/button-and-inputs.png"><br><br>(<a style="color:#666;text-decoration:underline;font-size:15px" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f61d43c4-6a6e-4d9f-8cdc-be1a519b9ee3/button-and-inputs.png" target="_blank" rel="noopener">大图预览</a>)<br></center><p>重置背景可以解决这个问题：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">button </span><span class="token punctuation">{</span>    <span class="token property">appearance</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> transparent<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 其它样式 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><iframe id="cp_embed_MzWBYv" src="//codepen.io/shadeed/embed/MzWBYv?height=260&theme-id=dark&slug-hash=MzWBYv&default-tab=css,result" scrolling="no" frameborder="no" height="260" allowtransparency="true" allowfullscreen class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><center style="color:#666;font-size:15px">查看 Ahmad Shadeed（<a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed" target="_blank" rel="noopener">@shadeed</a>）在 <a style="color:#666;text-decoration:underline" href="https://codepen.io" target="_blank" rel="noopener">Codepen</a> 上的代码 <a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed/pen/MzWBYv/" target="_blank" rel="noopener">按钮和输入框</a>。</center><h3 id="2-Overflow-scroll-和-auto"><a href="#2-Overflow-scroll-和-auto" class="headerlink" title="2. Overflow: scroll 和 auto"></a>2. Overflow: <code>scroll</code> 和 <code>auto</code></h3><p>为了限制一个元素的高度并允许用户在其中滚动，添加 <code>overflow: scroll-y</code>。在 macOS 下的 Chrome 中，这看起来不错，但是在 Windows 下的 Chrome 中，滚动条始终存在（即使内容很短）。这是因为 <code>scroll-y</code> 会无视内容，一直显示滚动条。而 <code>overflow: auto</code> 只在需要的时候才会显示滚动条。</p><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/424ab30e-eac3-45c0-b9d0-04763ec6e6cf/overflow-y.png"><br><br><span>左边：macOS 下的 Chrome。右边：Windows 下的 Chrome</span> (<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/424ab30e-eac3-45c0-b9d0-04763ec6e6cf/overflow-y.png" target="_blank" rel="noopener">大图预览</a>)<br></center><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.element</span> </span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">overflow-y</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><iframe id="cp_embed_vQYwXj" src="//codepen.io/shadeed/embed/vQYwXj?height=260&theme-id=dark&slug-hash=vQYwXj&default-tab=css,result" scrolling="no" frameborder="no" height="260" allowtransparency="true" allowfullscreen class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><center style="color:#666;font-size:15px">查看 Ahmad Shadeed（<a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed" target="_blank" rel="noopener">@shadeed</a>）在 <a style="color:#666;text-decoration:underline" href="https://codepen.io" target="_blank" rel="noopener">Codepen</a> 上的代码 <a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed/pen/vQYwXj/" target="_blank" rel="noopener">overflow-y</a>。</center><h3 id="3-添加-flex-wrap"><a href="#3-添加-flex-wrap" class="headerlink" title="3. 添加 flex-wrap"></a>3. 添加 <code>flex-wrap</code></h3><p>要想让一个元素表现得像弹性容器那样，只需添加 <code>display: flex</code>。但是，如果没有添加 <code>flex-wrap</code> ，那么当屏幕尺寸缩小的时候，将会出现水平滚动条。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.wrapper</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.item</span> </span><span class="token punctuation">{</span>    <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">120</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子在大屏幕下表现正常。在移动端下，浏览器将会出现水平滚动条。</p><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6d093ace-fe0a-4e1d-9731-4167b43dc5ff/flex-wrap.jpg"><br><br><span>左边：出现水平滚动条，并且项目没有换行。右边：项目换行，呈两行显示</span> (<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6d093ace-fe0a-4e1d-9731-4167b43dc5ff/flex-wrap.jpg" target="_blank" rel="noopener">大图预览</a>)<br></center><p>解决方法很简单。wrapper 应该在空间不足时让项目换行。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.wrapper</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>    <span class="token property">flex-wrap</span><span class="token punctuation">:</span> wrap<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><iframe id="cp_embed_JejVLG" src="//codepen.io/shadeed/embed/JejVLG?height=260&theme-id=dark&slug-hash=JejVLG&default-tab=css,result" scrolling="no" frameborder="no" height="260" allowtransparency="true" allowfullscreen class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><center style="color:#666;font-size:15px">查看 Ahmad Shadeed（<a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed" target="_blank" rel="noopener">@shadeed</a>）在 <a style="color:#666;text-decoration:underline" href="https://codepen.io" target="_blank" rel="noopener">Codepen</a> 上的代码 <a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed/pen/JejVLG/" target="_blank" rel="noopener">flex-wrap</a>。</center><h3 id="4-当弹性项目数量不定时，不要使用-justify-content-space-between"><a href="#4-当弹性项目数量不定时，不要使用-justify-content-space-between" class="headerlink" title="4. 当弹性项目数量不定时，不要使用 justify-content: space-between"></a>4. 当弹性项目数量不定时，不要使用 <code>justify-content: space-between</code></h3><p>对一个弹性容器应用 <code>justify-content: space-between</code> 时，它会为元素分配空间，使它们互相之间的距离相等。我们的例子中有 8 个卡片项目，看起来没什么问题。如果由于某种原因，项目的数量是 7 呢？第二行的元素看起来将会与第一行的不同。</p><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c36764b1-db7b-4b62-9e54-1265b8058ebf/justify-content.png"><br><br><span>包含 8 个项目的 wrapper</span> (<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c36764b1-db7b-4b62-9e54-1265b8058ebf/justify-content.png" target="_blank" rel="noopener">大图预览</a>)<br><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9f194fe2-73f1-4815-983a-6a8953da7e43/justify-content-less-items.png"><br><br><span>包含 7 个项目的 wrapper</span> (<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9f194fe2-73f1-4815-983a-6a8953da7e43/justify-content-less-items.png" target="_blank" rel="noopener">大图预览</a>)<br></center><iframe id="cp_embed_XyWLLo" src="//codepen.io/shadeed/embed/XyWLLo?height=260&theme-id=dark&slug-hash=XyWLLo&default-tab=css,result" scrolling="no" frameborder="no" height="260" allowtransparency="true" allowfullscreen class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><center style="color:#666;font-size:15px">查看 Ahmad Shadeed（<a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed" target="_blank" rel="noopener">@shadeed</a>）在 <a style="color:#666;text-decoration:underline" href="https://codepen.io" target="_blank" rel="noopener">Codepen</a> 上的代码 <a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed/pen/XyWLLo/" target="_blank" rel="noopener">flex-wrap</a>。</center><p>在这种情况下，使用 CSS 网格将会更加合适。</p><h3 id="5-长词和链接"><a href="#5-长词和链接" class="headerlink" title="5. 长词和链接"></a>5. 长词和链接</h3><p>在手机屏幕上浏览文章的时候，一个长词或者内联链接可能会导致页面出现水平滚动条。使用 CSS 的 <code>word-break</code> 可以防止这个问题。</p><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c6030181-179d-4f28-86cd-d95c11323012/long-words.gif"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c6030181-179d-4f28-86cd-d95c11323012/long-words.gif" target="_blank" rel="noopener">大图预览</a>)<br></center><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.article-content</span> p </span><span class="token punctuation">{</span>    <span class="token property">word-break</span><span class="token punctuation">:</span> break-all<span class="token punctuation">;</span><span class="token punctuation">}</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/965443c4-3be5-4ba9-ba7c-9376da152f6b/long-words-solved.png"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/965443c4-3be5-4ba9-ba7c-9376da152f6b/long-words-solved.png" target="_blank" rel="noopener">大图预览</a>)<br></center><p><a href="https://css-tricks.com/snippets/css/prevent-long-urls-from-breaking-out-of-container/" target="_blank" rel="noopener">详情查看 CSS-Tricks</a> 。</p><h3 id="6-透明渐变"><a href="#6-透明渐变" class="headerlink" title="6. 透明渐变"></a>6. 透明渐变</h3><p>当使用透明起点和终点添加渐变的时候，在 Safari 下会呈现一片漆黑。这是因为 Safari 无法识别关键字 <code>transparent</code>。通过使用 <code>rgba(0, 0, 0, 0)</code> 来替代它，我们可以达到预期的效果。注意下面的截图：</p><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/756d8b47-21c4-4b75-8b99-8805ea880b24/transparent-gradient.png"><br><br><span>顶部： Chrome 70.底部：Safari 12</span>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/756d8b47-21c4-4b75-8b99-8805ea880b24/transparent-gradient.png" target="_blank" rel="noopener">大图预览</a>)<br></center><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.section-hero</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>transparent, <span class="token hexcode">#d7e0ef</span><span class="token punctuation">)</span>, <span class="token hexcode">#527ee0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 其它样式 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该替换为：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.section-hero</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span><span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0</span>,<span class="token number">0</span><span class="token punctuation">)</span>, <span class="token hexcode">#d7e0ef</span><span class="token punctuation">)</span>, <span class="token hexcode">#527ee0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 其它样式 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-CSS-网格布局中关于-auto-fit-和-auto-fill-差异的误解"><a href="#7-CSS-网格布局中关于-auto-fit-和-auto-fill-差异的误解" class="headerlink" title="7. CSS 网格布局中关于 auto-fit 和 auto-fill 差异的误解"></a>7. CSS 网格布局中关于 <code>auto-fit</code> 和 <code>auto-fill</code> 差异的误解</h3><p>在 CSS 网格布局中，<code>repeat</code> 函数可以在不使用媒体查询的情况下创建响应式列布局。为此，可以使用 <code>auto-fill</code> 或者 <code>auto-fit</code>。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.wrapper</span> </span><span class="token punctuation">{</span>    <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>auto-fill, <span class="token function">minmax</span><span class="token punctuation">(</span><span class="token number">100</span>px, <span class="token number">1</span>fr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/72b6190c-a54e-4ab3-97fa-a83c1bd96527/auto-fill-vs-auto-fit.png"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/72b6190c-a54e-4ab3-97fa-a83c1bd96527/auto-fill-vs-auto-fit.png" target="_blank" rel="noopener">大图预览</a>)<br></center><p>简而言之，<code>auto-fill</code> 将会在不扩展列宽度的情况下对它们进行排列，而<code>auto-fit</code> 则会在存在空列的时候使其宽度塌陷为 0。Sara Soueidan 写了一篇<a href="https://css-tricks.com/auto-sizing-columns-css-grid-auto-fill-vs-auto-fit/" target="_blank" rel="noopener">不错的文章</a>讨论过这个问题。</p><h3 id="8-当视窗高度不足时将元素固定在屏幕顶部"><a href="#8-当视窗高度不足时将元素固定在屏幕顶部" class="headerlink" title="8. 当视窗高度不足时将元素固定在屏幕顶部"></a>8. 当视窗高度不足时将元素固定在屏幕顶部</h3><p>如果你在视窗不够高的时候将一个元素固定在屏幕顶部，会发生什么事呢？很简单：它将占用屏幕空间，最终导致可供用户浏览网站的垂直区域变得很小、很不舒服，影响他们的体验。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">min-height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>    <span class="token selector"><span class="token class">.site-header</span> </span><span class="token punctuation">{</span>        <span class="token property">position</span><span class="token punctuation">:</span> sticky<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 其它样式 */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，我们让浏览器只在视窗高度等于或大于 500 像素的时候才固定顶部。</p><p>还有一点很重要：使用 <code>position: sticky</code> 的时候，除非指定 <code>top</code> 属性，否则它不会生效。</p><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ebf1d848-4f96-4dc6-999c-5b06d06237d6/fixed-header.gif"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ebf1d848-4f96-4dc6-999c-5b06d06237d6/fixed-header.gif" target="_blank" rel="noopener">大图预览</a>)<br></center><iframe id="cp_embed_oQLYmg" src="//codepen.io/shadeed/embed/oQLYmg?height=260&theme-id=dark&slug-hash=oQLYmg&default-tab=css,result" scrolling="no" frameborder="no" height="260" allowtransparency="true" allowfullscreen class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><center style="color:#666;font-size:15px">查看 Ahmad Shadeed（<a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed" target="_blank" rel="noopener">@shadeed</a>）在 <a style="color:#666;text-decoration:underline" href="https://codepen.io" target="_blank" rel="noopener">Codepen</a> 上的代码 <a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed/pen/oQLYmg/" target="_blank" rel="noopener">垂直媒体查询：固定顶部</a>。</center><h3 id="9-为图片设置-max-width"><a href="#9-为图片设置-max-width" class="headerlink" title="9. 为图片设置 max-width"></a>9. 为图片设置 <code>max-width</code></h3><p>添加图片时，定义 <code>max-width: 100%</code>，这样图片会在屏幕较小的时候改变大小。否则浏览器将会显示水平滚动条。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">img </span><span class="token punctuation">{</span>    <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="10-使用-CSS-网格定义-main-和-aside-元素"><a href="#10-使用-CSS-网格定义-main-和-aside-元素" class="headerlink" title="10. 使用 CSS 网格定义 main 和 aside 元素"></a>10. 使用 CSS 网格定义 <code>main</code> 和 <code>aside</code> 元素</h3><p>CSS 网格可用于定义布局中的 <code>main</code> 部分和 <code>aside</code> 部分，这是 CSS 网格的绝佳用途。问题是，即使 <code>aside</code> 是空的，它的高度也会和 <code>main</code> 的高度相等。</p><p>要修复这个问题，可以让 <code>aside</code> 元素与其父元素的起点对齐，这样它的高度就不会扩展了。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.wrapper</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>    <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">12</span>, <span class="token function">minmax</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">1</span>fr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">grid-gap</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">// align-self 将会让 aside 元素与其父元素的起点对齐。aside </span><span class="token punctuation">{</span>    <span class="token property">grid-column</span><span class="token punctuation">:</span> <span class="token number">1</span> / <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token property">grid-row</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token property">align-self</span><span class="token punctuation">:</span> start<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">main </span><span class="token punctuation">{</span>    <span class="token property">grid-column</span><span class="token punctuation">:</span> <span class="token number">4</span> / <span class="token number">13</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/80f4372d-8642-4865-913d-2df7634405a9/main-and-aside.png"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/80f4372d-8642-4865-913d-2df7634405a9/main-and-aside.png" target="_blank" rel="noopener">大图预览</a>)<br></center><iframe id="cp_embed_yQJgXr" src="//codepen.io/shadeed/embed/yQJgXr?height=260&theme-id=dark&slug-hash=yQJgXr&default-tab=css,result" scrolling="no" frameborder="no" height="260" allowtransparency="true" allowfullscreen class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><center style="color:#666;font-size:15px">查看 Ahmad Shadeed（<a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed" target="_blank" rel="noopener">@shadeed</a>）在 <a style="color:#666;text-decoration:underline" href="https://codepen.io" target="_blank" rel="noopener">Codepen</a> 上的代码 <a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed/pen/yQJgXr/" target="_blank" rel="noopener">main 和 aside</a>。</center><h3 id="11-给一个-SVG-添加-fill"><a href="#11-给一个-SVG-添加-fill" class="headerlink" title="11. 给一个 SVG 添加 fill"></a>11. 给一个 SVG 添加 <code>fill</code></h3><p>使用 SVG 时，如果在 SVG 内部添加 <code>fill</code>，有时候它可能不会如预期的那样生效。要修复这个问题，要么移除 SVG 自身的 <code>fill</code> 属性，要么覆盖 <code>fill: color</code>。</p><p>举个例子：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.some-icon</span> </span><span class="token punctuation">{</span>    <span class="token property">fill</span><span class="token punctuation">:</span> <span class="token hexcode">#137cbf</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果 SVG 有一个内联 fill 的话，这段代码将不会生效。应该替换为：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.some-icon</span> path </span><span class="token punctuation">{</span>    <span class="token property">fill</span><span class="token punctuation">:</span> <span class="token hexcode">#137cbf</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="12-使用伪元素"><a href="#12-使用伪元素" class="headerlink" title="12. 使用伪元素"></a>12. 使用伪元素</h3><p>无论何时，我都很喜欢使用伪元素。伪元素为我们提供了一种创建假元素的方法，主要用来装饰，同时又无需将其添加到 HTML 中。</p><p>使用它们的时候，开发者可能会忘记做下面的事情：</p><ul><li>添加 <code>content: &quot;&quot;</code> 属性，</li><li>在没有定义 <code>display</code> 属性的情况下设置它们的 <code>width</code> 和 <code>height</code></li></ul><p>下面的例子中，我们有一个标题，其标记是一个伪元素。必须给元素添加 <code>content: &quot;&quot;</code> 属性，同时还要为它设置 <code>display: inline-block</code> ，以使 <code>width</code> 和 <code>height</code> 像预期的那样生效。</p><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2d68e677-dd33-4714-9576-8e6031bb63f0/hiding-pseudo-element.gif"><br><br>(<a style="color:#666;text-decoration:underline" href="hhttps://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2d68e677-dd33-4714-9576-8e6031bb63f0/hiding-pseudo-element.gif" target="_blank" rel="noopener">大图预览</a>)<br></center><h3 id="13-使用-display-inline-block-时奇怪的空隙"><a href="#13-使用-display-inline-block-时奇怪的空隙" class="headerlink" title="13. 使用 display: inline-block 时奇怪的空隙"></a>13. 使用 <code>display: inline-block</code> 时奇怪的空隙</h3><p>给两个或两个以上的元素设置 <code>display: inline-block</code> 或者 <code>display: inline</code> ，将会导致它们之间产生一个微小的空隙。原因是浏览器会将元素当作字词去解释，从而给每个元素之间添加一个字符的空隙。</p><p>下面的例子中，每个项目的右侧都有一个 <code>8px</code> 的空隙，但是使用 <code>display: inline-block</code> 而产生的小空隙将会使其变为 <code>12px</code>，这不是我们想要的效果。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">li<span class="token pseudo-class">:not(:last-child)</span> </span><span class="token punctuation">{</span>    <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">8</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a9c8f61f-75b9-4c63-8f7a-b4a95b472e14/inline-block-before.jpg"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a9c8f61f-75b9-4c63-8f7a-b4a95b472e14/inline-block-before.jpg" target="_blank" rel="noopener">大图预览</a>)<br></center><p>通过给父元素设置 <code>font-size: 0</code> 可以简单地解决这个问题。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">ul </span><span class="token punctuation">{</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">li </span><span class="token punctuation">{</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">16</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 应该在这里重新设置字体大小，因为它会从父元素继承 `font-size: 0`。*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f94d53ad-2aaf-4960-bd66-30b0abbaefeb/inline-block-after.jpg"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f94d53ad-2aaf-4960-bd66-30b0abbaefeb/inline-block-after.jpg" target="_blank" rel="noopener">大图预览</a>)<br></center><iframe id="cp_embed_qQYPxV" src="//codepen.io/shadeed/embed/qQYPxV?height=260&theme-id=dark&slug-hash=qQYPxV&default-tab=css,result" scrolling="no" frameborder="no" height="260" allowtransparency="true" allowfullscreen class="cp_embed_iframe" style="width:100%;overflow:hidden"></iframe><center style="color:#666;font-size:15px">查看 Ahmad Shadeed（<a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed" target="_blank" rel="noopener">@shadeed</a>）在 <a style="color:#666;text-decoration:underline" href="https://codepen.io" target="_blank" rel="noopener">Codepen</a> 上的代码 <a style="color:#666;text-decoration:underline" href="https://codepen.io/shadeed/pen/qQYPxV/" target="_blank" rel="noopener">内联块状空隙</a>。</center><h3 id="14-分配一个标签元素给一个输入框时，添加-for-quot-ID-quot"><a href="#14-分配一个标签元素给一个输入框时，添加-for-quot-ID-quot" class="headerlink" title="14. 分配一个标签元素给一个输入框时，添加 for=&quot;ID&quot;"></a>14. 分配一个标签元素给一个输入框时，添加 <code>for=&quot;ID&quot;</code></h3><p>使用表单元素时，确保所有的 <code>label</code> 元素都分配到了一个 ID。这将提高它们的可访问性，点击的时候，相关的输入框将获得焦点。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emailAddress<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Email address:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>emailAddress<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/15bc8dc7-2aec-48e7-abc1-49c9a56e3a0c/label-focus.gif"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/15bc8dc7-2aec-48e7-abc1-49c9a56e3a0c/label-focus.gif" target="_blank" rel="noopener">大图预览</a>)<br></center><h3 id="15-交互式-HTML-元素的字体不生效"><a href="#15-交互式-HTML-元素的字体不生效" class="headerlink" title="15. 交互式 HTML 元素的字体不生效"></a>15. 交互式 HTML 元素的字体不生效</h3><p>给整个文档设置字体的时候，字体并不会应用于诸如 <code>input</code>， <code>button</code> <code>select</code> 和 <code>textarea</code> 这些元素上。默认情况下，它们并不会继承文档字体，因为浏览器给它们应用了系统字体。</p><p>要修复这个问题，直接设置字体属性：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">input, button, select, textarea </span><span class="token punctuation">{</span>    <span class="token property">font-family</span><span class="token punctuation">:</span> your-awesome-font-name<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="16-水平滚动条"><a href="#16-水平滚动条" class="headerlink" title="16. 水平滚动条"></a>16. 水平滚动条</h3><p>有些元素的宽度可能会导致出现一个水平滚动条。</p><p>要找到问题的根源，最简单的方法就是使用 CSS outline。Addy Osmani 写了一个方便的<a href="https://gist.github.com/addyosmani/fd3999ea7fce242756b1" target="_blank" rel="noopener">脚本</a> 。将其添加到浏览器的控制台，页面上所有元素的轮廓都会显示出来。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forEach<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token function">$$</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    a<span class="token punctuation">.</span>style<span class="token punctuation">.</span>outline <span class="token operator">=</span>    <span class="token string">"1px solid #"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7da947a3-15ef-4685-a4d0-a7f60959108c/outline-page.png"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7da947a3-15ef-4685-a4d0-a7f60959108c/outline-page.png" target="_blank" rel="noopener">大图预览</a>)<br></center><h3 id="17-压缩或拉伸图片"><a href="#17-压缩或拉伸图片" class="headerlink" title="17. 压缩或拉伸图片"></a>17. 压缩或拉伸图片</h3><p>用 CSS 调整一张图片的大小时，如果纵横比与图片的宽高不一致，则图片会被压缩或拉伸。</p><p>解决方法很简单：使用 CSS 的 <code>object-fit</code>。它的功能和给背景图片设置 <code>background-size: cover</code> 类似。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">img </span><span class="token punctuation">{</span>    <span class="token property">object-fit</span><span class="token punctuation">:</span> cover<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f0f0f149-327b-4b7a-a440-31a451c6bd84/css-object-fit.png"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f0f0f149-327b-4b7a-a440-31a451c6bd84/css-object-fit.png" target="_blank" rel="noopener">大图预览</a>)<br></center><p><code>object-fit</code> 并非百试百灵。一些图片必须在不裁剪或者不调整大小的情况下显示，并且某些平台会强制用户以特定的尺寸裁剪或上传图片。例如，Dribbble 规定上传的缩略图尺寸为 800 x 600 像素。</p><h3 id="18-为-input-添加正确的-type"><a href="#18-为-input-添加正确的-type" class="headerlink" title="18. 为 input 添加正确的 type"></a>18. 为 <code>input</code> 添加正确的 <code>type</code></h3><p>为 <code>input</code> 使用正确的 <code>type</code>。这将改善移动端的用户体验，并使用户更容易访问。</p><p>这是部分 HTML：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Full name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Email<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>phone<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Phone<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tel<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>phone<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个输入框分别获取焦点时，看起来是这样的：</p><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7d3404c2-b73c-4e85-af46-968223da8393/input-mobile.png"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7d3404c2-b73c-4e85-af46-968223da8393/input-mobile.png" target="_blank" rel="noopener">大图预览</a>)<br></center><h3 id="19-RTL-布局中的手机号码"><a href="#19-RTL-布局中的手机号码" class="headerlink" title="19. RTL 布局中的手机号码"></a>19. RTL 布局中的手机号码</h3><p>在一个从右到左的布局中添加诸如 <code>+ 972-123555777</code> 的手机号码时，加号将会位于号码末尾。要修复这个问题，可以重新指定手机号码的方向。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">p </span><span class="token punctuation">{</span>    <span class="token property">direction</span><span class="token punctuation">:</span> ltr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><center style="color:#666;font-size:15px"><br><img src="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3564b48a-3b11-4dfc-9676-dc7f6175d9be/phone-number-rtl.png"><br><br>(<a style="color:#666;text-decoration:underline" href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3564b48a-3b11-4dfc-9676-dc7f6175d9be/phone-number-rtl.png" target="_blank" rel="noopener">大图预览</a>)<br></center><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这里提到的所有问题都是我在前端开发工作中最常遇到的。我的目标是在开发 web 项目时定期检查这份清单。</p><p>你在 CSS 中有没有经常遇到什么问题呢？欢迎在评论区分享！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」什么是抽象语法树</title>
      <link href="/2019/06/15/Trs-%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/"/>
      <url>/2019/06/15/Trs-%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91-1.jpg" alt=""><a id="more"></a></p><blockquote><ul><li>原文地址：<a href="https://blog.bitsrc.io/what-is-an-abstract-syntax-tree-7502b71bde27?" target="_blank" rel="noopener">What is an Abstract Syntax Tree</a></li><li>原文作者：Chidume Nnamdi</li><li>译者：Chor</li></ul></blockquote><p>AST 是抽象语法树的缩写词，表示编程语言的语句和表达式中生成的 token。有了 AST，解释器或编译器就可以生成机器码或者对一条指令求值。</p><p><strong>小贴士</strong>: 通过使用 <a href="https://github.com/teambit/bit" target="_blank" rel="noopener"><strong>Bit</strong></a>，你可以将任意的 JS 代码转换为一个可在项目和应用中共享、使用和同步的 API，从而更快地构建并重用更多代码。试一下吧。</p><p>假设我们有下面这条简单的表达式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用 AST 来表示的话，它是这样的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">+</span> BinaryExpression <span class="token operator">-</span> type<span class="token punctuation">:</span> <span class="token operator">+</span> <span class="token operator">-</span> left_value<span class="token punctuation">:</span>   LiteralExpr<span class="token punctuation">:</span>   value<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token operator">-</span> right_vaue<span class="token punctuation">:</span>  LiteralExpr<span class="token punctuation">:</span>   value<span class="token punctuation">:</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>诸如 <code>if</code> 的语句则可以像下面这样表示：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">></span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> d  <span class="token operator">=</span> <span class="token number">90</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">}</span>IfStatement <span class="token operator">-</span> condition  <span class="token operator">+</span> BinaryExpression   <span class="token operator">-</span> type<span class="token punctuation">:</span> <span class="token operator">></span>   <span class="token operator">-</span> left_value<span class="token punctuation">:</span> <span class="token number">2</span>   <span class="token operator">-</span> right_value<span class="token punctuation">:</span> <span class="token number">6</span> <span class="token operator">-</span> body  <span class="token punctuation">[</span>    <span class="token operator">-</span> Assign        <span class="token operator">-</span> left<span class="token punctuation">:</span> <span class="token string">'d'</span><span class="token punctuation">;</span>        <span class="token operator">-</span> right<span class="token punctuation">:</span>             LiteralExpr<span class="token punctuation">:</span>            <span class="token operator">-</span> value<span class="token punctuation">:</span> <span class="token number">90</span>    <span class="token operator">-</span> MethodCall<span class="token punctuation">:</span>         <span class="token operator">-</span> instanceName<span class="token punctuation">:</span> console         <span class="token operator">-</span> methodName<span class="token punctuation">:</span> log         <span class="token operator">-</span> args<span class="token punctuation">:</span> <span class="token punctuation">[</span>         <span class="token punctuation">]</span>  <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这告诉解释器如何解释语句，同时告诉编译器如何生成语句对应的代码。</p><p>看看这条表达式： <code>1 + 2</code>。我们的大脑判定这是一个将左值和右值相加的加法运算。现在，为了让计算机像我们的大脑那样工作，我们必须以类似于大脑看待它的形式来表示它。</p><p>我们用一个类来表示，其中的属性告诉解释器运算的全部内容、左值和右值。因为一个二元运算涉及两个值，所以我们给这个类命名为 <code>Binary</code>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Binary</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> operator<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left          <span class="token keyword">this</span><span class="token punctuation">.</span>operator <span class="token operator">=</span> operator          <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例化期间，我们将会把 <code>1</code> 传给第一个属性，把 <code>ADD</code> 传给第二个属性，把 <code>2</code> 传给第三个属性：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们把它传递给解释器的时候，解释器认为这是一个二元运算，接着检查操作符，认为这是一个加法运算，紧接着继续请求实例中的 <code>left</code> 值和 <code>right</code> 值，并将二者相加：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> binExpr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>binExpr<span class="token punctuation">.</span>operator <span class="token operator">==</span> <span class="token string">'ADD'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> binExpr<span class="token punctuation">.</span>left <span class="token operator">+</span> binExpr<span class="token punctuation">.</span>right  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 返回 `3` </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看，AST 可以像大脑那样执行表达式和语句。</p><p>单数字、字符串、布尔值等都是表达式，它们可以在 AST 中表示并求值。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token number">23343</span><span class="token boolean">false</span><span class="token boolean">true</span><span class="token string">"nnamdi"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>拿 1 举例：<br><code>1</code><br>我们在 AST 的 Literal（字面量） 类中来表示它。一个字面量就是一个单词或者数字，Literal 类用一个属性来保存它：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Literal</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以像下面这样表示 Literal 中的 1：<br><code>new Literal(1)</code><br>当解释器对它求值时，它会请求 Literal 实例中 <code>value</code> 属性的值：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> oneLit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  oneLit<span class="token punctuation">.</span>value  <span class="token comment" spellcheck="true">// `1`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在我们的二元表达式中，我们直接传递了值<br><code>new Binary(&#39;1&#39;, &#39;ADD&#39;, &#39;2&#39;)</code><br>这其实并不合理。因为正如我们在上面看到的，<code>1</code> 和 <code>2</code> 都是一条表达式，一条基本的表达式。作为字面量，它们同样需要被求值，并且用 Literal 类来表示。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> oneLit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> twoLit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此，二元表达式会将 <code>oneLit</code> 和 <code>twoLit</code> 分别作为左属性和右属性。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// ...  </span><span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span>oneLit<span class="token punctuation">,</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> twoLit<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在求值阶段，左属性和右属性同样需要进行求值，以获得各自的值：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> oneLit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> twoLit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> binExpr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span>oneLit<span class="token punctuation">,</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> twoLit<span class="token punctuation">)</span><span class="token keyword">if</span><span class="token punctuation">(</span>binExpr<span class="token punctuation">.</span>operator <span class="token operator">==</span> <span class="token string">'ADD'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> binExpr<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value <span class="token operator">+</span> binExpr<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 返回 `3` </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其它语句在 AST 中也大多是用二元来表示的，例如 if 语句。</p><p>我们知道，在 if 语句中，只有条件为真的时候代码块才会执行。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">9</span> <span class="token operator">></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Yay!!'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的 if 语句中，代码块执行的条件是 <code>9</code> 必须大于 <code>7</code>，之后我们可以在终端上看到输出 <code>Yay!!</code>。</p><p>为了让解释器或者编译器这样执行，我们将会在一个包含 <code>condition</code>、 <code>body</code> 属性的类中来表示它。<code>condition</code> 保存着解析后必须为真的条件，<code>body</code> 则是一个数组，它包含着 if 代码块中的所有语句。解释器将会遍历该数组并执行里面的语句。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">IfStmt</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> body<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>condition <span class="token operator">=</span> condition          <span class="token keyword">this</span><span class="token punctuation">.</span>body <span class="token operator">=</span> body      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，让我们在 IfStmt 类中表示下面的语句</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">9</span> <span class="token operator">></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Yay!!'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>条件是一个二元运算，这将表示为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cond <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"GREATER"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就像之前一样，但愿你还记得？这回是一个 GREATER 运算。</p><p>if 语句的代码块只有一条语句：一个函数调用。函数调用同样可以在一个类中表示，它包含的属性有：用于指代所调用函数的 <code>name</code> 以及用于表示传递的参数的 <code>args</code>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">FuncCall</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name          <span class="token keyword">this</span><span class="token punctuation">.</span>args <span class="token operator">=</span> args      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，log(“Yay!!”) 调用可以表示为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> logFuncCall <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FuncCall</span><span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，把这些组合在一起，我们的 if 语句就可以表示为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> cond <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"GREATER"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> logFuncCall <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FuncCall</span><span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> ifStmt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IfStmt</span><span class="token punctuation">(</span>cond<span class="token punctuation">,</span> <span class="token punctuation">[</span>      logFuncCall  <span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释器可以像下面这样解释 if 语句：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> ifStmt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IfStmt</span><span class="token punctuation">(</span>cond<span class="token punctuation">,</span> <span class="token punctuation">[</span>      logFuncCall  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">interpretIfStatement</span><span class="token punctuation">(</span>ifStmt<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">evalExpr</span><span class="token punctuation">(</span>ifStmt<span class="token punctuation">.</span>conditon<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> stmt <span class="token keyword">of</span> ifStmt<span class="token punctuation">.</span>body<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token function">evalStmt</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token function">interpretIfStatement</span><span class="token punctuation">(</span>ifStmt<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：<br><code>Yay!!</code></p><p>因为 <code>9 &gt; 7</code> :)</p><p>我们通过检查 <code>condition</code> 解析后是否为真来解释 if 语句。如果为真，我们遍历 <code>body</code> 数组并执行里面的语句。</p><h3 id="执行-AST"><a href="#执行-AST" class="headerlink" title="执行 AST"></a>执行 AST</h3><p>使用访问者模式对 AST 进行求值。访问者模式是设计模式的一种，允许一组对象的算法在一个地方实现。</p><p>ASTs，Literal，Binary，IfStmnt 是一组相关的类，每一个类都需要携带方法以使解释器获得它们的值或者对它们求值。</p><p>访问者模式让我们能够创建单个类，并在类中编写 AST 的实现，将类提供给 AST。每个 AST 都有一个公有的方法，解释器会通过实现类实例对其进行调用，之后 AST 类将在传入的实现类中调用相应的方法，从而计算其 AST。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Literal</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value      <span class="token punctuation">}</span>    <span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> visitor<span class="token punctuation">.</span><span class="token function">visitLiteral</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Binary</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> operator<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left          <span class="token keyword">this</span><span class="token punctuation">.</span>operator <span class="token operator">=</span> operator          <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right      <span class="token punctuation">}</span>    <span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> visitor<span class="token punctuation">.</span><span class="token function">visitBinary</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看，AST Literal 和 Binary 都有访问方法，但是在方法里面，它们调用访问者实例的方法来对自身求值。Literal 调用 visitLiteral，Binary 则调用 <code>visitBinary</code>。</p><p>现在，将 Vistor 作为实现类，它将实现 visitLiteral 和 visitBinary 方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>    <span class="token function">visitBinary</span><span class="token punctuation">(</span>binExpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// ...  </span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'not yet implemented'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token function">visitLiteral</span><span class="token punctuation">(</span>litExpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// ...  </span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'not yet implemented'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>visitBinary 和 visitLiteral 在 Vistor 类中将会有自己的实现。因此，当一个解释器想要解释一个二元表达式时，它将调用二元表达式的访问方法，并传递 Vistor 类的实例：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> binExpr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> visitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Visitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>binExpr<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>访问方法将调用访问者的 visitBinary，并将其传递给方法，之后打印 <code>not yet implemented</code>。这称为双重分派。</p><ol><li>调用 <code>Binary</code> 的访问方法。</li><li>它 (<code>Binary</code>) 反过来调用 <code>Visitor</code> 实例的<code>visitBinary</code>。</li></ol><p>我们把 visitLiteral 的完整代码写一下。由于 Literal 实例的 value 属性保存着值，所以这里只需返回这个值就好：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>    <span class="token function">visitBinary</span><span class="token punctuation">(</span>binExpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// ...  </span>        <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'not yet implemented'</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token function">visitLiteral</span><span class="token punctuation">(</span>litExpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> litExpr<span class="token punctuation">.</span>value      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 visitBinary，我们知道 Binary 类有操作符、左属性和右属性。操作符表示将对左右属性进行的操作。我们可以编写实现如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>    <span class="token function">visitBinary</span><span class="token punctuation">(</span>binExpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">switch</span><span class="token punctuation">(</span>binExpr<span class="token punctuation">.</span>operator<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">case</span> <span class="token string">'ADD'</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true">// ...  </span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token function">visitLiteral</span><span class="token punctuation">(</span>litExpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> litExpr<span class="token punctuation">.</span>value      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，左值和右值都是表达式，可能是字面量表达式、二元表达式、调用表达式或者其它的表达式。我们并不能确保二元运算的左右两边总是字面量。每一个表达式必须有一个用于对表达式求值的访问方法，因此在上面的 visitBinary 方法中，我们通过调用各自对应的 <code>visit</code> 方法对 Binary 的左属性和右属性进行求值：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>    <span class="token function">visitBinary</span><span class="token punctuation">(</span>binExpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">switch</span><span class="token punctuation">(</span>binExpr<span class="token punctuation">.</span>operator<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">case</span> <span class="token string">'ADD'</span><span class="token punctuation">:</span>                  <span class="token keyword">return</span> binExpr<span class="token punctuation">.</span>left<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">+</span> binExpr<span class="token punctuation">.</span>right<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token function">visitLiteral</span><span class="token punctuation">(</span>litExpr<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> litExpr<span class="token punctuation">.</span>value      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，无论左值和右值保存的是哪一种表达式，最后都可以进行传递。</p><p>因此，如果我们有下面这些语句:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> oneLit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> twoLit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> binExpr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span>oneLit<span class="token punctuation">,</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> twoLit<span class="token punctuation">)</span>  <span class="token keyword">const</span> visitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Visitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>binExpr<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，二元运算保存的是字面量。</p><p>访问者的 <code>visitBinary</code> 将会被调用，同时将 binExpr 传入，在 Vistor 类中，<code>visitBinary</code> 将 oneLit 作为左值，将 twoLit 作为右值。由于 oneLit 和 twoLit 都是 Literal 的实例，因此它们的访问方法会被调用，同时将 Visitor 类传入。对于 oneLit，其 Literal 类内部又会调用 Vistor 类的 visitLiteral 方法，并将 <code>oneLit</code> 传入，而 Vistor 中的 visitLiteral 方法返回 Literal 类的 value 属性，也就是 <code>1</code>。同理，对于 twoLit 来说，返回的是 <code>2</code>。</p><p>因为执行了 switch 语句中的 <code>case &#39;ADD&#39;</code>，所以返回的值会相加，最后返回 3。</p><p>如果我们将 <code>binExpr.visit(visitor)</code> 传给 <code>console.log</code>，它将会打印 <code>3</code></p><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>binExpr<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如下，我们传递一个 3 分支的二元运算：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先，我们选择 <code>1 + 2</code>，那么其结果将作为左值，即 <code>+ 3</code>。</p><p>上述可以用 Binary 类表示为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Binary</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，右值不是字面量，而是一个二元表达式。所以在执行加法运算之前，它必须先对这个二元表达式求值，并将其结果作为最终求值时的右值。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> oneLit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> threeLit <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token keyword">const</span> twoLit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">const</span> binExpr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Binary</span><span class="token punctuation">(</span>twoLit<span class="token punctuation">,</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> threeLit<span class="token punctuation">)</span>  <span class="token keyword">const</span> binExpr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Binary</span> <span class="token punctuation">(</span>oneLit<span class="token punctuation">,</span> <span class="token string">'ADD'</span><span class="token punctuation">,</span> binExpr2<span class="token punctuation">)</span><span class="token keyword">const</span> visitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Visitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">log</span><span class="token punctuation">(</span>binExpr1<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加-if-语句"><a href="#添加-if-语句" class="headerlink" title="添加 if 语句"></a>添加 <code>if</code> 语句</h3><p>将 <code>if</code> 语句带到等式中。为了对一个 if 语句求值，我们将会给 IfStmt 类添加一个 <code>visit</code> 方法，之后它将调用 visitIfStmt 方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">IfStmt</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> body<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>condition <span class="token operator">=</span> condition          <span class="token keyword">this</span><span class="token punctuation">.</span>body <span class="token operator">=</span> body      <span class="token punctuation">}</span>    <span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> visitor<span class="token punctuation">.</span><span class="token function">visitIfStmt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>见识到访问者模式的威力了吗？我们向一些类中新增了一个类，对应地只需要添加相同的访问方法即可，而这将调用它位于 Vistor 类中的对应方法。这种方式将不会破坏或者影响到其它的相关类，访问者模式让我们遵循了开闭原则。</p><p>因此，我们在 Vistor 类中实现 <code>visitIfStmt</code>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// ...</span>    <span class="token function">visitIfStmt</span><span class="token punctuation">(</span>ifStmt<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>ifStmt<span class="token punctuation">.</span>condition<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> stmt <span class="token keyword">of</span> ifStmt<span class="token punctuation">.</span>body<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  stmt<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为条件是一个表达式，所以我们调用它的访问方法对其进行求值。我们使用 JS 中的 if 语句检查返回值，如果为真，则遍历语句的代码块 <code>ifStmt.body</code>，通过调用 <code>visit</code> 方法并传入 Vistor，对数组中每一条语句进行求值。</p><p>因此我们可以翻译出这条语句：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">67</span> <span class="token operator">></span> <span class="token number">90</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="添加函数调用和函数声明"><a href="#添加函数调用和函数声明" class="headerlink" title="添加函数调用和函数声明"></a>添加函数调用和函数声明</h3><p>接着来添加一个函数调用。我们已经有一个对应的类了：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">FuncCall</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name          <span class="token keyword">this</span><span class="token punctuation">.</span>args <span class="token operator">=</span> args      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加一个访问方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">FuncCall</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name          <span class="token keyword">this</span><span class="token punctuation">.</span>args <span class="token operator">=</span> args      <span class="token punctuation">}</span>    <span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> visitor<span class="token punctuation">.</span><span class="token function">visitFuncCall</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给 <code>Visitor</code> 类添加 <code>visitFuncCall</code> 方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// ...</span>    <span class="token function">visitFuncCall</span><span class="token punctuation">(</span>funcCall<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">const</span> funcName <span class="token operator">=</span> funcCall<span class="token punctuation">.</span>name          <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> expr <span class="token keyword">of</span> funcCall<span class="token punctuation">.</span>args<span class="token punctuation">)</span>              args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// ...  </span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个问题。除了内置函数之外，还有自定义函数，我们需要为后者创建一个“容器”，并在里面通过函数名保存和引用该函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> FuncStore <span class="token operator">=</span> <span class="token punctuation">(</span>      <span class="token keyword">class</span> <span class="token class-name">FuncStore</span> <span class="token punctuation">{</span>        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token function">setFunc</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> body<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> body<span class="token punctuation">)</span>          <span class="token punctuation">}</span>        <span class="token function">getFunc</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FuncStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>FuncStore</code> 保存着函数，并从一个 <code>Map</code> 实例中取回这些函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// ...</span>    <span class="token function">visitFuncCall</span><span class="token punctuation">(</span>funcCall<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">const</span> funcName <span class="token operator">=</span> funcCall<span class="token punctuation">.</span>name          <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> expr <span class="token keyword">of</span> funcCall<span class="token punctuation">.</span>args<span class="token punctuation">)</span>              args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>funcName <span class="token operator">==</span> <span class="token string">"log"</span><span class="token punctuation">)</span>              console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>FuncStore<span class="token punctuation">.</span><span class="token function">getFunc</span><span class="token punctuation">(</span>funcName<span class="token punctuation">)</span><span class="token punctuation">)</span>              FuncStore<span class="token punctuation">.</span><span class="token function">getFunc</span><span class="token punctuation">(</span>funcName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>stmt <span class="token operator">=</span><span class="token operator">></span> stmt<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看下我们做了什么。如果函数名 <code>funcName</code>（记住，<code>FuncCall</code> 类将函数名保存在 <code>name</code> 属性中）为 <code>log</code>，则运行 JS <code>console.log(...)</code>，并传参给它。如果我们在函数保存中找到了函数，那么就对该函数体进行遍历，依次访问并执行。</p><p>现在看看怎么把我们的函数声明放进函数保存中。</p><p>函数声明以 <code>fucntion</code> 开头。一般的函数结构是这样的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">function_name</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// function body  </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因此，我们可以在一个类中用属性表示一个函数声明：name 保存函数函数名，body 则是一个数组，保存函数体中的语句：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">FunctionDeclaration</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> body<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name          <span class="token keyword">this</span><span class="token punctuation">.</span>body <span class="token operator">=</span> body      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们添加一个访问方法，该方法在 Vistor 中被称为 visitFunctionDeclaration：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">FunctionDeclaration</span> <span class="token punctuation">{</span>      <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> body<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name          <span class="token keyword">this</span><span class="token punctuation">.</span>body <span class="token operator">=</span> body      <span class="token punctuation">}</span>    <span class="token function">visit</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> visitor<span class="token punctuation">.</span><span class="token function">visitFunctionDeclaration</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Visitor 中：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// ...</span>    <span class="token function">visitFunctionDeclaration</span><span class="token punctuation">(</span>funcDecl<span class="token punctuation">)</span> <span class="token punctuation">{</span>          FuncStore<span class="token punctuation">.</span><span class="token function">setFunc</span><span class="token punctuation">(</span>funcDecl<span class="token punctuation">.</span>name<span class="token punctuation">,</span> funcDecl<span class="token punctuation">.</span>body<span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将函数名作为键即可保存函数。</p><p>现在，假设我们有下面这个函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">addNumbers</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">logNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>      <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它可以表示为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> funcDecl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FunctionDeclaration</span><span class="token punctuation">(</span><span class="token string">'logNumbers'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>      <span class="token keyword">new</span> <span class="token class-name">FuncCall</span><span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token keyword">new</span> <span class="token class-name">FuncCall</span><span class="token punctuation">(</span><span class="token string">'log'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token punctuation">)</span>visitor<span class="token punctuation">.</span><span class="token function">visitFunctionDeclaration</span><span class="token punctuation">(</span>funcDecl<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们来调用函数 <code>logNumbers</code>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> funcCall <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FuncCall</span><span class="token punctuation">(</span><span class="token string">'logNumbers'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  visitor<span class="token punctuation">.</span><span class="token function">visitFuncCall</span><span class="token punctuation">(</span>funcCall<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>控制台将会打印：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token number">5</span><span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>理解 AST 的过程是令人望而生畏并且非常消耗脑力的。即使是编写最简单的解析器也需要大量的代码。</p><p>注意，我们并没有介绍扫描仪和解析器，而是先行解释了 ASTs 以展示它们的工作过程。如果你能够深入理解 AST 以及它所需要的内容，那么在你开始编写自己的编程语言时，自然就事半功倍了。<br>熟能生巧，你可以继续添加其它的编程语言特性，例如：</p><ul><li>类和对象</li><li>方法调用</li><li>封装和继承</li><li><code>for-of</code> 语句</li><li><code>while</code> 语句</li><li><code>for-in</code> 语句</li><li>其它任何你能想到的有趣特性</li></ul><p>如果你对此有任何疑问，或者是任何我需要添加、修改、删减的内容，欢迎评论和致邮。</p><p>感谢 ！！！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」Flexbox 基本原理</title>
      <link href="/2019/06/07/Trs-FlexBox%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/06/07/Trs-FlexBox%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="https://marina-ferreira.github.io/tutorials/css/flexbox/" target="_blank" rel="noopener">Flexbox Fundamentals</a></li><li>原文作者：<a href="https://marina-ferreira.github.io/" target="_blank" rel="noopener">Marina-ferreira</a></li><li>译文地址：<a href="https://juejin.im/post/5cfb34316fb9a07eef69fec7" target="_blank" rel="noopener">「译」Flexbox 基本原理</a></li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/0.png" alt="Flexbox"></p><p>整理自 <a href="https://developer.mozilla.org/bm/docs/Web" target="_blank" rel="noopener">MDN web docs</a> 的笔记，同时参考了 <a href="http://wesbos.com/" target="_blank" rel="noopener">Web Bos</a> 上的<a href="https://flexbox.io/" target="_blank" rel="noopener">什么是 Flexbox</a>系列视频。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Flexbox 是 <code>Flexible Box Module</code> 的缩写。 它是一种布局模型，允许我们方便地控制 html 元素之间的空间分布和对齐 [2]。</p><p>Flexbox 一次只能控制一个维度的定位（行或者列）。二维定位的控制需要依靠网格布局 [2]。</p><p>给出以下模板：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-6<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-7<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-9<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box box-10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 div 的行为默认遵循正常的 html 文档流，因此从上到下、从左到右进行渲染，并且会占据整个 body 的宽度，因为它们的 <code>display</code> 属性默认是 <code>block</code>。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/2.png" alt="Normal document flow"></p><h2 id="弹性项目"><a href="#弹性项目" class="headerlink" title="弹性项目"></a>弹性项目</h2><p>当为 <code>.container</code>div 设置 <code>display: flex</code> 时，所有的直接子 div 将成为弹性项目，并且获得新的行为 [2]：</p><ul><li>由于 <code>flex-direction</code> 默认值为 <code>row</code>，因此它们会呈一行排列</li><li>它们将会从左到右排列</li></ul><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/3.png" alt="Display flex"></p><ul><li>项目不会依靠伸展来适应整个宽度（主轴），相反，它们采用收缩的方式</li></ul><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/4.gif" alt="Items shrink to fit"></p><ul><li><p>项目将会伸展以适应交叉轴（在这个例子中是高度）。如果各个项目的高度不同，它们将会伸展至与最高的那个项目等高。</p></li><li><p><code>flex-basis</code> 默认值为 <code>auto</code>(项目宽度将取决于其自身的内容)</p></li><li><p><code>flex-wrap</code> 默认值为 <code>nowrap</code>（如果容器的宽度不足以囊括所有的项目，则项目不会换行，只会溢出）</p></li></ul><p>出于可视化的目的，我们拉伸容器以占据整个高度。</p><h2 id="弹性容器"><a href="#弹性容器" class="headerlink" title="弹性容器"></a>弹性容器</h2><p><code>display: flex</code> 使容器拓展整个可用宽度；与之相对的，<code>display: inline-flex</code> 使容器宽度塌陷至与内容宽度相等。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/5.png" alt="Display inline flex"></p><h2 id="弹性方向"><a href="#弹性方向" class="headerlink" title="弹性方向"></a>弹性方向</h2><p>一旦声明为弹性容器，我们就可以将元素看作位于两条轴中。一条是由 <code>flex-direction</code> 定义的主轴，一条是与前者垂直的交叉轴 [2]。</p><p><code>flex-direction</code> 属性有四个值: <code>row</code>, <code>row-reverse</code>, <code>column</code> 和 <code>column-reverse</code>.</p><p>默认值是 <code>row</code>，它将主轴设置为从左到右的水平方向，而交叉轴从上到下与之垂直相交。同理，<code>column</code> 将主轴设置为从上到下的垂直方向，而交叉轴则是从左到右。对这两个值添加 <code>reverse</code> ，则主轴将反转 180°，而交叉轴保持不变 [1][2]。</p><p>可以通过下图观察这些值对应的弹性项目行为：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/6.gif" alt="Flex direction"></p><h2 id="弹性换行"><a href="#弹性换行" class="headerlink" title="弹性换行"></a>弹性换行</h2><p>当容器空间不足以容纳全部弹性项目时，利用 <code>flex-wrap</code> 属性处理弹性项目 [3]。</p><p><code>flex-wrap</code> 的默认值为 <code>nowrap</code>，这意味着如果容器不能在保留项目原始宽度的同时将它们排列成一行的话，项目将会收缩以进行适应。如果由于某些原因无法收缩，则项目会溢出容器外 [1][3]。</p><p>通过给项目设置 300px 的宽度，<code>nowrap</code> 选项输出下面这个结果：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/7.png" alt="flex-wrap: nowrap"></p><p>其中，每个项目收缩到大约 70px 以适应容器。</p><p>当属性值更新为 <code>wrap</code> 时，项目的宽度将等于原先的值，300px。当第一行的宽度不足以容纳 300px 时，项目不再溢出容器外，而是会换行 [3]。每一行都应该被视为是一个独立的弹性容器，任何一个容器内的空间分布均不会影响与之相邻的其他容器 [2]。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/8.png" alt="flex-wrap: wrap"></p><p>但是为什么弹性项目会占据整个屏幕的高度呢？在第一部分，容器高度被设置为 100vh，因此可用空间被这四行平分以适应 300px 的项目。假如我们没有设置 100vh，则容器高度将等于项目内容的高度，如下图所示 [1]：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/9.png" alt="Wrap/height unset"></p><p>另一个选项是 <code>wrap-reverse</code>，它将会反转交叉轴。通过属性 <code>flex-direction</code> 设置的从上到下的方向会被 <code>wrap-reverse</code> 转化为从下到上 [1]。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/10.png" alt="flex-wrap: wrap-reverse"></p><p>通过 <code>flex-direction: column</code> 反转主轴，容纳不下的元素将会换行至另一列，同时剩余空间会被平分 [1]。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/11.png" alt="flex-wrap/column"></p><p><code>wrap-reverse</code> 选项与 <code>column</code> 方向搭配使用，则将反转交叉轴的方向为从右到左，产生如下输出：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/12.png" alt="flex-wrap/column"></p><p>弹性布局是一维布局，虽然在反转换行的时候，项目会从下到上排列（在方向为 row 的情况下），但是依然保持着从左到右的结构。改变的只有交叉轴。</p><h2 id="弹性流"><a href="#弹性流" class="headerlink" title="弹性流"></a>弹性流</h2><p><code>flex-direction</code> 和 <code>flex-wrap</code> 可以在一个单属性中进行声明： <code>flex-flow: [direction] [wrap]</code> [2]。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.flex-container</span> </span><span class="token punctuation">{</span>    <span class="token property">flex-flow</span> <span class="token punctuation">:</span> column wrap<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="项目之间的空隙"><a href="#项目之间的空隙" class="headerlink" title="项目之间的空隙"></a>项目之间的空隙</h3><p>回到主轴方向为 row 且进行换行的情况。通过给项目设置 <code>width: 33.3333%</code>，容器能够完全被填满。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/13.png" alt="item width: 33.33%"></p><p>但是当你让子 div 之间有空隙时，它们将不会像预期的那样进行换行：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/14.png" alt="Broken gutter"></p><p>可以通过使用 CSS 函数 <code>calc()</code> 解决这个问题 [1]：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.flex-item</span> </span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">33.33333%</span> - <span class="token number">40</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/15.png" alt="Gutter"></p><p>为了消除容器边缘的空间，这里对容器设置负外边距 [3]：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/16.png" alt="Gutter no edge"></p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.flex-container</span> </span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> -<span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p><code>order</code> 属性允许修改项目的呈现顺序。顺序是以组为单位进行分配的。默认情况下所有的弹性项目都设置为 <code>order：0</code> ，这意味着所有的项目位于同一组，并且它们会按照原始顺序进行定位。如果有两个或者两个以上的组，那么各组将会相对于它们的整数值进行排序 [4]。</p><p>在下面的例子中，有三个<code>顺序组</code>， <code>-1</code>， <code>0</code> 和 <code>1</code>，它们按照如下顺序排列。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.box-3</span> </span><span class="token punctuation">{</span> <span class="token property">order</span><span class="token punctuation">:</span>  <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token selector"><span class="token class">.box-7</span> </span><span class="token punctuation">{</span> <span class="token property">order</span><span class="token punctuation">:</span>  <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token selector"><span class="token class">.box-8</span> </span><span class="token punctuation">{</span> <span class="token property">order</span><span class="token punctuation">:</span> -<span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/17.png" alt="Order"></p><p>表面上，这个属性重新分配了项目，但在诸如使用 tab 键对它们进行遍历的交互中则依然保留它们的原始位置。如果项目顺序与可访问性有关的话，这一点是需要考虑的。同理， <code>flex-direction</code> 也是这样 [4]。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/18.gif" alt="Order and Accessibility"></p><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/19.png" alt="Alignment Digest"></p><p>在弹性布局中，沿着轴的项目对齐和空间分布可以通过四个属性控制 [5]：</p><ul><li><code>justify-content</code>：将所有项目在主轴上对齐</li><li><code>align-items</code> ：将所有项目在交叉轴上对齐</li><li><code>align-self</code>：将单个项目在主轴上对齐</li><li><code>align-content</code>：控制交叉轴上各条线之间的空间</li></ul><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/20.png" alt="justify-content digest"></p><p><code>justify-content</code> 是一个在主轴上处理项目的容器属性。最常用的 6 个值是： <code>flex-start</code>， <code>flex-end</code>， <code>center</code>， <code>space-around</code>， <code>space-between</code>， <code>space-evenly</code>。其中，默认值为 <code>flex-start</code>。</p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/21.png" alt="align-items digest"></p><p><code>align-items</code> 同样是一个容器属性，它在交叉轴上处理项目的对齐。 默认值是 <code>stretch</code> ，其他值是 <code>flex-start</code>， <code>flex-end</code>， <code>center</code> 和 <code>baseline</code> [5]。</p><p>如果设置了容器高度，则 <code>stretch</code> 属性值会使所有的项目伸展至与容器等高；如果没有设置，则所有项目与最高的项目等高 [5]。上面第一张图片中容器高度设置为 <code>100vh</code>，第二张图片则没有设置高度。</p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/22.png" alt="align-content digest"></p><p><code>align-content</code> 是第四个也是最后一个容器属性，它在交叉轴上分配各条线之间的空间。作为最后一个属性，它的初始值为 <code>stretch</code> ，并且和 <code>justify-content</code> 一样接受以下几个属性值：<code>flex-start</code>， <code>flex-end</code>， <code>center</code>， <code>space-around</code>， <code>space-between</code>， <code>space-evenly</code> [5]。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/23.png" alt="align-self digest"></p><p><code>align-items</code> 属性实际上是通过给容器内的所有项目设置 <code>align-self</code> 而生效的。通过单独设置 <code>align-self</code>，可以覆盖先前设置的总的属性值。该属性和 <code>align-items</code> 拥有相同的可选值，但是还多了一个 ‘auto’ [5]。</p><p><code>auto</code> 会重置 <code>align-self</code> 的值，使之重新等于通过 <code>align-items</code> 给容器全局定义的值 [5]。</p><h2 id="弹性项目大小"><a href="#弹性项目大小" class="headerlink" title="弹性项目大小"></a>弹性项目大小</h2><p>项目的大小和弹性可以通过三个属性控制：<code>flex-grow</code>，<code>flex-shrink</code> 和 <code>flex-basis</code>。这些属性都在主轴上发挥作用 [2]。</p><ul><li><code>flex-grow</code>：如果有额外空间，每个项目应该如何伸展</li><li><code>flex-shrink</code>：如果空间不足，每个项目应该如何收缩</li><li><code>flex-basis</code>：在设置以上两个属性之前项目的大小</li></ul><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>该属性设置的是<code>弹性增长系数</code>，这是一个用于处理项目之间相对大小的比率 [7]。</p><p>默认值是 0，这意味着如果有剩余空间，就把这个空间放在最后一个项目的后面 [1]。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/24.png" alt="flex-grow-default"></p><p>在上面的例子中，<code>direction</code> 设置为 <code>row</code>，每个弹性项目的宽度是 <code>60px</code>。由于容器的宽度是 <code>980px</code> ，因此有 <code>680px</code> 的可用空间，这个空间称为 <code>正向自由空间</code> [7]。</p><p>通过将 <code>flex-grow</code> 设置为 <code>1</code>，正向自由空间将会被弹性项目平分。每个项目的宽度都会增加 <code>136px</code>，总的宽度是 <code>196px</code> [7]。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/25.png" alt="flex-grow: 1"></p><p>通过给第三个项目设置 <code>flex-grow: 2</code> ，它获得的可用正向自由空间是其他项目的两倍，即比起其他项目的 <code>173px</code> ，它的总宽度为 <code>286px</code> [7]。</p><p>下图中，项目的 <code>flex-grow</code> 属性设置为自身的内容值。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/26.png" alt="flex-grow: variable"></p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>当容器没有足够空间来容纳所有项目时，使用 <code>flex-shrink</code> 处理项目大小。因此，它通过收缩项目来处理它们的负向自由空间 [7]。</p><p>如下图所示，<code>980px</code> 的容器存放着 5 个 <code>300px</code> 宽度的容器。由于没有足够空间来容纳所需要的 <code>1500px</code>，默认的<code>弹性收缩系数</code> <code>1</code> 会使每个项目收缩至 <code>196px</code>。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/27.png" alt="flex-shrink-default"></p><p>通过给第三个项目设置 <code>2</code> 的比率，它会比其它项目小两倍。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/28.png" alt="flex-shrink-1"></p><p>下图中，每个项目以自身内容值作为弹性收缩比率。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/29.png" alt="flex-shrink-variable"></p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><code>flex-basis</code> 属性会在实际设置可用空间之前检查每个项目应该具有的大小。默认值是 <code>auto</code>，项目宽度要么通过 <code>width</code> 显式设置，要么等于内容宽度。它同样也接受像素值 [7]。</p><p>下面的 gif 展示了一个 <code>800px</code> 宽度的容器和 5 个设置了 <code>flex-basis: 160px</code> 的弹性项目。这告诉浏览器：理想情况下有足够的空间放置所有的项目，项目的 <code>160px</code> 宽度将会得到保留，并且没有正向/负向自由空间。如果没有足够的空间，由于 <code>flex-shrink</code> 默认为 <code>1</code>，所有的项目会均匀地收缩。如果有剩余的空间，由于 <code>flex-grow</code> 默认为 <code>0</code>，剩余空间会放置在最后一个项目的后面。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/30.gif" alt="flex-basis"></p><p>下面的 gif 中，项目 1 设置为 <code>flex-shrink: 10</code>，项目 4 设置为 <code>flex-grow: 10</code>。对于负向自由空间，项目 1 减小的宽度是其它项目减小宽度的 10 倍；对于正向自由空间，项目 4 增加的宽度是其它项目增加宽度的 10 倍。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/31.gif" alt="flex-basis"></p><p><code>flex-basis</code> 还可以接受值 <code>content</code>。此时，无论有没有设置 <code>width</code>，自由空间计算都只会基于项目内容去计算宽度。如果你不打算在计算时考虑项目宽度，则将其设置为 <code>0</code>。</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p><code>flex</code> 是 <code>flex-grow</code>， <code>flex-shrink</code> 和 <code>flex-basis</code> 的简写属性 [2]。</p><p>它接受下面的预定于值：</p><ul><li><code>initial</code>：重置为弹性布局的默认值，与 flex: 0 1 auto 效果一样</li><li><code>auto</code>：弹性项目可以根据需要伸展/收缩，与 flex: 1 1 auto 效果一样</li><li><code>none</code>：使项目失去弹性，与 flex: 0 0 auto 效果一样</li><li><code>flex: 1</code>：弹性项目可以伸展/收缩，并且 <code>flex-basis</code> 设置为 0 ，与 flex: 1 1 0 效果一样</li></ul><h2 id="Autoprefixer"><a href="#Autoprefixer" class="headerlink" title="Autoprefixer"></a>Autoprefixer</h2><p>考虑到跨浏览器兼容性，给属性加上所有必要的前缀很重要，这可以确保提供全面的支持 [1]。</p><p>手动给每个属性添加前缀是一项非常繁琐的任务，并且还会徒增样式维护的难度。作为替代方法，<a href="https://gulpjs.com/" target="_blank" rel="noopener">Gulp</a> 可以自动化地完成这些任务。</p><p>要使用 Gulp，我们需要将其作为依赖项添加到项目中。这是通过 <code>package.json</code> 文件完成的，它负责跟踪依赖项及其版本。通过终端创建文件类型 [1]：</p><pre class="line-numbers language-js"><code class="language-js">    🌹  npm init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在提示下输入信息，点击回车键进行确认。输出文件大概类似下面这样：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"project-name"</span><span class="token punctuation">,</span>    <span class="token string">"version"</span><span class="token punctuation">:</span> <span class="token string">"1.0.0"</span><span class="token punctuation">,</span>    <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"Project description"</span><span class="token punctuation">,</span>    <span class="token string">"main"</span><span class="token punctuation">:</span> <span class="token string">"index.js"</span><span class="token punctuation">,</span>    <span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"author"</span><span class="token punctuation">:</span> <span class="token string">"Author Name"</span><span class="token punctuation">,</span>    <span class="token string">"license"</span><span class="token punctuation">:</span> <span class="token string">"ISC"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>全局安装 gulp ：</p><pre class="line-numbers language-js"><code class="language-js">    🌹  npm install gulp <span class="token operator">-</span>g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 gulp 和 gulp-autoprefixer 作为项目的依赖性：</p><pre class="line-numbers language-js"><code class="language-js">    🌹  npm install gulp <span class="token operator">--</span>save<span class="token operator">-</span>dev    🌹  npm install gulp<span class="token operator">-</span>autoprefixer <span class="token operator">--</span>save<span class="token operator">-</span>dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它们会出现在 <code>package.json</code> 文件的 <code>devDependencies</code> 键下。</p><p>创建一个 <code>gulpfile.js</code> 文件：</p><pre class="line-numbers language-js"><code class="language-js">    🌹  touch gulpfile<span class="token punctuation">.</span>js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加下面内容 [9]：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//gulpfile.js</span><span class="token keyword">var</span> gulp <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'gulp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> autoprefixer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'gulp-autoprefixer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">'styles'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> gulp<span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token string">'./styles.css'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">autoprefixer</span><span class="token punctuation">(</span><span class="token punctuation">{</span> browsers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'last 2 versions'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cascade<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">'build'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>gulp</code> 从 <code>styles.css</code> 中提取内容并通过 <code>gulp-autoprefixer</code> 进行传递。输出文件保留在 <code>build</code> 文件夹下。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>[1] <a href="https://flexbox.io/" target="_blank" rel="noopener">What the Flexbox Course</a></li><li>[2] <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank" rel="noopener">Basic concepts of flexbox</a> - 25/03/2018</li><li>[3] <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Mastering_Wrapping_of_Flex_Items" target="_blank" rel="noopener">Mastering Wrapping of Flex Items</a> - 26/03/2018</li><li>[4] <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Ordering_Flex_Items" target="_blank" rel="noopener">Ordering Flex Items</a> - 26/03/2018</li><li>[5] <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Aligning_Items_in_a_Flex_Container" target="_blank" rel="noopener">Aligning Items in a Flex Container</a> - 26/03/2018</li><li>[6] <a href="https://stackoverflow.com/questions/34606879/whats-the-difference-between-flex-start-and-baseline" target="_blank" rel="noopener">StackOverflow</a> - 27/03/2018</li><li>[7] <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Controlling_Ratios_of_Flex_Items_Along_the_Main_Ax" target="_blank" rel="noopener">Controlling Ratios of Flex Items Along the Main Axis</a> - 28/03/2018</li><li>[8] <a href="https://gulpjs.com/" target="_blank" rel="noopener">Gulp</a></li><li>[9] <a href="https://www.npmjs.com/package/gulp-autoprefixer" target="_blank" rel="noopener">Gulp Autoprefixer</a></li></ul><blockquote><p>译者注：<br>弹性项目：Flex Items<br>弹性容器：Flex Container<br>弹性方向：Flex Direction<br>弹性换行：Flex Wrap<br>弹性流：Flex Flow<br>弹性项目大小：Flexbox Sizing</p></blockquote><hr><p>关于一级标题翻不翻译的问题拿捏了很久，最后决定翻译。<br>如果有条件的话推荐阅读英文原文，因为翻译肯定是比不上原汁原味的文章。我觉得这篇博客的亮点在于：</p><ul><li>给出了大量图片和示例（其中不少是动图），对于理解很有帮助；</li><li>每一个引用的地方都带有注释，给读者追溯文章信息的源头提供了机会（这一点是第一次看到，值得学习）；</li><li>涉及到了一些细节，比如交叉轴的确定。一些文章说和顺时针、逆时针有关，其实这是错的。从文章中我们也知道了，交叉轴确实由主轴确定，但是它不一定就是由主轴按照一个方向旋转得到的</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础系列：flex 布局</title>
      <link href="/2019/06/06/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/"/>
      <url>/2019/06/06/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-1.png" alt=""></p><a id="more"></a><h2 id="1-布局演变史"><a href="#1-布局演变史" class="headerlink" title="1.布局演变史"></a>1.布局演变史</h2><p><strong>1）初代：table 布局</strong><br>在网页布局没有进入 CSS 的时代，排版几乎是通过 table 元素实现的。虽然它可以很方便地实现水平和垂直对齐，但是缺点也很明显：<br>代码臃肿；不利于SEO；不够语义化；后期难以修改</p><p><strong>2）第二代：div+css 布局</strong><br>随着 Web 语义化的流行，CSS 标准为我们提供了 3 种布局方式：标准文档流、浮动布局和定位布局。这几种方式的搭配使用可以轻松搞定 PC 端页面的常见需求。然而，这些写法也存在一些缺陷：缺少语义并且不够灵活。</p><p><strong>3）第三代：flex 布局</strong><br>flex 布局属于一维布局，适合用于局部组件。目前在移动端布局日渐成为主流，也是本文重点。</p><p><strong>4）第四代：grid布局</strong><br>grid 布局属于二维布局，适合用于页面框架。目前兼容性不是很好，尚未完全普及。</p><h2 id="2-flex-布局"><a href="#2-flex-布局" class="headerlink" title="2.flex 布局"></a>2.flex 布局</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。利用Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持。</p><p>要使用 flex 布局，只需给元素设置 <code>display:flex</code> 或者 <code>display:inline-flex</code> 。前者会将元素作为块状弹性容器，若没有指定宽度，默认撑满一整行；后者会将元素作为内联弹性容器，若没有指定宽度，默认由内容撑开。</p><p>注意，设为 Flex 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><h4 id="1）父容器和子项目"><a href="#1）父容器和子项目" class="headerlink" title="1）父容器和子项目"></a>1）父容器和子项目</h4><p>设置了 <code>display:flex</code> 或者 <code>display:inline-flex</code> 的元素将成为父容器 (flex container) ，其内部所有子元素成为子项目 (flex item)。</p><h4 id="2）主轴和交叉轴"><a href="#2）主轴和交叉轴" class="headerlink" title="2）主轴和交叉轴"></a>2）主轴和交叉轴</h4><p>如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-2.png" alt=""></p><ul><li>父容器存在两条轴，<strong>主轴</strong>（main axis）和<strong>交叉轴</strong>（cross axis）。</li><li>主轴的开始位置叫做 <code>main start</code>，结束位置叫做 <code>main end</code>；交叉轴的开始位置叫做 <code>cross start</code>，结束位置叫做 <code>cross end</code>。主轴默认情况下水平向右，我们可以通过 <code>flex-direction</code> 指定它的方向，主轴方向确定后，我们进而可以得到交叉轴的方向。</li><li>子项目默认沿主轴排列。单个项目占据的主轴空间叫做 <code>main size</code>，占据的交叉轴空间叫做 <code>cross size</code>。</li></ul><h4 id="3）6-大容器属性"><a href="#3）6-大容器属性" class="headerlink" title="3）6 大容器属性"></a>3）6 大容器属性</h4><p>以下 6 个属性设置在父容器上：</p><ul><li><code>flex-direction</code></li><li><code>justify-content</code></li><li><code>align-items</code></li><li><code>flex-wrap</code></li><li><code>flex-flow</code></li><li><code>align-content</code></li></ul><blockquote><p><code>flex-direction</code> 属性定义主轴的方向，进而决定子项目的排列方向</p></blockquote><p><code>row</code>:<br>默认值。主轴水平向右，同时交叉轴垂直向下</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-3.png" alt=""></p><p><code>row-reverse</code>：<br>主轴水平向左，同时交叉轴垂直向下</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-4.png" alt=""></p><p><code>column</code>：<br>主轴垂直向下，同时交叉轴水平向右</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-5.png" alt=""></p><p><code>column-reverse</code>：<br>主轴垂直向上，同时交叉轴水平向右</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-6.png" alt=""></p><p><strong>注意</strong>：只要主轴是 row，交叉轴就一定是向下的；而只要主轴是 column，交叉轴就一定是向右的。和所谓的逆时针、顺时针没关系。详细的解释<a href="https://chorer.github.io/2019/06/07/Trs-FlexBox%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">另一篇博客</a>有说明。</p><blockquote><p><code>justify-content</code> 属性定义子项目沿着主轴方向具体如何排列</p></blockquote><p><code>flex-start</code>:起始端对齐</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-7.png" alt=""></p><p><code>flex-end</code>：末尾端对齐</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-7.5.png" alt=""></p><p><code>center</code>: 居中对齐（用于实现水平居中）<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-8.png" alt=""></p><p><code>space-around</code>: 子项目沿主轴均匀分布，位于首尾两端的子项目到父容器的距离是子项目间距的一半（注意 around 的意思）</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-9.png" alt=""></p><p><code>space-between</code>: 子项目沿主轴均匀分布，位于首尾两端的子项目与父容器相切</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-10.png" alt=""></p><blockquote><p><code>align-items</code> 属性定义子项目沿着交叉轴方向具体如何排列</p></blockquote><p><code>flex-start</code>: 起始端对齐</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-11.png" alt=""></p><p><code>flex-end</code>: 末尾端对齐</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-12.png" alt=""></p><p><code>center</code>：居中对齐（用于实现垂直居中）</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-13.png" alt=""></p><p><code>baseline</code>: 基线对齐。以一开始是起始端对齐为例，<code>cross-strat</code> 到各个子项目基线的距离可能各不相同，一旦设置了基线对齐，则：距离最大的那个子项目保持与 <code>corss-start</code> 相切，其他子项目的基线均向该项目的基线对齐</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/blog-2019-6-7-flex%20layout/14.png" alt=""></p><p><code>stretch</code>：子项目沿着交叉轴方向拉伸至与父容器尺寸一样</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-15.png" alt=""></p><blockquote><p><code>flex-wrap</code> 属性定义子项目是否换行、如何换行</p></blockquote><p><code>nowrap</code>:<br>不换行（默认）。也就是说父容器尺寸不够时，会为了达到不换行的效果而压缩子项目的尺寸</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-16.png" alt=""></p><p><code>wrap</code>：<br>正常换行</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-17.png" alt=""></p><p><code>wrap-reverse</code>：<br>逆序换行。即沿着交叉轴的反方向换行，如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-18.png" alt=""></p><p>确定换行方向，也可以采用以下方法：</p><ul><li>首先确定正常换行情况下的排列方式</li><li>保持第一行不动，将其他行沿着与主轴垂直的方向翻转</li></ul><blockquote><p><code>flex-flow</code> 属性定义子项目如何流动，以及流动到终点是否换行。简单地说，它是 <code>flex-direction</code> 和 <code>flex-wrap</code> 属性的结合。它的取值可以是：</p></blockquote><ul><li><code>row nowrap</code></li><li><code>row</code></li><li><code>wrap</code><br>等等。</li></ul><blockquote><p><code>align-content</code> 属性定义子项目存在多行时，行与行之间的对齐方式</p></blockquote><p><code>flex-start</code>：起始端对齐</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-19.png" alt=""></p><p><code>flex-end</code>：末尾端对齐</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-20.png" alt=""></p><p><code>center</code>：居中对齐</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-21.png" alt=""></p><p><code>space-around</code>：各行沿交叉轴均匀分布，位于首尾两端的行到父容器的距离是行与行距离的一半</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-22.png" alt=""></p><p><code>space-between</code>: 各行沿交叉轴均匀分布，位于首尾两端的行到父容器相切</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-23.png" alt=""></p><p><code>stretch</code>：拉伸对齐</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-24.png" alt=""></p><h4 id="4-6-大项目属性"><a href="#4-6-大项目属性" class="headerlink" title="4) 6 大项目属性"></a>4) 6 大项目属性</h4><p>以下 6 个属性设置在子项目上：</p><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><blockquote><p><code>order</code> 属性定义子项目的排列顺序，它会覆盖 HTML 结构中的顺序。默认值为 0 ，即遵循 HTML 结构排列；可以是负值，数值越小越靠前。</p></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-25.png" alt=""></p><blockquote><p><code>flex-grow</code> 属性定义了父容器还有剩余空间时，子项目如何瓜分这些<strong>剩余空间</strong>。</p></blockquote><ul><li>其值为一个权重（扩张因子），子项目将按照设定的这个权重去瓜分父容器的剩余空间。</li><li>如果为 0（默认）：即使有剩余空间，子项目也不会去瓜分</li><li><p>如果为整数，举个例子：<br>父容器宽度 500px，三个子项目的 width 分别为 100px，150px，100px。<br>于是剩余空间为 150px<br>三个项目的 <code>flex-grow</code> 分别是 1，2，3，于是三个项目所得到的多余空间分别是：<br>150 <em>1 / 6 = 25px<br>150 </em>2 / 6 = 50px<br>150 * 3 / 6 = 75px<br>于是三个项目最终的宽度分别为：<br>100px + 25px = 125px<br>150px + 50px = 200px<br>100px + 75px = 175px</p></li><li><p>如果为小数，那么将不会计算权重之和作为权重率的分母，而是直接取 1 作为分母。在这个基础上，若权重之和小于 1 .则剩余空间不会全部分配给子项目。比如改一下上面的例子：<br>三个项目的 <code>flex-grow</code> 改为 0.1，0.2，0.3，那么计算公式将变成下面这样：<br>150 <em>0.1 / 1 = 15px<br>150 </em>0.2 / 1 = 30px<br>150 * 0.3 / 1 = 45px<br>150px - 15px - 30px - 45px = 60px，可见还有 60px 没有分配给任何子项目。<br>三个项目的最终宽度分别为：<br>100px + 15px = 115px<br>150px + 30px = 180px<br>100px + 45px = 145px</p></li></ul><p>注意：<code>flex-grow</code> 还会受到 <code>max-width</code> 的影响。如果最终 grow 后的结果大于 <code>max-width</code> 指定的值，则 <code>max-width</code> 的值将会优先使用。同样会导致父容器有部分剩余空间没有分配。</p><blockquote><p><code>flex-shrink</code> 属性定义了父容器空间不足时子项目<strong>如何收缩</strong>以适应有限的空间</p></blockquote><p>该属性与 <code>flex-grow</code> 相对，不同的是其值的计算还与自身宽度有关。举个例子：<br>父容器 500px，三个子项目宽度分别为 150px，200px，300px，<br><code>flex-shrink</code> 分别为 1，2，3。</p><p>首先，计算子元素溢出多少：150 + 200 + 300 - 500 = -150px。<br>那么这 -150px 将由三个元素的分别收缩一定的量来弥补。</p><p>具体的计算方式为：每个元素收缩的权重为其 <code>flex-shrink</code> 乘以其宽度。</p><p>所以总权重为 1 <em>150 + 2 </em>200 + 3 * 300 = 1450</p><p>三个元素分别收缩：<br>150 <em>1(flex-shrink) </em>150(width) / 1450 = -15.5<br>150 <em>2(flex-shrink) </em>200(width) / 1450 = -41.4<br>150 <em>3(flex-shrink) </em>300(width) / 1450 = -93.1</p><p>三个元素的最终宽度分别为：<br>150 - 15.5 = 134.5<br>200 - 41.4 = 158.6<br>300 - 93.1 = 206.9</p><p>同样，当所有元素的 flex-shrink 之和小于 1 时，计算方式也会有所不同：<br>此时，并不会收缩所有的空间，而只会收缩 <code>flex-shrink</code> 之和相对于 1 的比例的空间。</p><p>还是上面的例子，但是 flex-shrink 分别改为 0.1，0.2，0.3。</p><p>于是总权重为 145（正好缩小 10 倍，略去计算公式）。</p><p>三个元素收缩总和并不是 150px，而是只会收缩 150px 的 (0.1 + 0.2 + 0.3) / 1 即 60% 的空间：90px。</p><p>每个元素收缩的空间为：<br>90 <em>0.1(flex-shrink) </em>150(width) / 145 = 9.31<br>90 <em>0.2(flex-shrink) </em>200(width) / 145 = 24.83<br>90 <em>0.3(flex-shrink) </em>300(width) / 145 = 55.86</p><p>三个元素的最终宽度分别为：<br>150 - 9.31 = 140.69<br>200 - 24.83 = 175.17<br>300 - 55.86 = 244.14</p><p>当然，<code>flex-shrink</code> 也会受到 <code>min-width</code> 的影响。</p><blockquote><p><code>flex-basis</code> 属性定义了子项目在不伸缩（即没有以上两个属性影响）时的原始尺寸，主轴水平时表示宽度，主轴垂直时表示高度。默认值为 auto。</p></blockquote><p>以主轴水平为例，说一下子项目宽度如何决定：<br>简单地说，应用规则是：<br>content –&gt; width –&gt; flex-basis (limted by max|min-width)<br>也就是说，</p><ul><li>在显式指定 <code>flex-basis</code> 时，<code>flex-basis</code> 即为该值，<code>width</code> 被忽略；</li><li>在没有显式指定 <code>flex-basis</code> 时，<code>flex-basis</code> 为 <code>auto</code>，即采用 width 的值；</li><li>在没有设置 <code>width</code> 的值时， <code>flex-basis</code> 采用项目内容的大小</li><li><code>flex-basis</code> 始终无法小于指定的最小宽度，无法大于指定的最大宽度</li></ul><blockquote><p><code>flex</code>是一个复合属性，值只有一个时等同于 <code>flex-grow</code>,值为三个时，等同于设置了 <code>flex-grow</code>,<code>flex-shrink</code>,<code>flex-basis</code></p></blockquote><p>虽然 flex 是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求</p><blockquote><p><code>align-self</code> 属性单独定义了一个子项目在交叉轴方向上如何排列，它的可选值与 <code>align-items</code> 的可选值完全一致，两者同时设置时将优先考虑 <code>align-self</code>。</p></blockquote><h3 id="2-2-历史版本"><a href="#2-2-历史版本" class="headerlink" title="2.2 历史版本"></a>2.2 历史版本</h3><p>flex 在演化过程有三个版本：<br>2009 旧版本： display:box | inline-box<br>2011 混合版本： display:flexbox | inline-flexbox<br>2016 新版本： display: flex | inline-flex</p><p>旧版相对于新版的主要区别：flex项目必须是block，没有换行设置，没有反向设置，主轴没有space-around，顺序值从1开始。当然，我们只了解新版 flex 就可以。</p><h3 id="2-3-浏览器兼容性"><a href="#2-3-浏览器兼容性" class="headerlink" title="2.3 浏览器兼容性"></a>2.3 浏览器兼容性</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-26.jpg" alt=""></p><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><p>最后放一张属性总结的思维导图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Aflex%20%E5%B8%83%E5%B1%80/flex%20%E5%B8%83%E5%B1%80-27.png" alt=""></p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/24372279" target="_blank" rel="noopener">详解 flex-grow 与 flex-shrink</a><br><a href="https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb#heading-1" target="_blank" rel="noopener">一劳永逸的搞定 flex 布局</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a><br><a href="https://www.cnblogs.com/thinkingthigh/p/10033809.html" target="_blank" rel="noopener">flex basis 与 width 的区别</a><br><a href="https://marina-ferreira.github.io/tutorials/css/flexbox/" target="_blank" rel="noopener">Flexbox Fundamentals</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「译」创建一个Hexo主题-Part3 :评论、分析和小部件</title>
      <link href="/2019/06/05/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart3/"/>
      <url>/2019/06/05/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-3-Comments-Analytics-and-Widgets/" target="_blank" rel="noopener">Create an Hexo Theme - Part 3: Comments, Analytics and Widgets</a></li><li>原文作者：Jonathan Klughertz</li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p>在这个系列教程中，你将学习怎么从零开始制作一个 Hexo 主题。<br>在 <a href="https://chorer.github.io/%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1%2F">part1</a> 和 <a href="https://chorer.github.io/%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2%2F">part2</a> 中，我们已经创建了博客的所有页面。在这篇文章中，我们将给博客添加 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus 评论系统</a>，实现 <a href="https://www.google.com.sg/analytics/" target="_blank" rel="noopener">谷歌分析</a>以及完成侧边栏的小部件。</p><h2 id="其它文章的链接："><a href="#其它文章的链接：" class="headerlink" title="其它文章的链接："></a>其它文章的链接：</h2><ul><li><a href="https://chorer.github.io/%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1%2F">创建一个Hexo主题-Part1:首页</a></li><li><a href="https://chorer.github.io/%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2%2F">创建一个Hexo主题-Part2:其他页面</a></li><li><a href="https://chorer.github.io/2019/06/05/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart3/">创建一个Hexo主题-Part3:评论、分析和小部件</a></li></ul><h2 id="Disqus-评论系统"><a href="#Disqus-评论系统" class="headerlink" title="Disqus 评论系统"></a>Disqus 评论系统</h2><p>我已经写了一篇关于<a href="http://www.codeblocq.com/2015/12/Add-Disqus-comments-in-Hexo/" target="_blank" rel="noopener">如何在 Hexo 中使用 Disqus 评论系统</a>的文章。请前往查看以了解更多信息，这里我只简单介绍一下怎么使用：</p><p>第一步是获取 Disqus UID 来测试评论功能，可以利用你的账号在这里获取：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98-Part3%20%E8%AF%84%E8%AE%BA%E3%80%81%E5%88%86%E6%9E%90%E5%92%8C%E5%B0%8F%E9%83%A8%E4%BB%B6/add-disqus-comments-hexo-unique-name.jpg" alt=""><br>接下来需要完成三个部分：主题文件的 disqus 配置、评论占位区、Disqus 脚本。事不宜迟，我们开始吧。</p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>我们希望 Disqus UID 是可以配置的，因此给主题的 <code>config.yml</code> 文件添加一个条目：</p><pre class="line-numbers language-js"><code class="language-js"># Disqus Comments Shortnamedisqus_shortname<span class="token punctuation">:</span> klugjoTest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="评论占位区"><a href="#评论占位区" class="headerlink" title="评论占位区"></a>评论占位区</h3><p>接下来我们给页面和文章详情页添加评论系统。和之前一样，创建一个局部视图文件 <code>layout/_partial/comments.ejs</code>，之后打开 <code>layout/_partial/article-full.ejs</code> 文件，把它插入到末尾。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* layout/_partial/comments.ejs */</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post"</span><span class="token operator">></span>   <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Comments <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'comments'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Disqus 需要 ID 为 <code>disqus_thread</code> 的 div 元素，因此我们这里复制官方文档提供的代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>disqus_thread<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>noscript</span><span class="token punctuation">></span></span>Please enable JavaScript to view the <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//disqus.com/?ref_noscript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>comments powered by Disqus.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>noscript</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将上面的代码合并到 <code>comments</code> 文件中：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* layout/_partial/comments.ejs */</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span>comments <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>disqus_shortname<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-comments"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>h3<span class="token operator">></span>Comments<span class="token punctuation">:</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span>        <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"disqus_thread"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>noscript<span class="token operator">></span>Please enable JavaScript to view the <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"//disqus.com/?ref_noscript"</span><span class="token operator">></span>comments powered by Disqus<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>noscript<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先我们检查是否开启了评论功能和设置了 disqus UID，之后将 Disqus 标记代码放到容器里。<br>以下是容器的 CSS 样式代码：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* source/css/blog.css */</span><span class="token selector"><span class="token class">.blog-post-comments</span> </span><span class="token punctuation">{</span>    <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Disqus-脚本"><a href="#Disqus-脚本" class="headerlink" title="Disqus 脚本"></a>Disqus 脚本</h3><p>在测试之前，我们还需要添加 Disqus 的脚本，这是一切生效的关键。将它和其他脚本一起放在 <code>layout/_partial/after-footer.ejs</code> 的末尾</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* layout/_partial/after-footer.ejs */</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Disqus Comments <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>disqus_shortname<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>        <span class="token keyword">var</span> disqus_shortname <span class="token operator">=</span> <span class="token string">'&lt;%= theme.disqus_shortname %>'</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">var</span> dsq <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dsq<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span>            dsq<span class="token punctuation">.</span><span class="token keyword">async</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            dsq<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'//'</span> <span class="token operator">+</span> disqus_shortname <span class="token operator">+</span> <span class="token string">'.disqus.com/&lt;% if (page.comments){ %>embed.js&lt;% } else { %>count.js&lt;% } %>'</span><span class="token punctuation">;</span>            <span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'head'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>dsq<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>脚本来自于<a href="https://help.disqus.com/customer/portal/articles/472097-universal-embed-code" target="_blank" rel="noopener">官方文档</a>,并且我们在这里将 Disqus UID 参数化。<br>接着就可以测试一切是否正常工作了。</p><h2 id="谷歌分析"><a href="#谷歌分析" class="headerlink" title="谷歌分析"></a>谷歌分析</h2><p>谷歌分析的实现和 Disqus 差不多，所以这里我只简单提一下。具体步骤可以看我的<a href="http://www.codeblocq.com/2015/12/Add-Google-Analytics-to-your-hexo-blog/" target="_blank" rel="noopener">另一篇博客</a>。</p><h3 id="在主题配置文件中设置-tracking-ID"><a href="#在主题配置文件中设置-tracking-ID" class="headerlink" title="在主题配置文件中设置 tracking ID"></a>在主题配置文件中设置 tracking ID</h3><p>从你的账号中获取谷歌分析的 tracking ID，之后再配置文件中新增条目。</p><pre class="line-numbers language-js"><code class="language-js"># Google Analytics Tracking IDgoogle_analytics<span class="token punctuation">:</span> UA<span class="token number">-83746351</span><span class="token operator">-</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="创建一个新的局部文件"><a href="#创建一个新的局部文件" class="headerlink" title="创建一个新的局部文件"></a>创建一个新的局部文件</h3><p>创建一个新的局部视图文件 <code>layout/_partial/google-analytic.ejs</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* layout/_partial/google-analytic.ejs */</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>google_analytics<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>script<span class="token operator">></span>        <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>s<span class="token punctuation">,</span>o<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token punctuation">,</span>a<span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">{</span>i<span class="token punctuation">[</span><span class="token string">'GoogleAnalyticsObject'</span><span class="token punctuation">]</span><span class="token operator">=</span>r<span class="token punctuation">;</span>i<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">||</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token punctuation">(</span>i<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span>q<span class="token operator">=</span>i<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span>q<span class="token operator">||</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>i<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token operator">=</span><span class="token number">1</span><span class="token operator">*</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">,</span>                m<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token keyword">async</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span>src<span class="token operator">=</span>g<span class="token punctuation">;</span>m<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>m<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span>document<span class="token punctuation">,</span><span class="token string">'script'</span><span class="token punctuation">,</span><span class="token string">'//www.google-analytics.com/analytics.js'</span><span class="token punctuation">,</span><span class="token string">'ga'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ga</span><span class="token punctuation">(</span><span class="token string">'create'</span><span class="token punctuation">,</span> <span class="token string">'&lt;%= theme.google_analytics %>'</span><span class="token punctuation">,</span> <span class="token string">'auto'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ga</span><span class="token punctuation">(</span><span class="token string">'send'</span><span class="token punctuation">,</span> <span class="token string">'pageview'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是从<a href="https://support.google.com/analytics/answer/1008080?hl=en" target="_blank" rel="noopener">谷歌分析跟踪代码</a>复制粘贴过来的，其中包括一个参数化的 ID。</p><h3 id="合并到局部文件中"><a href="#合并到局部文件中" class="headerlink" title="合并到局部文件中"></a>合并到局部文件中</h3><p>我们希望可以在任何页面中获取到跟踪代码，而页面上又没有合适的位置来存放，因此我们选择把它添加到 <code>&lt;head&gt;&lt;/head&gt;</code> 的末尾：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* layout/_partial/head.ejs */</span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"X-UA-Compatible"</span> content<span class="token operator">=</span><span class="token string">"IE=edge"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1"</span><span class="token operator">></span>    <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Google Analytics <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'google-analytics'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大功告成！</p><h2 id="小部件"><a href="#小部件" class="headerlink" title="小部件"></a>小部件</h2><p>此时，<code>sidebar.ejs</code> 文件中的小部件还只是一堆采用硬编码的静态 HTML。我们来修复这个问题。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>先从配置开始吧。<br>我们准备创建两个小部件，一个是“关于”，一个是“标签”。相关配置如果以 JavaScript 对象的形式来书写，大概是下面这样：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>    widgets<span class="token punctuation">:</span> <span class="token punctuation">{</span>        about<span class="token punctuation">:</span> <span class="token string">"Here goes the about text"</span><span class="token punctuation">,</span>        tags<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// Or any additional configuration the widget needs</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是它在我们的主题配置文件中转换成 YML 的形式：</p><pre class="line-numbers language-js"><code class="language-js"># Widgets Listwidgets<span class="token punctuation">:</span>  about<span class="token punctuation">:</span> This blog is based off the official bootstrap blog template<span class="token punctuation">.</span> Checkout the corresponding tutorial at <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://www.codeblocq.com"</span><span class="token operator">></span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>codeblocq<span class="token punctuation">.</span>com<span class="token operator">&lt;</span><span class="token operator">/</span>a  tags<span class="token punctuation">:</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="侧边栏代码"><a href="#侧边栏代码" class="headerlink" title="侧边栏代码"></a>侧边栏代码</h3><p>作为所有小部件的占位区，我们的侧边栏需要遍历配置文件中的所有小部件并将其渲染出来：<br>侧边栏的 EJS 模板如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* layout/_partial/sidebar.ejs */</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> widget <span class="token keyword">in</span> theme<span class="token punctuation">.</span>widgets<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'widget/'</span> <span class="token operator">+</span> widget<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第一个小部件：“关于”"><a href="#第一个小部件：“关于”" class="headerlink" title="第一个小部件：“关于”"></a>第一个小部件：“关于”</h3><p>新建一个局部文件 <code>layout/_partial/widget/about.ejs</code>，之后在里面创建第一个小部件。<br>代码是从原先的 bootstrap 模板中复制过来的，文本则来自于配置文件。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* layout/_partial/widget/about.ejs */</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>theme<span class="token punctuation">.</span>widgets<span class="token punctuation">.</span>about<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sidebar-module sidebar-module-inset"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>h4<span class="token operator">></span>About<span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> theme<span class="token punctuation">.</span>widgets<span class="token punctuation">.</span>about <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第二个小部件：“标签”"><a href="#第二个小部件：“标签”" class="headerlink" title="第二个小部件：“标签”"></a>第二个小部件：“标签”</h3><p>我们给这个部件做一些略微高级的改动。设置一个段落用于存放博客中用过的所有标签。它们互相之间用空格隔开，并且字体大小与标签使用次数成比例。<br>这是 <code>layout/_partial/widget/tags.ejs</code> 的代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* layout/_partial/widget/tags.ejs */</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>widgets<span class="token punctuation">.</span>tags <span class="token operator">&amp;&amp;</span> site<span class="token punctuation">.</span>tags<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sidebar-module"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>h4<span class="token operator">></span>Tags<span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span> site<span class="token punctuation">.</span>tags<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>                <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- item.path %>"</span> style<span class="token operator">=</span><span class="token string">"font-size: &lt;%- Math.min(item.posts.length * 2 + 13, 30) %>px"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> item<span class="token punctuation">.</span>name <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>site.tags</code> 让我们可以获取所有标签</li><li><code>site.tags.sort(&#39;name)</code> 按照字母表的顺序对所有标签进行排序</li><li><code>item.path</code> 对应标签归档页的相对 URL</li><li><code>item.posts.length</code> 表示标签的使用次数</li><li><code>item.name</code> 是标签的名字</li></ul><p>我这里选择 <code>13+（标签使用次数 *2）px</code> 作为字体大小的计算方式，并且最大不超过 <code>30px</code>。当然，你可以根据自己的喜好来。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>教程到这里就结束了，我希望你从中可以学到不少有趣的东西。<br>如果你想进一步打磨主题，可以考虑下面这些事情：</p><ul><li>通过参数化 <code>&lt;title&gt;</code> 和所有 <a href="http://ogp.me/" target="_blank" rel="noopener">Open Graph</a> 属性完善 <code>head</code> 部分</li><li>添加更多小部件，例如<a href="https://github.com/hexojs/hexo-theme-light/blob/master/layout/_widget/search.ejs" target="_blank" rel="noopener">搜索小部件</a> 或者是一个 <a href="https://github.com/hexojs/hexo-theme-light/blob/master/layout/_widget/recent_posts.ejs" target="_blank" rel="noopener">近期文章小部件</a></li><li>将你的主题提交到 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官方主题站点</a></li><li>查看我的其他 <a href="http://www.codeblocq.com/tags/" target="_blank" rel="noopener">Hexo 教程</a>来改进你的博客</li><li>查看<a href="https://github.com/cgmartin/hexo-theme-bootstrap-blog" target="_blank" rel="noopener">hexo-theme-bootstrap-blog</a>,这个主题同样是基于 bootstrap 模板实现的</li><li>从零开始打造你自己的主题</li></ul><p>感谢阅读！欢迎在评论区留下你的评论、指正和意见。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础系列：常见布局方式</title>
      <link href="/2019/05/31/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/05/31/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-1.jpg" alt=""></p><a id="more"></a><h2 id="1-单列布局"><a href="#1-单列布局" class="headerlink" title="1.单列布局"></a>1.单列布局</h2><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-2.jpg" alt=""></p><p>常见的单列布局有两种：</p><ul><li>header、content、footer等宽</li><li>header、footer 等宽，content 略窄</li></ul><p><strong><i class="fa fa-hand-o-right"></i> 对于第一种：</strong></p><p>给 header、content、footer 设置相同的 width 或者 max-width（显示的宽度都一样，但是前者内容过长会溢出，后者会换行），再设置 margin 达到水平居中。</p><p>代码示例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.header</span></span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">0</span> auto<span class="token punctuation">;</span>     <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">960</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.content</span></span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span>    <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">960</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.footer</span></span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span>    <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">960</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><i class="fa fa-hand-o-right"></i> 对于第二种：</strong></p><p>首先给 header 和 footer 共同的宽度（不设置宽度时默认撑满整个屏幕），之后给 content 和 header 子元素（比如头部的导航条）、footer 子元素一个共同的宽度。最后通过 margin 设置水平居中。</p><p>代码示例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.header</span></span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">0</span> auto<span class="token punctuation">;</span>    <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">960</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.nav</span></span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span>    <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">800</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> darkgray<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.content</span></span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span>    <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">800</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.footer</span></span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span>    <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">960</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-两列自适应布局"><a href="#2-两列自适应布局" class="headerlink" title="2.两列自适应布局"></a>2.两列自适应布局</h2><p>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式。有三种常用方式可以达到两列自适应布局</p><p><strong><i class="fa fa-hand-o-right"></i> float + BFC：</strong></p><p>左元素在没有固定宽度的情况下设置浮动，因此宽度由内容撑开；右元素激活 BFC（这里采用 <code>overflow:hidden</code>）后，可以防止被浮动元素盖住，且正是为了防止被盖住，右元素宽度才会由默认的撑满屏幕变为撑满剩余部分。这里还要注意一个点是：浮动元素的 margin 是相对于与自己同级的浮动兄弟元素来说的。</p><p>代码示例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>parent<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background-color</span><span class="token punctuation">:</span> lightgrey<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background-color</span><span class="token punctuation">:</span> lightblue<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name">  <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background-color</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">margin-right</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>  <span class="token property">zoom</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 兼容 IE */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><i class="fa fa-hand-o-right"></i> flex 布局：</strong></p><p>设置父盒子为弹性盒后，子元素默认成一行显示，之后设置右元素 <code>flex:1</code>。该属性默认为 0，表示即使该行有额外空间也不会占满，设置为 1 表示右元素占满额外空间。</p><p>代码示例：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* html部分同上 */</span><span class="token selector"><span class="token class">.parent</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span>flex<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span>   <span class="token property">flex</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><i class="fa fa-hand-o-right"></i> grid 布局：</strong></p><p>代码示例：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* html部分同上 */</span><span class="token selector"><span class="token class">.parent</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span>grid<span class="token punctuation">;</span>  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span>auto <span class="token number">1</span>fr<span class="token punctuation">;</span>  <span class="token property">grid-gap</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-三栏布局"><a href="#3-三栏布局" class="headerlink" title="3.三栏布局"></a>3.三栏布局</h2><p>即中间列自适应宽度，旁边两侧固定宽度的布局方式，最典型的是圣杯布局和双飞翼布局。</p><p><strong><i class="fa fa-hand-o-right"></i> 3.1 圣杯布局：</strong></p><p>3.1.1 代码示例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.body</span></span><span class="token punctuation">{</span>    <span class="token property">min-width</span><span class="token punctuation">:</span> <span class="token number">600</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>    <span class="token property">padding-left</span><span class="token punctuation">:</span> <span class="token number">220</span>px<span class="token punctuation">;</span>    <span class="token property">padding-right</span><span class="token punctuation">:</span> <span class="token number">220</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> -<span class="token number">220</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">500</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> -<span class="token number">220</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.1.2 实现步骤：</p><ul><li>首先我们想要优先加载 center 部分的内容，所以 dom 结构上先写 center</li><li>为了让三者共在一行，给它们设置浮动；为了让 center 自适应，给它设置宽度 100%。此时布局是这样的：</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-3.jpg" alt=""></p><p>这里要注意的点：块级元素在不显式设置宽度的情况下确实撑满整个屏幕，从这个角度来看，width 设置为 100% 似乎没有必要。但不要忘记了我们给它设置了浮动 —— 浮动元素具有包裹性，在不显式设置宽度的情况下由内容撑开。这里如果不设置 100% 宽度，且里面没有足够的内容，那么会导致布局崩坏。</p><ul><li>设置 left 和 right 的 margin-left 为负值，让它们回到与 center 同一行。此时布局是这样的：</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-4.jpg" alt=""></p><p>这里要注意的点：所有浮动元素可以看作位于同一个浮动流，利用负边距可以让某个元素在这个流中移动，并且会叠加到相应元素的上面。对于 left 来说，它需要左移父元素的总宽度，对于 right 来说，它需要左移自身宽度。</p><ul><li>设置父容器的左右 padding，使内部内容向中间挤压，从而使左右留白。此时布局是这样的：</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-5.jpg" alt=""></p><ul><li>给 left 和 right 设置绝对定位，让它们占据父元素的留白空间。最终得到的布局是这样的：</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-6.jpg" alt=""></p><ul><li>给页面设置 <code>min-width: 600px</code></li></ul><p>这里要注意的点：由于左右两列宽度固定，因此我们至少要给页面一个最小宽度，但这个最小宽度并不是简单的左右两列宽度之和 —— 别忘了，之前的 left 位于 center，left 是 relative 定位，所以在 center 上占据过的空间不会消失。所以页面最小宽度是 <code>left-width * 2 + right-width</code>。</p><p>3.1.3 缺点；</p><p>如果其中一列内容高度拉长，其他两列的背景并不会自动填充（后面介绍的等高布局可以解决这个问题）</p><p><strong><i class="fa fa-hand-o-right"></i> 3.2 双飞翼布局：</strong></p><p>双飞翼布局在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。</p><p>3.2.1 代码示例</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>inner<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>双飞翼布局<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.body</span> </span><span class="token punctuation">{</span>    <span class="token property">min-width</span><span class="token punctuation">:</span> <span class="token number">600</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.center</span> </span><span class="token punctuation">{</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">500</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.center</span> <span class="token class">.inner</span> </span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">200</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 主要区别 */</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">400</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">200</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.2.2 实现步骤</p><p>前两步与圣杯布局一样：</p><ul><li>三个部分都设定为左浮动，然后设置 center 的宽度为 100%，此时，left 和 right 部分会跳到下一行；</li><li>通过设置负 margin 让 left 和 right 部分回到与 center 部分同一行；</li></ul><p>这里开始有所不同：</p><ul><li>center 部分增加一个内层div，并设margin: 0 200px；</li><li>同样要给页面设置最小宽度，这里没有用定位，所以最小宽度可以直接等于左右两列宽度之和</li></ul><p>3.2.3 缺点：</p><p>多加一层 dom 树节点，增加渲染树生成的计算量。</p><p><strong><i class="fa fa-bell-o"></i> 两种布局的对比：</strong></p><ul><li>优先加载主列。</li><li>三列浮动，配合负外边距形成三列布局</li><li>两种布局方式的主要区别在于如何处理主列，从而让其内容不被覆盖。对于圣杯布局，它是利用父盒子的左右 padding 确保将主列内容挤到中间，在效果上表现为三个独立列；对于双飞翼布局，它是在主列里放置一个子盒子，利用子盒子的左右 margin 确保内容位于中间，在效果上表现为左右两列在主列上面。</li></ul><p><strong><i class="fa fa-hand-o-right"></i> 3.3 flex 布局：</strong></p><p>flex 布局是最简便的，而且在移动端应用广泛。</p><p>3.3.1 代码示例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span></span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.center</span></span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">500</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span></span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>         <span class="token property">background-color</span><span class="token punctuation">:</span>gray<span class="token punctuation">;</span>     <span class="token property">order</span><span class="token punctuation">:</span> -<span class="token number">1</span><span class="token punctuation">;</span>    <span class="token property">flex</span><span class="token punctuation">:</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">100</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.right</span></span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">100</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.3.2 实现步骤：</p><p>只说几个注意的点</p><ul><li><p>在不优先加载主列的情况下，dom 结构可以按照左中右顺序书写，这样不需要额外设置 order；因为我们这里要优先加载主列，所以 dom 结构还是先写主列，之后通过降低左列的 order 恢复顺序。</p></li><li><p>flex 只有一个值时，设置的是 <code>flex-grow</code>，代表弹性子元素对父元素剩余空间的分配，因为不设置的时候默认是 0，所以这里只有设置了 1 的主列参与分配剩余空间，从而实现宽度自适应。</p></li><li><p>flex 有三个值时，设置的是 <code>flex-grow</code>，<code>flex-shrink</code>，<code>flex-basis</code>。这里左右两列的 <code>flex-basis</code> 都是 100px，实际上为它们设置了固定宽度。</p></li></ul><h2 id="4-等高布局"><a href="#4-等高布局" class="headerlink" title="4.等高布局"></a>4.等高布局</h2><p>等高布局是指多个子元素在父元素中高度相等的布局方式。</p><p><strong><i class="fa fa-hand-o-right"></i> 4.1 正 padding + 负 margin：</strong></p><p>该方法可以解决圣杯布局各子元素高度不等的缺点。给各个子元素设置一个大数值的 <code>padding-bottom</code>，再设置相同数值的负的 <code>margin-bottom</code>，并给总的父盒子设置 <code>overflow:hidden</code>，把溢出背景切掉。假设某一列高度最大，则父盒子的高度会等于这一列高度，而其他列本来的留白部分由带背景色的 padding 补偿。<br>基本代码与圣杯布局一样，新增代码如下：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 注意是三个都设置 */</span><span class="token selector"><span class="token class">.center</span>,<span class="token class">.left</span>,<span class="token class">.right</span> </span><span class="token punctuation">{</span>    <span class="token property">padding-bottom</span><span class="token punctuation">:</span> <span class="token number">10000</span>px<span class="token punctuation">;</span>    <span class="token property">margin-bottom</span><span class="token punctuation">:</span> -<span class="token number">10000</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>    <span class="token property">padding-left</span><span class="token punctuation">:</span> <span class="token number">220</span>px<span class="token punctuation">;</span>    <span class="token property">padding-right</span><span class="token punctuation">:</span> <span class="token number">220</span>px<span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于原理，我暂时是这么理解的，不一定正确：可以看作 margin 负值是向内收缩至与 padding 高度相等处，虽然 padding 还在（所以有背景颜色），但是丧失了在空间上撑开父盒子的能力（因为此时被 margin 取代，margin 撑不开高度），即父盒子由最高列撑开，其他两列不足高度的部分由 padding 填充。</p><p><strong><i class="fa fa-hand-o-right"></i> 4.2 利用背景图片：</strong></p><p>这种方法是我们实现等高列最早使用的一种方法，就是使用背景图片，在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的css样式就可以轻松实现,但此方法不适合流体布局等高列的布局。</p><p>在制作样式之前需要一张类似下面的背景图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-7.jpg" alt=""></p><p>代码示例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span>”container</span> <span class="token attr-name">clearfix”</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span>”left”</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span>”content”</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span>”right”</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url">url("column.png")</span> repeat-y<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">960</span>px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.left</span> </span><span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">220</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.content</span> </span><span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">480</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.right</span> </span><span class="token punctuation">{</span>  <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">220</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><i class="fa fa-hand-o-right"></i> 4.3 利用表格布局：</strong></p><p>这是一种非常简单，易于实现的方法。不过兼容性不好，低版本 IE 无法正常运行。</p><pre class="line-numbers language-css"><code class="language-css">&lt;div class=<span class="token string">"container table"</span>>    &lt;div class=<span class="token string">"containerInner tableRow"</span>>    <span class="token comment" spellcheck="true">/* 左列 */</span>    &lt;div class=<span class="token string">"column tableCell cell1"</span>>        &lt;div class=<span class="token string">"left aside"</span>>        <span class="token number">....</span>        &lt;/div>    &lt;/div>    <span class="token comment" spellcheck="true">/* 主列 */</span>    &lt;div class=<span class="token string">"column tableCell cell2"</span>>        &lt;div class=<span class="token string">"content section"</span>>        <span class="token number">...</span>        &lt;/div>    &lt;/div>    <span class="token comment" spellcheck="true">/* 右列 */</span>    &lt;div class=<span class="token string">"column tableCell cell3"</span>>        &lt;div class=<span class="token string">"right aside"</span>>        <span class="token number">...</span>        &lt;/div>    &lt;/div>    &lt;/div>&lt;/div><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.table</span> </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>  <span class="token property">min-width</span><span class="token punctuation">:</span> <span class="token number">1000</span>px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.tableRow</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> table-row<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.tableCell</span> </span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">33%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.cell1</span> </span><span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#f00</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">800</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.cell2</span> </span><span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#0f0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.cell3</span> </span><span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#00f</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><i class="fa fa-hand-o-right"></i> 4.4 使用边框和定位：</strong></p><p>这种方法是使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。</p><p>代码示例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mainContent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sidebar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token id">#wrapper</span> </span><span class="token punctuation">{</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">960</span>px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#mainContent</span> </span><span class="token punctuation">{</span>  <span class="token property">border-right</span><span class="token punctuation">:</span> <span class="token number">220</span>px solid <span class="token hexcode">#dfdfdf</span><span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">740</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">800</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#sidebar</span> </span><span class="token punctuation">{</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#dfdfdf</span><span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> <span class="token number">740</span>px<span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">800</span>px<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">220</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><i class="fa fa-hand-o-right"></i> 4.5 利用 flex 布局：</strong></p><p>最简单的方法就是直接设置父盒子为弹性盒。此时弹性子元素的 align-items 属性默认值是 stretch，也就是在 y 轴上将所有子元素拉伸为同一高度，从而达到等高布局。</p><h2 id="5-粘连布局"><a href="#5-粘连布局" class="headerlink" title="5.粘连布局"></a>5.粘连布局</h2><ul><li>内容区 <code>main</code> 高度足够长的时候，<code>footer</code> 紧跟在 <code>main</code>后面；</li><li>内容区 <code>main</code> 高度不够长的时候，<code>footer</code> 粘连在屏幕的底部</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F-8.jpg" alt=""></p><p>5.1 代码示例：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    main <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>    main <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>    main <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>footer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">* </span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">html,body </span><span class="token punctuation">{</span><span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 高度一层层继承下来 */</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#wrap</span> </span><span class="token punctuation">{</span>    <span class="token property">min-height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#wrap</span> <span class="token class">.main</span> </span><span class="token punctuation">{</span>    <span class="token property">padding-bottom</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token id">#footer</span> </span><span class="token punctuation">{</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>    <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> deeppink<span class="token punctuation">;</span>    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>    <span class="token property">margin-top</span><span class="token punctuation">:</span> -<span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.2 实现步骤</p><ul><li><code>footer</code> 必须是一个独立的结构，与 <code>wrap</code> 没有任何嵌套关系</li><li><code>wrap</code> 区域的高度通过设置 <code>min-height</code>，变为视口高度</li><li><code>footer</code> 要使用 <code>margin</code> 为负来确定自己的位置</li><li>在 <code>main</code> 区域需要设置 <code>padding-bottom</code>。这也是为了防止负 <code>margin</code> 导致 <code>footer</code> 覆盖任何实际内容。</li></ul><p>参考：<br><a href="https://juejin.im/post/5bbcd7ff5188255c80668028#heading-19" target="_blank" rel="noopener">https://juejin.im/post/5bbcd7ff5188255c80668028#heading-19</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM 和 BOM 中的各种宽高属性</title>
      <link href="/2019/05/30/F-DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/05/30/F-DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7-1.png" alt=""></p><a id="more"></a><ul><li>先区分一下 window 对象和 document 对象：<br>window 对象表示浏览器中打开的窗口，而 document 对象表示整个 html 文档，它是 window 对象的一部分。</li></ul><h2 id="原生-JavaScript"><a href="#原生-JavaScript" class="headerlink" title="原生 JavaScript"></a>原生 JavaScript</h2><h3 id="1-与-window-相关的宽高"><a href="#1-与-window-相关的宽高" class="headerlink" title="1.与 window 相关的宽高"></a>1.与 window 相关的宽高</h3><h4 id="1-1-与窗口相关"><a href="#1-1-与窗口相关" class="headerlink" title="1.1 与窗口相关"></a>1.1 与窗口相关</h4><p><strong><code>window.innerHeight</code>/<code>window.innerWidth</code></strong>:<br>返回表示窗口的内部高度/宽度的数字。不包括开发者工具、顶部栏、侧边栏、滚动条、边框等不由 HTML 控制的部分</p><p><strong><code>window.outerHeight</code>/<code>window.outerWidth</code></strong>：<br>返回表示窗口的外部高度/宽度的数字。包括开发者工具、顶部栏、侧边栏、滚动条、边框等不由 HTML 控制的部分</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7-2.png" alt=""></p><h4 id="1-2-与屏幕相关"><a href="#1-2-与屏幕相关" class="headerlink" title="1.2 与屏幕相关"></a>1.2 与屏幕相关</h4><p><strong><code>window.screen.width</code>/<code>window.screen.height</code></strong>：<br>返回表示屏幕的宽度/高度的数字。包括可能位于任意一侧的任务栏。这两个属性不受浏览器窗口位置的影响。</p><p><strong><code>window.screen.availHeight</code>/<code>window.screen.availWidth</code></strong>：<br>返回表示屏幕的可用宽度/可用高度的数字。不包括可能位于任意一侧的任务栏。这两个属性不受浏览器窗口位置的影响</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7-3.jpg" alt=""></p><p><strong><code>window.screenLeft</code>/<code>window.screenTop</code></strong>:<br>返回表示窗口到屏幕距离的数字。无视任务栏。注意：IE 和 Opera 下表示的是窗口文档区到屏幕的距离，这意味着窗口最大化时，<code>screenTop</code> 返回的是窗口顶部栏的高度而不是 0。</p><p>兼容性：主流浏览器均支持，FireFox 浏览器在 v64 之后才支持</p><p><strong><code>window.screenY</code>/<code>window.screenX</code></strong>:<br>返回表示窗口到屏幕距离的数字。<br>兼容性：主流浏览器均支持</p><h3 id="2-与-document-相关的宽高"><a href="#2-与-document-相关的宽高" class="headerlink" title="2.与 document 相关的宽高"></a>2.与 document 相关的宽高</h3><h4 id="2-1-client-系列"><a href="#2-1-client-系列" class="headerlink" title="2.1 client 系列"></a>2.1 client 系列</h4><p><strong><code>element.clientHeight</code>/<code>element.clientWidth</code></strong>：<br>返回元素的可视部分的高度/宽度，且不包括滚动条。即<br><code>clientHeight = height + padding - scrollBar</code><br><code>clientWidth = width + padding - scrollBar</code></p><p><strong><code>element.clientTop</code>/<code>element.clientLeft</code></strong>：<br>返回元素的上边框/左边框厚度。即<br><code>clientTop = borderTop</code><br><code>clientLeft = borderLeft</code></p><h4 id="2-2-offset-系列"><a href="#2-2-offset-系列" class="headerlink" title="2.2 offset 系列"></a>2.2 offset 系列</h4><p><strong><code>element.offsetWidth</code>/<code>element.offsetHeight</code></strong>：<br>返回元素的总高度/总宽度，包括滚动条和边框。即<br><code>offsetWidth = width + padding + border</code><br><code>offsetHeight = height + padding + border</code></p><p>其实这里可以看出来，以 <code>offsetWidth</code> 为例，可以得出：<code>offsetWidth = clientWidth + scrollBar + border</code></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7-4.jpg" alt=""></p><p><strong><code>element.offsetTop</code>/<code>element.offsetLeft</code></strong><br>首先了解什么是 <code>offsetParent</code>: 它是距离 <code>element</code> 最近的设置了定位的父元素，如果 <code>element</code> 的所有父元素都没有设置定位，则 <code>offsetParent</code> 为 <code>body</code> 元素。</p><pre class="line-numbers language-js"><code class="language-js">element<span class="token punctuation">.</span>offsetTop <span class="token operator">=</span> offsetParent<span class="token punctuation">.</span>marginTop <span class="token operator">+</span> offsetParent<span class="token punctuation">.</span>borderTop <span class="token operator">+</span> offsetParent<span class="token punctuation">.</span>paddingTop <span class="token operator">+</span> element<span class="token punctuation">.</span>marginTopelement<span class="token punctuation">.</span>offsetLeft <span class="token operator">=</span> offsetParent<span class="token punctuation">.</span>marginLeft <span class="token operator">+</span> offsetParent<span class="token punctuation">.</span>borderLeft <span class="token operator">+</span> offsetParent<span class="token punctuation">.</span>paddingLeft <span class="token operator">+</span> element<span class="token punctuation">.</span>marginLeft<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-3-scroll-系列"><a href="#2-3-scroll-系列" class="headerlink" title="2.3 scroll 系列"></a>2.3 scroll 系列</h4><p><strong><code>scrollWidth</code>/<code>scrollHeight</code></strong>：</p><p>对于 <code>body</code> 元素，在没有滚动条的情况下：<br><code>body.scrollWidth = window.innerWidth - scrollBar</code><br><code>body.scrollHeight = window.innerHeight - scrollBar</code><br>在有滚动条的情况下：<br><code>body.scrollWidth = width + padding + border + margin</code><br><code>body.scrollHeight = height + padding + border + margin</code></p><p>对于其他元素，在没有滚动条的情况下：<br><code>element.scrollWidth = element.clientWidth</code><br><code>element.scrollHeight = element.clientHeight</code><br>在有滚动条的情况下跟 <code>body</code> 元素是一样的。</p><p><strong><code>element.scrollTop</code>/<code>element.scrollLeft</code></strong>：<br>返回元素在垂直方向或者水平方向上已滚动的距离。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7-5.png" alt=""></p><p>例如，上图中的红框是固定的屏幕可视区，而网页视为可以上下拖动的文档，当滚动条下拉的时候，实际上是文档向上拖动，而这个拖动的距离就是 <code>element.scrollTop</code></p><h4 id="2-4-返回对象系列"><a href="#2-4-返回对象系列" class="headerlink" title="2.4 返回对象系列"></a>2.4 返回对象系列</h4><p><strong><code>element.style.property</code>/<code>element.getBoundingClientRect().property;</code></strong>：</p><p>对于一个 dom 元素，它的 <code>style</code> 属性返回的是一个属性可读写的对象，且属性值常常是带有单位的。注意：这种方式只能够获取元素的行内样式，而并不能获取到元素的最终样式 —— 要获取计算好的样式，使用 <code>element.currentstyle</code>（IE 浏览器）或者 <code>element.getComputedStyle</code>(IE 之外的浏览器)。</p><p>对于一个 dom 元素，它的 <code>getBoundingClientRect()</code> 方法返回的是该元素对应的矩形对象，通过 <code>top</code>，<code>bottom</code>，<code>left</code>，<code>right</code> 可以分别获得该对象各边相对于窗口上边或者左边的距离。如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7-6.png" alt=""></p><p>可以看出，假如元素在页面滚动条的拖动下向上移动，则元素的 <code>top</code> 会是负值。</p><h3 id="3-与-event-相关的宽高"><a href="#3-与-event-相关的宽高" class="headerlink" title="3.与 event 相关的宽高"></a>3.与 event 相关的宽高</h3><p>event 对象同样存在着很多位置属性，这些位置属性的参照物都不同。</p><p><strong><code>ev.clientX</code>/<code>ev.clientY</code></strong>：</p><p>事件发生时，鼠标点击位置相对于<strong>浏览器可视区</strong>（不包括滚动条和工具栏）左上角（该点为原点）的坐标。</p><p><strong><code>ev.screenX</code>/<code>ev.screenY</code></strong>：</p><p>事件发生时，鼠标点击位置相对于<strong>设备屏幕</strong>左上角（该点为原点）的坐标</p><p><strong><code>ev.offsetX</code>/<code>ev.offsetY</code></strong>：</p><p>事件发生时，鼠标点击位置相对于<strong>事件源</strong>左上角（该点为原点）的坐标。FireFox 不支持</p><p><strong><code>ev.layerX</code>/<code>ev.layerY</code></strong>：</p><p>事件发生时，鼠标点击位置相对于 <strong><code>document</code></strong> 或者<strong>设置了定位的事件源</strong>左上角（该点为原点）的坐标。仅 FireFox 支持，要想使 <code>layerX</code> 与 <code>offsetX</code> 相等，必须给事件源设置定位。</p><p><strong><code>ev.pageX</code>/<code>ev.pageY</code></strong></p><p>事件发生时，鼠标点击位置相对于<strong>页面</strong>左上角（该点为原点）的坐标。窗口无滚动条时，该属性与 <code>ev.clientX</code>/<code>ev.clientY</code> 等价；窗口出现滚动条时，该属性的值将更大，因为它针对的是整个页面，即包含已滚动的区域。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7-7.png" alt=""></p><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p><strong><code>width()</code>/<code>height()</code></strong>：<br>无参时返回元素的 content 的宽度/高度，传参时（数字或者函数）设置元素的 content 的宽度/高度。对于 <code>window.document</code> 传参无效，即只支持读不支持写</p><p><strong><code>innerWidth()</code>/<code>innerHeight()</code></strong>：<br>基本同上，不同的是额外包含了元素的 <code>padding</code>，另外不推荐对 <code>window.document</code> 使用这个方法。</p><p><strong><code>outerWidth()</code>/<code>outerHeight()</code></strong>：<br>基本同上，不同的是额外包含了元素的 <code>border</code>，如果传参 <code>true</code>，则还会包含 <code>margin</code>。同样不推荐对 <code>window.document</code> 使用这个方法。</p><p><strong><code>scrollLeft()</code>/<code>scrollTop()</code></strong>：<br>水平方向上或者垂直方向上，滑块相对于整个滚动条的位置。对于某个元素，滑块处于初始位置或者无滚动条时，该方法返回 0。</p><p><strong><code>offset()</code></strong></p><p>返回元素相对于 document (左上角为原点)的当前坐标值，因此即使页面向上拖动，坐标值也不变。</p><p><strong><code>position()</code></strong>:</p><p>返回元素相对于其 <code>offsetParent</code>（(左上角为原点)） 的当前坐标值</p><p>两者区别看下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7/%E5%90%84%E7%A7%8D%E5%AE%BD%E9%AB%98%E5%B1%9E%E6%80%A7-8.png" alt=""></p><p>参考：<br><a href="https://juejin.im/entry/583a9d4961ff4b007ecbfaff" target="_blank" rel="noopener">https://juejin.im/entry/583a9d4961ff4b007ecbfaff</a><br><a href="https://segmentfault.com/a/1190000007515034" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007515034</a><br><a href="https://www.jianshu.com/p/60332df38393" target="_blank" rel="noopener">https://www.jianshu.com/p/60332df38393</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」JavaScript 究竟是如何工作的？（第二部分）</title>
      <link href="/2019/05/27/Trs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2019/05/27/Trs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="https://blog.bitsrc.io/how-does-javascript-work-part-2-40cc15360bc" target="_blank" rel="noopener">How Does JavaScript Really Work? (Part 2)</a></li><li>原文作者：<a href="https://blog.bitsrc.io/@priyeshp18" target="_blank" rel="noopener">Priyesh Patel</a></li><li>译文地址：<a href="https://juejin.im/post/5cef7e766fb9a07efd46f183" target="_blank" rel="noopener">[译] JavaScript 究竟是如何工作的？（第二部分）</a></li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89-1.jpg" alt=""><br><span style="font-size:14px;color:#999">照片来源于 <a href="https://unsplash.com/search/photos/storage?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Unsplash</a> 上的 <a href="https://unsplash.com/photos/JuFcQxgCXwA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText" target="_blank" rel="noopener">Samuel Zeller</a></span><br><br><br>在<a href="https://chorer.github.io/2019/05/10/Trs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/">这篇文章的第一部分</a>，我简要概述了编程语言的一般工作机制，并深入探讨了 V8 引擎的管道。第二部分将介绍一些更重要的概念，这些概念是每一个 JavaScript 程序员都必须了解的，并且不仅仅和 V8 引擎有关。<br>对于任何一个程序员来说，最关注的两个问题无非就是：<strong>时间复杂度</strong>和<strong>空间复杂度</strong>。<a href="https://chorer.github.io/2019/05/10/Trs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/">第一部分</a>介绍了 V8 为改进 JavaScript 执行时间所做的速度提升和优化，第二部分则将着重介绍内存管理方面的知识。</p><h2 id="内存堆"><a href="#内存堆" class="headerlink" title="内存堆"></a>内存堆</h2><center><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89-2.jpg"></center><br><center style="font-size:14px;color:#999">Orinoco 的 logo：V8 的垃圾回收器</center><ul><li>每当你在 JavaScript 程序中定义了一个变量、常量或者对象时，你都需要一个地方来存储它。这个地方就是内存堆。</li><li>当遇到语句 <code>var a = 10</code> 的时候，内存会分配一个位置用于存储 <code>a</code> 的值</li><li>可用内存是有限的，而复杂的程序可能有很多变量和嵌套对象，因此合理地使用可用内存非常重要。</li><li>和诸如 C 这种需要显式分配和释放内存的语言不同，JavaScript 提供了自动垃圾回收机制。一旦对象/变量离开了上下文并且不再使用，它的内存就会被回收并返还到可用内存池中。</li><li>在 V8 中，垃圾回收器的名字叫做 Orinoco，它的处理过程非常高效。<a href="https://v8.dev/blog/trash-talk" target="_blank" rel="noopener">这篇文章</a>有相关解释。</li></ul><h2 id="标记与清除算法"><a href="#标记与清除算法" class="headerlink" title="标记与清除算法"></a>标记与清除算法</h2><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89-3.jpg" alt=""></p><center style="font-size:14px;color:#999">标记和清除算法</center><p>我们通常会使用这种简单有效的算法来判定可以从内存堆中安全清除的对象。算法的工作方式正如其名：将对象标记为可获得/不可获得，并将不可获得的对象清除。<br>垃圾回收器周期性地从根部或者全局对象开始，移向被它们引用的对象，接着再移向被这些对象引用的对象，以此类推。所有不可获得的对象会在之后被清除。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>虽然垃圾回收器很高效，但是开发者不应该就此将内存管理的问题束之高阁。管理内存是一个很复杂的过程，哪一块内存不再需要并不是单凭一个算法就能决定的。<br>内存泄漏指的是，程序之前需要用到部分内存，而这部分内存在用完之后并没有返回到内存池。<br>下面是一些会导致你的程序出现内存泄漏的常见错误：<br><strong>全局变量</strong>：如果你不断地创建全局变量，不管有没有用到它们，它们都将滞留在程序的整个执行过程中。如果这些变量是深层嵌套对象，将会浪费大量内存。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  c <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这是一个你没有意识到的全局变量</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你试图访问一个此前没有声明过的变量，那么将在全局作用域中创建一个变量。在上面的例子中，<code>c</code> 是没有使用 <code>var</code> 关键字显式创建的变量/对象。</p><p><strong>事件监听器</strong>：为了增强网站的交互性或者是制作一些浮华的动画，你可能会创建大量的事件监听器。而用户在你的单页面应用中移向其他页面时，你又忘记移除这些监听器，那么也可能会导致内存泄漏。当用户在这些页面来回移动的时候，这些监听器会不断增加。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> element  <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Intervals 和 Timeouts</strong>：当在这些闭包中引用对象时，除非闭包本身被清除，否则不会清除相关对象。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 引用对象</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这时候忘记清除计时器</span><span class="token comment" spellcheck="true">// 那么将导致内存泄漏！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>移除 DOM 元素</strong>：这个问题很常见，类似于全局变量导致的内存泄漏。DOM 元素存在于对象图内存和 DOM 树中。用例子来解释可能会更好：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> terminator <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'terminate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> badElem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'toDelete'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>terminator<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>memory  badElem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在你通过 <code>id = ‘terminate’</code> 点击了按钮之后，<code>toDelete</code> 会从 DOM 中移除。不过，由于它仍然被监听器引用，为这个对象分配的内存并不会被释放。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> terminator <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'terminate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>terminator<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>  <span class="token keyword">var</span> badElem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'toDelete'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  badElem<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>badElem</code> 是局部变量，在移除操作完成之后，内存将会被垃圾回收器回收。</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>栈是一种遵循 LIFO（先进后出）规则的数据结构，用于存储和获取数据。JavaScript 引擎通过栈来记住一个函数中最后执行的语句所在的位置。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">multiplyByTwo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> x<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> sum <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">multiplyByTwo</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> hello <span class="token operator">=</span> <span class="token string">"some more code follows"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.引擎了解到我们的程序中有两个函数<br>2.运行 <code>calculate()</code> 函数<br>3.将 <code>calculate</code> 压栈并计算两数之和<br>4.运行 <code>multiplyByTwo()</code> 函数<br>5.将 <code>multiplyByTwo</code> 函数压栈并执行算术计算 x*2<br>6.在返回结果的同时，将 <code>multiplyByTwo()</code> 从栈中弹出，之后回到 <code>calculate()</code> 函数<br>7.在 <code>calculate()</code> 函数返回结果的同时，将 <code>calculate()</code> 从栈中弹出，继续执行后面的代码</p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><center><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89/Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89-4.jpg"></center><p>在不对栈执行弹出的情况下，可连续压栈的数目取决于栈的大小。如果超过了这个界限之后还不断地压栈，最终会导致栈溢出。chrome 浏览器将会抛出一个错误以及被称为<strong>栈帧</strong>的栈快照。</p><p><strong>递归</strong>：递归指的是函数调用自身。递归可以大幅度地减少执行算法所花费的时间（时间复杂度），不过它的理解和实施较为复杂。<br>下面的例子中，基本事件永远不会执行，<code>lonley</code> 函数在没有返回值的情况下不断地调用自身，最终会导致栈溢出。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">lonely</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 基本事件</span> <span class="token punctuation">}</span> <span class="token function">lonely</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 递归调用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="为什么-JavaScript-是单线程的？"><a href="#为什么-JavaScript-是单线程的？" class="headerlink" title="为什么 JavaScript 是单线程的？"></a>为什么 JavaScript 是单线程的？</h2><p>一个线程代表着在同一时间段内可以单独执行的程序部分的数目。要想查看一门语言是单线程的还是多线程的，最简单的方式就是了解它有多少个调用栈。JS 只有一个，所以它是单线程语言。<br>这样不是会阻碍程序运行吗？如果我运行多个耗时的阻塞操作，例如 HTTP 请求，那么程序必须得在每一个操作得到响应之后才能执行后面的代码。<br>为了解决这个问题，我们需要找到一种可以在单线程下异步完成任务的办法。事件循环就是用来发挥这个作用的。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>到现在为止，我们谈到的内容大多包含在 V8 里面，但是如果你去查看 V8 的代码库，你会发现它并不包含例如 setTimeout 或者 DOM 的实现。事实上，除了运行引擎之外，JS 还包括浏览器提供的 Web API，这些 API 用于拓展 JS。<br>关于事件循环的概念，菲利普·罗伯茨讲得比我更好，可以看下面这段视频。</p><iframe height="360" width="640" src="https://player.youku.com/embed/XNDIwMTM5NzI0MA==" frameborder="0" allowfullscreen></iframe><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>关于制作一门编程语言，其实还有很多内容，并且语言的实现在这些年也是不断变化的。我希望这两篇博客可以帮助你成为一名更好的 JS 程序员，并且接受 JS 中那些晦涩难懂的内容 。对于诸如“V8”，“事件循环”，“调用栈”这样的术语，你现在应该熟悉了。<br>大部分的学生（比如我）是从一个新的框架起步，之后再去学习原生 JS。现在他们应该熟悉代码背后发生的事情了，反过来，这将帮助他们写出更好的代码。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础系列：水平垂直居中方案</title>
      <link href="/2019/05/25/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/"/>
      <url>/2019/05/25/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88-1.png" alt=""></p><a id="more"></a><p>比较全面的水平垂直居中方案。水平垂直居中问题大体分为两类，一类目标元素是行内元素，一类目标元素是块级元素(其中，块级元素又包括定宽高和不定宽高）。</p><h3 id="1-水平居中方案"><a href="#1-水平居中方案" class="headerlink" title="1.水平居中方案"></a>1.水平居中方案</h3><p><strong>1.1 行内元素水平居中</strong><br>把该行内元素包裹在一个块级父元素中，之后设置父元素:</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>1.2 块级元素水平居中</strong><br>设置该元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 注意宽度一定要给出 */</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* auto 是必须的 */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3 多个块级元素水平居中</strong></p><ul><li>转换为行内元素。设置目标块级元素 <code>display:inline-block</code>，之后设置父元素：</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>利用弹性盒子。设置父元素：</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span>flex<span class="token punctuation">;</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-垂直居中方案"><a href="#2-垂直居中方案" class="headerlink" title="2.垂直居中方案"></a>2.垂直居中方案</h3><p><strong>2.1 单行行内元素垂直居中</strong></p><p>设置块级父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 设置父元素的高度等于行高 */</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">line-height</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tip)：这里的 <code>line-height</code> 最终是通过继承作用在子元素上的，所以也可以直接设置子元素为 <code>line-height:100px</code>。</p><p><strong>2.2 多行行内元素垂直居中</strong></p><p>设置父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span>table-cell<span class="token punctuation">;</span>    <span class="token property">vertical-align</span><span class="token punctuation">:</span>middle<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Tip): 注意父元素得有高度，否则默认高度由子元素撑起，就没有垂直居中的说法了。</p><p><strong>2.3 已知高度的块级元素垂直居中</strong></p><p>设置父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span>relative<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置子块级元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">margin-top</span><span class="token punctuation">:</span> -<span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tip): 原理是绝对定位。<code>top:50%</code> 确保了子元素位于父元素 1/2 分割线以下，<code>margin-top: -50px</code>代表子元素在这个基础上上移自身的一半高度，此时子元素与父元素中线重合，实现垂直居中。</p><p><strong>2.4 未知高度的块级元素垂直居中</strong></p><p>核心代码与上面一样，不过因为我们不知道子元素高度，也就不知道要在 <code>top:50%</code> 的基础上上移多少距离，因此把 <code>margin-top:-50px</code> 改为 <code>transform: translateY(-50%);</code></p><h3 id="3-水平垂直居中方案"><a href="#3-水平垂直居中方案" class="headerlink" title="3. 水平垂直居中方案"></a>3. 水平垂直居中方案</h3><p><strong>3.1 已知高度和宽度的元素</strong></p><ul><li>方法一：</li></ul><p>设置父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置目标元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span>auto<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">bottom</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tip):这段代码比较优美和灵活。原理其实是：子元素依然相对于父元素定位，但是由于 <code>top:0</code> 和 <code>bottom:0</code> 无法同时满足，且该元素的 <code>margin</code> 又是自适应，因此最终变成了由上下外边距平分尺寸，从而达到垂直居中。至于水平居中，原理也是一样。</p><ul><li>方法二：</li></ul><p>设置父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置目标元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span><span class="token number">50%</span><span class="token punctuation">;</span>    <span class="token property">margin-top</span><span class="token punctuation">:</span> -<span class="token number">25</span>px<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">50</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tip)：原理和 2.3 其实一样，只是现在多了一个水平方向的居中。看下图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88-2.png" alt=""></p><p><strong>3.2 未知高度和宽度的元素</strong></p><p>设置父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置目标元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">position</span><span class="token punctuation">:</span>absolute<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span><span class="token number">50%</span><span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-<span class="token number">50%</span>,-<span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tip): 原理和 2.4 一样，不同的是我们现在不知道子元素高度和宽度，也就不知道要在 <code>top:50%</code> 和 <code>left:50%</code> 的基础上再移动多少距离，因此把 <code>margin-top:-25px</code> 和 <code>margin-left:-50px</code> 对应改为 <code>transform: translateY(50%，50%);</code></p><p><strong>3.3 任意元素</strong></p><ul><li>3.3.1 利用弹性布局一</li></ul><p>设置父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span>flex<span class="token punctuation">;</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>    <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>3.3.2 利用弹性布局二</li></ul><p>设置父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置子元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>3.3.3 利用网格布局一</li></ul><p>设置父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置子元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">justify-self</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span>    <span class="token property">align-self</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>3.3.4 利用网格布局二</li></ul><p>设置父元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span></span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置子元素：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>3.3.5 利用伪元素</li></ul><p>设置父元素</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.parent</span> </span><span class="token punctuation">{</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 消除空隙 */</span>    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 实现水平居中*/</span>    <span class="token selector">&amp;<span class="token pseudo-element">::before</span> </span><span class="token punctuation">{</span>        <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>        <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置子元素</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<br><a href="https://segmentfault.com/a/1190000003761600" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003761600</a><br><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/92</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 居中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 参数默认值引起的中间作用域</title>
      <link href="/2019/05/24/F-ES6%20%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2019/05/24/F-ES6%20%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>ES6 参数默认值的问题，其实之前在<a href="https://chorer.github.io/2019/05/02/Trs-ES6%EF%BC%9A%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/">这篇文章</a>中已经有涉及，之所以再谈起这个问题，是在阅读《ES6 标准入门》时产生的一个疑惑。阮老师的代码是：<br><a id="more"></a></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>x <span class="token comment" spellcheck="true">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么解释输出？</p><ul><li>首先需要明确的是，参数默认值确实会引起一个额外的参数作用域，不信看一下<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-functiondeclarationinstantiation" target="_blank" rel="noopener">标准</a>：<blockquote><p>If the function’s formal parameters do not include any default value initializers then the body declarations are instantiated in the same Environment Record as the parameters. If default value parameter initializers exist, a second Environment Record is created for the body declarations. Formal parameters and functions are initialized as part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.</p></blockquote></li></ul><p>（注意这里的 default value parameter initializers exist，也就是说声明了默认参数值不一定会产生这个作用域，只有初始化了、确实用到了这个默认值，作用域才会产生。）</p><ul><li>第二个需要明确的地方是：上面代码中，存在全局作用域、参数作用域、函数作用域，并且这三者的关系如图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/ES6%20%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BD%9C%E7%94%A8%E5%9F%9F/ES6%20%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-1.png" alt=""></li></ul><p>明确这两点之后开始来分析结果。实际上这段代码中存在着三个不同的 <code>x</code>，分别是全局的 <code>x</code>，参数作用域的 <code>x</code> 以及函数体内重新声明的 <code>x</code>。调用 <code>foo</code> 执行到 <code>y</code> 函数的时候，将值赋给 <code>x</code>，那么这是哪个 <code>x</code> 呢？对于 <code>y</code> 函数，<code>x</code> 不是在其体内声明的，所以这个 <code>x</code> 对它来说是自由变量，根据作用域链查找的规则，此时会查找到参数作用域中的 <code>x</code> ，并赋值为 2。之后打印 <code>x</code>，首先会在 <code>foo</code> 函数对应的变量对象中查找 <code>x</code> 的声明，确实 <code>foo</code> 函数里面有这个声明，所以就把它打印出来，为 3。后面在全局访问 <code>x</code> 时也同理，因为全局已经有这个 <code>x</code> 的声明，所以就把它打印出来，为 1。</p><p>事情到这里其实问题不大，直到后面遇到了两段代码，对于输出无法理解。</p><h3 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h3><p>先说第一个 snippet ：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> f1 <span class="token punctuation">(</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>  f <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>     <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码会报错：Identifier ‘x’ has already been declared。如果在同一作用域中用 let 重复声明一个变量，则确实会报错，但是根据上面的分析，这里其实是不同的两个作用域，按道理说不应该报错。为什么会报错呢？首先从标准来回答这个问题：</p><blockquote><p>4.1.2 Static Semantics:Early Errors<br>It is a Syntax Error if any element of the BoundNames of <strong>FormalParameters</strong> also occurs in the LexicallyDeclaredNames of <strong>FunctionBody</strong></p></blockquote><p>意思是说，如果参数名和函数体内的变量名相同，将会报 Syntax Error，而且注意这是一个 Early Errors，也就是说，在解析阶段就会报错 ——— 由此看出，这里的参数 x 和函数体内 x 其实是一起解析的，并在解析时报错。那么为什么要这么设计呢？根据 @紫云飞 老师的说法，这其实是出于合理情况的考虑 —— 这里就应该报错。因为如果不报错，让开发者重复声明了一个变量，那么在函数体作用域内，实参将难以获取（事实上我们依然可以通过参数作用域里的函数返回这个实参，但这不是我们希望的访问方式）。因此这里的报错是一种合理的设计。<br>到这里，这个问题就算解释清楚了，接下来说第二个问题。</p><h3 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h3><p>这是第二个 snippet</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> f1 <span class="token punctuation">(</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>  f <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">var</span> x<span class="token punctuation">;</span>     <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>奇怪，上面不是说重复声明会有 Syntax Error 吗？为何这里又不报错了？说实话，这个问题我暂时没有找到比较好的解释，只能说可能是由于上面的 Error 是针对 <code>let</code> 声明这种情况来说的，因为 ES5 中 <code>var</code> 的重复声明确实不会报错，在这里也一样不报错。那么回到问题，为什么这里会输出 2？先按照正常思路分析，执行 <code>f</code> 函数时，为 <code>x</code> 赋值 3，这个 <code>x</code> 按照之前的解释，应该是参数 <code>x</code> 而不是函数体内的 <code>x</code> 。所以，函数体的 <code>x</code> 依然是 <code>undefined</code>（只声明，没赋值），不过我们知道，结果打印的是 2，与预想相反。可以肯定的是，这里访问的一定是函数体的 <code>x</code>，那么它为何会有值 2 呢，难道它默认会有一个值吗？确实如此，我们再来看标准：</p><blockquote><p>NOTE vars whose names are the same as a formal parameter, initially have the same value as the corresponding initialized parameter.</p></blockquote><p>意思是说，与参数同名的 <code>var</code> 变量在初始的时候会具有一个与对应的参数相同的值。在这个例子中，函数体中的 x 的值将会和参数默认值一样，为 2。我们可以打下断点：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/ES6%20%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BD%9C%E7%94%A8%E5%9F%9F/ES6%20%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-2.png" alt=""></p><p>那么这样设计的目的是什么呢？前面我们说过，我们期望的合理行为是：可以在函数体内成功访问到实参，或者更准确地说，访问到实参的值。虽然这里我们无法轻易访问到实参，但是通过设置同名变量的值与实参相同，达到了类似的期望效果。</p><p>到这里问题算是解决了。这次问题的解决主要从三个方面入手：自主搜索、平台提问、阅读规范。网上有很多文章讲到参数默认值，但是提及参数作用域的文章数量很有限，所以最后也基本是依靠知乎上两位老师的回答以及自己的琢磨得出了结论。对我来说，阅读规范的难度还是太大了，很难定位到重点，所以本篇文章极有可能有表述错误的地方，如果你在阅读之后有任何的想法，欢迎在底下评论区留言。</p><p>这里附上一些相关的文章链接：<br><a href="https://juejin.im/post/5c7350c7f265da2dde06f3aa" target="_blank" rel="noopener">https://juejin.im/post/5c7350c7f265da2dde06f3aa</a><br><a href="https://segmentfault.com/a/1190000007537913#articleHeader0" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007537913#articleHeader0</a><br><a href="https://segmentfault.com/q/1010000015237136/a-1020000015242350" target="_blank" rel="noopener">https://segmentfault.com/q/1010000015237136/a-1020000015242350</a><br><a href="https://code.wileam.com/default-value-n-params-env/" target="_blank" rel="noopener">https://code.wileam.com/default-value-n-params-env/</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」利用 JavaScript 复制文本到剪贴板</title>
      <link href="/2019/05/23/Trs-%E5%88%A9%E7%94%A8JavaScript%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF/"/>
      <url>/2019/05/23/Trs-%E5%88%A9%E7%94%A8JavaScript%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>一个小小的诀窍。实现主题的复制代码功能时，思路刚好和这篇文章差不多，不过这篇文章的代码要更加合理。</p><blockquote><ul><li>原文地址：<a href="https://hackernoon.com/copying-text-to-clipboard-with-javascript-df4d4988697f" target="_blank" rel="noopener">Copying text to clipboard with JavaScript</a></li><li>原文作者：<a href="https://hackernoon.com/@chalarangelo?source=post_header_lockup" target="_blank" rel="noopener">Angelos Chalaris</a></li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p>本文将会深入介绍 <a href="https://github.com/Chalarangelo/30-seconds-of-code" target="_blank" rel="noopener">30 秒代码</a> 中 <strong><code>copyToClipboard</code></strong> 代码块的工作原理。你可以在项目仓库中找到它的源代码以及更多其他的实用方法。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E5%88%A9%E7%94%A8%20JavaScript%20%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF/%E5%88%A9%E7%94%A8JavaScript%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF-1.png" alt=""></p><center style="font-size:14px;color:#999">30 秒代码：可以在 30 秒或更短时间内理解的 JavaScript 代码块</center><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><p><a href="https://hackernoon.com/tagged/web-development" target="_blank" rel="noopener">搭建网站</a>时经常会遇到一个需求，那就是在用户没有选中或者使用键盘组合键的情况下，复制文本到剪贴板。<a href="https://hackernoon.com/tagged/javascript" target="_blank" rel="noopener">JavaScript</a> 可以用短短五步轻松解决这个问题：</p><p>1.创建一个稍后将插入到文档中的 <code>&lt;textarea&gt;</code> 元素。将我们想要复制到剪贴板的字符串设置为它的 <code>value</code> 。<br>2.将上诉 <code>&lt;textarea&gt;</code> 元素插入到当前的 HTML 文档中。<br>3.使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select" target="_blank" rel="noopener"><code>HTMLInputElement.select()</code></a> 选中 <code>&lt;textarea&gt;</code> 元素的内容。<br>4.使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Commands" target="_blank" rel="noopener"><code>Document.execCommand(&#39;copy&#39;)</code></a> 复制 <code>&lt;textarea&gt;</code> 元素的内容到剪贴板。<br>5.从文档中移除 <code>&lt;textarea&gt;</code> 元素。</p><p>这个方法的最简版本大概如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> copyToClipboard <span class="token operator">=</span> str <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'textarea'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  el<span class="token punctuation">.</span>value <span class="token operator">=</span> str<span class="token punctuation">;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>  el<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span><span class="token function">execCommand</span><span class="token punctuation">(</span><span class="token string">'copy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center style="font-size:14px;color:#999">copyToClipboard 方法的基本实现</center><p>记住，这个方法不是在任何情况下都可以使用的。因为 <code>Document.execCommand()</code> 的工作方式，它必须作为用户操作的响应结果。</p><h3 id="让插入的元素不可见"><a href="#让插入的元素不可见" class="headerlink" title="让插入的元素不可见"></a>让插入的元素不可见</h3><p>如果你试用了上面的方法，你可能会在 <code>&lt;textarea&gt;</code> 元素插入或者移除时看到闪烁。这对使用屏幕阅读器的人来说很糟糕，因为它会导致一些非常烦人的问题。因此，下一步合理的操作就是使用 CSS 让元素不可见，同时设置只读，以防止用户的试图干扰。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> copyToClipboard <span class="token operator">=</span> str <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'textarea'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  el<span class="token punctuation">.</span>value <span class="token operator">=</span> str<span class="token punctuation">;</span>  el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'readonly'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>position <span class="token operator">=</span> <span class="token string">'absolute'</span><span class="token punctuation">;</span>  el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token string">'-9999px'</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>  el<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span><span class="token function">execCommand</span><span class="token punctuation">(</span><span class="token string">'copy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center style="font-size:14px;color:#999">隐藏文本域的 copyToClipboard 实现</center><h3 id="保存和恢复原先的文档选中"><a href="#保存和恢复原先的文档选中" class="headerlink" title="保存和恢复原先的文档选中"></a>保存和恢复原先的文档选中</h3><p>最后需要考虑的问题是，用户可能已经在 HTML 文档中选中了一些内容，明智之举是不移除他们选中的这些内容。幸运的是，我们可以使用诸如 <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/getSelection" target="_blank" rel="noopener"><code>DocumentOrShadowRoot.getSelection()</code></a>,<a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount" target="_blank" rel="noopener"><code>Selection.rangeCount</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/getRangeAt" target="_blank" rel="noopener"><code>Selection.getRangeAt()</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/removeAllRanges" target="_blank" rel="noopener"><code>Selection.removeAllRanges()</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection/addRange" target="_blank" rel="noopener"><code>Selection.addRange()</code></a> 等现成的 JavaScript 方法和属性来保存和恢复原先的文档选中。这是最终的带注释的改良代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> copyToClipboard <span class="token operator">=</span> str <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'textarea'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建一个 &lt;textarea> 元素</span>  el<span class="token punctuation">.</span>value <span class="token operator">=</span> str<span class="token punctuation">;</span>                                 <span class="token comment" spellcheck="true">// 设置它的值为你想复制的字符串</span>  el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'readonly'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 设置为只读以防止干扰</span>  el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>position <span class="token operator">=</span> <span class="token string">'absolute'</span><span class="token punctuation">;</span>                   el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token string">'-9999px'</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 移出屏幕外以使其不可见</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 插入 &lt;textarea> 元素到 HTML 文档中</span>  <span class="token keyword">const</span> selected <span class="token operator">=</span>                document<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rangeCount <span class="token operator">></span> <span class="token number">0</span>        <span class="token comment" spellcheck="true">// 检查是否之前曾选中过内容</span>      <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRangeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 如果找到，则保存选中</span>      <span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">// 标记为  false 以表示不存在之前选中的内容</span>  el<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment" spellcheck="true">// 选中 &lt;textarea> 的内容</span>  document<span class="token punctuation">.</span><span class="token function">execCommand</span><span class="token punctuation">(</span><span class="token string">'copy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 复制 - 仅当作为用户操作的响应结果时才可以工作(比如，点击事件)</span>  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 移除 &lt;textarea> 元素</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>selected<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                 <span class="token comment" spellcheck="true">// 如果在复制前已存在选中的内容</span>    document<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeAllRanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 取消 HTML 文档中所有的选中部分</span>    document<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addRange</span><span class="token punctuation">(</span>selected<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 恢复原来的选中</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center style="font-size:14px;color:#999">最终形式的 copyToClipboard，可以保存选中</center><p>这就是全部的内容。仅用了不到 20 行代码，我们已经创建了前端开发中最常用的方法之一。</p><p>如果喜欢这篇文章，给一个 clap（或者 fifty）。记得查看 <a href="https://github.com/Chalarangelo/30-seconds-of-code" target="_blank" rel="noopener">30 秒代码</a> ，为你的 JavaScript 项目找到更多实用的代码块！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 30 seconds of code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习知识体系</title>
      <link href="/2019/05/22/T-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"/>
      <url>/2019/05/22/T-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="https://segmentfault.com/a/1190000018992363" target="_blank" rel="noopener">一名【合格】前端工程师的自检清单</a></li><li>原文作者：<a href="https://segmentfault.com/u/conardli" target="_blank" rel="noopener">ConardLi</a><a id="more"></a></li></ul></blockquote><p>原文题目是《一名合格前端工程师的自检清单》，我目前的水平离前端工程师还很遥远，所以更愿意把这篇文章当作是对知识体系或者学习路线的总结。同时也是对自己的一个警醒，做好长期学习的准备。</p><p>PS：<i class="fa fa-floppy-o"></i> 表示自己增加的部分</p><hr><h2 id="一、JavaScript"><a href="#一、JavaScript" class="headerlink" title="一、JavaScript"></a>一、JavaScript</h2><p><strong>变量和类型</strong></p><ul><li>1.JavaScript 规定了几种数据类型</li><li>2.JavaScript 对象的底层数据结构是什么</li><li>3.Symbol 类型在实际开发中的应用、可手动实现一个简单的 Symbol</li><li>4.基本类型对应的内置对象，以及他们之间的装箱拆箱操作</li><li>5.理解值类型和引用类型</li><li>6.赋值、浅拷贝、深拷贝的区别</li><li>7.<code>null</code> 和 <code>undefined</code> 的区别</li><li>8.至少可以说出三种判断 JavaScript 数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</li><li>9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用</li><li>10.出现小数精度丢失的原因， JavaScript 可以存储的最大数字、最大安全数字， JavaScript 处理大数字的方法、避免精度丢失的方法</li></ul><p><strong>原型和原型链</strong></p><ul><li>1.理解原型设计模式以及 JavaScript中的原型规则</li><li>2.instanceof的底层实现原理，手动实现一个 instanceof</li><li>3.实现继承的几种方式以及他们的优缺点</li><li>4.至少说出一种开源项目(如 Node)中应用原型继承的案例</li><li>5.可以描述 new一个对象的详细过程，手动实现一个 new操作符</li><li>6.理解 es6class构造以及继承的底层实现原理</li></ul><p><strong>作用域和闭包</strong></p><ul><li>1.理解词法作用域和动态作用域</li><li>2.理解 JavaScript 的作用域和作用域链</li><li>3.理解 JavaScript 的执行上下文栈和变量对象，可以应用堆栈信息快速定位问题</li><li>4.this 的绑定，<code>call</code>、<code>apply</code>、<code>bind</code> 的原理</li><li>5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用</li><li>6.如何处理循环的异步操作</li><li>7.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理</li></ul><p><strong>内存机制</strong></p><ul><li>内存空间，堆栈存储</li><li>理解堆栈溢出、内存泄漏的原理，如何防止，如何进行垃圾回收</li></ul><p><strong>执行机制</strong></p><ul><li>1.为何 try 里面放 return， finally 还会执行，理解其内部机制</li><li>2.JavaScript 如何实现异步编程，可以详细描述 EventLoop 机制</li><li>3.宏任务和微任务分别有哪些</li><li>4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法</li><li>5.使用 Promise 实现串行</li><li>6.Node 与浏览器 EventLoop 的差异</li><li>7.如何在保证页面运行流畅的情况下处理海量数据</li></ul><p><strong>语法和API</strong></p><ul><li>1.理解 ECMAScript 和 JavaScript 的关系</li><li>2.熟练运用 es5、 es6 提供的语法规范，尤其是掌握 es6 的 let、解构、箭头函数、Promise、Async、Await、Class 等</li><li>3.熟练掌握 JavaScript提供的全局对象、全局函数、全局属性</li><li>4.熟练应用 <code>map</code>、 <code>reduce</code>、 <code>filter</code> 等高阶函数解决问题</li><li>5.setInterval 需要注意的点，使用 settimeout 实现 setInterval</li><li>6.JavaScript 提供的正则表达式 API、可以使用正则表达式（邮箱校验、 URL 解析、去重等）解决常见问题</li><li>7.JavaScript 异常处理的方式，统一的异常处理方案</li></ul><p><strong>jQuery</strong></p><ul><li>1.熟练掌握选择器，样式操作，dom 操作，事件绑定</li><li>2.链式编程（方法链），动画</li><li>3.常用组件，通过源代码了解封装原理</li></ul><h2 id="二、HTML和CSS"><a href="#二、HTML和CSS" class="headerlink" title="二、HTML和CSS"></a>二、HTML和CSS</h2><p><strong>HTML</strong></p><ul><li>1.从规范的角度理解 HTML，从分类和语义的角度使用标签</li><li>2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式</li><li>3.元信息类标签( head、 title、 meta)的使用目的和配置方法</li><li>4.HTML5离线缓存原理</li><li>5.可以使用 CanvasAPI、 SVG 等绘制高性能的动画</li></ul><p><strong>CSS</strong></p><ul><li>1.CSS 盒模型，在不同浏览器的差异（w3c 盒模型，IE 盒模型）</li><li>2.CSS 所有选择器及其优先级、使用场景，哪些属性可以继承，如何运用 at规则</li><li>3.CSS 伪类和伪元素有哪些，它们的区别和实际应用</li><li>4.HTML 文档流的排版规则， CSS 几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理</li><li>5.水平垂直居中的方案、可以实现 6 种以上并对比它们的优缺点</li><li>6.BFC 实现原理，可以解决的问题，如何创建 BFC，如何清除浮动</li><li>7.了解布局方案的发展历史（table、div+css、一维 flex、二维 grid）。熟悉 flex 布局的六大容器属性和项目属性</li><li>7.可使用 CSS 函数复用代码，实现特殊效果</li><li>8.PostCSS、 Sass、 Less 的异同，以及使用配置，至少掌握一种</li><li>9.CSS 模块化方案、如何配置按需加载、如何防止 CSS 阻塞渲染</li><li>10.CSS 浏览器兼容性写法，了解不同 API 在不同浏览器下的兼容性情况</li><li>11.掌握多套完整的响应式布局方案</li></ul><p><strong>手写</strong></p><ul><li>1.手写瀑布流、轮播图、焦点图、弹出层、手风琴菜单、返回顶部、导航定位 <i class="fa fa-floppy-o"></i></li><li>2.使用 CSS 绘制几何图形（圆形、三角形、扇形、菱形等）</li><li>3.使用纯 CSS 实现曲线运动（贝塞尔曲线）</li><li>4.使用 CSS 实现常见动画，如渐变、移动、旋转、缩放等等</li><li>4.实现常用布局效果（二列、三列、圣杯、双飞翼、吸顶、移动吸顶），可以说出多种方式并理解其优缺点</li></ul><p><strong>框架</strong></p><ul><li>bootstrap 的组件应用、常用模板、删格系统 <i class="fa fa-floppy-o"></i></li></ul><h2 id="三、计算机基础"><a href="#三、计算机基础" class="headerlink" title="三、计算机基础"></a>三、计算机基础</h2><blockquote><p>关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要</p></blockquote><p><strong>编译原理</strong></p><ul><li>1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序</li><li>2.正则表达式的匹配原理和性能优化</li><li>3.如何将 JavaScript代码解析成抽象语法树( AST)</li><li><ol start="4"><li>base64的编码原理</li></ol></li><li>5.几种进制的相互转换计算方法，在 JavaScript中如何表示和转换</li></ul><p><strong>网络协议</strong></p><ul><li>1.理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用</li><li>2.三次握手和四次挥手详细原理，为什么要使用这种机制</li><li>3.有哪些协议是可靠， TCP 有哪些手段保证可靠交付</li><li>4.DNS 的作用、 DNS 解析的详细过程， DNS 优化原理</li><li>5.CDN 的作用和原理</li><li>6.HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么</li><li>7.HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题</li><li>8.HTTP1.1、 HTTP2.0 带来的改变</li><li>9.HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求</li><li>10.理解 WebSocket 协议的底层原理、与 HTTP 的区别</li></ul><p><strong>设计模式</strong></p><ul><li>1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等</li><li>2.发布订阅模式和观察者模式的异同以及实际应用</li><li>3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用</li></ul><h2 id="四、数据结构和算法"><a href="#四、数据结构和算法" class="headerlink" title="四、数据结构和算法"></a>四、数据结构和算法</h2><p><strong>JavaScript编码能力</strong></p><ul><li>1.多种方式实现数组去重、扁平化、对比优缺点</li><li>2.多种方式实现深拷贝、对比优缺点</li><li>3.手写函数柯里化工具函数、并理解其应用场景和优势</li><li>4.手写防抖和节流工具函数、并理解其内部原理和应用场景</li><li>5.实现一个 sleep 函数</li></ul><p><strong>手动实现前端轮子</strong></p><ul><li>1.手动实现 <code>call</code>、<code>apply</code>、<code>bind</code></li><li>2.手动实现符合 Promise/A+ 规范的 Promise、手动实现 asyncawait</li><li>3.手写一个 EventEmitter 实现事件发布、订阅</li><li>4.可以说出两种实现双向绑定的方案、可以手动实现</li><li>5.手写 JSON.stringify、JSON.parse</li><li>6.手写一个模版引擎，并能解释其中原理</li><li>7.手写懒加载、下拉刷新、上拉加载、预加载等效果</li></ul><p><strong>数据结构</strong></p><ul><li>1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点</li><li>2.理解数组、字符串的存储原理，并熟练应用他们解决问题</li><li>3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题</li><li>4.了解图、堆的基本结构和使用场景</li></ul><p><strong>算法</strong></p><ul><li>1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗</li><li>2.至少理解五种排序算法的实现原理、应用场景、优缺点,可快速说出时间、空间复杂度</li><li>3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用</li><li>4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题</li><li>5.前端处理海量数据的算法方案</li></ul><h2 id="五、运行环境"><a href="#五、运行环境" class="headerlink" title="五、运行环境"></a>五、运行环境</h2><blockquote><p>我们需要理清语言和环境的关系：ECMAScript描述了 JavaScript语言的语法和基本对象规范浏览器作为 JavaScript的一种运行环境，为它提供了：文档对象模型（ DOM），描述处理网页内容的方法和接口、浏览器对象模型（ BOM），描述与浏览器进行交互的方法和接口Node也是 JavaScript的一种运行环境，为它提供了操作 I/O、网络等 API</p></blockquote><p><strong>浏览器 API</strong></p><ul><li>1.浏览器提供的符合 W3C标准的 DOM 操作 API、浏览器差异、兼容性</li><li>2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局 API、浏览器差异、兼容性</li><li>3.大量 DOM 操作、海量数据的性能优化(合并操作、Diff、 requestAnimationFrame 等)</li><li>4.浏览器海量数据存储、操作性能优化</li><li><ol start="5"><li>DOM 事件流的具体实现机制、不同浏览器的差异、事件代理</li></ol></li><li>6.前端发起网络请求的几种方式及其底层实现、可以手写原生 ajax、 fetch、可以熟练使用第三方库</li><li>7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型</li><li>8.浏览器跨域解决方案</li><li>9.浏览器提供的几种存储机制、优缺点、开发中正确的选择</li><li>10.浏览器跨标签通信</li></ul><p><strong>浏览器原理</strong></p><ul><li>1.各浏览器使用的 JavaScript 引擎以及它们的异同点、如何在代码中进行区分</li><li>2.请求数据到请求结束与服务器进行了几次交互</li><li>3.可详细描述浏览器从输入 URL 到页面展现的详细过程</li><li>4.浏览器解析 HTML 代码的原理，以及构建 DOM 树的流程</li><li>5.浏览器如何解析 CSS 规则，并将其应用到 DOM 树上</li><li>6.浏览器如何将解析好的带有样式的 DOM 树进行绘制</li><li>7.浏览器的运行机制，如何配置资源异步同步加载</li><li>8.浏览器回流与重绘的底层原理，引发原因，如何有效避免</li><li>9.浏览器的垃圾回收机制，如何避免内存泄漏</li><li>10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案</li></ul><p><strong>AJAX</strong> <i class="fa fa-floppy-o"></i></p><ul><li>1.Ajax 简介、异步的概念、Ajax 框架的封装、XMLHttpRequest 对象、兼容性处理方法、Ajax 缓存问题、XML 介绍和使用</li><li>2.JSON 和 JSON 解析、数据绑定和模板技术、JSONP、跨域技术、图片预读取和 lazy-load 技术、JQuery 框架中的 AjaxAPI</li></ul><p><strong>Node</strong></p><ul><li>1.理解 Node 在应用程序中的作用，可以使用 Node 搭建前端运行环境、使用 Node 操作文件、操作数据库等等</li><li>2.掌握一种 Node 开发框架，如 Express， Express 和 Koa的区别</li><li>3.熟练使用 Node 提供的 API 如 Path、 Http、 ChildProcess 等并理解其实现原理</li><li>4.Node 的底层运行原理、和浏览器的异同</li><li>5.Node 事件驱动、非阻塞机制的实现原理</li></ul><h2 id="六、框架和类库"><a href="#六、框架和类库" class="headerlink" title="六、框架和类库"></a>六、框架和类库</h2><blockquote><p>轮子层出不穷，从原理上理解才是正道</p></blockquote><p><strong>TypeScript</strong></p><ul><li>1.理解泛型、接口等面向对象的相关概念，TypeScript 对面向对象理念的实现</li><li>2.理解使用 TypeScript 的好处，掌握 TypeScript 基础语法</li><li>3.TypeScript 的规则检测原理</li><li>4.可以在 React、 Vue 等框架中使用 TypeScript 进行开发</li></ul><p><strong>Vue</strong></p><ul><li>1.熟练使用 Vue 的 API、生命周期、钩子函数</li><li>2.MVVM 框架设计理念</li><li>3.Vue 双向绑定实现原理、Diff 算法的内部实现</li><li>4.Vue 的事件机制</li><li>5.从 template 转换成真实 DOM 的实现机制</li></ul><p><strong>多端开发</strong></p><ul><li>1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发 SPA的方案</li><li>2.理解 Viewport、em、rem 的原理和用法，分辨率、 px、 ppi、 dpi、 dp的区别和实际应用</li><li>3.移动端页面适配解决方案、不同机型适配方案，移动端测试和调试</li><li>4.掌握一种 JavaScript移动客户端开发技术，如 ReactNative：可以搭建 ReactNative 开发环境，熟练进行开发，可理解 ReactNative 的运作原理，不同端适配</li><li>5.掌握一种 JavaScript PC客户端开发技术，如 Electron：可搭建 Electron 开发环境，熟练进行开发，可理解 Electron 的运作原理</li><li>6.掌握一种小程序开发框架或原生小程序开发</li><li>7.理解多端框架的内部实现原理，至少了解一个多端框架的使用</li></ul><p><strong>数据流管理</strong></p><ul><li>1.掌握 React 和 Vue 传统的跨组件通信方案，对比采用数据流管理框架的异同</li><li>2.熟练使用 Redux 管理数据流，并理解其实现原理，中间件实现原理</li><li>3.熟练使用 Mobx 管理数据流，并理解其实现原理，相比 Redux 有什么优势</li><li>4.熟练使用 Vuex 管理数据流，并理解其实现原理</li><li>5.以上数据流方案的异同和优缺点，不情况下的技术选型</li></ul><p><strong>实用库</strong></p><ul><li>1.至少掌握一种 UI 组件框架，如 antd design，理解其设计理念、底层实现</li><li>2.掌握一种图表绘制框架，如 Echart，理解其设计理念、底层实现，可以自己实现图表</li><li>3.掌握一种 GIS 开发框架，如百度地图 API</li><li>4.掌握一种可视化开发框架，如 Three.js、 D3</li><li>5.工具函数库，如 lodash、 underscore、 moment 等，理解使用的工具类或工具函数的具体实现原理</li></ul><p><strong>开发和调试</strong></p><ul><li>1.熟练使用各浏览器提供的调试工具</li><li>2.熟练使用一种代理工具实现请求代理、抓包，如 charls</li><li>3.可以使用 Android、 IOS模拟器进行调试，并掌握一种真机调试方案</li><li>4.了解 Vue、 React等框架调试工具的使用</li></ul><h2 id="七、前端工程"><a href="#七、前端工程" class="headerlink" title="七、前端工程"></a>七、前端工程</h2><blockquote><p>前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度</p></blockquote><p><strong>项目构建</strong></p><ul><li>1.理解 npm、 yarn依赖包管理的原理，两者的区别</li><li>2.可以使用 npm运行自定义脚本</li><li>3.理解 Babel、 ESLint、 webpack等工具在项目中承担的作用</li><li>4.ESLint规则检测原理，常用的 ESLint配置</li><li>5.Babel的核心原理，可以自己编写一个 Babel插件</li><li>6.可以配置一种前端代码兼容方案，如 Polyfill</li><li>7.Webpack的编译原理、构建流程、热更新原理， chunk、 bundle和 module的区别和应用</li><li>8.可熟练配置已有的 loaders和 plugins解决问题，可以自己编写 loaders和 plugins</li></ul><p><strong>nginx</strong></p><ul><li>1.正向代理与反向代理的特点和实例</li><li>2.可手动搭建一个简单的 nginx服务器、</li><li>3.熟练应用常用的 nginx内置变量，掌握常用的匹配规则写法</li><li>4.可以用 nginx实现请求过滤、配置 gzip、负载均衡等，并能解释其内部原理</li></ul><p><strong>开发提速</strong></p><ul><li>1.熟练掌握一种接口管理、接口 mock工具的使用，如 yapi</li><li>2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题</li><li>3.理解 TDD与 BDD模式，至少会使用一种前端单元测试框架</li></ul><p><strong>版本控制</strong></p><ul><li>1.理解 Git的核心原理、工作流程、和 SVN的区别</li><li>2.熟练使用常规的 Git命令、 git rebase、 git stash等进阶命令</li><li>3.可以快速解决 线上分支回滚、 线上分支错误合并等复杂问题</li><li>4.熟练使用Github平台</li></ul><p><strong>持续集成</strong></p><ul><li>1.理解 CI/CD技术的意义，至少熟练掌握一种 CI/CD工具的使用，如 Jenkins</li><li>2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括 Web应用、移动客户端应用、 PC客户端应用、小程序、 H5等等）</li></ul><h2 id="八、项目和业务后端技能"><a href="#八、项目和业务后端技能" class="headerlink" title="八、项目和业务后端技能"></a>八、项目和业务后端技能</h2><ul><li>1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言</li><li>2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库</li></ul><p><strong>性能优化</strong></p><ul><li>1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案</li><li>2.了解常见的 Web、 App性能优化方案</li><li>3.SEO排名规则、 SEO优化方案、前后端分离的 SEO</li><li>4.SSR实现方案、优缺点、及其性能优化</li><li>5.Webpack的性能优化方案</li><li>6.Canvas性能优化方案</li><li>7.React、 Vue等框架使用性能优化方案</li></ul><p><strong>前端安全</strong></p><ul><li>1.XSS攻击的原理、分类、具体案例，前端如何防御</li><li>2.CSRF攻击的原理、具体案例，前端如何防御</li><li>3.HTTP劫持、页面劫持的原理、防御措施</li></ul><p><strong>业务相关</strong></p><ul><li>1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题</li><li>2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题</li><li>3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性</li></ul><h2 id="九、学习提升"><a href="#九、学习提升" class="headerlink" title="九、学习提升 "></a>九、学习提升 <i class="fa fa-floppy-o"></i></h2><ul><li>1.博客：持续更新博客，定期总结知识，不断完善自己的知识体系</li><li>2.英语：参与社区翻译，在阅读资料上逐渐往官方文档和英文博客靠拢</li><li>3.人际：保持好奇心，保持解疑的热情，保持理性交流</li><li>4.知识管理：RSS/书籍/社区 —— 印象笔记 —— 博客</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础系列：从清除浮动和margin塌陷问题谈BFC</title>
      <link href="/2019/05/17/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC/"/>
      <url>/2019/05/17/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E8%B0%88BFC/%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC-0.jpg" alt=""><br><a id="more"></a></p><h2 id="1-清除浮动"><a href="#1-清除浮动" class="headerlink" title="1.清除浮动"></a>1.清除浮动</h2><p>浮动的元素会影响其兄弟元素的位置，并可能导致父元素的高度塌陷（假如父元素没设置高度），因此需要清除浮动（带来的影响）。</p><h3 id="1-1-方法"><a href="#1-1-方法" class="headerlink" title="1.1 方法"></a>1.1 方法</h3><p>常用方法有：</p><ul><li>给浮动元素的父元素一个固定高度（不推荐）</li><li>给浮动元素新增一个空的 <code>div</code> 兄弟元素，设置 <code>clear:both</code></li><li>给浮动元素新增一个 <code>&lt;br&gt;</code> 兄弟元素，设置 clear 属性为 all</li><li>给浮动元素的父元素新增一个 after 伪类，设置该伪类和父元素：</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">{</span>    <span class="token property">zoom</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">div<span class="token pseudo-element">:after</span></span><span class="token punctuation">{</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">""</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>    <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>给浮动元素的父元素设置 <code>display: table</code>（触发BFC）</li><li>给浮动元素的父元素也设置浮动（触发 BFC。不推荐）</li><li>给浮动元素的父元素设置 <code>overflow: hidden</code>（触发 BFC）</li></ul><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h3><p>这里主要说下 <code>clear:both</code>。<code>clear:both</code> 意思是说，设置了该属性的元素，其左边和右边不允许存在浮动元素。</p><ul><li>父元素高度塌陷的情况：子元素浮动后脱离了文档流，未设置高度的父元素在形式上表现为 0 高度，设置了 <code>clear:both</code> 的元素为了满足其左右两边没有浮动元素的这个条件，只能自身下移，从而带动了父元素高度的撑开。</li><li>兄弟元素覆盖的情况：同理，比如A由于浮动覆盖了 C，我们在 AC 之间新增一个 B 元素，则 BC 位于同一文档流，B 为了满足其左右两边没有浮动元素的这个条件，只能自身下移，从而带动了 C 元素向下移动直到没有被 A 覆盖。</li></ul><p>那么为什么除了 <code>clear:both</code> 之外，其他方法也能清除浮动呢？因为那些方法大都触发了 BFC，而 BFC 是可以清除浮动的，这个后面再介绍。</p><h2 id="2-margin-塌陷"><a href="#2-margin-塌陷" class="headerlink" title="2.margin 塌陷"></a>2.margin 塌陷</h2><p>文档流内，块级元素与块级元素在垂直方向上的 margin 有时会合并（塌陷）为单个 margin，这样的现象称之为 margin 塌陷（margin collapse）。具体包括三种情况：</p><ul><li><span style="background-color:#fffa7d">相邻的兄弟元素之间：</span><br>原因：<br>相邻的兄弟元素默认位于同一个块级上下文中<br>计算规则：<br>正正取大值，正负值相加，负负最小值<br><br></li><li><span style="background-color:#fffa7d">父元素与第一个/最后一个子元素之间：</span><br>原因：<br><strong>a.margin-top 重叠</strong><br>父元素非块状格式化上下文元素<br>父元素没有border-top设置<br>父元素没有padding-top值<br>父元素和第一个子元素之间没有inline元素分隔<br><strong>b.margin-bottom 重叠</strong><br>父元素非块状格式化上下文设置<br>父元素没有 <code>border-bottom</code> 设置<br>父元素没有 <code>padding-bottom</code> 值<br>父元素和第一个子元素之间没有inline元素分隔<br>父元素没有 height，min-height，max-height<br>计算规则：<br>子元素和父元素上边界重叠，并且以子元素的 <code>margin-top</code> 作为父元素的 <code>margin-top</code> 整体移动。对于 <code>margin-bottom</code> 同理。<br><br></li><li><span style="background-color:#fffa7d">空的block元素:</span><br>原因：<br>元素没有 border 设置<br>元素没有 padding 值<br>里面没有 inline 元素<br>没有 height 或者min-height</li></ul><p>那么怎么解决 margin 塌陷问题呢？同样是利用接下来要讲到的 BFC。</p><h2 id="3-BFC"><a href="#3-BFC" class="headerlink" title="3.BFC"></a>3.BFC</h2><h3 id="3-1-什么是-BFC？"><a href="#3-1-什么是-BFC？" class="headerlink" title="3.1 什么是 BFC？"></a>3.1 什么是 BFC？</h3><p>BFC 即 Block formatting context，译为块级格式化上下文。简单来说，它是一种属性，这种属性影响着元素的定位以及与其兄弟元素之间的相互作用。因为是属性，所以我们通常说“元素具有 BFC”、“元素触发了 BFC”，而不说“元素是 BFC”。</p><p>从样式上看，具有 BFC 的元素与普通的容器没有什么区别；但是从功能上，具有 BFC 的元素可以看作是隔离了的独立容器，容器里面的子元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性。</p><h3 id="3-2-如何触发-BFC？"><a href="#3-2-如何触发-BFC？" class="headerlink" title="3.2 如何触发 BFC？"></a>3.2 如何触发 BFC？</h3><p>CSS 规定满足下列 CSS 声明之一的元素便会生成 BFC：</p><ul><li>根元素或其它包含它的元素；</li><li>float 的值不为 none；</li><li>overflow 的值不为 visible；</li><li>position 的值为 absolute 或 fixed；</li><li>display 的值为 inline-block、table-cell、table-caption、table、flex、inline-flex、flow-root<blockquote><p>table 本身不生成 BFC，而是 table 默认生成的匿名 table-cell 会生成 BFC</p></blockquote></li></ul><h3 id="3-3-BFC-的特性"><a href="#3-3-BFC-的特性" class="headerlink" title="3.3 BFC 的特性"></a>3.3 BFC 的特性</h3><p>从整体上看，BFC 是隔离了的容器，这个具体可以表现为三个特性：</p><h4 id="3-3-1-BFC-会阻止-margin-塌陷"><a href="#3-3-1-BFC-会阻止-margin-塌陷" class="headerlink" title="3.3.1 BFC 会阻止 margin 塌陷"></a>3.3.1 BFC 会阻止 margin 塌陷</h4><p>前面我们说过 BFC 可以用于解决 margin 塌陷问题。</p><ul><li>因为相邻兄弟元素默认位于同一个 BFC 是导致 margin 塌陷的原因，所以我们只需要设法隔离它们两者即可 ———— 假设有兄弟元素 A 和 B，可以使 A 的父元素触发 BFC，此时，触发了 BFC 的父元素里面的 A 子元素不会在布局上影响到 B，也自然不会有 margin 的叠加。</li><li>同样地，如果是父子嵌套的 margin 塌陷问题，只需要触发父元素的 BFC 即可。</li></ul><h4 id="3-3-2-BFC-可以包含浮动的元素"><a href="#3-3-2-BFC-可以包含浮动的元素" class="headerlink" title="3.3.2 BFC 可以包含浮动的元素"></a>3.3.2 BFC 可以包含浮动的元素</h4><p>前面说过，父元素没有设置高度时，子元素的浮动会导致父元素表现为 0 高度，也就是说正常情况下父元素无法包含浮动的子元素。如图：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.Fa</span></span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">2</span>px solid red<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.son</span></span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">180</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">180</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span>yellow<span class="token punctuation">;</span>    <span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E8%B0%88BFC/%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC-2.png" alt=""></p><p>但是触发了父元素的 BFC 后，父元素将可以包含浮动的子元素。如图：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.Fa</span></span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">2</span>px solid red<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 随便一个 BFC 的触发条件 */</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.son</span></span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">180</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">180</span>px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span>yellow<span class="token punctuation">;</span>    <span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E8%B0%88BFC/%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC-3.png" alt=""></p><h4 id="3-3-3-BFC-可以阻止元素被浮动元素覆盖"><a href="#3-3-3-BFC-可以阻止元素被浮动元素覆盖" class="headerlink" title="3.3.3 BFC 可以阻止元素被浮动元素覆盖"></a>3.3.3 BFC 可以阻止元素被浮动元素覆盖</h4><p>前面说过浮动元素会影响兄弟元素的位置，具体地说就是浮动之后脱离了文档流，使得兄弟元素上移填补空缺，而这会使得它被浮动元素覆盖。如图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E8%B0%88BFC/%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC-4.png" alt=""></p><p>但是触发了兄弟元素的 BFC 后，兄元素将不会被浮动的元素覆盖 ———— 不会被覆盖，意味着兄弟元素出现在浮动元素的旁边或者下面，具体取决于父元素的宽度。<br>如果父元素的宽度足以包含这两个子元素的宽度之和，则子兄弟元素和子浮动元素并排。如图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E8%B0%88BFC/%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC-5.png" alt=""></p><p>如果父元素的宽度不足以包含这两个子元素的宽度之和，则子兄弟元素会出现在子浮动元素的下面。如图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E8%B0%88BFC/%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC-6.png" alt=""></p><h2 id="4-可视化格式模型"><a href="#4-可视化格式模型" class="headerlink" title="4.可视化格式模型"></a>4.可视化格式模型</h2><p>让我们进一步拓展一下可视化格式模型的一些概念，由于比较复杂，所以只做了解即可。</p><blockquote><p>可视化格式模型规定了客户端（浏览器）如何在媒介（显示器）中渲染文档树(document tree)。如下图，每个节点、元素都有属于自己的可见或不可见、有名或匿名的盒模型，可视化格式模型即规定了这些盒、框框如何整齐地排列在页面中，还有盒子之间的相互作用。</p></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BB%8E%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98%E8%B0%88BFC/%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC-7.gif" alt=""></p><p>可视化格式模型的体系包括：<br>1.包含块 CB(Containing block)<br>2.控制框：块框、行框<br>3.FC(Formatting Context, 格式化上下文)</p><ul><li>BFC(Block Formatting Context, 块级格式化上下文)</li><li>IFC(Inline Formatting Context, 行内格式上下文)</li><li>GFC(Grid Formatting Context, 网格布局格式化上下文)</li><li>FFC(Flex formatting contexts, 自适应格式上下文)<br>4.定位体系/方案(普通流、定位流、浮动流)<br>5.浮动体系</li></ul><p>这里只说 FC 和定位体系。</p><h3 id="4-1-FC"><a href="#4-1-FC" class="headerlink" title="4.1 FC"></a>4.1 FC</h3><blockquote><p>FC 即 Formatting context，译为格式化上下文。这是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系、相互作用。除了最常见的 CSS2.1 中的 BFC 和 IFC 之外，CSS3 中还增加了 GFC 和 FFC。</p></blockquote><h4 id="4-1-1-BFC："><a href="#4-1-1-BFC：" class="headerlink" title="4.1.1 BFC："></a>4.1.1 BFC：</h4><p>前面已经说过了。</p><h4 id="4-1-2-IFC："><a href="#4-1-2-IFC：" class="headerlink" title="4.1.2 IFC："></a>4.1.2 IFC：</h4><ul><li>IFC 的 line box 高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。IFC 的line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 IFC 下的多个 line box 高度会不同。</li><li>IFC 中是不可能有块级元素的，当插入块级元素时（如 <code>p</code> 中插入 <code>div</code>）会产生两个匿名块与 <code>div</code> 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 <code>div</code> 垂直排列。</li><li>那么IFC一般有什么用呢？<br>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。<br>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 <code>vertical-align:middle</code>，其他行内元素则可以在此父元素下垂直居中。</li></ul><h4 id="4-1-3-GFC："><a href="#4-1-3-GFC：" class="headerlink" title="4.1.3 GFC："></a>4.1.3 GFC：</h4><ul><li>当为一个元素设置 <code>display:grid</code> 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。</li><li>那么 GFC 有什么用呢，和 table 又有什么区别呢？首先同样是一个二维的表格，但 GridLayout 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。</li></ul><h4 id="4-1-4-FFC："><a href="#4-1-4-FFC：" class="headerlink" title="4.1.4 FFC："></a>4.1.4 FFC：</h4><p><code>display:flex</code> 或者 <code>display:inline-flex</code> 的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少 safari 和 chrome 还是 OK 的，毕竟这俩在移动端才是王道。<br>Flex box 由伸缩容器和伸缩项目组成。通过设置元素<code>display:flex</code> 或者 <code>display:inline-flex</code> 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。<br>伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flex box 定义了伸缩容器内伸缩项目该如何布局。</p><h3 id="4-2-定位方案"><a href="#4-2-定位方案" class="headerlink" title="4.2 定位方案"></a>4.2 定位方案</h3><p>在定位的时候，浏览器会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。在 CSS2.1 中，有三种定位方案 ———— 普通流、浮动和绝对定位，下面分别对这三种布局简略说明一下：</p><p><strong>普通流(Normal flow)</strong></p><ul><li>在普通流中，盒一个接着一个排列;</li><li>在块级格式化上下文里面，它们竖着排列；</li><li>在行内格式化上下文里面，它们横着排列;</li><li>通常情况下， position 为 static 或 relative，并且 float 为 none ，因而会触发普通流；</li><li>position 为 static 时，盒的位置是常规流布局里的位置；</li><li>position 为 relative 时，盒偏移位置由 top，bottom，left 和 right 定义。即使有偏移，仍然保留原有的位置，其它普通流不能占用这个位置。</li></ul><p><strong>浮动 (Floats)</strong></p><ul><li>元素脱离普通流，并且影响普通流的布局 ———— 导致普通流环绕在它的周边，除非设置 clear 属性；</li><li>盒称为浮动盒(floating boxes)；</li><li>它位于当前行的开头或末尾；</li></ul><p><strong>绝对定位 (Absolute positioning)</strong></p><ul><li>元素脱离普通流，并且不影响普通流的布局</li><li>它的定位相对于它的包含块，相关CSS属性：top，bottom，left 和 right；</li><li>如果元素为 <code>position:absolute</code> 或 <code>position:fixed</code>，它是绝对定位元素；</li><li>对于 <code>position: absolute</code>，元素将相对最近的一个非 static 定位的父元素进行定位，如果没有则相对于 body；</li></ul><p>参考：<br><a href="https://juejin.im/post/59b73d5bf265da064618731d#heading-1" target="_blank" rel="noopener">学习 BFC (Block Formatting Context)</a><br><a href="https://wz71014q.github.io/2019/03/23/CSS-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B/#more" target="_blank" rel="noopener">CSS-可视化格式模型</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFC </tag>
            
            <tag> 浮动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「译」JavaScript 究竟是如何工作的？（第一部分）</title>
      <link href="/2019/05/10/Trs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2019/05/10/Trs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="https://blog.bitsrc.io/how-does-javascript-really-work-part-1-7681dd54a36d" target="_blank" rel="noopener">How Does JavaScript Really Work? (Part 1)</a></li><li>原文作者：<a href="https://blog.bitsrc.io/@priyeshp18" target="_blank" rel="noopener">Priyesh Patel</a></li><li>译文地址：<a href="https://juejin.im/post/5cef7f1be51d45777811732c" target="_blank" rel="noopener">[译] JavaScript 究竟是如何工作的？（第一部分）</a></li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/JavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89-1.jpg" alt=""></p><p>如果你是一个 JS 开发者或者是正在学习这门语言的学生，很大概率上你会遇到双字母词”V8”。在这篇文章中，我将会为你简述不同的 JS 引擎并深入探究 V8 引擎的工作机制。文章的第二部分涵盖了内存管理的概念，不久后将发布。</p><p>这篇文章是由 <a href="https://bit.dev" target="_blank" rel="noopener"><strong>Bit</strong></a> (<a href="https://github.com/teambit/bit" target="_blank" rel="noopener">GitHub</a>) 带来的。作为一个共享组件的平台，Bit 帮助每个人构建模块化的 JavaScript 应用程序，在项目和团队之间轻松地共享组件，同时实现更好&amp;更快的构建。<a href="https://bit.dev" target="_blank" rel="noopener">试试看</a>。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/JavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89-2.gif" alt=""></p><h3 id="1-编程语言是如何工作的？"><a href="#1-编程语言是如何工作的？" class="headerlink" title="1.编程语言是如何工作的？"></a>1.编程语言是如何工作的？</h3><p>在开始讲解 JavaScript 之前，我们首先要理解任意一门编程语言的基本工作方式。电脑是由微处理器构成的，我们通过书写代码来命令这台小巧但功能强大的机器。但是微处理器能理解什么语言？它们无法理解 Java，Python 等语言，而只懂机器码。<br>用机器语言或汇编语言编写企业级代码是不可行的，因此我们需要像 Java，Python 这样配带一个解释器或者编译器用于将其转换为机器码的高级语言。</p><h4 id="1-1编译器和解释器"><a href="#1-1编译器和解释器" class="headerlink" title="1.1编译器和解释器"></a>1.1编译器和解释器</h4><p>编译器/解释器可以用它处理的语言或任何其他语言来编写。</p><p><strong>解释器：</strong> 一行一行地快速读取和翻译文件。这就是 JavaScript 最初的工作原理。</p><p><strong>编译器：</strong> 编译器提前运行并创建一个文件，其中包含了输入文件的机器码转换。</p><p>有两种途径可以将 JavaScript 代码转换为机器码。编译代码时，机器对代码开始运行前将要发生的事情有更好的理解，这将加快稍后的执行速度。不过，在这个过程之前需要花费时间。</p><p>另一方面，解释代码时，执行是立即的，因此要更快，但是缺乏优化导致它在大型应用程序下运行缓慢。</p><p>创建 ECMAScript 引擎的人很聪明，他们集二者之长开发了 JIT(Just-in-time) 编译器。JavaScript 同时被编译和解释，但实际实现和顺序取决于引擎。我们将会看到 V8 团队采用的是什么策略。</p><h3 id="2-从-JavaScript-到机器码"><a href="#2-从-JavaScript-到机器码" class="headerlink" title="2.从 JavaScript 到机器码"></a>2.从 JavaScript 到机器码</h3><p>就 JavaScript 而言，有一个引擎将其转换为机器码。和其他语言类似，引擎可以用任何语言来开发，因此这样的引擎不止一个。</p><ul><li>V8 是谷歌针对 Chorme 浏览器的引擎实现。</li><li>SpiderMonkey 是第一个引擎，针对网景浏览器开发，现用于驱动 FireFox。</li><li>JavaScriptCore 是苹果针对 Safari 浏览器使用的引擎。</li></ul><p>还有很多，如果你想知道 Internet Explorer 背后的引擎，查看<a href="https://en.wikipedia.org/wiki/JavaScript_engine" target="_blank" rel="noopener">这个维基百科页面</a>.</p><h4 id="2-1-ECMAScript"><a href="#2-1-ECMAScript" class="headerlink" title="2.1 ECMAScript"></a>2.1 ECMAScript</h4><p>面对这么多的引擎，你可能会问：我可以开发自己的引擎吗？可以，只要遵循 ECMAScript 标准。</p><p>如果我们打算做一个翻译器，那么就必须知道这两门语言的有效字。我们已经知道机器语言中什么是有效的了，但是对于 JavaScript，这是需要进行标准化的。</p><p>JavaScript 的标准化工作是由 Ecma 国际组织负责的，相关规范被称为 ECMAScript 或者 ES。因此，当你看到一篇文章/视频提到“ES7 有什么新特性？”时，你就知道它代表的是 ECMAScript 标准中新增的 JS 特性。</p><h3 id="3-V8-引擎"><a href="#3-V8-引擎" class="headerlink" title="3.V8 引擎"></a>3.V8 引擎</h3><h4 id="3-1-部分历史"><a href="#3-1-部分历史" class="headerlink" title="3.1 部分历史"></a>3.1 部分历史</h4><p>谷歌针对浏览器开发了谷歌地图，而这对浏览器的处理能力提出了很高的要求。那时的 JavaScript 实现尚不足以快速地运行地图。谷歌想要吸引更多的用户使用这项服务，从而进行广告销售并牟利。基于这个原因，这项服务必须快速且稳定。因此谷歌自己用 C++ 开发了 V8 引擎并在 2008 年启用，它的速度很快，或者就像一些人说的，它的速度是最快的。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/JavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89-3.jpg" alt=""></p><h4 id="3-2-解析和构建树"><a href="#3-2-解析和构建树" class="headerlink" title="3.2 解析和构建树"></a>3.2 解析和构建树</h4><p>JavaScript 文件进入引擎后，解析器进行词法解析，它将代码分解成 token 以确定它们的含义。这些 token 组成了<strong>AST(抽象语法树)。</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/JavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89-4.jpg" alt=""></p><p>编译器在语义分析中验证语言元素和关键词的正确用法，而 ASTs 在这个过程中扮演着重要的角色。之后，ASTs 被用于生成实际的字节码或者机器码。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/JavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89-5.jpg" alt=""></p><h4 id="3-3-引擎的核心"><a href="#3-3-引擎的核心" class="headerlink" title="3.3 引擎的核心"></a>3.3 引擎的核心</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8DJavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89/JavaScript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89-6.jpg" alt=""></p><ul><li>我们之前谈到，JavaScript 是由 <strong>Ignition</strong> 这个解释器解释的，同时由 <strong>TurboFan</strong> 这个 JIT 优化编译器进行编译。</li><li>首先，前面步骤生成的 ASTs 传递给解释器，该解释器迅速生成未经过优化的机器码，并且其执行是无延迟的。</li><li><strong>Profiler</strong> 在代码运行时进行观察，找出可以进行优化的地方。例如，一个‘for’循环跑了 100 次，但是每次迭代产生的结果都是一样的。</li><li>使用这个分析器后，任何未优化的代码都将传递给编译器以进行优化，同时生成机器码，它最终会替换掉之前由解释器生成的未优化代码中的对应部分。</li><li>随着分析器和编译器不断地更改字节码，JavaScript 的执行性能逐渐提高。</li></ul><h4 id="3-4-更多历史"><a href="#3-4-更多历史" class="headerlink" title="3.4 更多历史"></a>3.4 更多历史</h4><p>在V8 的 5.9 版本推出之前，它使用两个优化编译器和一个基线编译器。</p><ul><li>基线编译器 full-codegen 迅速生成未优化的机器码。</li><li>两个优化编译器 Crankshaft 和 TurboFan 用于优化代码。</li></ul><p>JavaScript 增加了新的特性后，架构的复杂度上升，维护相同的管道对 V8 团队来说变得更加困难了。如果你想阅读更多相关的旧方法以及转向新管道的原因，可以访问<a href="https://v8.dev/blog" target="_blank" rel="noopener">他们的网站</a>。</p><h4 id="3-5-放眼未来"><a href="#3-5-放眼未来" class="headerlink" title="3.5 放眼未来"></a>3.5 放眼未来</h4><p>随着更多进一步提升性能的研究的进行，V8 引擎的工作机制在未来还可能发生变化。此外，随着 <a href="https://webassembly.org" target="_blank" rel="noopener">Webassembly</a> 逐渐成形，可能会向管道添加额外步骤。</p><h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h3><p>ECMAScript 引擎的实现有很多，其中以谷歌的 V8 最为出名。希望这篇文章的简述不仅可以帮助你理解 JavaScript 的工作原理，还能从大体上了解一门编程语言的工作原理。如果你想了解 V8 团队的未来计划或者引擎的细节，这里有一篇很不错的<a href="https://v8.dev/blog" target="_blank" rel="noopener">博客</a>。</p><p>本文的第二部分将会在不久后发布，其中将谈到内存堆，栈，事件循环以及更多与 JavaScript 代码执行相关的概念。敬请关注！</p><p>如果你不清楚 Node.js 在其中的作用，我这里碰巧写了一篇不错的文章：<br><a href="https://medium.freecodecamp.org/what-exactly-is-node-js-ae36e97449f5" target="_blank" rel="noopener">What exactly is Node.js?</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>翻译术语表</title>
      <link href="/2019/05/03/Trs-%E7%BF%BB%E8%AF%91%E6%9C%AF%E8%AF%AD%E8%A1%A8/"/>
      <url>/2019/05/03/Trs-%E7%BF%BB%E8%AF%91%E6%9C%AF%E8%AF%AD%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>翻译技术文章时积累的术语，可用于阅读，也可用于规范提问。<a id="more"></a></li></ul></blockquote><table><thead><tr><th>English</th><th>中文</th><th>English</th><th>中文</th></tr></thead><tbody><tr><td>arity</td><td>参数个数</td><td>argument</td><td>实参</td></tr><tr><td>assignment</td><td>赋值</td><td>array of arrays</td><td>多维数组</td></tr><tr><td>block scope</td><td>块级作用域</td><td>build-in</td><td>内置的</td></tr><tr><td>currying</td><td>柯里化</td><td>class-based</td><td>基于类的</td></tr><tr><td>classical inheritance</td><td>类式继承</td><td>closure</td><td>闭包</td></tr><tr><td>coexist</td><td>共存</td><td>declarative</td><td>声明式</td></tr><tr><td>dynamic</td><td>动态的</td><td>duplicate</td><td>重复；副本</td></tr><tr><td>execution context</td><td>执行上下文</td><td>event handler</td><td>事件处理器</td></tr><tr><td>event driven</td><td>事件驱动的</td><td>function signature</td><td>函数声明</td></tr><tr><td>free variable</td><td>自由变量</td><td>getter-only</td><td>只读</td></tr><tr><td>global scope</td><td>全局作用域</td><td>global variable</td><td>全局变量</td></tr><tr><td>hoist</td><td>提升</td><td>invoke</td><td>调用</td></tr><tr><td>identifier</td><td>标识符</td><td>iterate</td><td>遍历</td></tr><tr><td>iterator</td><td>迭代器</td><td>non-extensible</td><td>不可拓展</td></tr><tr><td>Object-oriented</td><td>面向对象的</td><td>prototypal inheritance</td><td>原型式继承</td></tr><tr><td>private property</td><td>私有属性</td><td>prototype chain</td><td>原型链</td></tr><tr><td>parameter</td><td>形参</td><td>scope chain</td><td>作用域链</td></tr><tr><td>strict mode</td><td>严格模式</td><td>semantics</td><td>语义</td></tr><tr><td>statement</td><td>语句</td><td>silentl failure</td><td>静默失败</td></tr><tr><td>syntactical sugar</td><td>语法糖</td><td>throw an exception</td><td>抛出异常</td></tr><tr><td>library</td><td>库</td><td>framework</td><td>框架</td></tr><tr><td>LexicalEnvironment</td><td>词法环境</td><td>programming patterns and paradigms</td><td>编程范式</td></tr><tr><td>heap</td><td>堆</td><td>stack</td><td>栈</td></tr><tr><td>sync</td><td>同步</td><td>async</td><td>异步</td></tr><tr><td>instance</td><td>实例</td><td>encapsulation</td><td>封装</td></tr><tr><td>implicit</td><td>隐式</td><td>explicit</td><td>显式</td></tr><tr><td>call by value</td><td>按值调用</td><td>call by reference</td><td>按引用调用</td></tr><tr><td>override</td><td>覆盖</td><td>binding</td><td>绑定</td></tr><tr><td>Immediately Invoked Function Expression</td><td>立即执行函数表达式</td><td>Named Function Expression</td><td>具名函数表达式</td></tr><tr><td>single thread</td><td>单线程</td><td>recursive</td><td>递归</td></tr><tr><td>snippet</td><td>代码片段</td><td>resolve</td><td>解析</td></tr><tr><td>LIFO（Last-In-First-Out）</td><td>先进后出</td><td>FIFO（First-In-First-Out）</td><td>先进先出</td></tr><tr><td>loop</td><td>循环</td><td>backward compatibility</td><td>向下（向后）兼容</td></tr><tr><td>destructuring assignment</td><td>解构赋值</td><td>enumerated</td><td>可枚举的</td></tr><tr><td>distributed version control system（VCS）</td><td>分布式版本控制系统</td><td>roll back</td><td>回滚</td></tr><tr><td>cross-platform</td><td>跨平台的</td><td>pseudocode</td><td>伪代码</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 术语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「译」ES6：参数默认值的实现细节</title>
      <link href="/2019/05/02/Trs-ES6%EF%BC%9A%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"/>
      <url>/2019/05/02/Trs-ES6%EF%BC%9A%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters/" target="_blank" rel="noopener">ES6: Default values of parameters</a></li><li>原文作者：Dmitry Soshnikov</li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p>在这篇文章中我们会介绍另一个 ES6 的特性，带<strong>默认值</strong>的函数参数。正如我们将看到的，有一些微妙的案例。</p><h2 id="1-ES5-及更低版本的手动默认值"><a href="#1-ES5-及更低版本的手动默认值" class="headerlink" title="1.ES5 及更低版本的手动默认值"></a>1.ES5 及更低版本的手动默认值</h2><p>以前的默认参数值是通过以下几种可选方式手动处理的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> level<span class="token punctuation">)</span> <span class="token punctuation">{</span>  level <span class="token operator">=</span> level <span class="token operator">||</span> <span class="token string">'warning'</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> <span class="token string">': '</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'low memory'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// warning: low memory</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'out of memory'</span><span class="token punctuation">,</span> <span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: out of memory</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免参数未传递的情况，通常可以看到 <code>typeof</code> 检查：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> level <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  level <span class="token operator">=</span> <span class="token string">'warning'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有时，你也可以检查 <code>arguments.length</code> :</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  level <span class="token operator">=</span> <span class="token string">'warning'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所有这些方法都行之有效，但是，它们太偏向手动了，并且不够抽象。ES6 标准化了一种句法结构，在函数头直接定义了参数默认值。</p><h2 id="2-ES6-默认值：基本实例"><a href="#2-ES6-默认值：基本实例" class="headerlink" title="2.ES6 默认值：基本实例"></a>2.ES6 默认值：基本实例</h2><p>许多语言都存在默认参数值，所以大多数开发人员应该熟悉它的基本形式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> level <span class="token operator">=</span> <span class="token string">'warning'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span> <span class="token string">': '</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'low memory'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// warning: low memory</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'out of memory'</span><span class="token punctuation">,</span> <span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: out of memory</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种默认参数用法相当随意，但是却很方便。让我们深入实现细节来理清默认参数可能带来的困惑。</p><h2 id="3-实现细节"><a href="#3-实现细节" class="headerlink" title="3.实现细节"></a>3.实现细节</h2><p>以下是一些关于 ES6 函数默认参数值的实现细节。</p><h3 id="3-1-执行阶段的重新计值"><a href="#3-1-执行阶段的重新计值" class="headerlink" title="3.1 执行阶段的重新计值"></a>3.1 执行阶段的重新计值</h3><p>一些其他语言（例如 Python）会在<strong>定义阶段</strong>对默认参数进行一次计值，相比之下，ECMAScript 则会在<strong>执行阶段</strong>计算默认参数值 —— 每次函数调用的时候。采用这种设计是为了避免与作为默认值的复杂对象混淆。思考下面的 Python 例子：</p><pre class="line-numbers language-js"><code class="language-js">def <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  x<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> x# 我们可以看到默认值在函数定义时# 只创建了一次，并且保存于# 函数对象的属性中<span class="token function">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>__defaults__<span class="token punctuation">)</span> # <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> # <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> # <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> # <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span># 正如我们所说的，原因是：<span class="token function">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>__defaults__<span class="token punctuation">)</span> # <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了避免这种情况，Python 开发者习惯将默认值定义为 <code>None</code>，并且显式检查这个值：</p><pre class="line-numbers language-js"><code class="language-js">def <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> None<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> x is None<span class="token punctuation">:</span>    x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  x<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>__defaults__<span class="token punctuation">)</span> # <span class="token punctuation">(</span>None<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> # <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> # <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> # <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token function">print</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>__defaults__<span class="token punctuation">)</span> # <span class="token punctuation">(</span><span class="token punctuation">[</span>None<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，这与手动处理实际默认值的方式是一样不方便的，并且最初的案例让人感到疑惑。因此，为了避免这种情况，ECMAScript 会在每次函数执行时计算默认值：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1]</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1]</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一切都很好，很直观。接下来你会发现，如果我们不了解默认值的工作机制，ES 语义可能会让我们感到困惑。</p><h3 id="3-2-外部作用域的遮蔽"><a href="#3-2-外部作用域的遮蔽" class="headerlink" title="3.2 外部作用域的遮蔽"></a>3.2 外部作用域的遮蔽</h3><p>思考下面的例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2，不是 1！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如我们<strong>看到</strong>的，上面的例子输出的 <code>y</code> 是 <code>2</code> ，不是 <code>1</code> 。 原因是参数中的 <code>x</code> 与全局的 <code>x</code> <strong>不是同一个</strong>。由于执行阶段会计算默认值，在赋值 <code>= x</code> 发生的时候， <code>x</code> 已经在<strong>内部作用域</strong>被解析了，并且指向了 <strong><code>x</code> 参数自身</strong>。具有相同名称的参数 <code>x</code> <strong>遮蔽了</strong>全局变量，使得对来自默认值的 <code>x</code> 的所有访问都指向参数。</p><h3 id="3-3-参数的-TDZ（暂时性死区）"><a href="#3-3-参数的-TDZ（暂时性死区）" class="headerlink" title="3.3 参数的 TDZ（暂时性死区）"></a>3.3 参数的 TDZ（暂时性死区）</h3><p>ES6 提到了所谓的 <strong>TDZ</strong>（表示<strong>暂时性死区</strong>）—— 这是程序的一部分，在这个区域内变量或者参数在<strong>初始化</strong>（即接受一个值）之前将<strong>无法访问</strong>。</p><p>就参数而言，一个<strong>参数不能以自身作为默认值</strong>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 抛出错误！</span>  <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们上面提到的赋值 <code>= x</code> 在参数作用域中解析 <code>x</code> ，遮蔽了全局 <code>x</code> 。 但是，参数 <code>x</code> 位于 TDZ 内，在初始化之前无法访问。因此，它无法初始化为自身。</p><p>注意，上面带有 <code>y</code> 的例子是有效的，因为 <code>x</code> 已经初始化（为隐式默认值 <code>undefined</code> ）了。我们再来看一下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 可行</span>  <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之所以可行，是因为 ECMAScript 中的参数是按照<strong>从左到右的顺序</strong>初始化的，我们已经有可供使用的 <code>x</code> 了。</p><p>我们提到参数已经与“内部作用域”相关联了，在 ES5 中我们可以假定是<strong>函数体</strong>的作用域。但是，它实际上更加复杂：它<strong>可能</strong>是一个函数的作用域，<strong>或者</strong>是一个为了<strong>存储参数绑定</strong>而特别创建的<strong>中间作用域</strong>。我们来思考一下。</p><h3 id="3-4-特定的参数中间作用域"><a href="#3-4-特定的参数中间作用域" class="headerlink" title="3.4 特定的参数中间作用域"></a>3.4 特定的参数中间作用域</h3><p>事实上，如果<strong>一些</strong>（至少有一个）参数具有默认值，ES6 会定义一个<strong>中间作用域</strong>用于存储参数，并且这个作用域与<strong>函数体</strong>的作用域<strong>不共享</strong>。这是与 ES5 存在主要区别的一个方面。我们用例子来证明：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// `x` 被共用了吗？</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有，依然是 3，不是 2 </span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 并且外部的 `x` 也不受影响</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，我们有<strong>三个作用域</strong>：全局环境，参数环境，以及函数环境：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">:</span>  <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 内部</span><span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 参数</span><span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 全局</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以看到，当函数 <code>y</code> 执行时，它在最近的环境（即参数环境）中解析 <code>x</code> ，函数作用域对其并不可见。</p><h4 id="3-4-1-转译为-ES5"><a href="#3-4-1-转译为-ES5" class="headerlink" title="3.4.1 转译为 ES5"></a>3.4.1 转译为 ES5</h4><p>如果我们要将 ES6 代码编译为 ES5，并看看这个中间作用域是怎样的，我们会得到下面的结果：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// ES6</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// `x` 被共用了吗？</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有，依然是 3，不是 2</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 编译为 ES5</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 设置默认值。</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> y <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 现在可以清楚地看到，它更新了参数 `x`</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 现在可以清楚地看到，这个 `x` 来自内部作用域</span>    <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-2-参数作用域的源由"><a href="#3-4-2-参数作用域的源由" class="headerlink" title="3.4.2 参数作用域的源由"></a>3.4.2 参数作用域的源由</h4><p>但是，设置这个<strong>参数作用域</strong>的<strong>确切目的</strong>是什么？为什么我们不能像 ES5 那样与函数体共享参数？理由是：函数体中的同名变量<strong>不应该因为名字相同而影响到<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="noopener">闭包</a>绑定中的捕获行为</strong>。</p><p>我们用下面的例子展示：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 捕获 `x`</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是 1，不是 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们在<strong>函数体</strong>的作用域中创建函数 <code>y</code>，它将会捕获内部的 <code>x</code> ,也即 <code>2</code>。但显而易见，它应该捕获的是外部的 <code>x</code>，也即 <code>1</code>(除非它被同名参数<strong>遮蔽</strong>)。</p><p>同时，我们无法在外部作用域中创建函数，这意味着我们无法从这样的函数中访问<strong>参数</strong>。我们可以这样做：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 可以看到 `x` 和 `y`</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2，不是 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-3-何时不会创建参数作用域"><a href="#3-4-3-何时不会创建参数作用域" class="headerlink" title="3.4.3 何时不会创建参数作用域"></a>3.4.3 何时不会创建参数作用域</h4><p>上述的语义与默认值的<strong>手动实现</strong>是<strong>完全不同</strong>的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> y <span class="token operator">==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    y <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// `x` 被共用了吗？</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是的！ 2</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 外部的 `x` 依然不受影响</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在有一个有趣的事实：如果一个函数<strong>没有默认值</strong>，它就<strong>不会创建这个中间作用域</strong>，并且会与一个<strong>函数环境</strong>中的参数绑定<strong>共享</strong>，即<strong>以 ES5 模式运行</strong>。</p><p>为什么要这么复杂呢？为什么不总是创建参数作用域呢？这仅仅和优化有关吗？并非如此。确切地说，这是为了向下兼容 ES5：上述手动实现默认值的代码<strong>应该</strong>更新函数体中的 <code>x</code>（也就是参数自身，且位于相同作用域中）。</p><p>同时还要注意，那些重复声明只适用于 <code>var</code> 和函数。用 <code>let</code> 或者 <code>const</code> 重复声明参数是不行的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误</span>  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 错误</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-undefined-检查"><a href="#3-5-undefined-检查" class="headerlink" title="3.5 undefined 检查"></a>3.5 <code>undefined</code> 检查</h3><p>还要注意另一个有趣的事实，是否应用默认值，取决于对参数初始值（其赋值发生在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#entering-the-execution-context" target="_blank" rel="noopener">一进入上下文</a>时）的检查结果是否为值 <code>undefined</code> 。我们来证明一下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined, 2</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 2</span><span class="token function">foo</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined, 2</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常，在编程语言中带默认值的参数在必需参数之后，但是，上述事实允许我们在 JavaScript 中使用如下结构：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, undefined</span><span class="token function">foo</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2, 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-解构组件的默认值"><a href="#3-6-解构组件的默认值" class="headerlink" title="3.6 解构组件的默认值"></a>3.6 解构组件的默认值</h3><p>涉及默认值的另一个地方是解构组件的默认值。本文不会涉及解构赋值的主题，不过我们会展示一些小例子。不管是在函数参数中使用解构，还是上述的使用简单默认值，处理默认值的方式都是一样的：即在需要的时候创建两个作用域。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// undefined, 5</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 5</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管解构的默认值更加通用，不仅仅用于函数中：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token punctuation">{</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4 结论"></a>4 结论</h2><p>希望这篇简短的笔记可以帮助解释 ES6 中默认值的细节。注意，在本文撰写的那一天（2014 年 8 月 21 日），默认值<strong>还没有得到真正的实现</strong>（它们都只是创建了一个与函数体共享的作用域），因为这个“第二作用域”是在最近才添加到标准草案里的。默认值一定会是一个很有用的特性，它将使我们的代码更加优雅和整洁。</p><blockquote><p>另外，你也可以在<a href="https://juejin.im/post/5cd0eab95188251b984d8abe" target="_blank" rel="noopener">掘金翻译计划</a>找到本篇译文。</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>译文排版规范</title>
      <link href="/2019/05/01/Trs-%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83/"/>
      <url>/2019/05/01/Trs-%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%AF%91%E6%96%87%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83/%E8%AF%91%E6%96%87%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83.png" alt=""></p><a id="more"></a><p>前言：<br>这是之前还在论坛当版主的时候，给自己定下的汉化规矩：<br>1.按照固定格式来排版；<br>2.能力有限不是机翻和偷工减料的借口；<br>3.尽量得到原作者的转载授权<br>虽然不再参与汉化工作了，但是有一些好的习惯值得继续保持。</p><hr><blockquote><p>统一中文文案、排版的相关用法，降低沟通成本，增强译文的规范性和气质，使其更加易读。</p></blockquote><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。与大家共勉之。」——<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">vinta/paranoid-auto-spacing</a></p><h3 id="中英文之间需要增加空格"><a href="#中英文之间需要增加空格" class="headerlink" title="中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：</p><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p></blockquote><blockquote><p>在 LeanCloud上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p><h3 id="中文与数字之间需要增加空格"><a href="#中文与数字之间需要增加空格" class="headerlink" title="中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：</p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：</p><blockquote><p>今天出去买菜花了 5000元。</p></blockquote><blockquote><p>今天出去买菜花了5000元。</p></blockquote><h3 id="数字与单位之间需要增加空格"><a href="#数字与单位之间需要增加空格" class="headerlink" title="数字与单位之间需要增加空格"></a>数字与单位之间需要增加空格</h3><p>正确：</p><blockquote><p>我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。</p></blockquote><p>错误：</p><blockquote><p>我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。</p></blockquote><p>例外：度／百分比与数字之间不需要增加空格：</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p></blockquote><blockquote><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：</p><blockquote><p>今天是 233 ° 的高温。</p></blockquote><blockquote><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全角标点与其他字符之间不加空格"><a href="#全角标点与其他字符之间不加空格" class="headerlink" title="全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：</p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：</p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p></blockquote><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><h3 id="不重复使用标点符号"><a href="#不重复使用标点符号" class="headerlink" title="不重复使用标点符号"></a>不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p></blockquote><blockquote><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p></blockquote><blockquote><p>德国队竟然战胜了巴西队！！！！！！！！</p></blockquote><blockquote><p>她竟然对你说「喵」？？！！</p></blockquote><blockquote><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><h3 id="破折号前后需要增加一个空格"><a href="#破折号前后需要增加一个空格" class="headerlink" title="破折号前后需要增加一个空格"></a>破折号前后需要增加一个空格</h3><p>正确：</p><blockquote><p>你好，我是破折号 —— 一个不苟言笑的符号。</p></blockquote><p>错误：</p><blockquote><p>你好，我是破折号——一个不苟言笑的符号。</p></blockquote><h2 id="全角和半角"><a href="#全角和半角" class="headerlink" title="全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="http://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2" target="_blank" rel="noopener">全角和半角</a>』。</p><h3 id="使用全角中文标点"><a href="#使用全角中文标点" class="headerlink" title="使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p></blockquote><blockquote><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎!</p></blockquote><blockquote><p>嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎!</p></blockquote><blockquote><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p></blockquote><blockquote><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="数字使用半角字符"><a href="#数字使用半角字符" class="headerlink" title="数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p><blockquote><p>这件蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这件蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。</p><h3 id="遇到完整的英文整句、特殊名词，其內容使用半角标点"><a href="#遇到完整的英文整句、特殊名词，其內容使用半角标点" class="headerlink" title="遇到完整的英文整句、特殊名词，其內容使用半角标点"></a>遇到完整的英文整句、特殊名词，其內容使用半角标点</h3><p>正确：</p><blockquote><p>乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」</p></blockquote><blockquote><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」</p></blockquote><blockquote><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a href="#专有名词使用正确的大小写" class="headerlink" title="专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p></blockquote><blockquote><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p></blockquote><blockquote><p>使用 GITHUB 登录</p></blockquote><blockquote><p>使用 Github 登录</p></blockquote><blockquote><p>使用 gitHub 登录</p></blockquote><blockquote><p>使用 gｲんĤЦ8 登录</p></blockquote><blockquote><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p></blockquote><blockquote><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p></blockquote><blockquote><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p></blockquote><blockquote><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p></blockquote><blockquote><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><h3 id="不要使用不地道的缩写"><a href="#不要使用不地道的缩写" class="headerlink" title="不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><h3 id="斜体文字使用加粗样式代替"><a href="#斜体文字使用加粗样式代替" class="headerlink" title="斜体文字使用加粗样式代替"></a>斜体文字使用加粗样式代替</h3><p>正确：</p><blockquote><p><strong>斜体本身是为西文文字所设计，为了保持良好的阅读效果，在中文排版时不应出现斜体，因此统一使用加粗样式代替。</strong></p></blockquote><p>错误：</p><blockquote><p><em>斜体本身是为西文文字所设计，为了保持良好的阅读效果，在中文排版时不应出现斜体，因此统一使用加粗样式代替。</em></p></blockquote><h3 id="如果文章中有脚注怎么办"><a href="#如果文章中有脚注怎么办" class="headerlink" title="如果文章中有脚注怎么办"></a>如果文章中有脚注怎么办</h3><p>英文原文中经常会出现脚注的情况，我们在译者 <a href="https://github.com/LeopPro" target="_blank" rel="noopener">LeopPro</a> 的推荐下，选择如下的方案：</p><pre class="line-numbers language-js"><code class="language-js">这里是修改后的脚注显示方案 <span class="token operator">&lt;</span>sup<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#note1"</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>sup<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">.</span> <span class="token operator">&lt;</span>a name<span class="token operator">=</span><span class="token string">"note1"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span> <span class="token punctuation">[</span>how<span class="token operator">-</span>to<span class="token operator">-</span>add<span class="token operator">-</span>footnotes<span class="token operator">-</span>to<span class="token operator">-</span>github<span class="token operator">-</span>flavoured<span class="token operator">-</span>markdown<span class="token punctuation">]</span><span class="token punctuation">(</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>stackoverflow<span class="token punctuation">.</span>com<span class="token operator">/</span>questions<span class="token operator">/</span><span class="token number">25579868</span><span class="token operator">/</span>how<span class="token operator">-</span>to<span class="token operator">-</span>add<span class="token operator">-</span>footnotes<span class="token operator">-</span>to<span class="token operator">-</span>github<span class="token operator">-</span>flavoured<span class="token operator">-</span>markdown<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>预览效果如下：</p><blockquote><p>这里是修改后的脚注显示方案 <sup><a href="#note1">[1]</a></sup></p></blockquote><ol><li><a name="note1"></a> <a href="http://stackoverflow.com/questions/25579868/how-to-add-footnotes-to-github-flavoured-markdown" target="_blank" rel="noopener">how-to-add-footnotes-to-github-flavoured-markdown</a></li></ol><blockquote><p>详见译者 <a href="https://github.com/LeopPro" target="_blank" rel="noopener">LeopPro</a> 提的 Issue：<a href="https://github.com/xitu/gold-miner/issues/3153" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/issues/3153</a></p></blockquote><h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是<strong>正确</strong>的，但<strong>同一篇文章风格要保持一致</strong>。</p><h3 id="链接之间增加空格"><a href="#链接之间增加空格" class="headerlink" title="链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p></blockquote><blockquote><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a> 并分配给相关同事。</p></blockquote><blockquote><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="简体中文使用直角引号"><a href="#简体中文使用直角引号" class="headerlink" title="简体中文使用直角引号"></a>简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th>仓库</th><th>语言</th></tr></thead><tbody><tr><td><a href="https://github.com/vinta/paranoid-auto-spacing" target="_blank" rel="noopener">vinta/paranoid-auto-spacing</a></td><td>JavaScript</td></tr><tr><td><a href="https://github.com/huei90/pangu.node" target="_blank" rel="noopener">huei90/pangu.node</a></td><td>Node.js</td></tr><tr><td><a href="https://github.com/huacnlee/auto-correct" target="_blank" rel="noopener">huacnlee/auto-correct</a></td><td>Ruby</td></tr><tr><td><a href="https://github.com/sparanoid/space-lover" target="_blank" rel="noopener">sparanoid/space-lover</a></td><td>PHP (WordPress)</td></tr><tr><td><a href="https://github.com/NauxLiu/auto-correct" target="_blank" rel="noopener">nauxliu/auto-correct</a></td><td>PHP</td></tr><tr><td><a href="https://github.com/hotoo/pangu.vim" target="_blank" rel="noopener">hotoo/pangu.vim</a></td><td>Vim</td></tr><tr><td><a href="https://github.com/sparanoid/grunt-auto-spacing" target="_blank" rel="noopener">sparanoid/grunt-auto-spacing</a></td><td>Node.js (Grunt)</td></tr><tr><td><a href="https://github.com/hjiang/scripts/blob/master/add-space-between-latin-and-cjk" target="_blank" rel="noopener">hjiang/scripts/add-space-between-latin-and-cjk</a></td><td>Python</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">Chinese Copywriting Guidelines</a></li><li><a href="https://github.com/xitu/gold-miner/wiki/%E8%AF%91%E6%96%87%E6%8E%92%E7%89%88%E8%A7%84%E5%88%99%E6%8C%87%E5%8C%97" target="_blank" rel="noopener">掘金翻译计划译文排版指北</a></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分享一些实用工具和平台</title>
      <link href="/2019/04/23/To-%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B9%B3%E5%8F%B0/"/>
      <url>/2019/04/23/To-%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B9%B3%E5%8F%B0/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B9%B3%E5%8F%B0.png" alt=""></p><a id="more"></a><p>这个帖子用来不定期更新网上收集的一些实用工具和平台。</p><p>Tip：很多网站国内是无法访问的，请使用谷歌访问助手进入 google store，之后下载代理工具 Cow 进行访问。</p><h3 id="社区-："><a href="#社区-：" class="headerlink" title="社区 ："></a>社区 ：</h3><p><a href="https://stackoverflow.com/" target="_blank" rel="noopener">StackOverflow</a> ：<br>个人觉得最棒的编程问答社区，英文好的强烈推荐去这里提问。老外是比较热心的，不过请记住：<strong>只有好的提问才有可能得到好的回答</strong><br><a href="https://segmentfault.com/" target="_blank" rel="noopener">SegmentFault</a> ：<br>国内编程问答社区，仿上面网站的，不过有自己的特色。App bug 贼多，而且看来是不打算修复了，建议网页访问就好。<br><a href="https://juejin.im/" target="_blank" rel="noopener">掘金</a> ：<br>技术氛围很浓厚的社区，大部分内容是前端相关的。如果你有不清楚的知识点，可以尝试到这里搜一下。<br><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a> ：<br>比较早期的博客网站，UI 有一定的时代感。是个比较纯粹的技术博客网站，没有太多多余花俏的东西。<br><a href="https://medium.com" target="_blank" rel="noopener">Medium</a> ：<br>颜值和文章质量都很高的博客网站，内容并不局限于编程，几乎涉及各个领域。</p><p>如果不是会员，那么会有阅读数量的限制。你有三个方法可以解除这个限制：</p><ul><li>chrome 隐身/无痕模式打开文章</li><li>文章链接粘贴到 twitter</li><li>去<a href="https://medium-unlimited.ml/download/" target="_blank" rel="noopener">这里</a>下载 chrome 或者 firefox 扩展（推荐）</li></ul><p>当然，这不是鼓励大家白嫖，如果你愿意，可以开通会员，毕竟那上面的文章真的值得起这个价格。<br><br></p><h3 id="博客-："><a href="#博客-：" class="headerlink" title="博客 ："></a>博客 ：</h3><p>这是我关注的一些大神的博客。他们看待事物的方式也许会给你一些启发。</p><p><a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a><br><a href="https://icehe.xyz/#/" target="_blank" rel="noopener">icehe</a><br><a href="https://molunerfinn.com/" target="_blank" rel="noopener">MARKSZのBlog</a><br><a href="http://pjhubs.com/" target="_blank" rel="noopener">PJHubs</a><br><a href="http://www.nowamagic.net/" target="_blank" rel="noopener">简明现代魔法</a><br><a href="https://www.zhangxinxu.com/wordpress/" target="_blank" rel="noopener">张鑫旭</a><br><a href="https://www.barretlee.com/blog/" target="_blank" rel="noopener">小胡子哥</a><br><a href="http://dmitrysoshnikov.com/" target="_blank" rel="noopener">Dmitry soshnikov</a><br><a href="http://latentflip.com/" target="_blank" rel="noopener">Philip Roberts</a><br><br></p><h3 id="资讯获取："><a href="#资讯获取：" class="headerlink" title="资讯获取："></a>资讯获取：</h3><p><a href="https://www.infoq.cn/" target="_blank" rel="noopener">InfoQ</a>：可以了解到很多 IT 资讯<br><a href="https://teahour.fm/" target="_blank" rel="noopener">TeaHour</a>： IT 相关的电台访谈节目<br><a href="http://www.itdks.com/" target="_blank" rel="noopener">IT大咖说</a>：提供了很多技术峰会的现场录播<br><a href="https://javascriptweekly.com" target="_blank" rel="noopener">JavaScript Weekly</a>：以周为频度更新 JavaScript 相关文章，感兴趣的话可以订阅一下，可以自动推送到邮箱的。当然也可以考虑用 RSS 订阅器。</p><h3 id="前端相关："><a href="#前端相关：" class="headerlink" title="前端相关："></a>前端相关：</h3><p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN Web Doc</a> ： MDN文档<br><a href="https://www.ecma-international.org/publications/standards/Standard.htm" target="_blank" rel="noopener">ECMAScript International</a> ： ECMAScript 标准<br><a href="https://www.html.cn/book/css/all-properties.html#a2" target="_blank" rel="noopener">CSS速查总表</a> ： 速查属性<br><a href="https://caniuse.com/" target="_blank" rel="noopener">Caniuse</a> ： 前端兼容性自查<br><a href="https://rextester.com/l/js_online_compiler" target="_blank" rel="noopener">compile javascript online</a> / <a href="https://www.onlinegdb.com/" target="_blank" rel="noopener">GDB online Debugger</a> ： 在线编译<br><a href="https://codepen.io/pen" target="_blank" rel="noopener">Codepen</a> ： 代码托管和分享<br><a href="https://screendump.techulus.com/" target="_blank" rel="noopener">ScreenDump</a> ： 响应式效果测试<br><a href="https://tylermcginnis.com/javascript-visualizer/" target="_blank" rel="noopener">JavaScript Visualizer</a> ： 可视化JavaScript执行过程（仅ES6之前）<br><a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">Loupe</a> ： 可视化事件循环 （Philps Roberts大神的作品）<br><a href="https://regexr.com/" target="_blank" rel="noopener">RegExr</a> / <a href="https://jex.im/regulex/" target="_blank" rel="noopener">Regulex</a> ： 可视化正则表达式<br><a href="http://resources.jointjs.com/demos/javascript-ast" target="_blank" rel="noopener">Javascript-ast Visualizer</a> ： 可视化抽象语法树<br><a href="https://cubic-bezier.com/#.17,.67,.83,.67" target="_blank" rel="noopener">cubic-bezier</a> ： 可视化贝塞尔曲线</p><h3 id="文件编辑类："><a href="#文件编辑类：" class="headerlink" title="文件编辑类："></a>文件编辑类：</h3><p><a href="https://www.online-convert.com/" target="_blank" rel="noopener">Online converter</a> ： 文件格式转换<br><a href="https://smallpdf.com/pdf-to-word" target="_blank" rel="noopener">PDF To Word</a> ： pdf 转 word<br><a href="https://go4convert.com/to-epub" target="_blank" rel="noopener">Online PDF to EPUB converter</a> ： pdf 转 epub<br><a href="https://tableconvert.com/" target="_blank" rel="noopener">Table Convert Online</a> ： 表格转换<br><a href="https://tinypng.com/" target="_blank" rel="noopener">Compress images</a> / <a href="https://tinypng.com/" target="_blank" rel="noopener">Tinypng</a> / <a href="https://shrinkme.app/" target="_blank" rel="noopener">Shrinkme</a>： 图片压缩<br><a href="https://www.smartresize.com/zh-cn" target="_blank" rel="noopener">Smart Resize</a> ： 图片修改<br><a href="http://www.planetb.ca/syntax-highlight-word" target="_blank" rel="noopener">Syntax-highlight-word</a> ： 可以在 word 中使用代码高亮<br><a href="https://tool.lu/markdown/" target="_blank" rel="noopener">tool.lu</a> ： 在线编写 markdown 以及 html 和 md 转换<br><a href="http://sina.lt/" target="_blank" rel="noopener">长链接压缩</a> ： 长链接转换为短链接<br><a href="https://bigjpg.com/" target="_blank" rel="noopener">Bigjpg</a> ： AI 图片无损放大<br><a href="https://cowtransfer.com/" target="_blank" rel="noopener">Cowtransfer</a>：更方便的上传和下载，适合小文件的共享<br><a href="http://client.jijidown.com/" target="_blank" rel="noopener">JJ Down</a>：bilibili 很多教程视频都是分 p 的，这个软件可以批量下载视频合集，而且速度很快。<br><br></p><h3 id="电子书："><a href="#电子书：" class="headerlink" title="电子书："></a>电子书：</h3><p><a href="https://github.com/justjavac/free-programming-books-zh_CN#csshtml" target="_blank" rel="noopener">GitHub coding books online reading</a> ： Github编程相关书籍分享<br><a href="https://itbook.download" target="_blank" rel="noopener">itbook.download</a> ： 编程相关书籍免费下载<br><a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">Jiumo Search</a> ： 目前用过最棒的电子书搜索网站<br><a href="https://ebookee.org/" target="_blank" rel="noopener">Ebookee</a> ： 编程相关书籍免费下载（外文）<br><br></p><h3 id="搜索引擎："><a href="#搜索引擎：" class="headerlink" title="搜索引擎："></a>搜索引擎：</h3><p><a href="https://search.chongbuluo.com/" target="_blank" rel="noopener">chongbuluo search</a> ： 集成搜索网站<br><a href="https://duckduckgo.com/" target="_blank" rel="noopener">DuckDuckGo</a> ： 搜索引擎<br><br></p><h3 id="素材："><a href="#素材：" class="headerlink" title="素材："></a>素材：</h3><p><a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS Picture</a> ： 免费图床<br><a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">Font Awesome</a> ： 图标库<br><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">Iconfont</a> ： 图标网站<br><a href="https://www.iconfinder.com/" target="_blank" rel="noopener">free icons</a> ： 图标网站<br><a href="https://www..com/" target="_blank" rel="noopener">fontke</a> ： 字体网站<br><a href="http://asciiflow.com/" target="_blank" rel="noopener">asciiflow</a> ： 在线生成字符码图<br><a href="https://picular.co/" target="_blank" rel="noopener">Picular</a> ： 根据关键词检索与之相关的色彩<br><a href="https://bennettfeely.com/clippy/" target="_blank" rel="noopener">Clippy — CSS clip-path maker</a> ： CSS3 clip 工具<br><a href="https://www.bestvist.com/css-gradient" target="_blank" rel="noopener">Bestvist</a> ： CSS3 颜色渐变工具<br><br></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://www.moakt.com/" target="_blank" rel="noopener">Moakt</a> ： 临时邮箱</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解this绑定</title>
      <link href="/2019/04/17/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A/"/>
      <url>/2019/04/17/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A-0.jpg" alt=""></p><a id="more"></a><p>最近在阅读《你不知道的JavaScript》，再次补充了一下之前不熟悉的this绑定问题，在这里做一下阅读笔记。（很多晦涩的概念包括闭包、作用域链等都和js中的调用栈有关，所以也得另外找个时间系统学一下了）</p><h2 id="1-调用位置"><a href="#1-调用位置" class="headerlink" title="1.调用位置"></a>1.调用位置</h2><p>js中的词法作用域是静态的，需要关注的往往是函数的声明位置而不是调用位置—–例如闭包引用自由变量时，应该注意闭包函数的声明位置；而this却在某种程度上类似于动态作用域，this到底绑定的是谁，要看函数的调用位置（或者说调用方法），只有在函数调用的时候this的指向才能被确定。</p><p>确定当前执行函数的调用位置，有两种方法：</p><h3 id="1-1-分析调用栈"><a href="#1-1-分析调用栈" class="headerlink" title="1.1 分析调用栈"></a>1.1 分析调用栈</h3><p>调用栈即：为了到达当前执行位置所调用的所有函数。而当前执行函数的调用位置就在该函数的前一个调用中。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//当前调用栈是:baz</span>    <span class="token comment" spellcheck="true">// 因此，当前调用位置是全局作用域</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"baz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// bar的调用位置</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前调用栈是baz -> bar</span>    <span class="token comment" spellcheck="true">// 因此，当前调用位置在baz中</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// foo的调用位置</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前调用栈是baz -> bar -> foo</span>    <span class="token comment" spellcheck="true">// 因此，当前调用位置在bar中</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// &lt;-- baz的调用位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，例如当前执行函数为bar，bar函数的调用位置即bar函数的前一个调用，分析调用栈baz -&gt; bar可知，是baz。</p><h3 id="1-2-设置断点或debugger"><a href="#1-2-设置断点或debugger" class="headerlink" title="1.2 设置断点或debugger"></a>1.2 设置断点或debugger</h3><p>上面的方法将调用栈当作了函数调用链，这种方法比较麻烦，且容易出错，所以我们采取设置断点或debugger的方法寻找调用位置。我们在上面代码的foo函数中的第一行插入<code>debugger;</code>，那么运行代码时（当前执行函数是foo），调试器会在那个位置暂停，右侧的call stack展示了当前位置的函数调用列表，即调用栈。而调用位置就是栈中的第二个元素。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A-2.png" alt=""></p><h2 id="2-绑定规则"><a href="#2-绑定规则" class="headerlink" title="2.绑定规则"></a>2.绑定规则</h2><h3 id="2-1-默认绑定"><a href="#2-1-默认绑定" class="headerlink" title="2.1 默认绑定"></a>2.1 默认绑定</h3><p>可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。独立函数调用（如代码中的foo函数，它是直接使用不带任何修饰的函数引用进行调用的）应用的就是默认绑定规则。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，函数<span style="background-color:#fffa7d">运行在严格模式下</span>时，this的默认绑定将无法绑定全局对象，而是绑定到undefined。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token string">"use strict"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 函数运行在严格模式下</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// TypeError: Cannot read property 'a' of undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，函数在<span style="background-color:#fffa7d">严格模式下调用</span>时，默认绑定不受影响。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token string">"use strict"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//函数在严格模式下调用    </span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-隐式绑定"><a href="#2-2-隐式绑定" class="headerlink" title="2.2 隐式绑定"></a>2.2 隐式绑定</h3><p>当函数引用有上下文对象时（或者说被某个对象“包含”/“拥有”），隐式绑定规则会把函数中的this绑定到这个上下文对象。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    foo<span class="token punctuation">:</span> foo<span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对象属性引用链中只有上一层或者说最后一层在调用中起作用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    obj2<span class="token punctuation">:</span> obj2<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2<span class="token operator">=</span><span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">42</span>    foo<span class="token punctuation">:</span> foo<span class="token punctuation">}</span>obj1<span class="token punctuation">.</span>obj2<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 42</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-1-隐式丢失"><a href="#2-2-1-隐式丢失" class="headerlink" title="2.2.1 隐式丢失"></a>2.2.1 隐式丢失</h4><p>隐式绑定在一些情况下会丢失绑定对象，应用默认绑定，使this指向全局对象或者undefined。以下情况会发生隐式丢失：</p><ul><li>将绑定上下文对象的函数的引用赋值给变量并调用</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span>    foo<span class="token punctuation">:</span> foo<span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span>；<span class="token keyword">var</span> bar <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然bar是obj.foo的一个引用，但实际上是直接引用了foo函数本身，此时的bar()是不带任何修饰的函数调用，因此使用了默认绑定</p><ul><li>传入回调函数</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span>    foo<span class="token punctuation">:</span> foo<span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传参其实是隐式赋值，即把实参（这里是绑定上下文对象的函数的引用）赋值给形参变量，该变量也是直接引用了foo函数本身，和上面的情况其实是一样的。</p><p>这也解释了为什么传参给setTimeout函数时会发生隐式丢失：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    foo<span class="token punctuation">:</span> foo<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为上面的代码实际上相当于：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 100......</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-显式绑定"><a href="#2-3-显式绑定" class="headerlink" title="2.3 显式绑定"></a>2.3 显式绑定</h3><h4 id="2-3-1-call-和-apply"><a href="#2-3-1-call-和-apply" class="headerlink" title="2.3.1 call() 和 apply()"></a>2.3.1 <code>call()</code> 和 <code>apply()</code></h4><p><code>call()</code> 或者 <code>apply()</code> 方法接受一个 thisArg，将函数的 this 绑定到该 thisArg。<br>thisArg 的取值有以下四种情况：</p><ul><li><p>不传，或者传null,undefined：函数中的 this 指向 window 对象</p></li><li><p>传递另一个函数的函数名：函数中的 this 指向这个函数的引用</p></li><li><p>传递字符串、数值或布尔类型等基本类型：函数中的 this 指向其对应的包装对象，如 String、Number、Boolean</p></li><li><p>传递一个对象：函数中的 this 指向这个对象</p></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-硬绑定-bind"><a href="#2-3-2-硬绑定-bind" class="headerlink" title="2.3.2 硬绑定 bind()"></a>2.3.2 硬绑定 <code>bind()</code></h4><p>但是这两种方法依然无法解决绑定丢失的问题，所以有了硬绑定:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 2</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 2</span>bar<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//无效，硬绑定之后的this不可再更改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>硬绑定新创建了一个函数，并在该函数内部完成了this的绑定，之后不管怎么调用新建的这个函数，this的绑定都不会丢失。</p><p>典型应用场景是<br>1.创建一个包裹函数，负责接收参数并返回值。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> something <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> something<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> foo<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> obj<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2 3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.创建一个可以重复使用的辅助函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> something <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> something<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 简单的辅助绑定函数</span><span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> obj<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span> foo<span class="token punctuation">,</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2 3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ES5提供了内置方法Function.prototype.bind，对上面这种辅助函数进行了封装：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> something<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> something<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2 3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>bind()</code>方法将返回一个完成硬绑定的新函数。</p><h4 id="2-3-3-API调用的“上下文”"><a href="#2-3-3-API调用的“上下文”" class="headerlink" title="2.3.3 API调用的“上下文”"></a>2.3.3 API调用的“上下文”</h4><p>同样可以解决绑定丢失的问题。<br>JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> <span class="token string">"awesome"</span><span class="token punctuation">}</span><span class="token keyword">var</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">// 调用foo(..)时把this绑定到obj</span>myArray<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> el<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1 awesome 2 awesome 3 awesome</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-new-绑定"><a href="#2-4-new-绑定" class="headerlink" title="2.4 new 绑定"></a>2.4 new 绑定</h3><p>在<a href="https://chorer.github.io/2019/03/31/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/#5-1-new">这篇文章</a>中，其实已经谈到了new的内部原理，在这里再做一下总结—–使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ul><li>1.创建一个新对象</li><li>2.为该对象执行<code>[[prototype]]</code>链接</li><li>3.将该对象绑定到构造函数的this</li><li>4.如果函数没有显式返回对象，则new操作最终将返回步骤1中创建的新对象</li></ul><p>基于这些步骤，我们就可以手写实现new了，具体过程依然可以参考上面链接的文章。</p><p>有时候会将硬绑定与new一起使用，目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数（<strong>柯里化</strong>）</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> p1 <span class="token operator">+</span> p2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么</span><span class="token comment" spellcheck="true">// 反正使用new时this会被修改</span><span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"p1"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bar</span><span class="token punctuation">(</span> <span class="token string">"p2"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>baz<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p1p2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-this的判断"><a href="#3-this的判断" class="headerlink" title="3. this的判断"></a>3. this的判断</h2><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条this绑定规则。可以按照下面的顺序来进行判断：</p><ol><li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。<br><code>var bar = new foo()</code></li><li>函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。<br><code>var bar = foo.call(obj2)</code></li><li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。<br><code>var bar = obj1.foo()</code></li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定 到全局对象。<br><code>var bar = foo()</code></li></ol><h2 id="4-绑定例外"><a href="#4-绑定例外" class="headerlink" title="4.绑定例外"></a>4.绑定例外</h2><h3 id="4-1-被忽略的this"><a href="#4-1-被忽略的this" class="headerlink" title="4.1 被忽略的this"></a>4.1 被忽略的this</h3><p>把<code>null</code>或者<code>undefined</code>作为this的绑定对象传入<code>call</code>、<code>apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认规则。</p><p>下面两种情况下会传入<code>null</code>:</p><ul><li>使用<code>apply(..)</code>来“展开”一个数组，并当作参数传入一个函数</li><li><code>bind(..)</code>可以对参数进行柯里化（预先设置一些参数）</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">"a:"</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">"，b:"</span> <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 把数组”展开“成参数</span>foo<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a:2，b:3</span><span class="token comment" spellcheck="true">// 使用bind(..)进行柯里化</span><span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a:2，b:3 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总是传入<code>null</code>来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。</p><p><span style="background-color:#fffa7d">更安全的做法</span>:</p><p>传入一个空对象，把this绑定到这个对象不会对你的程序产生任何副作用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">"a:"</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">"，b:"</span> <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 我们的空对象</span><span class="token keyword">var</span> ø <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 把数组”展开“成参数</span>foo<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> ø<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a:2，b:3</span><span class="token comment" spellcheck="true">// 使用bind(..)进行柯里化</span><span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span> ø<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a:2，b:3 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-间接引用"><a href="#4-2-间接引用" class="headerlink" title="4.2 间接引用"></a>4.2 间接引用</h3><p>你可能会有意无意地创建一个函数的间接引用，尤其是在赋值的时候</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo()</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> foo<span class="token punctuation">:</span> foo <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>o<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>foo <span class="token operator">=</span> o<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-软绑定"><a href="#4-3-软绑定" class="headerlink" title="4.3 软绑定"></a>4.3 软绑定</h2><ul><li>硬绑定可以把this强制绑定到指定的对象（new除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this。</li><li>如果给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 默认绑定规则，优先级排最后</span><span class="token comment" spellcheck="true">// 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>softBind<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>softBind <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 捕获所有curried参数</span>        <span class="token keyword">var</span> curried <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">var</span> bound <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>                <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span> <span class="token operator">||</span> <span class="token keyword">this</span> <span class="token operator">===</span> <span class="token punctuation">(</span>window <span class="token operator">||</span> global<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>                     obj <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">,</span>                curried<span class="token punctuation">.</span>concat<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> curried<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        bound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> fn<span class="token punctuation">.</span>prototype <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bound<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"obj"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"obj2"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    obj3 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">"obj3"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj</span><span class="token keyword">var</span> fooOBJ <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">softBind</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fooOBJ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// name: obj </span><span class="token comment" spellcheck="true">// 隐式绑定规则</span>obj2<span class="token punctuation">.</span>foo <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">softBind</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>obj2<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// name: obj2 &lt;---- 看！！！</span><span class="token comment" spellcheck="true">// 显式绑定规则</span>fooOBJ<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj3 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// name: obj3 &lt;---- 看！！！</span><span class="token comment" spellcheck="true">// 绑定丢失，应用软绑定</span><span class="token function">setTimeout</span><span class="token punctuation">(</span> obj2<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// name: obj</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-this词法"><a href="#5-this词法" class="headerlink" title="5 this词法"></a>5 this词法</h2><h3 id="5-1-箭头函数"><a href="#5-1-箭头函数" class="headerlink" title="5.1 箭头函数"></a>5.1 箭头函数</h3><p>ES6新增了箭头函数，上述四条规则对这种函数是不生效的。</p><blockquote><p>箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。</p></blockquote><p>拿下面的代码举例，箭头函数在词法层面的上一层是<code>foo()</code>，所以它的this和<code>foo()</code>的this是一样的。由于<code>foo()</code>的this绑定到<code>obj1</code>，所以<code>bar</code>(引用箭头函数)的this也会绑定到<code>obj1</code>。需要注意的是，箭头函数的绑定无法被修改 —— 因为箭头函数没有自己的 this，所以是不能对它使用 <code>call</code>，<code>apply</code>，<code>bind</code> 的，new也不行。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 返回一个箭头函数</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// this继承自foo()</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 绑定foo()的this为obj</span><span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj1 <span class="token punctuation">)</span><span class="token punctuation">;</span>bar<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2，不是3！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>箭头函数常用于回调函数中，例如事件处理器或者定时器。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 这里的this在词法上继承自foo()        </span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>         a<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-self-this与箭头函数"><a href="#5-2-self-this与箭头函数" class="headerlink" title="5.2 self = this与箭头函数"></a>5.2 <code>self = this</code>与箭头函数</h3><p>this在通常情况下都是动态作用域的，而箭头函数很明显是静态（词法）作用域。实际上，在ES6之前，也有类似于箭头函数的模式—–<code>self = this</code>，采用的正是词法作用域：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lexical capture of this</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> self<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// self只是继承了foo()函数的this绑定</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-代码风格统一"><a href="#5-3-代码风格统一" class="headerlink" title="5.3 代码风格统一"></a>5.3 代码风格统一</h3><p>如果你经常编写this风格的代码，但是绝大部分时候都会使用<code>self = this</code>或者箭头函数来否定this机制，那你或许应当：</p><ol><li>只使用词法作用域并完全抛弃错误 this 风格的代码；</li><li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。</li></ol><p>当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
            <tag> 调用栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由一道题引发的思考</title>
      <link href="/2019/04/13/T-%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2019/04/13/T-%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><p>“不惧怕争论，也不要带情绪，保持理性争论才能获得提升。有时候一直以来以为正确的，说不好真实不一定就是你想的那样。”<br><a id="more"></a></p></blockquote><p>昨天，A群有个人问了一道题：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  say<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 为什么输出undefined</span>  <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先说结果。其实这道题是很简单的，只要注意在自执行函数执行过程中，<code>obj</code>变量尚未完成赋值就行了—–所以这时候打印的是执行上下文创建阶段的<code>obj</code>的值（<code>undefined</code>）；如果是let声明，那就是打印未初始化的变量<code>obj</code>，将在一开始就报错。如果非要用执行上下文来解释的话，详细的过程看下图：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/由一道题引发的思考-1.png" alt=""></p><hr><p>但是问题就在于，我坚信A群的看法是正确的，并且把这个问题带到了B群，引发了一场激烈的讨论（幸亏最后没有撕起来），我在那时是完全听不进B群的解释的。虽然下午争论的时候不了了之，但是晚上的时候我还是放不下这道题，于是选择到StackOverflow提问，之后又结合 <a href="https://tylermcginnis.com/javascript-visualizer/" target="_blank" rel="noopener">Javascript visualizer</a> 看到了代码执行的可视化过程，这时候我才明白自己的想法是错误的，B群的解释才是正确的。</p><p>为什么我会在一开始那么相信A群的说法？我开始思考这个问题。</p><p>首先是因为我没有从完全空白的状态去独立思考这道题，而是依附别人的看法去建立对这道题的认知；其次是因为我太相信那些看上去很权威的人，A群在我眼中是大佬云集的群，所以我很笃信他们的看法，但是大佬就一定是对的吗？就像那些传播很广的转载和翻译的文章，为什么要在没有任何根据的情况下去相信这些文字？换句话说，为什么不回到信息源头确认一下，打消自己的疑虑？在我看来，这根本不是钻牛角尖，我想表达的意思是：如果你不确定，你就想办法去确定，不要带着连自己都怀疑的东西继续自己的学习；对于A群的过度相信还和对B群的不信任有关，我向来是很讨厌扯高嗓子显得自己最有道理的那类人的，所以当B群的群友（有点激动地）发表自己的意见时，我并没有把他的话太放在心上，而结果却证明他说的才是正确的。</p><p>另一个值得思考的地方是，如何在交流中保持自己的理性。</p><p>B群有个群友说了一段话，我觉得很在理，这里拿出来分享一下，共勉：</p><blockquote><p>不惧怕争论，也不要带情绪，保持理性争论才能获得提升。有时候一直以来以为正确的，说不好真实不一定就是你想的那样。</p></blockquote><p>网络世界中，交谈起来往往是无所顾忌的，这种无所顾忌让撕逼变成了一种常态（我自己加了很多社群，所以清楚不过了）。那么如何做到理性的交流？<br>第一点，找那些值得交流的人。如果你发现一个人在交流中带有太多的个人情绪、对人不对事，那么请不要继续和他浪费口舌。有没有个人情绪看他说话方式和内容就知道了，尤其是不断加各种感叹号以示强调的人，早点远离为好。值得交流的人，是那种即使打心眼里无法认同你的看法，也能安静地听你陈述的人，大有一种“我不赞同你的观点，但我誓死捍卫你说话的权利”的感觉。想一想，能做到这样的人真的多吗？<br>第二点，清楚自己的目的。争论也好，交流也好，不要偏离自己的目的。很多情况下，你不仅仅是为了一个答案，还想要寻求自我认知修正的机会。确实，我们一直以来认为正确的不一定就是我们想的那样，正因为我们的认知有可能是错误的，所以才要在交流中试图找出这个错误，从而获得提升。知识不是一成不变的，所以请随时做好推翻自己想法的准备。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解变量对象、作用域链和闭包</title>
      <link href="/2019/04/10/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/"/>
      <url>/2019/04/10/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85-00.png" alt=""></p><a id="more"></a><p>执行上下文、执行栈、作用域链、闭包，这其实是一整套相关的东西，之前<a href="https://chorer.github.io/2019/03/04/F-%E9%97%AD%E5%8C%85/">转载的文章</a>也有讲到这些。下面两篇文章会更加详细地解释这些概念。</p><ul><li><a href="https://chorer.github.io/2019/04/08/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/">深入理解执行上下文和执行栈</a></li><li><a href="https://chorer.github.io/2019/04/10/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/">深入理解变量对象、作用域链和闭包</a></li></ul><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>首先引用下winter大的原话：</p><blockquote><p>在<span style="background-color:#fffa7d">ES3</span>中，执行上下文包含三个部分:<br>1.scope: 作用域，也常常被叫做作用域链。<br>2.variable object:变量对象，用于存储变量的对象。<br>3.this value: this值。<br>在<span style="background-color:#fffa7d">ES5</span>中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子:<br>1.lexical environment:词法环境，当获取变量时使用。<br>2.variable environment:变量环境，当声明变量时使用。<br>3.this value: this值。<br>在<span style="background-color:#fffa7d">ES2018</span>中，this值被归入lexical environment,同时增加了不少内容：<br>1.lexical environment:词法环境，当获取变量或者this值时使用。<br>2.variable environment:变量环境，当声明变量时使用。<br>3…….</p></blockquote><blockquote><p>我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的ES2018中规定的术语定义。</p></blockquote><p>所以，你会看到本文讲解的部分与另一篇文章有出入（例如变量对象VS环境记录），只需要知道是不同时期的不同规范就行了，没必要深究。</p><h1 id="2-执行上下文"><a href="#2-执行上下文" class="headerlink" title="2.执行上下文"></a>2.执行上下文</h1><p>每个执行上下文都有三个重要的属性：变量对象、作用域链、this。在执行上下文压栈后，将进行初始化，这个过程具体来说就是：</p><ul><li>创建变量对象</li><li>创建作用域链</li><li>确定this指向</li></ul><p>用代码表示如下：</p><pre class="line-numbers language-js"><code class="language-js">ExecutionContext <span class="token operator">=</span> <span class="token punctuation">{</span>    VO<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 或者 AO</span>    <span class="token keyword">this</span><span class="token punctuation">:</span> thisValue<span class="token punctuation">,</span>    Scope<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token comment" spellcheck="true">// 所用域链</span>      <span class="token comment" spellcheck="true">// 所有变量对象的列表</span>      <span class="token comment" spellcheck="true">// 用于标识符查询</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们针对这三个东西一一进行解释。</p><h1 id="3-变量对象"><a href="#3-变量对象" class="headerlink" title="3.变量对象"></a>3.变量对象</h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><p>变量对象即Variable object/VO，它是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p><ul><li>在全局执行上下文中，变量对象即全局对象（在浏览器中是window对象），它是可以访问的。</li><li>在函数执行上下文中，变量对象是不能直接访问的，此时由活动对象(Activation Object/AO)扮演变量对象的角色，也就是所谓的VO–&gt;AO。</li></ul><p>总而言之，变量对象和活动对象的区别就是：<br>1、变量对象是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。<br>2、当进入到一个函数执行上下文后，这个变量对象才会被激活，成为活动对象，这时候活动对象上的各种属性才能被访问。</p><h2 id="3-2-从执行上下文看变量对象"><a href="#3-2-从执行上下文看变量对象" class="headerlink" title="3.2 从执行上下文看变量对象"></a>3.2 从执行上下文看变量对象</h2><p>首先，执行上下文分为两个阶段：<br>1.进入执行上下文<br>2.代码执行</p><h3 id="3-2-1-进入执行上下文"><a href="#3-2-1-进入执行上下文" class="headerlink" title="3.2.1 进入执行上下文"></a>3.2.1 进入执行上下文</h3><p>很明显，这个时候还没有执行代码。<br>此时的变量对象将包含（按照如下顺序初始化）：</p><p>1.<span style="background-color:#fffa7d">一个指向arguments对象的arguments变量</span>（如果是函数执行上下文）：具体地说，在变量对象内部将创建局部变量arguments和arguments对象，并使该变量指向该对象。arguments对象包括下列属性：</p><ul><li>callee：指向当前函数的引用</li><li>length： 真正传递的参数的个数</li><li>properties-indexes：就是函数的参数值(按参数列表从左到右排列)</li></ul><p>2.<span style="background-color:#fffa7d">函数的所有形参</span>（如果是函数执行上下文）：有实参则赋值，无实参则为undefined。<br>3.<span style="background-color:#fffa7d">函数声明</span>：如果声明的函数跟已经声明的形参在名称上是相同的，则完全替换这个形参变量。<br>4.<span style="background-color:#fffa7d">变量声明</span>：如果声明的变量跟已经声明的形参/函数在名称上是相同的，则变量声明不会干扰它们，仅赋值部分是生效的。</p><p>同时明确，变量对象将不包含：</p><ul><li>函数表达式（与函数声明相对）</li><li>没有使用var声明的变量（这属于“全局式”的声明方式，只是给全局添加了一个属性，并不在变量对象中）</li></ul><p>拿下面代码作为例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在调用函数foo后，将进入其对应的函数执行上下文，此时的变量对象（实际上是活动对象）根据上面的说法，应为：</p><pre class="line-numbers language-js"><code class="language-js">AO <span class="token operator">=</span> <span class="token punctuation">{</span>    arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        length<span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    b<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>    c<span class="token punctuation">:</span> reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    d<span class="token punctuation">:</span> undefined<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以从arguments对象的<code>properties-indexes</code>属性或者a看出，形参此时已经赋值了，但是变量仍是<code>undefined</code>。</p><h3 id="3-2-2-代码执行"><a href="#3-2-2-代码执行" class="headerlink" title="3.2.2 代码执行"></a>3.2.2 代码执行</h3><p>这个阶段会顺序执行代码，修改变量对象的值，执行完成后变量对象如下：</p><pre class="line-numbers language-js"><code class="language-js">AO <span class="token operator">=</span> <span class="token punctuation">{</span>    arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        length<span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    b<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    c<span class="token punctuation">:</span> reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    d<span class="token punctuation">:</span> reference to FunctionExpression <span class="token string">"d"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面说过，函数表达式和没有使用var声明的变量将不会包含在变量对象里，所以如果添加如下代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>e <span class="token operator">=</span> <span class="token number">1</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量对象是不会变的</p><h1 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4.作用域链"></a>4.作用域链</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><p>作用域链其实就是所有执行上下文的变量对象的列表。我们可以将其看作数组，并表示为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> Scope <span class="token operator">=</span> <span class="token punctuation">[</span>VO1<span class="token punctuation">,</span> VO2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">,</span> VOn<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体来说，函数执行上下文的作用域链包括该上下文的活动对象和该上下文对应函数的内部<code>[[Scope]]</code>属性。表示为：</p><pre class="line-numbers language-js"><code class="language-js">Scope <span class="token operator">=</span> AO <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-2-作用："><a href="#4-2-作用：" class="headerlink" title="4.2 作用："></a>4.2 作用：</h2><p>作用域链的作用是：在处理标识符的时候进行变量查询。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。</p><h2 id="4-3-Scope和-Scope-："><a href="#4-3-Scope和-Scope-：" class="headerlink" title="4.3 Scope和[[Scope]]："></a>4.3 <code>Scope</code>和<code>[[Scope]]</code>：</h2><p>前面我们说的<code>Scope</code>是执行上下文的属性，而<code>[[Scope]]</code>是函数的属性。<br>具体来说，<code>[[Scope]]</code>是一个包含了所有上层变量对象的分层链，它属于当前函数执行上下文，在函数创建伊始就存在了，并保存在函数中。</p><p>这里要注意的很重要的一点是：<code>[[Scope]]</code>是在函数创建的时候保存起来的——静态的（不变的），只有一次并且一直都存在——直到函数销毁。 比方说，哪怕函数永远都不能被调用到，<code>[[Scope]]</code>属性也已经保存在函数对象上了。</p><h2 id="4-4-从执行上下文看作用域链："><a href="#4-4-从执行上下文看作用域链：" class="headerlink" title="4.4 从执行上下文看作用域链："></a>4.4 从执行上下文看作用域链：</h2><p>下面用具体的例子回顾一下在执行上下文中，变量对象和作用域链的创建过程</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token function">alert</span><span class="token punctuation">(</span>x <span class="token operator">+</span>  y <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 60</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先进入全局执行上下文，创建变量对象（全局对象window）</p><pre class="line-numbers language-js"><code class="language-js">globalContext<span class="token punctuation">.</span>VO <span class="token operator">===</span> Global <span class="token operator">=</span> <span class="token punctuation">{</span>  x<span class="token punctuation">:</span> undefined  foo<span class="token punctuation">:</span> <span class="token operator">&lt;</span>reference to <span class="token keyword">function</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之后开始执行代码，变量对象变为：</p><pre class="line-numbers language-js"><code class="language-js">globalContext<span class="token punctuation">.</span>VO <span class="token operator">===</span> Global <span class="token operator">=</span> <span class="token punctuation">{</span>  x<span class="token punctuation">:</span> <span class="token number">10</span>  foo<span class="token punctuation">:</span> <span class="token operator">&lt;</span>reference to <span class="token keyword">function</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，在创建foo函数时，确认它的<code>[[Scope]]</code>属性：</p><pre class="line-numbers language-js"><code class="language-js">foo<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>  globalContext<span class="token punctuation">.</span>VO<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后，调用foo函数，进入其对应的函数执行上下文，此时函数的变量对象激活为活动对象：</p><pre class="line-numbers language-js"><code class="language-js">fooContext<span class="token punctuation">.</span>AO <span class="token operator">=</span> <span class="token punctuation">{</span>  y<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>  bar<span class="token punctuation">:</span> <span class="token operator">&lt;</span>reference to <span class="token keyword">function</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同时确认了foo函数执行上下文的作用域链：</p><pre class="line-numbers language-js"><code class="language-js">fooContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> fooContext<span class="token punctuation">.</span>AO <span class="token operator">+</span> foo<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// i.e.:</span>fooContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> <span class="token punctuation">[</span>  fooContext<span class="token punctuation">.</span>AO<span class="token punctuation">,</span>  globalContext<span class="token punctuation">.</span>VO<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后开始执行代码，变量对象变为：</p><pre class="line-numbers language-js"><code class="language-js">fooContext<span class="token punctuation">.</span>AO <span class="token operator">=</span> <span class="token punctuation">{</span>  y<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>  bar<span class="token punctuation">:</span> <span class="token operator">&lt;</span>reference to <span class="token keyword">function</span><span class="token operator">></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，在创建bar函数时，确认它的<code>[[Scope]]</code>属性：</p><pre class="line-numbers language-js"><code class="language-js">bar<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>  fooContext<span class="token punctuation">.</span>AO<span class="token punctuation">,</span>  globalContext<span class="token punctuation">.</span>VO<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之后，调用bar函数，进入bar函数对应的函数执行上下文，此时函数的变量对象激活为活动对象：</p><pre class="line-numbers language-js"><code class="language-js">barContext<span class="token punctuation">.</span>AO <span class="token operator">=</span> <span class="token punctuation">{</span>  z<span class="token punctuation">:</span> undefined<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同时确认了bar函数执行上下文的作用域链：</p><pre class="line-numbers language-js"><code class="language-js">barContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> barContext<span class="token punctuation">.</span>AO <span class="token operator">+</span> bar<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// i.e.:</span>barContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> <span class="token punctuation">[</span>  barContext<span class="token punctuation">.</span>AO<span class="token punctuation">,</span>  fooContext<span class="token punctuation">.</span>AO<span class="token punctuation">,</span>  globalContext<span class="token punctuation">.</span>VO<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后开始执行代码，变量对象变为：</p><pre class="line-numbers language-js"><code class="language-js">barContext<span class="token punctuation">.</span>AO <span class="token operator">=</span> <span class="token punctuation">{</span>  z<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在运行<code>alert(x + y + z);</code>这一语句的时候，开始进行变量（或者说标识符）查询：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">-</span> <span class="token string">"x"</span><span class="token operator">--</span> barContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// not found</span><span class="token operator">--</span> fooContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// not found</span><span class="token operator">--</span> globalContext<span class="token punctuation">.</span>VO <span class="token comment" spellcheck="true">// found - 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">-</span> <span class="token string">"y"</span><span class="token operator">--</span> barContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// not found</span><span class="token operator">--</span> fooContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// found - 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">-</span> <span class="token string">"z"</span><span class="token operator">--</span> barContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// found - 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>这里需要注意，由于确认执行上下文的作用域链时，总会将当前上下文的变量对象/活动对象推至作用域链的顶端( <code>Scope=当前活动对象+所有上层对象</code> )，所以变量查询也将从该变量对象开始，而全局对象则一直处于末端，是最后被查询的。</p></blockquote><p>bar执行完毕，出栈—&gt;foo执行完毕，出栈—&gt;回到全局执行上下文</p><h1 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5.闭包"></a>5.闭包</h1><h2 id="5-1-从向下Funarg问题谈静态作用域"><a href="#5-1-从向下Funarg问题谈静态作用域" class="headerlink" title="5.1 从向下Funarg问题谈静态作用域"></a>5.1 从向下Funarg问题谈静态作用域</h2><blockquote><p>“Funarg”即函数式参数，指的是值为函数的参数。如：</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">exampleFunc</span><span class="token punctuation">(</span>funArg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">funArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先看下这段代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>funArg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token function">funArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10, 而不是20!</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 将 `foo` 作为实参传给 `bar`。</span><span class="token function">bar</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于函数foo，变量x就是自由变量。当foo函数被调用时，它在哪里解析x绑定呢？是从创建函数的外层作用域，还是从调用函数的外层作用域？<br>这就是所谓的<span style="background-color:#fffa7d">向下funarg问题</span>(downwards funarg problem)，即在判断绑定的环境时的歧义性：它应该是创建时的环境，还是调用时的环境？</p><p>这是通过达成约定使用静态作用域来解决的。静态作用域也就是词法作用域（这也是词法环境这个名称的由来），它是通过捕获函数创建所在的环境来实现的，因而会到函数创建时保存起来的静态作用域链中进行变量查询。如果一个语言只通过查找源代码，就可以判断绑定在哪个环境中解析，那么该语言就实现了静态作用域。</p><p>与静态作用域相对的是动态作用域。动态作用域是在当前活跃的动态链（而不是在函数创建时保存起来的静态作用域链）中进行变量查询的。对于上面的代码，如果是动态作用域，将输出20而不是10。</p><h2 id="5-2-从向上Funarg问题谈闭包"><a href="#5-2-从向上Funarg问题谈闭包" class="headerlink" title="5.2 从向上Funarg问题谈闭包"></a>5.2 从向上Funarg问题谈闭包</h2><p>另一种Funarg问题是<span style="background-color:#fffa7d">向上funarg问题</span>(upwards funarg problem)。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 闭包，捕获`foo`的环境。</span>  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 向上funarg。</span>  <span class="token keyword">return</span> bar<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 调用`foo`来返回`bar`闭包。</span><span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10，而不是20!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了判断绑定环境的歧义性，向上funarg问题面临的另一个问题是：如果JavaScript是面向堆栈的，那么foo函数在调用结束后，其执行上下文将带着变量对象销毁，这样一来，在我们调用bar函数时将发生错误（因为bar函数需要用到自由变量x，而该变量已经随着foo函数变量对象的销毁而消失了）。而且，在面向堆栈实现模型中，要想将bar函数返回根本是不可能的，因为它也是foo函数变量对象的一部分，也会随之销毁。</p><p>也就是说我们面临两个问题：</p><ul><li>绑定环境的歧义性</li><li>被引用的自由变量在上下文销毁后无法得到保留</li></ul><p>为了解决这两类问题，引入了闭包的概念。</p><h2 id="5-3-闭包"><a href="#5-3-闭包" class="headerlink" title="5.3 闭包"></a>5.3 闭包</h2><h3 id="5-3-1-定义"><a href="#5-3-1-定义" class="headerlink" title="5.3.1 定义"></a>5.3.1 定义</h3><p>ECMAScript中，闭包指的是：</p><ul><li><p>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p></li><li><p>从实践角度：以下函数才算是闭包：<br>1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）<br>2.在代码中引用了自由变量</p></li></ul><p>JavaScript显然是支持词法作用域的（除了this），所以解决了向下Funarg问题；同时由于闭包的存在，即使创建闭包的执行上下文出栈后被销毁，其变量对象也依然存在，所以闭包函数依然有办法访问到该对象，这就解决了向上Funarg问题。</p><blockquote><p>这个过程具体来说就是：通过某种方式（通常是返回值）调用闭包后，创建闭包对应的执行上下文并压栈，该上下文的属性<code>Scope</code>包括了闭包本身的变量对象和闭包的<code>[[Scope]]</code>属性，后者使得闭包执行时有机会访问到自由变量，因为<code>[[Scope]]</code>在闭包的词法创建阶段便已确定，并在那时候保存了其上层变量对象（上层，也就是闭包的父函数）。</p></blockquote><h3 id="5-3-2-注意"><a href="#5-3-2-注意" class="headerlink" title="5.3.2 注意"></a>5.3.2 注意</h3><p>不过这里需要注意，仅变量对象里被引用的自由变量依然存在，不需要用到的变量会被垃圾清除机制清除。可以用下面的代码做个测试：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> hello <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> unused <span class="token operator">=</span> <span class="token string">"nope"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">debugger</span><span class="token punctuation">;</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>debugger查看closure，发现只有hello变量，而找不到unused变量:</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85-2.png" alt=""></p><p>在控制台打印unused变量时，报错：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85-3.png" alt=""></p><p>另外一个需要注意的地方是：同一个上下文中可能存在多个闭包，而这些闭包是共用同一个<code>[[Scope]]</code>属性的。也就是说，某个闭包对其中的变量做修改会影响到其他闭包对该变量的读取：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> firstClosure<span class="token punctuation">;</span><span class="token keyword">var</span> secondClosure<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  firstClosure <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  secondClosure <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">--</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对AO["x"]产生了影响, 其值在两个闭包的[[Scope]]中</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">firstClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3, 通过 firstClosure.[[Scope]]</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">firstClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">secondClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也可以解释经典的for循环问题：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3, 而不是 0</span>data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3, 而不是 1</span>data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3, 而不是 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一个函数都是一个闭包，拥有同一个<code>[[Scope]]</code>属性，这个属性包含了全局对象，而全局对象包含了变量k，这个k在循环跑完后变成了3，所以闭包调用的时候统一输出3。</p><h3 id="5-3-3-闭包的运用"><a href="#5-3-3-闭包的运用" class="headerlink" title="5.3.3 闭包的运用"></a>5.3.3 闭包的运用</h3><p>实际使用的时候，闭包可以创建出非常优雅的设计，允许对funarg上定义的多种计算方式进行定制。 如下就是数组排序的例子，它接受一个排序条件函数作为参数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">...</span> <span class="token comment" spellcheck="true">// 排序条件</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同样的例子还有，数组的map方法（并非所有的实现都支持数组map方法，SpiderMonkey从1.6版本开始有支持），该方法根据函数中定义的条件将原数组映射到一个新的数组中：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> element <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [2, 4, 6]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用函数式参数，可以很方便的实现一个搜索方法，并且可以支持无穷多的搜索条件：</p><pre class="line-numbers language-js"><code class="language-js">someCollection<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> element<span class="token punctuation">.</span>someProperty <span class="token operator">==</span> <span class="token string">'searchCondition'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>还有应用函数，比如常见的forEach方法，将funarg应用到每个数组元素：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>join<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1;2;3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>闭包还有另外一个非常重要的应用 —— 延迟调用：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10, 一秒钟后</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也可以用于回调函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">...</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// only for example</span>xmlHttpRequestObject<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 当数据就绪的时候，才会调用;</span>  <span class="token comment" spellcheck="true">// 这里，不论是在哪个上下文中创建，变量“x”的值已经存在了</span>  <span class="token function">alert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以用于封装作用域来隐藏辅助对象：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// initialization</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  object<span class="token punctuation">.</span>getX <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">_getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// get closured "x" – 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<br><a href="http://dmitrysoshnikov.com/ecmascript" target="_blank" rel="noopener">http://dmitrysoshnikov.com/ecmascript</a><br><a href="http://goddyzhao.tumblr.com/post/11311499651/closures" target="_blank" rel="noopener">http://goddyzhao.tumblr.com/post/11311499651/closures</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> 变量对象 </tag>
            
            <tag> 作用域链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解执行上下文和执行栈</title>
      <link href="/2019/04/08/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
      <url>/2019/04/08/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-1.jpg" alt=""></p><a id="more"></a><p>执行上下文、执行栈、作用域链、闭包，这其实是一整套相关的东西，之前<a href="https://chorer.github.io/2019/03/04/F-%E9%97%AD%E5%8C%85/">转载的文章</a>也有讲到这些。下面两篇文章会更加详细地解释这些概念。</p><ul><li><a href="https://chorer.github.io/2019/04/08/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/">深入理解执行上下文和执行栈</a></li><li><a href="https://chorer.github.io/2019/04/10/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/">深入理解变量对象、作用域链和闭包</a></li></ul><h1 id="1-执行上下文"><a href="#1-执行上下文" class="headerlink" title="1.执行上下文"></a>1.执行上下文</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>执行上下文（execution context）是当前 JavaScript 代码被解析和执行时所在环境的抽象概念，</p><h2 id="1-2-类型"><a href="#1-2-类型" class="headerlink" title="1.2 类型"></a>1.2 类型</h2><ul><li>全局执行上下文<br>只有一个。它创建了一个全局对象（浏览器中是window对象），并将this指向该对象。</li><li>函数执行上下文<br>无数个。每次调用函数时，都会为该函数创建一个新的执行上下文。</li><li>eval函数执行上下文<br>运行在 eval 函数中的代码也获得了自己的执行上下文，eval函数不常用，所以这里不讨论</li></ul><h1 id="2-执行栈"><a href="#2-执行栈" class="headerlink" title="2.执行栈"></a>2.执行栈</h1><p>执行栈（execution stack），也即调用栈（call stack），具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。<br>当 JavaScript 引擎首次读取脚本时，它会创建一个全局执行上下文并将其push到当前的执行栈。每当调用函数的时候，都会为该函数创建一个新的执行上下文并将其push到栈顶；在函数执行完毕后，对应的执行上下文将会从栈顶pop出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'Hello World!'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside first function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Again inside first function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside second function'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Inside Global Execution Context'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Inside first function</span><span class="token comment" spellcheck="true">// Inside second function</span><span class="token comment" spellcheck="true">// Again inside first function</span><span class="token comment" spellcheck="true">// Inside Global Execution Context</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-2.jpg" alt=""></p><h1 id="3-执行上下文的创建"><a href="#3-执行上下文的创建" class="headerlink" title="3.执行上下文的创建"></a>3.执行上下文的创建</h1><p>执行上下文分两个阶段创建：1）创建阶段（The Creation Phase）； 2）执行阶段（The Execution Phase）</p><h2 id="3-1-创建阶段"><a href="#3-1-创建阶段" class="headerlink" title="3.1 创建阶段"></a>3.1 创建阶段</h2><ul><li>词法环境组件被创建</li><li>变量环境组件被创建</li></ul><p>用伪代码表示就是：</p><pre class="line-numbers language-js"><code class="language-js">ExecutionContext <span class="token operator">=</span> <span class="token punctuation">{</span>    LexicalEnvironment <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 词法环境</span>  VariableEnvironment <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 变量环境</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-1-词法环境"><a href="#3-1-1-词法环境" class="headerlink" title="3.1.1 词法环境"></a>3.1.1 词法环境</h3><p>词法环境（Lexical environment）是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用）</p><p>词法环境有三个组成部分：</p><ul><li>环境记录：存储变量和函数声明的实际位置</li><li>对外部环境的引用：可以访问其外部词法环境</li><li>this绑定：确定this的指向</li></ul><p>词法环境有两种类型：</p><ul><li>全局环境：全局执行上下文的词法环境。</li><li>函数环境：函数执行上下文的词法环境。</li></ul><h4 id="3-1-1-1-环境记录："><a href="#3-1-1-1-环境记录：" class="headerlink" title="3.1.1.1 环境记录："></a>3.1.1.1 环境记录：</h4><p>根据词法环境的两种类型，环境记录（Environment record）同样也有两种类型：</p><ul><li><p>对象环境记录（Object environment record）：<br>全局环境的环境记录类型。存储全局变量和函数声明、全局对象（window 对象）和关联的属性/方法。</p></li><li><p>声明性环境记录（Declarative environment record）：<br>函数环境的环境记录类型。存储局部变量和函数声明、<code>arguments</code>对象。<code>arguments</code>对象包含了索引与参数之间的映射，以及传给函数的参数的个数。</p></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// argument object</span>Arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-1-2-外部环境引用："><a href="#3-1-1-2-外部环境引用：" class="headerlink" title="3.1.1.2 外部环境引用："></a>3.1.1.2 外部环境引用：</h4><p>外部环境引用（Reference to the outer environment）表明当前词法环境能够访问外部词法环境。这意味着如果JavaScript引擎未在当前词法环境找到变量，它将向外部词法环境寻找（这有点类似原型链中的属性查找）</p><p>全局环境没有外部环境，其外部环境引用为 null。</p><p>函数环境有外部环境，其外部环境引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p><h4 id="3-1-1-3-this绑定："><a href="#3-1-1-3-this绑定：" class="headerlink" title="3.1.1.3 this绑定："></a>3.1.1.3 this绑定：</h4><p>全局执行上下文中，this绑定（this binding）到全局对象（对于浏览器，该对象为window）；函数执行上下文中，this绑定到谁将取决于函数的调用位置（或者说调用方法）。<br>我会在另一篇文章总结this的绑定机制，所以这里不再展开。</p><p>讲完了词法环境的三个组成部分，最后再配合伪代码理解一下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 全局执行上下文</span>GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>  LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>    EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>      Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">// 标识符绑定在这里 </span>    <span class="token punctuation">}</span>    outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>global object<span class="token operator">></span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 函数执行上下文</span>FunctionExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>  LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>    EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>      Type<span class="token punctuation">:</span> <span class="token string">"Declarative"</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">// 标识符绑定在这里 </span>    <span class="token punctuation">}</span>    outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global or outer <span class="token keyword">function</span> environment reference<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token keyword">this</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span>depends on how <span class="token keyword">function</span> is called<span class="token operator">></span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-2-变量环境"><a href="#3-1-2-变量环境" class="headerlink" title="3.1.2 变量环境"></a>3.1.2 变量环境</h3><p>变量环境（Variable environment）同样也是词法环境，因此它具有上面定义的词法环境的所有特征。这两者的区别主要在于：<br>在 ES6 中，词法环境用于存储函数声明和变量（let和const）绑定，而变量环境仅用于存储变量（var）绑定。</p><h2 id="3-2-执行阶段"><a href="#3-2-执行阶段" class="headerlink" title="3.2 执行阶段"></a>3.2 执行阶段</h2><p>在执行阶段，完成对所有变量的分配，最后执行代码。</p><h2 id="3-3-举例说明"><a href="#3-3-举例说明" class="headerlink" title="3.3 举例说明"></a>3.3 举例说明</h2><p>通过一个例子来了解执行上下文的整个创建和执行过程。<br>以下面的代码为例</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">var</span> c<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">multiply</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token keyword">return</span> e <span class="token operator">*</span> f <span class="token operator">*</span> g<span class="token punctuation">;</span><span class="token punctuation">}</span>c <span class="token operator">=</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在开始读取代码后，JavaScript引擎创建全局执行上下文并压栈，全局执行上下文的创建阶段的伪代码如下：</p><pre class="line-numbers language-js"><code class="language-js">GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 词法环境</span>  LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>    EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>      Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>      a<span class="token punctuation">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">></span><span class="token punctuation">,</span>      b<span class="token punctuation">:</span> <span class="token operator">&lt;</span> uninitialized <span class="token operator">></span><span class="token punctuation">,</span>      multiply<span class="token punctuation">:</span> <span class="token operator">&lt;</span> func <span class="token operator">></span>    <span class="token punctuation">}</span>    outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">,</span>    ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">></span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// 变量环境</span>  VariableEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>    EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>      Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>      c<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">,</span>    ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">></span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后进入全局执行上下文的执行阶段，开始进行变量分配/赋值，伪代码如下：</p><pre class="line-numbers language-js"><code class="language-js">GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 词法环境</span>    LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>        Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>        a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>        b<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>        multiply<span class="token punctuation">:</span> <span class="token operator">&lt;</span> func <span class="token operator">></span>        <span class="token punctuation">}</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">,</span>        ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 变量环境</span>    VariableEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>        Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>        c<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>        <span class="token punctuation">}</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">,</span>        ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随着执行阶段的进行，我们遇到了<code>multiply(20, 30)</code>，这是一个函数调用语句，所以此时创建了该函数对应的函数执行上下文并压栈，函数执行上下文的创建阶段的伪代码如下：</p><pre class="line-numbers language-js"><code class="language-js">FunctionExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 词法环境</span>    LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>        Type<span class="token punctuation">:</span> <span class="token string">"Declarative"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>        Arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">></span><span class="token punctuation">,</span>        ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object or undefined<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 变量环境</span>    VariableEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>        Type<span class="token punctuation">:</span> <span class="token string">"Declarative"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>        g<span class="token punctuation">:</span> undefined        <span class="token punctuation">}</span><span class="token punctuation">,</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">></span><span class="token punctuation">,</span>        ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object or undefined<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后进入函数执行上下文的执行阶段，开始进行函数内的变量的分配/赋值，伪代码如下：</p><pre class="line-numbers language-js"><code class="language-js">FunctionExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 词法环境</span>    LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>        Type<span class="token punctuation">:</span> <span class="token string">"Declarative"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>        Arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">></span><span class="token punctuation">,</span>        ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object or undefined<span class="token operator">></span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 变量环境</span>    VariableEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>        Type<span class="token punctuation">:</span> <span class="token string">"Declarative"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>        g<span class="token punctuation">:</span> <span class="token number">20</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span>GlobalLexicalEnvironment<span class="token operator">></span><span class="token punctuation">,</span>        ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object or undefined<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数执行完毕，函数执行上下文出栈，此时的执行上下文是全局执行上下文。由于函数的返回值被赋给变量c，此时全局执行上下文对应的全局词法环境得到更新，伪代码如下：</p><pre class="line-numbers language-js"><code class="language-js">GlobalExectionContext <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 词法环境</span>    LexicalEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>        Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>        a<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>        b<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>        multiply<span class="token punctuation">:</span> <span class="token operator">&lt;</span> func <span class="token operator">></span>        <span class="token punctuation">}</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">,</span>        ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 变量环境</span>    VariableEnvironment<span class="token punctuation">:</span> <span class="token punctuation">{</span>        EnvironmentRecord<span class="token punctuation">:</span> <span class="token punctuation">{</span>        Type<span class="token punctuation">:</span> <span class="token string">"Object"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 标识符绑定在这里</span>        c<span class="token punctuation">:</span> <span class="token number">12000</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span>        outer<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">null</span><span class="token operator">></span><span class="token punctuation">,</span>        ThisBinding<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Global Object<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>全局执行上下文的执行阶段结束，程序结束。</p><p><strong>补充</strong>：</p><p>在全局执行上下文创建阶段的伪代码中我们可以看到，<code>let</code>和<code>const</code>定义的变量没有任何与之关联的值，但<code>var</code>定义的变量设置为<code>undefined</code>。</p><p>这是因为在创建阶段，JavaScript引擎会扫描一遍代码并解析所有的变量和函数声明，其中函数声明被存储在环境记录中，而变量的情况则比较特殊：<code>var</code>声明的变量将被设置为<code>undefined</code>，<code>let</code>和<code>const</code>声明的变量将保持未初始化。</p><p>因此，我们可以在声明之前就访问<code>var</code>定义的变量（尽管是<code>undefined</code> ），但如果在声明之前访问<code>let</code>和<code>const</code>定义的变量则会提示引用错误（因为在执行阶段之前其始终是未初始化的）。</p><p>这就是我们所谓的变量提升。</p><p>注： 在执行阶段，如果Javascript引擎在源代码中声明的实际位置找不到 <code>let</code>变量的值，那么将为其分配<code>undefined</code>值。</p><hr><p><strong>注意</strong>：<br>如果你发现译文和原文的说法存在出入，例如：<br><span style="background-color:#fffa7d">在原文中</span>：</p><blockquote><p>The execution context is created during the creation phase. Following things happen during the creation phase:<br>1.LexicalEnvironment component is created.<br>2.VariableEnvironment component is created.</p></blockquote><blockquote><p>Each Lexical Environment has three components:<br>1.Environment Record<br>2.Reference to the outer environment,<br>3.This binding</p></blockquote><p><span style="background-color:#fffa7d">在译文中</span>：</p><blockquote><p>在任何 JavaScript 代码执行之前，执行环境经历了创建阶段，创建阶段包含以下三个事：<br>1.this 的值确定，也被称为 This Binding.<br>2.Lexical Environment 被创建。<br>3.Variable Environment 被创建。</p></blockquote><blockquote><p>在词法环境中，有两种组件：<br>(1) environment record<br>(2) reference to the outer environment.</p></blockquote><p>这是因为（请看这幅图）：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88-3.jpg" alt=""></p><p>总而言之是由于ECAMAScript的标准变更导致的。原文最初是基于ES5编写的，this绑定的确是执行上下文创建阶段的一环，但是在<del>ES2015</del> ES2018 的规范中，this绑定被并入词法环境的环境记录，所以原作者后来进行了更改，只是各种翻译和转载没有改过来就是了。关于具体内容，可以参考：<br><a href="https://es5.github.io/#x10.2" target="_blank" rel="noopener">ES5规范</a><br><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#table-23" target="_blank" rel="noopener">ES6规范</a><br><a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/#structure-of-execution-context" target="_blank" rel="noopener">上图的文章</a></p><hr><p>本文参考：<br><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd" target="_blank" rel="noopener">原文</a><br><a href="https://github.com/RicoLiu/automatic-goggles/issues/9" target="_blank" rel="noopener">译文</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行上下文 </tag>
            
            <tag> 词法环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PureBlue 主题更新记录</title>
      <link href="/2019/04/04/P-PureBlue%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/04/04/P-PureBlue%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><style>strong{font-size:18px}</style><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.6.3：</strong></p><p><i class="fa fa-wrench"></i> 修复文章目录过长覆盖 footer 的问题<br><i class="fa fa-wrench"></i> 本来想集成 Alogolia 搜索，无奈问题一个接着一个，只好放弃</p><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.5.29：</strong></p><p><i class="fa fa-wrench"></i> 完成部分移动端适配工作<br>是的，终于填了一点坑了。用的是媒体查询，虽说没有适配全部尺寸的手机，但是大部分已经可以正常显示了，第一次看到博客在手机上正常显示还是很开心的哈哈哈。总的来说最近更新比较频繁，两天三头就改一些地方，是时候 release 一下了。</p><a id="more"></a><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.5.27：</strong></p><p><i class="fa fa-wrench"></i> 修改导航栏布局<br><i class="fa fa-wrench"></i> 修复代码块与顶部条宽度不一致的 bug。<br>本来代码块和顶部条在同一个父元素里的话是很好控制宽度一致的，无奈插件是直接暴露代码块在外面。而我又不想用jq来给它们嵌套一个父元素，所以最后采用了计算代码块宽度再赋值给顶部条的方法。</p><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.5.21：</strong></p><p><i class="fa fa-wrench"></i> 改进代码块样式，增加复制功能。<br>代码高亮还是用现成的插件实现的，但是在样式上借鉴了 <a href="https://carbon.now.sh" target="_blank" rel="noopener">Carbon</a>，最主要的是在右上角添加了复制代码功能（有 ZeroClipboard 插件可以用，但是不知怎地用不了，所以自己写了一个。怎么实现的就不说了，因为代码比较丑）。现在代码高亮效果是这样的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.5.19：</strong></p><p><i class="fa fa-wrench"></i> 修改了配色基调<br><i class="fa fa-wrench"></i> 添加站内搜索，现在可以搜索文章了</p><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.5.14：</strong></p><p><i class="fa fa-wrench"></i> 一直觉得banner光秃秃的，所以换上了随机的背景图<br><i class="fa fa-wrench"></i> 利用媒体查询对手机端的样式做了部分调整（虽然还是没有达到想要的效果）。感觉是个大工程，还是以后再来弄吧。</p><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.5.10：</strong></p><p><i class="fa fa-wrench"></i> 一点小改动。翻译文章时突然发现一件事，有的文章标题下是有类似subtitle的东西的，但不是hexo的内置变量，所以自己定义了一个（说实话之前没考虑到这个问题）。</p><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.4.2：</strong></p><p><i class="fa fa-wrench"></i> 优化了部分代码<br><i class="fa fa-wrench"></i> (总算)引入分享插件，只需要在主题的<code>config.yml</code>文件配置即可。之前以为没法在<code>script</code>标签里写ejs，所以采用了在js里拼接字符串的方法，想想真是又笨又奇葩。</p><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.4.1：</strong></p><p>几个优化阅读体验的小变动<br><i class="fa fa-wrench"></i> 引入了font-awesome库，增加了一些图标<br><i class="fa fa-wrench"></i> 现在TOC目录中的标题会随着屏幕滚动而对应高亮。为了醒目，<del>暂时采用了我比较喜欢的荧光黄</del>采用红色<br><i class="fa fa-wrench"></i> 取消纯黑字体，现在阅读文章不会那么晃眼了<br><i class="fa fa-wrench"></i> 修复代码块背景显示不正常的问题<br><i class="fa fa-wrench"></i> 增加文章字数统计和阅读时长统计，可配置</p><p><i class="fa fa-calendar-plus-o"></i> <strong>2019.3.31:</strong></p><p>发布 Version 1.0<br><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/PureBlue主题更新记录-1.png" alt=""></p><p>最近确实还是挺忙的。虽说主题做出来了，但是一些大大小小的毛病或者 bug 总是让我心里不太舒服，所以花了一些功夫进行了修复，并终于发布了第一个版本。现在看起来已经好很多了（也已经与初版完全不同了）。至于响应式布局，目前没打算做，因为我还是习惯用 PC 端浏览。</p><p><i class="fa fa-wrench"></i> 整体布局：<br>比较直观的感受应该就是布局上的调整。为了让整体更加趋向扁平化，我去除了初版中所有圆润的元素，尤其是那个巨丑的导航栏。还有一个就是稍微美化了一下滑动条，现在和主题更加搭配了。</p><p><i class="fa fa-wrench"></i> 配色：<br>虽然主题叫做PureBlue，但并不是所有人都能接受默认的颜色，所以在以蓝色为主配色的前提下，我提供了其他的几种方案可供选择，只要修改配置文件即可。这个也算是给我的一个tip：为了提高主题的可配置性，应该避免在一些地方采用硬编码，而是代之以变量（stylus本身是支持书写变量的）。</p><p><i class="fa fa-wrench"></i> 阅读体验优化：<br>之前比较尴尬的两个问题，一个是图片无法放大查看（= =无法放大的图片要你何用），一个是没有文章目录（阅读长文非常痛苦）。图片问题我是用fancybox插件解决的，同时支持放大、下载和分享。这里有一点比较关键:因为md文件引用的图片默认是放在<code>&lt;p&gt;&lt;/p&gt;</code>中的，而插件针对的图片必须有<code>&lt;a&gt;&lt;/a&gt;</code>嵌套，所以需要用js给所有的img嵌套上<code>&lt;a&gt;&lt;/a&gt;</code>；至于文章目录，可以用TOC函数生成，之后再编写样式就行。当然，目录是类似侧边栏的存在，所以必须用js做一些判断，之后进行适当的定位。</p><p><i class="fa fa-wrench"></i> 浏览体验优化：<br>首先是修复了分类页无法正常进入的问题（之前的分类点击之后会走archive页面的布局，所以我暂时给了个空链接）；然后是重写了分页器，说到这个，之前的分页器可以说是丑到无以复加，而且非常不人性化，只提供上一页和下一页的选择简直是不像话有木有！好在这个问题解决了，而且也简化了一些不必要的代码；再者一个是导航栏，导航栏条目可以根据当前所在页面的类型对应高亮。</p><p><i class="fa fa-wrench"></i> 第三方插件支持：<br>目前引入了valine评论插件，用起来还是很舒服的。后面看情况可能会增加对gittalk的支持；分享插件，我个人使用的是Addthis，之所以只有个人使用= =，因为这个插件必须要到它的官网去配置，而我要的效果是用户可以通过主题文件进行配置。<del>所以虽然好用，但不会考虑作为主题的分享插件</del> 增加了对Addthis的支持，现在用户可以通过配置pubid使用这个插件了。<del>说到插件，以后也许会增加Algolia站内搜索，现在看搜索功能还是比较鸡肋的，毕竟标签和分类其实已经足够发挥索引功能了</del>增加了本地搜索，用起来感觉还蛮不错。</p><p><i class="fa fa-wrench"></i> 其他小改动：<br>显示标签数、分类数和文章数，至于文章阅读时长和字数的统计可以以后再说；还有就是在<code>after-footer.ejs</code>中统一引用所有的js文件，没有之前那么乱糟糟的了；标签云的标签，之前鼠标移入的时候会“鬼畜”，这个问题也得到了修复。</p><p>总而言之改动还是挺大的，不过随着越来越多第三方插件的使用，以后实现去jq化也可能比较麻烦。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PureBlue </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解原型和继承</title>
      <link href="/2019/03/31/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/03/31/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-1.png" alt=""></p><a id="more"></a><p>这几天在掘金上阅读到了一篇关于原型的文章，角度较之前看到的几篇博客都不一样，顿时感觉我对于原型的知识点还没有完全吃透。鉴于本篇文章很可能会进行不定期的修订和拓展，故在此附上更新日志，以简单记录我在学习上的认知更新。</p><p>2019.2.24</p><ul><li>js继承的几种实现方式</li></ul><p>2019.2.19</p><ul><li>完善关于constructor属性的介绍</li><li>比对new和Object.create()的本质区别</li><li>纠正隐式原型的错误写法（之前没看仔细，一直写错，今天报错才发现）</li></ul><h2 id="1-创建对象的方法"><a href="#1-创建对象的方法" class="headerlink" title="1.创建对象的方法"></a>1.创建对象的方法</h2><p>在了解原型链之前，首先先了解一下创建对象的几种方式，为后面做个铺垫。介绍以下三种。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-2.png" alt=""></p><p>代码：</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">// 第一种方式：字面量</span>    <span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'o1'</span><span class="token punctuation">}</span>    <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'o2'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 第二种方式：构造函数</span>    <span class="token keyword">var</span> M <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">var</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token string">'o3'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 第三种方式：Object.create</span>    <span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'p'</span><span class="token punctuation">}</span>    <span class="token keyword">var</span> o4 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o3<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o4<span class="token punctuation">)</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-3.png" alt=""></p><h2 id="2-构造函数、实例、原型、原型链"><a href="#2-构造函数、实例、原型、原型链" class="headerlink" title="2.构造函数、实例、原型、原型链"></a>2.构造函数、实例、原型、原型链</h2><p>先来一张图简单了解一下<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-4.png" alt=""></p><h3 id="2-1-原型、实例、构造函数"><a href="#2-1-原型、实例、构造函数" class="headerlink" title="2.1  原型、实例、构造函数"></a>2.1 原型、实例、构造函数</h3><p>首先是代码</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token keyword">var</span> M <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">var</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token string">'o3'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>实例就是通过new一个构造函数生成的对象。在本例中o3就是实例，M就是构造函数。</li><li>每个函数都有prorotype属性，每个对象都有<strong>proto</strong> 属性（隐式原型,读作dunder prototype）</li><li>从上图中可以知道，实例的<strong>protpo</strong>指向原型对象。</li><li>从上图中可以知道，实例的构造函数的prototype也是指向原型对象。</li><li><p>原型对象的construor指向构造函数。</p><p>再来通过下面这个图来理解一下<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-5.png" alt=""></p></li></ul><h3 id="2-2-原型链"><a href="#2-2-原型链" class="headerlink" title="2.2 原型链"></a>2.2 原型链</h3><p>简单理解就是原型组成的链，实例的<strong>proto</strong>就是原型，而原型也是一个对象，也有<strong>proto</strong>属性，它会指向另一个原型…………就这样可以一直通过<strong>proto</strong>向上找，这就是原型链，当向上找找到Object这个构造函数的原型（即null）时，这条原型链就算到头了。也就是说，原型链的尽头是null 。</p><h3 id="2-3-原型的作用"><a href="#2-3-原型的作用" class="headerlink" title="2.3 原型的作用"></a>2.3 原型的作用</h3><p>原型的存在是为了帮助实现继承。我们先来思考一个问题：假如现在通过一个构造函数创建了多个实例，想要给它们添加同一个方法，该怎么做呢？</p><p>1.给每个实例去添加。太过麻烦，并不是一个明智的选择；<br>2.在构造函数的内部添加方法。这样做的话在每次用构造函数创建实例时都会大量产生方法的副本，这些方法副本功能一样，实际却是不同的。这会影响性能，且不利于代码复用；<br>3.这时，就该用上原型了。只要给构造函数的原型添加一个方法，那么构造函数的所有实例便都有了这个方法。接着上面的例子继续演示：</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token keyword">function</span> <span class="token function">M</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">var</span> o3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token string">'o3'</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> o5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token string">'o5'</span><span class="token punctuation">)</span>    M<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>say<span class="token operator">=</span><span class="token function">furnction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>     o3<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     o5<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o3<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>o5<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//  true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-5.1.png" alt=""></p><p>按照JS引擎的分析方式，在访问一个实例的方法时，首先在实例本身中找，如果找到了就说明其构造函数先前是有定义这个方法的(this)；如果没找到就去实例的原型中找，还没找到就再沿着原型链往上找，直到找到。当然，不止方法，属性也是可以继承自原型的。</p><p>那么怎么判断属性是实例本身具有的还是继承的？对实例用 hasOwnProperty( )方法即可。那么实例为何有这个方法？同样是继承来的。 由于所有的对象的原型链都会找到追溯到Object.prototype，因此所有的对象都会有Object.prototype的方法，其中就包括 hasOwnProperty( )方法 。</p><h3 id="2-4-访问原型"><a href="#2-4-访问原型" class="headerlink" title="2.4  访问原型"></a>2.4 访问原型</h3><p>可以用<code>obj.prototype</code>，<code>obj.__proto__</code>，或者<code>obj.getPrototypeOf()</code>。这里重点说后面两个。<br><code>__proto__</code>属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，更不推荐通过这种方式修改实例的原型，除了标准化的原因之外还有性能问题。<br>为了更好的支持，推荐使用 Object.getPrototypeOf()。</p><h3 id="2-5-原型、构造函数、实例、Function、Object的关系"><a href="#2-5-原型、构造函数、实例、Function、Object的关系" class="headerlink" title="2.5  原型、构造函数、实例、Function、Object的关系"></a>2.5 原型、构造函数、实例、Function、Object的关系</h3><p>前面我们给出了一幅图简单梳理了一下关系，但想追本溯源，光靠那张图是不够的。下面我们给出另一张更详细的图。请先记住，Function和Object 是特殊的构造函数。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-6.png" alt=""></p><p>首先从构造函数Foo（或任意一个普通构造函数）出发，它创建了实例f1和f2等，而实例的<code>__proto__</code>指向了Foo.prototype这个原型，该原型的<code>__proto__</code>向上再次指向其他构造函数的原型，一直向上，最终指向Object这个构造函数的原型，即Object.prototype。而Object.prototype的 <code>__proto__</code>指向了null，这时我们说到达了原型链的终点null。回过头看，该原型又被Object构造函数的实例的<code>__proto__</code>指向，而函数的实例就是我们通常通过字面量创建的那些对象，也即是图中的o1，o2。那么，普通构造函数（这里指Foo）和特殊构造函数Object又来自于哪里？答案是，来自于另一个特殊构造函数Function。</p><p>实际上，所有的函数都是由Function函数创建的实例，而构造函数当然也是函数，所以也来自于Function。从图中可以看到，实例Foo的<code>__proto__</code>和实例Object的<code>__proto__</code> 都指向了 Function的prototype，即Function.prototype 。</p><p>既然所有的函数都是由Function函数创建的实例，那么Function又是怎么来的？答案是，Function自己创造了自己。它既作为创造其他实例函数的构造函数而存在，也作为实例函数而存在，所以可以在图上看到<span style="background-color:#fffa7d">作为实例的Function</span>的<code>__proto__</code> 指向了<span style="background-color:#fffa7d">作为构造函数的Function</span>的prototype,</p><p>即<code>Function.__proto__ ===Function.prototype</code></p><p>正如我们前面所说的，Function.prototype的<code>__proto__</code>也像其他构造函数.prototype的<code>__proto__</code>一样，最终指向Object.porototype，而Object.porototype的<code>__proto__</code>最终指向null，原型链结束。</p><p>可以发现，经过简单梳理，这几者的关系没有我们想象的那么复杂。一句话，看懂这幅图就够了。</p><h2 id="3-instanceof的原理"><a href="#3-instanceof的原理" class="headerlink" title="3.instanceof的原理"></a>3.instanceof的原理</h2><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-7.png" alt=""></p><p>instanceof 沿着 <span style="background:#fffa7d">实例—&gt; <strong>proto</strong> —&gt; ……..</span> 这条线来找，同时沿着<span style="background:#fffa7d"> 实例的构造函数的prototype—&gt;<strong>proto</strong> —&gt; ……..</span> 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。如下图，很显然 f1 instanceof Object 成立<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-8.png" alt=""></p><p>注意：正因为 instanceof 的原理如上所述，因此实例的instanceof在比较的时候，与原型链上向上找的的构造函数相比都是true。</p><p>继续上面的代码<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-9.png" alt=""></p><p>那怎么判断实例是由哪个构造函数生成的呢？这时候就要用到constructor了。<br>实例的原型的构造函数， obj.<strong>proto</strong>.constructor<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-10.png" alt=""></p><h2 id="4-constructor属性"><a href="#4-constructor属性" class="headerlink" title="4.constructor属性"></a>4.constructor属性</h2><h3 id="4-1-定义："><a href="#4-1-定义：" class="headerlink" title="4.1 定义："></a>4.1 定义：</h3><p>构造函数的prototype属性指向它的原型对象，在原型对象中有一个constructor属性，指向该构造函数。值类型（除了null和undefined，这两者不具有这个属性）的constructor是只读的，不可修改，引用类型的constructor是可修改的，例如5.2提到的修复指向。</p><h3 id="4-2-修复constructor的指向："><a href="#4-2-修复constructor的指向：" class="headerlink" title="4.2 修复constructor的指向："></a>4.2 修复constructor的指向：</h3><p>为了实现从父类到子类方法的继承，一般会重写构造函数的原型，如：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span>Student<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这将使得实例student具有构造函数Person的方法，但同时也会导致constructor的指向出现问题，造成继承链的紊乱，因此为了修复这个错误指向，需要显式指定<code>obj.prototype.constructor = obj</code> 。拿下面例子说明：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-11.0.png" alt=""></p><p>未重写原型对象之前，实例化了一个dog；第6行重写了原型对象，使其指向另一个实例（等式右边是字面量，因此可以看作是由Object构造函数实例化出来的一个对象），之后实例化了一个cat。</p><p>查看dog和cat的constructor：</p><pre class="line-numbers language-js"><code class="language-js">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//function Animal()</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//function Object()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">    dog<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//wan</span>    cat<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//miao</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先，构造函数没有constructor属性，这导致了它构造的实例也没有constructor属性，所以，实例将沿着原型链(注意，构造函数不算在原型链里)向上追溯对应的原型对象的constructor属性。dog.constructor可以指向原来的构造函数，说明原来的原型对象还存在；而cat.constructor 指向另一个构造函数，是因为Animal( )的原型被重写，并且作为Object( )构造函数的一个实例而存在，那么由cat实例出发，向上进行constructor属性追溯的时候，最终会找到Object( ) 构造函数。同样的，正因为原型重写前后创建的实例分别对应了初始原型和新的原型，所以我们可以对旧实例调用初始原型的方法、对新实例调用新的原型的方法，放在本例子中，就表现为dog依然可以调用say( )方法发出wan，而cat也可以调用say( )方法发出miao 。</p><p><strong>总结：</strong><br>重写原型对象之后，会切断构造函数与最初原型之间的连接，使新构造的实例对象的原型指向重写的原型，而先前构造的实例对象的原型还是指向最初原型。在这种情况下，先前的实例对象可以使用最初原型的方法，新的实例对象可以使用重写的原型的方法。</p><h2 id="5-new-和-Object-create-："><a href="#5-new-和-Object-create-：" class="headerlink" title="5. new 和 Object.create()："></a>5. new 和 Object.create()：</h2><p>这里，让我们回到文章开头提到的创建对象的三种方式。重点介绍后两种。</p><h3 id="5-1-new"><a href="#5-1-new" class="headerlink" title="5.1 new"></a>5.1 new</h3><p>new一个构造函数时，实际发生的过程是：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>o<span class="token punctuation">.</span>__proto__<span class="token operator">=</span>M<span class="token punctuation">.</span>prototypeM<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>第一步，创建一个空对象o；</li><li>第二步，令空对象的<strong>proto</strong>指向构造函数M的prototype；</li><li>第三步，令构造函数M中的this指针指向o，使得o具有M的属性或方法，如果M无返回值或返回的不是对象，则最后会返回o 。</li></ul><p>在这里要注意下面这个坑：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> Base <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Base<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>构造函数就好比印钞机，而它创建的实例就好比钞票。构造函数中的this.xxxx都是为了实例而准备的属性和方法，这些this在构造函数内，但并不指向构造函数，而是在new构造函数执行的时候转而指向新实例。构造函数自身没有这些属性和方法，像上面那样调用Base的a属性是会报错的，Base根本没有a属性。</p><p><strong>手动实现new（方法一）：</strong></p><p>下面根据new的工作原理通过代码手动实现一下new运算符</p><pre class="line-numbers language-js"><code class="language-js">    <span class="token keyword">var</span> new2 <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建一个空对象，并链接到原型    </span>    <span class="token keyword">var</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//改变func中的this指向，把func的结果赋给k　　 </span>    <span class="token keyword">var</span> k <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　　　　　　    <span class="token comment" spellcheck="true">//判断func是否显式返回对象</span>    <span class="token keyword">return</span> <span class="token keyword">typeof</span> k <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> k <span class="token punctuation">:</span> o<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF-11.png" alt=""></p><p>不难看出，我们手动编写的new2和new运算符的作用是一样的。</p><p><strong>手动实现new（方法二）：</strong></p><p>考虑到构造函数本身需要传参，这里提供第二种手写new的方法</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">new3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获得构造函数func（arguments的第一个参数）</span>    <span class="token keyword">var</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建一个空对象，并链接到原型</span>    <span class="token keyword">var</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>func<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 改变func中的this指向，把func的结果赋给k　</span>    <span class="token keyword">var</span> k <span class="token operator">=</span> func<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断func是否显式返回对象</span>    <span class="token keyword">return</span> k <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> k <span class="token punctuation">:</span> o<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用内置new</span><span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">M</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 使用手写new</span><span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">new3</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里要注意数组的<code>shift()</code>方法，它可以删去数组的第一个元素并返回该元素。但是arguments是类数组的对象，无法直接使用这个方法，所以我们使用<code>[].shift.call(arguments)</code>,意思是从参数列表（包括构造函数、构造函数的参数）中删去并返回第一个参数（构造函数），将其赋给func，之后的arguments将只包含构造函数func的参数。</p><h3 id="5-2-Object-create"><a href="#5-2-Object-create" class="headerlink" title="5.2 Object.create()"></a>5.2 Object.create()</h3><p>Object.create()方法创建一个新对象（实例），并使用现有的对象(参数)作为新创建的对象的<strong>proto</strong> 也就是说，这个方法可以起到指定原型的作用。</p><p>执行Object.create() 时，实际发生的过程是：</p><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>create <span class="token operator">=</span>  <span class="token keyword">function</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> F <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一步，创建空的构造函数；</li><li><p>第二步，令构造函数的prototype指向传入的对象；</p><blockquote><p>实际上也相当于 令新实例的<strong>proto</strong>指向传入的对象</p></blockquote></li><li><p>第三步，实例化一个对象并返回</p></li></ul><p>这里，如果Object.create()接受的参数是null，即<code>var obj = Object.create(null)</code>,则obj是真正意义上的空对象，不具有hasOwnProperty(),toString()等方法或属性。</p><h2 id="6-继承的7种方式"><a href="#6-继承的7种方式" class="headerlink" title="6 继承的7种方式"></a>6 继承的7种方式</h2><h3 id="6-1-原型链继承"><a href="#6-1-原型链继承" class="headerlink" title="6.1.原型链继承"></a>6.1.原型链继承</h3><ul><li>核心：重写子类原型，代之以父类的实例</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>Worker<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺点：<br>创建子类实例时，无法向父类构造函数传参；<br>对一个子类实例的引用类型属性的操作将会影响其他子类实例，即引用属性共享</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> worker1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> worker2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token function">alert</span><span class="token punctuation">(</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span class="token function">alert</span><span class="token punctuation">(</span>worker2<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-借用构造函数继承"><a href="#6-2-借用构造函数继承" class="headerlink" title="6.2.借用构造函数继承"></a>6.2.借用构造函数继承</h3><p>又称为冒充继承、经典继承、伪造对象继承</p><ul><li>核心：使用父类的构造函数来增强子类实例，等同于复制父类的实例属性给子类（不使用原型）</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Worker</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> worker1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> worker2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token function">alert</span><span class="token punctuation">(</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span class="token function">alert</span><span class="token punctuation">(</span>worker2<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//[6,12,24]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺点：虽然消除了原型链继承的缺点，但是不利于实现函数复用，每个子类都有父类实例函数的副本，影响性能。</li></ul><h3 id="6-3-组合继承"><a href="#6-3-组合继承" class="headerlink" title="6.3.组合继承"></a>6.3.组合继承</h3><ul><li>核心：原型链继承+借用构造函数继承。即使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shout<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Ahhhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">...</span>其余新增属性。。。<span class="token punctuation">}</span>Worker<span class="token punctuation">.</span>prototype<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Worker<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor<span class="token operator">=</span>Worker  <span class="token comment" spellcheck="true">//别忘记修正constructor的指向</span><span class="token keyword">var</span> worker1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺点：很常用的继承方式，但也有缺点，就是代码第11、13行合计调用了两次父类函数，造成了不必要的消耗。</li></ul><h3 id="6-4-原型式继承"><a href="#6-4-原型式继承" class="headerlink" title="6.4.原型式继承"></a>6.4.原型式继承</h3><p>用到了object()，规范化之后即为Object.create()</p><ul><li>核心：利用Object.create()对传入其中的对象进行浅拷贝</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>    age<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">var</span> worker1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token keyword">var</span> worker2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺点：和原型链继承一样，存在引用属性共享的问题。</li></ul><pre class="line-numbers language-js"><code class="language-js">worker1<span class="token punctuation">.</span>age<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span><span class="token function">alert</span><span class="token punctuation">(</span>worker1<span class="token punctuation">.</span>age<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span class="token function">alert</span><span class="token punctuation">(</span>worker2<span class="token punctuation">.</span>age<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//[6,12,24,48]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>原因很好解释，因为worker1无age属性，因此向它的原型查找，它的原型恰好就是Person对象。因此实际上是在改动Person的age属性。</p><h3 id="6-5-寄生继承"><a href="#6-5-寄生继承" class="headerlink" title="6.5.寄生继承"></a>6.5.寄生继承</h3><ul><li>核心：创建一个函数用于封装继承的过程，在函数内部增强对象，最后将其返回</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token punctuation">{</span>    age<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> worker0 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">;</span>    worker0<span class="token punctuation">.</span>shout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Ahhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> worker0<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> worker1 <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span>worker1<span class="token punctuation">.</span><span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缺点：和原型链继承一样，存在引用属性共享的问题;和经典继承一样，无法实现函数复用</li></ul><h3 id="6-6-寄生组合继承"><a href="#6-6-寄生组合继承" class="headerlink" title="6.6.寄生组合继承"></a>6.6.寄生组合继承</h3><ul><li>核心：结合寄生式继承和组合继承的优点，避免为了指定子类的原型而二次调用父类的构造函数</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//封装函数。功能：在避免二次调用父类函数的前提下令子类原型指向父类实例</span><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span>subType<span class="token punctuation">,</span> superType<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">var</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>      subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>    subType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//修正constructor的指向</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 父类初始化实例属性和原型属性</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>shout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Ahhhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）</span><span class="token keyword">function</span> <span class="token function">Worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 调用函数，令子类原型指向父类实例</span><span class="token function">inheritPrototype</span><span class="token punctuation">(</span>Worker<span class="token punctuation">,</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>优点：基本完美的继承方式，无任何缺点，也是目前库实现的方式。</li></ul><h3 id="6-7-extends类继承"><a href="#6-7-extends类继承" class="headerlink" title="6.7.extends类继承"></a>6.7.extends类继承</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 父类</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Ahhhhhh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//子类继承父类</span><span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"I am working"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>解释：可以看作是ES6新增的语法糖，使得js中继承的写法更趋向于传统的面向对象语言。super是关键字，代表父类构造函数，只有在子类的构造函数中调用super()函数，才能让父类构造出this给子类去丰富。</li></ul><p>参考：<br><a href="http://www.cnblogs.com/wangfupeng1988/p/3978131.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangfupeng1988/p/3978131.html</a><br><a href="https://www.cnblogs.com/chengzp/p/prototype.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengzp/p/prototype.html</a><br><a href="https://juejin.im/post/5c6a9c10f265da2db87b98f3" target="_blank" rel="noopener">https://juejin.im/post/5c6a9c10f265da2db87b98f3</a><br><a href="https://www.cnblogs.com/94pm/p/9113434.html" target="_blank" rel="noopener">https://www.cnblogs.com/94pm/p/9113434.html</a><br><a href="https://segmentfault.com/a/1190000016891009" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016891009</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> 原型 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>折腾博客系列之发布自己的主题：PureBlue</title>
      <link href="/2019/03/28/T-%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue/"/>
      <url>/2019/03/28/T-%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>这篇文章用来记录自己开发 PureBlue 主题过程中的感想。<br><a id="more"></a></p><h3 id="先立一个-Flag"><a href="#先立一个-Flag" class="headerlink" title="先立一个 Flag"></a>先立一个 Flag</h3><p>博客内容固然是最重要的，但是抛开内容不讲，博客本身也应该带有自己的Tag，而不是光会用别人的轮子。</p><p>最早接触的博客平台是 CSDN 和博客园，在上面学习到了很多网友的经验，于是萌发了想要创建自己博客的念头，在写了几篇文章后又觉得：为何不自己搭建一个博客平台呢？因此在今年一月份的寒假捣鼓了 hexo 和 github pages，包括下载各种漂亮的主题、添加各种有意思的插件，一时乐在其中。平静下来之后，我开始进行知识迁移的工作，把以前存放在印象笔记中的东西重新修改并整合，转移到个人博客里，于是内容慢慢充实起来。</p><p>直到十几天前，我用的还是 Next 主题，这的确是一个相当成熟和漂亮的主题，我特别喜欢它的简洁。直到某天看到一句话：</p><blockquote><p>当你看到你用的主题出现在两个以上的博客时，那你就要考虑自己写一个了。</p></blockquote><p>别说两个了，Next 主题的用户数应该是目前所有主题中最多的，而博客外观的雷同很显然是一件非常尴尬的事情。正好在那时我也陷入了一个纠结，就是我一直处于知识输入的状态却鲜有项目上的输出，简单地说就是学的多、做的少—-这是很要命的事，毕竟“纸上得来终觉浅”。也就是说我面临两个问题：</p><ul><li>缺少项目实践</li><li>博客主题缺少个性化</li></ul><p>这两个问题恰巧有共同的答案，那就是自己制作一个主题。当时想的是这学期能做出来都算好的了，于是立了一个 flag：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%9APureBlue/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue-3.md.jpg" alt=""></p><p>不过很欣慰的是，我赶在月底之前把它完成了，前后大约花了14天。（大概是这个 flag 给我的动力）</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%9APureBlue/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue-4.md.jpg" alt=""></p><p>这是<a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">项目地址</a>。</p><h3 id="体会和感想"><a href="#体会和感想" class="headerlink" title="体会和感想"></a>体会和感想</h3><p>虽然是一个小项目，而且代码也写得比较乱，但是收获颇丰——接触到了两个新的技术，一是模板引擎ejs，二个是css预处理器stylus，还有就是对hexo的原理有了更为深入的理解，至少知道了我写的markdown文件是怎么在网页上渲染出来的，而不是光会用却不知道原理。</p><p>万事开头难，前期准备工作的时候真的是一头雾水。首先是Hexo的官方文档，写得很不友好，所以读起来云里雾里；其次是不同主题使用的模板引擎和css预编译都不同，主题文件的结构也不同，这大大提高了阅读源码的难度和花在上面的时间成本。虽然经过“搜刮”，我找到了几篇教程，但是大部分还是讲的不够浅显易懂，越看越晕。这时候我意识到两个重要的问题：</p><ul><li>这些东西不是给纯新手准备的，我需要先了解基础的概念</li><li>善用搜索引擎，不要将视野局限在国内平台</li></ul><p>所以我开始去youtube上寻找相关的视频，幸运的是我的确找到了<a href="https://www.youtube.com/watch?v=vJsxE6-JXDs&amp;index=16&amp;list=PLLAZ4kZ9dFpOMJR6D25ishrSedvsguVSm" target="_blank" rel="noopener">纯新手向的主题制作教程</a>。每集只有几分钟，但是对于理解一些基础概念来说已经足够。不用担心听不懂，因为自带字幕，再配合up主的操作演示，还是很好理解的。</p><p>之后我又谷歌了相关的文章，成功找到了这个<a href="http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-1-Index/" target="_blank" rel="noopener">系列教程</a>，这是目前找到的最详细的教程，真真正正的从零开始教你怎么做一个主题，所以说实话真的很感谢这位老外。为了加深对主题制作的理解以及方便其他有需求的人，我将这个系列翻译了过来，可以在我的博客里找到，当然也可以去<a href="https://segmentfault.com/a/1190000018575126" target="_blank" rel="noopener">Segment Fault</a>。目前我只翻译了两篇，第三篇会另外找个时间搞定。</p><p>教程看下来，发现难点主要集中在两个地方：一是理清项目结构，进行合理的组织，二个是设计样式并具体实现。<br>准备工作差不多之后，就可以开始动工了，不需要太着急，每天完成一部分就行。<br>印象比较深的难点就是垂直时间轴的制作，也就是下面这个东西：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%9APureBlue/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue-1.md.png" alt=""></p><p>一个是要做出样式，主要涉及伪元素的使用，以及考虑怎么让垂直轴随着页面高度增加而延长；二个是逻辑，遍历所有文章并根据年份进行划分，这里需要使用ejs的语法，对Hexo的内置变量也要熟悉。</p><h3 id="踩了哪些坑"><a href="#踩了哪些坑" class="headerlink" title="踩了哪些坑"></a>踩了哪些坑</h3><p>当然，做这个主题的时候也踩了很多坑，这里做一下踩坑记录：</p><ul><li><p>路径问题。为了使代码更容易管理，通常制作主题都是采用模块化的方式，因此存在着大量的文件引用。而A文件引用B文件时，不一定是使用B相对于A的路径，而要看最终A文件被谁引用。</p></li><li><p>某篇文章中出现了一行很长的代码，因为没有对它进行换行和溢出处理，导致图片尺寸无法正常设置，同时所有的文本内容都被挤出div。</p></li><li><p>在本地测试的时候某些文章无法显示全文内容，并且底部div消失。这个问题比较奇葩，而且至今无解。猜想应该是渲染出错还是什么= =。</p></li><li><p>写stylus文件时混用了空格和tab，git报错。（这个是真的坑，开了sublime的提示才看出来的）</p></li><li><p>第三方插件失效。返回顶部按钮是用的第三方jq插件，坑的地方就在于，作者引用jq库时是用的http链接，被浏览器阻止了，导致插件失效。一开始以为是缓存问题导致的样式无法修改，在反复修改和刷新了一个半小时后才想到去控制台看报错信息：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%9APureBlue/%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue-2.md.png" alt=""><br>所以，为了保险一点还是在项目中放jq文件比较好，当然更好的做法应该是直接用原生js来写。</p></li><li><p>改动不生效的问题。比较常见的状况，在本地预览一切正常，通过域名访问的时候改动却迟迟没有生效，而且通常的清除浏览器缓存或者<code>hexo clean</code>还不一定有效。只能说改动的同步还是需要时间的= =</p></li><li><p>page页面共用。这个严格来说不算坑，而是应该留意的一个地方。Hexo中并没有专门的展示所有标签或者所有类别的页面，拿我用的ejs来说，layout文件夹下的tag.ejs实际指的是单一标签下的所有文章，同理categories.ejs指的是单一类别下的所有文章。而我们需要的展示页面实际上是统一放在page.ejs中，再根据条件判断生成对应页面。不过我实际操作的时候发现分类页走的是归档页的布局。<del>所以目前这个主题的分类页无法正常工作，也许之后会找到原因吧</del>问题已解决，目前分类页可以正常工作。</p></li><li><p>在 js 中引用 hexo 的内置变量。做导航栏时需要区分不同类型的页面。这个其实也很好解决，因为页面链接和导航栏条目是一一对应的（比如archive页面的链接是<code>/archive</code>，导航栏条目是<code>archive</code>），所以做一个判断就好。然而尴尬的是，首页压根就没有这种链接，首页就是一个<code>/</code>，尽管有 <code>is_home()</code> 函数可以用，不过 js 里是用不了的。所以这个时候我想到了直接通过配置文件拿到首页的 url，之后再做判断，但是又有一个问题 —— 这是hexo的内置变量，只能在ejs中使用，在js里是不识别的。考虑到ejs会生成dom元素，所以解决的思路是：<del>将内置变量存放在dom元素里并生成，之后在js中获取它的值，并设置该元素不可见</del> 直接作为dom元素的<code>data-*</code>属性即可。后面的 TOC 文本也是用的这个办法。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主题基本的东西都做好了，剩下的就是上传到 github，并且向 Hexo 官方站点发起 PR—-这些对于我这个菜鸟来说还很陌生，所以不得不去b站找了 github 和 git 使用的相关教程。本来应该一切顺利了，但是本地这边一直报错，原来是没有先 pull 远程仓库进行同步。</p><p>当然，git 和 github 是每个技术人的必备技能，所以之后我会另外找个时间系统学习一下这两者的使用。</p><p>最后当然就是编写说明文档了，这很像以前做汉化时写的使用说明。</p><p>感触比较深的两点：一个是注意阅读源码。如果实在没有思路，可以先参考别人是怎么写的，一开始制作主题的时候很难理清项目结构，所以我选择了先看看别人是怎么写的；二个是英语的重要性——1/5的答案在百度，4/5的答案在谷歌，学会英语就意味着你找到了解决问题的另一条途径，而且无疑是更加宽广的途径。比如 Hexo 主题的制作，国内是没有人真的会去为这个而做系列视频的，但是国外有；同样地，提问题时也可以考虑选择国外平台，如果你注意了提问礼仪，很大几率问题会得到秒回。</p><p>到这里差不多就告一段落了，之后的时间我会慢慢完善和更新这个主题。目前来说用户只有我自己，所以也算是为我自己而去努力地塑造它吧。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PureBlue </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「译」创建一个Hexo主题-Part2:其他页面</title>
      <link href="/2019/03/27/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2/"/>
      <url>/2019/03/27/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-2-Other-Pages/" target="_blank" rel="noopener">Create an Hexo Theme-Part2: Other Pages</a></li><li>原文作者：Jonathan Klughertz</li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p>在这个系列教程中，你将学习怎么从零开始制作一个 Hexo 主题。<br>在 <a href="https://chorer.github.io/%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1%2F">part1</a> 中，我们已经着手动工并创建了首页。在这篇文章中，我们将运用所学完成剩余的页面。</p><h2 id="其它文章的链接："><a href="#其它文章的链接：" class="headerlink" title="其它文章的链接："></a>其它文章的链接：</h2><ul><li><a href="https://chorer.github.io/%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1%2F">创建一个Hexo主题-Part1:首页</a></li><li><a href="https://chorer.github.io/%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2%2F">创建一个Hexo主题-Part2:其他页面</a></li><li><a href="https://chorer.github.io/2019/06/05/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart3/">创建一个Hexo主题-Part3:评论、分析和小部件</a></li></ul><h2 id="文章详情页"><a href="#文章详情页" class="headerlink" title="文章详情页"></a>文章详情页</h2><p>让我们继续完成 part1 中的剩余工作并创建文章详情页。<br>正如我们看到的，为了生成详情页，Hexo将会在<code>/layout/</code>文件夹中寻找一个<code>post.ejs</code>文件。<br>这是我的post.ejs文件：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/post.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-full'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> page<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了让代码更加有序，我们会将实际代码放在<code>_partial/article-full.ejs</code>中。现在先来创建这个文件：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-full.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Title <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h2 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-title"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- item.path %>"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>title <span class="token operator">||</span> item<span class="token punctuation">.</span>link<span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Date and Author <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-meta"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> item<span class="token punctuation">.</span>date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>date_format<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>author<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            by <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>author <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Content <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>content <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>hr <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Tags and Categories links <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'article-tags'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'article-categories'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个模板几乎和<code></code>_partial/article-excerpt.ejs`一样，除了：</p><ul><li>我们使用<code>&lt;%- item.content %&gt;</code>展示全文内容而不是摘要</li><li>在底部新增两个部分，分别是标签部分和分类部分。接下来分别创建它们。</li></ul><h3 id="文章标签"><a href="#文章标签" class="headerlink" title="文章标签"></a>文章标签</h3><p>文章标签部分将生成一篇文章对应的所有标签：<code>layout/_partial/article-tags.ejs</code><br>我们想要创建的是一系列的标签和链接，每个链接都将导向对应的标签页面，而标签页面会显示该标签的所有文章。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-tags.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>tags <span class="token operator">&amp;&amp;</span> item<span class="token punctuation">.</span>tags<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span>    <span class="token keyword">var</span> tags <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    item<span class="token punctuation">.</span>tags<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span><span class="token punctuation">{</span>        tags<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'&lt;a href="'</span> <span class="token operator">+</span> config<span class="token punctuation">.</span>root <span class="token operator">+</span> tag<span class="token punctuation">.</span>path <span class="token operator">+</span> <span class="token string">'">#'</span> <span class="token operator">+</span> tag<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'&lt;/a>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-tags-container"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>span <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"glyphicon glyphicon-tags"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> tags<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很简单，我们通过<code>post.tags</code>遍历文章的所有标签并让这些标签一个接一个地显示。我在每个标签前面加了一个#号，并且在列表前面额外加了一个图标。</p><h3 id="文章分类"><a href="#文章分类" class="headerlink" title="文章分类"></a>文章分类</h3><p><code>layout/_partial/article-categories.ejs</code>的内容和上面很相似</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-categories.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span>categories <span class="token operator">&amp;&amp;</span> item<span class="token punctuation">.</span>categories<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span>    <span class="token keyword">var</span> categories <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    item<span class="token punctuation">.</span>categories<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>category<span class="token punctuation">)</span><span class="token punctuation">{</span>        categories<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'&lt;a href="'</span> <span class="token operator">+</span> config<span class="token punctuation">.</span>root <span class="token operator">+</span> category<span class="token punctuation">.</span>path <span class="token operator">+</span> <span class="token string">'">'</span> <span class="token operator">+</span> category<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'&lt;/a>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-categories-container"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>span <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"glyphicon glyphicon-folder-open"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> categories<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' / '</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里不再赘述。</p><h3 id="文章样式"><a href="#文章样式" class="headerlink" title="文章样式"></a>文章样式</h3><p>可能有人注意到了，我们分别给了标签部分和分类部分一个类名，这是为了方便给它们设置样式。这是相关代码，将它们添加进<code>blog.css</code>中：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// source/css/blog.css</span><span class="token punctuation">.</span>blog<span class="token operator">-</span>tags<span class="token operator">-</span>container<span class="token punctuation">,</span> <span class="token punctuation">.</span>blog<span class="token operator">-</span>categories<span class="token operator">-</span>container <span class="token punctuation">{</span>    margin<span class="token operator">-</span>top<span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>    font<span class="token operator">-</span>size<span class="token punctuation">:</span> 20px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span>blog<span class="token operator">-</span>tags<span class="token operator">-</span>container span<span class="token punctuation">.</span>glyphicon<span class="token punctuation">,</span> <span class="token punctuation">.</span>blog<span class="token operator">-</span>categories<span class="token operator">-</span>container span<span class="token punctuation">.</span>glyphicon <span class="token punctuation">{</span>    margin<span class="token operator">-</span>right<span class="token punctuation">:</span> 20px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="页面类型模板的详情页"><a href="#页面类型模板的详情页" class="headerlink" title="页面类型模板的详情页"></a>页面类型模板的详情页</h2><p>这个很简单。“页面类型模板”和“文章类型模板”相差无几。就当做练习自定义一下就好，这是我的设置：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/page.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-full'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> page<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="归档页"><a href="#归档页" class="headerlink" title="归档页"></a>归档页</h2><p>归档页和首页一样会显示文章列表，只是它要更加简略—尽管基础结构和首页是差不多的：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/archive.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> page<span class="token punctuation">.</span>posts<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-archive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/pagination'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文章归档页部分"><a href="#文章归档页部分" class="headerlink" title="文章归档页部分"></a>文章归档页部分</h3><p>和前面一样，实际的工作是由<code>article-archive.ejs</code>完成的。我使用<code>article-excerpt</code>作为基础结构，做了适当删减，只保留标题、日期和作者。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-archive.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Title <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h2 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-title-archive"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- item.path %>"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>title <span class="token operator">||</span> item<span class="token punctuation">.</span>link<span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Date and Author <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-meta"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> item<span class="token punctuation">.</span>date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>date_format<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>author<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            by <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>author <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>细心的人可能注意到，我为标题创建了一个新的类名（它们太大了，我不喜欢）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// source/css/blog.css</span><span class="token punctuation">.</span>blog<span class="token operator">-</span>post<span class="token operator">-</span>title<span class="token operator">-</span>archive <span class="token punctuation">{</span>    margin<span class="token operator">-</span>bottom<span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>    font<span class="token operator">-</span>size<span class="token punctuation">:</span> 25px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="标签页和分类页"><a href="#标签页和分类页" class="headerlink" title="标签页和分类页"></a>标签页和分类页</h2><p>最后我们还需要创建两个页面。标签页将包括某个标签对应的全部文章，分类页同理。如果你还记得的话：<br>| 模板 | 备用模板 | 页面描述 |<br>|—–|—–|—-|<br>| archive | index | 这是归档页。它将显示我们博客中所有文章的标题和详情页链接|<br>| category | archive | 这是分类页。与归档页类似，但是会根据类别进行筛选|<br>| tag | archive | 这是标签页。与分类页类似，但是会根据标签进行筛选|</p><p><code>tag.ejs</code>和’category.ejs’的回退页是<code>archive.ejs</code>。我认为这三个页面并无太大区别，我们仅仅是在使用<code>archive.ejs</code>的回退页而已。好处就是代码量减少、提高代码可复用性和可维护性。</p><p>不过为了区分这三个页面，我们还是给归档页加上标题吧：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/archive.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span>    <span class="token keyword">var</span> title <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>category<span class="token punctuation">)</span> title <span class="token operator">=</span> page<span class="token punctuation">.</span>category<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>tag<span class="token punctuation">)</span> title <span class="token operator">=</span> page<span class="token punctuation">.</span>tag<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>archive<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>year<span class="token punctuation">)</span> title <span class="token operator">=</span> page<span class="token punctuation">.</span>year <span class="token operator">+</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>month <span class="token operator">?</span> <span class="token string">'/'</span> <span class="token operator">+</span> page<span class="token punctuation">.</span>month <span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> title <span class="token operator">=</span> <span class="token string">"Archives"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>   <span class="token operator">&lt;</span>h2 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-archive-title"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> title <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> page<span class="token punctuation">.</span>posts<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-archive'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/pagination'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们有了一个漂亮的标题用以描述了归档页的类型。<br>这是对应的CSS样式：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// source/css/blog.css</span><span class="token punctuation">.</span>blog<span class="token operator">-</span>archive<span class="token operator">-</span>title <span class="token punctuation">{</span>    margin<span class="token operator">-</span>bottom<span class="token punctuation">:</span> 50px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>本教程的第二篇文章非常简单，你只需要清楚<a href="https://segmentfault.com/a/1190000018575126" target="_blank" rel="noopener">第一篇文章</a>中提及的概念即可。我强烈推荐你根据自己的口味尝试修改主题。</p><p>在第三篇文章中，我们将添加评论部分、统计部分、装饰部件并做一些改进。期待与你再次相见！</p><blockquote><p>目前可以找到的比较完备的 Hexo 主题制作教程，我自己从中受益良多。有打算自己撸一个主题的都可以参考下，真的写得很不错。如果发现译文存在错误或其他需要改进的地方，欢迎在下面评论指出。</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础系列：inline-blcok和float</title>
      <link href="/2019/03/27/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Ainline-block%E5%92%8Cfloat/"/>
      <url>/2019/03/27/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Ainline-block%E5%92%8Cfloat/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><h3 id="1-比对："><a href="#1-比对：" class="headerlink" title="1.比对："></a>1.比对：</h3><p>简单比对一下div+css布局中的inline-block和float的特点，同时附上使用inline-block之后元素之间产生空隙的解决方法。<br><a id="more"></a><br>虽然设置浮动跟设置inline-block有些特征类似，但两者的区别还是非常明显的:</p><ul><li><p>文档流（Document flow）:<br>浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。</p></li><li><p>水平位置（Horizontal position）：<br>很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。</p></li><li><p>垂直对齐（Vertical alignment）：<br>在两个div的高度不同时，两种方式的对齐效果也不相同：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Ainline-blcok%E5%92%8Cfloat/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9Ainline-blcok%E5%92%8Cfloat-1.png" alt=""><br>图一：<code>display:inlne-block</code>属性修饰的元素没有脱离文档流，当然会与在正常的文档流中的元素一样采取的底端对齐方式。<br>图二： <code>float</code>属性修饰的元素在一定程度上脱离了普通文档流的限制，只用考虑向某个方向浮动，所以会产生如图的效果。<br>区别来了！！！如果是使用<code>display:inlne-block</code>，则我们可以通过<code>vertical-align</code>来控制两个元素的对齐方式：<br>我们为两个div分别添加一个属性：<code>vertical-align:middle</code></p></li></ul><pre class="line-numbers language-css"><code class="language-css">&lt;div class=<span class="token string">"myContainer"</span>>     &lt;div class=<span class="token string">"div1"</span> style=<span class="token string">"display: inline-block;vertical-align: middle"</span>>     &lt;/div>     &lt;div class=<span class="token string">"div2"</span> style=<span class="token string">"display: inline-block;vertical-align: middle"</span>>     &lt;/div>&lt;/div><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看一下运行效果：<br><img src="" alt=""></p><p>如图，div1出现在了div2的居中位置。假如使用的是float，我们是没办法使div1位于div2的中间位置的。</p><ul><li>空隙（Whitespace）：<br>inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空隙。而浮动元素会忽略空白节点，互相紧贴。</li></ul><h3 id="2-总结："><a href="#2-总结：" class="headerlink" title="2.总结："></a>2.总结：</h3><p>什么时候使用inline-block、什么时候使用float，这取决于你的设计稿跟解决方法。通常来说，当你需要控制元素的垂直对齐跟水平排列时，使用inline-block；当你需要让元素环绕某一个元素时，或者需要支持旧版本ie，或者不想处理inline-block带来的空隙问题时，使用浮动。</p><h3 id="3-如何消除inline-block带来的空隙"><a href="#3-如何消除inline-block带来的空隙" class="headerlink" title="3.如何消除inline-block带来的空隙;"></a>3.如何消除inline-block带来的空隙;</h3><h4 id="3-1-思路一："><a href="#3-1-思路一：" class="headerlink" title="3.1 思路一："></a>3.1 思路一：</h4><p>元素间的间隙出现的原因是元素标签之间的空格，把空格去掉间隙自然就会消失。来看以下几种写法：</p><ul><li>写法一/不建议使用：</li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>写法二：</li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>写法三：</li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--    --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--    --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--    --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-思路二："><a href="#3-2-思路二：" class="headerlink" title="3.2 思路二："></a>3.2 思路二：</h4><p>取消span的结束标签，这样间隙就没有了。为了兼容IE6/IE7，最后一个标签需要闭合。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>.demo span{     background:#ddd;     display: inline-block;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-思路三："><a href="#3-3-思路三：" class="headerlink" title="3.3 思路三："></a>3.3 思路三：</h4><p>不管是思路一还是思路二，都只适用于写静态页面的时候，一旦HTML是后台生成，就不生效了。<br>这时还有一个办法：在父容器上使用font-size:0。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>我是一个span<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>.demo {font-size: 0;}.demo span{        background:#ddd;        display: inline-block;        font-size: 14px; /*要设置相应的字号*/}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原理：<br>换行和回车会给各个span之间带来空格，而空格会被当成字符处理，因此通过给父元素设置字体大小为0，则空格字符大小也为0，相当于消除了其大小。需要注意的是，一定要额外设置span中的字体大小，否则会继承父元素的0大小字体。</p><h4 id="3-4-思路四："><a href="#3-4-思路四：" class="headerlink" title="3.4 思路四："></a>3.4 思路四：</h4><p>上面的思路其实已经很完美，但可惜不兼容Safari，以下给出终极方案,即<code>font-size:0</code>配合<code>letter-space:-N px</code>。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.finally-solve</span> </span><span class="token punctuation">{</span><span class="token property">letter-spacing</span><span class="token punctuation">:</span> -<span class="token number">4</span>px<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*根据不同字体字号或许需要做一定的调整*/</span><span class="token property">word-spacing</span><span class="token punctuation">:</span> -<span class="token number">4</span>px<span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.finally-solve</span> li </span><span class="token punctuation">{</span><span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">16</span>px<span class="token punctuation">;</span><span class="token property">letter-spacing</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span><span class="token property">word-spacing</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span><span class="token property">display</span><span class="token punctuation">:</span>inline-block<span class="token punctuation">;</span>*<span class="token property">display</span><span class="token punctuation">:</span> inline<span class="token punctuation">;</span><span class="token property">zoom</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」创建一个Hexo主题-Part1:首页</title>
      <link href="/2019/03/27/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1/"/>
      <url>/2019/03/27/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-1-Index/" target="_blank" rel="noopener">Create an Hexo Theme-Part1: Index</a></li><li>原文作者：Jonathan Klughertz</li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p>在这个系列教程中，你将学习怎么从零开始制作一个 Hexo 主题。我很喜欢 Hexo ，并且每天都在使用，不幸的是，直到今天关于主题制作的文档还是相当稀缺。所以我打算弥补这个空缺。</p><h2 id="其它文章的链接："><a href="#其它文章的链接：" class="headerlink" title="其它文章的链接："></a>其它文章的链接：</h2><ul><li><a href="https://chorer.github.io/%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1%2F">创建一个Hexo主题-Part1:首页</a></li><li><a href="https://chorer.github.io/%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2%2F">创建一个Hexo主题-Part2:其他页面</a></li><li><a href="https://chorer.github.io/2019/06/05/Trs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart3/">创建一个Hexo主题-Part3:评论、分析和小部件</a></li></ul><h2 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h2><ul><li>Hexo 博客的基础使用。如果你是第一次接触，请<a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">前往官网阅读教程</a></li><li>了解 Bootstrap</li><li>了解 Javascript 模板引擎（我们将使用 EJS ）</li></ul><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>这个项目旨在制作一个 Hexo 主题并详细了解 Hexo 引擎的工作方式。<br>我不想在 HTML 和 CSS 上花费太多时间，所以我们将重置下面这个Hexo主题：<a href="https://getbootstrap.com/docs/3.4/examples/blog/" target="_blank" rel="noopener">https://getbootstrap.com/docs/3.4/examples/blog/</a> 。它是 Bootstrap 文档中的一个标准初始模板样例。<br>我们将一步步地重用 CSS 、复制粘贴 HTML ，直到最后实现想要的效果。<br>如果你感到困惑或者只对它的代码感兴趣，请<a href="https://github.com/klugjo/bootstrap-blog-hexo" target="_blank" rel="noopener">前往 github </a>。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="创建一个新的-hexo-博客"><a href="#创建一个新的-hexo-博客" class="headerlink" title="创建一个新的 hexo 博客"></a>创建一个新的 hexo 博客</h3><p>让我们从搭建一个全新的 hexo 博客开始吧</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Create a new folder</span>mkdir hexo<span class="token operator">-</span>theme<span class="token operator">-</span>creation cd hexo<span class="token operator">-</span>theme<span class="token operator">-</span>creation<span class="token comment" spellcheck="true">// Initialise Hexo</span>hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建主题文件夹"><a href="#创建主题文件夹" class="headerlink" title="创建主题文件夹"></a>创建主题文件夹</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Enter the theme folder</span>cd themes<span class="token comment" spellcheck="true">// bootstrap-blog-hexo is also going to be the name of our theme</span>mkdir bootstrap<span class="token operator">-</span>blog<span class="token operator">-</span>hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：如果你想在 git 中保存主题的话（你也应该这么做），请在<code>/themes/bootstrap-blog-hexo/</code>中初始化 git 。</p><h3 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h3><p>这是我们开始工作所需要的文件和文件夹：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">|</span><span class="token operator">--</span> layout <span class="token comment" spellcheck="true">// .ejs templates </span><span class="token operator">|</span><span class="token operator">--</span> source <span class="token comment" spellcheck="true">// source files (CSS, scripts)</span><span class="token operator">|</span><span class="token operator">--</span> _config<span class="token punctuation">.</span>yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建以下两个文件夹和 _config.yml 文件。</p><ul><li>/layout/ 将包含<a href="https://hexo.io/docs/themes.html#layout" target="_blank" rel="noopener">我们所有的 EJS 模板</a></li><li>/source/ 将包含<a href="https://hexo.io/docs/themes.html#source" target="_blank" rel="noopener">我们所有的资源</a>（ CSS 文件、外部脚本和库）</li><li>_config.yml 包含<a href="https://hexo.io/docs/themes.html#config-yml" target="_blank" rel="noopener">我们的主题配置</a>。现在暂且不写入任何内容。</li></ul><h3 id="复制-bootstrap-blog-资源"><a href="#复制-bootstrap-blog-资源" class="headerlink" title="复制 bootstrap blog 资源"></a>复制 bootstrap blog 资源</h3><p>从 <a href="https://getbootstrap.com/docs/3.4/examples/blog/" target="_blank" rel="noopener">bootstrap blog template</a> 复制所有我们需要的资源并放在 source 文件夹里。你可以选择通过浏览器查看资源并复制下来，或者是下载该<a href="https://s3.amazonaws.com/klugjo.github.io/source-hex-blog-creation.zip" target="_blank" rel="noopener">压缩包</a>，之后解压到 source 文件夹里。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">|</span><span class="token operator">--</span> layout <span class="token operator">|</span><span class="token operator">--</span> source     <span class="token operator">|</span><span class="token operator">--</span> bootstrap <span class="token comment" spellcheck="true">// Copy the boostrap library files here </span>    <span class="token operator">|</span><span class="token operator">--</span> css <span class="token comment" spellcheck="true">// Copy the blog's css file here</span>    <span class="token operator">|</span><span class="token operator">--</span> favicon        <span class="token operator">|</span><span class="token operator">--</span> favicon<span class="token punctuation">.</span>ico <span class="token comment" spellcheck="true">// Your choice of favicon</span>    <span class="token operator">|</span><span class="token operator">--</span> js <span class="token comment" spellcheck="true">// Copy the blog's js file here</span><span class="token operator">|</span><span class="token operator">--</span> _config<span class="token punctuation">.</span>yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Hexo-的基本要素"><a href="#Hexo-的基本要素" class="headerlink" title="Hexo 的基本要素"></a>Hexo 的基本要素</h2><p>在我们开始写第一个模板文件之前，先来看看 Hexo 博客生成过程的基本要素。</p><h3 id="页面类型"><a href="#页面类型" class="headerlink" title="页面类型"></a>页面类型</h3><p>我们能够在主题中定义<a href="https://hexo.io/docs/templates.html" target="_blank" rel="noopener"> 6 种页面类型</a>，与之相对应地，在 public 文件夹生成的每一个单独的 HTML 页面都属于下面模板中的其中一个：</p><table><thead><tr><th>模板</th><th>回退</th><th>页面描述</th></tr></thead><tbody><tr><td>index</td><td>无</td><td>这是博客的首页，也是网站的主要入口。本教程中我们将让其显示文章摘要列表</td></tr><tr><td>post</td><td>index</td><td>这是文章的详情页。我们将展示一篇完整的文章以及一个评论区</td></tr><tr><td>page</td><td>index</td><td>这是页面的详情页，与 post 一样，但是是 page 类型的 post</td></tr><tr><td>archive</td><td>index</td><td>这是归档页。它将显示我们博客中所有文章的标题和详情页链接</td></tr><tr><td>category</td><td>archive</td><td>这是分类页。与归档页类似，但是会根据类别进行筛选</td></tr><tr><td>tag</td><td>archive</td><td>这是标签页。与分类页类似，但是会根据标签进行筛选</td></tr></tbody></table><p>在本篇教程中我们将创建 index 模板。</p><p>在页面生成过程中， Hexo 将会搜索名字为 index.ejs, post.ejs , page.ejs 等的文件，这些模板之后用于创建静态 HTML 页面。</p><h3 id="公共布局"><a href="#公共布局" class="headerlink" title="公共布局"></a>公共布局</h3><p>Hexo 支持使用 <a href="https://hexo.io/docs/templates.html#Layouts" target="_blank" rel="noopener">公共的布局文件</a> ，上面的模板都将使用到该文件。<br>该文件命名为 layout.ejs 。不同页面类型的模板会创建一些内容，而这个文件就好比这些内容的“外壳”。<br>在我们的主题中，公共布局将包括：<code>&lt;html&gt;</code>标签、<code>&lt;head&gt;</code>标签、头部、菜单、底部和侧边栏。基本上是所有类型的页面都具备的元素。<br>不同的页面模板将只负责创建实际内容，这些内容将放在我们的主体部位。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在所有的模板中，我们都可以使用<a href="https://hexo.io/docs/variables.html" target="_blank" rel="noopener"> hexo 引擎提供的内置变量</a>。以下是部分变量：</p><ul><li>Site：<code>site</code>包含了网站的信息。例如，我们可以通过<code>site.posts</code>访问博客中的所有文章。当我们想要显示统计数据的时候，这将派上用场。</li><li>Page：<code>page</code>是主要变量，包含了许多与当前页面相关的信息，包括所有的文章标题、日期、内容等。</li><li>Config：<code>config</code>是一个指向站点<code>_config.yml</code>文件的 JavaScript 对象</li><li>Theme：<code>theme</code>是一个指向主题<code>_config.yml</code>文件的 JavaScript 对象</li></ul><h2 id="主题的布局创建"><a href="#主题的布局创建" class="headerlink" title="主题的布局创建"></a>主题的布局创建</h2><p>上面提及了<code>/layout/layout.ejs</code>文件，现在我们开始来创建它。</p><h3 id="顶部标签"><a href="#顶部标签" class="headerlink" title="顶部标签"></a>顶部标签</h3><p>首先创建 layout.ejs 文件并插入<code>&lt;html&gt;&lt;/html&gt;</code>标签</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//layout/layout.ejs</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Head tag <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/head'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们将所有<code>&lt;head&gt;</code>标签里的代码提取出来并放在局部视图中，这有助于实现关注点分离和代码重用。<br>语法是<code>partial(&#39;path&#39; [, arguments])</code><br>在创建<code>layout/_partial/head.ejs</code>文件后，从 bootstrap 源码中复制 head 标签里的代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/head.ejs</span><span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">"X-UA-Compatible"</span> content<span class="token operator">=</span><span class="token string">"IE=edge"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width, initial-scale=1"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"description"</span> content<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span>    <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"author"</span> content<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span>    <span class="token operator">&lt;</span>link rel<span class="token operator">=</span><span class="token string">"icon"</span> href<span class="token operator">=</span><span class="token string">"favicon/favicon.ico"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span>Blog Template <span class="token keyword">for</span> Bootstrap<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Bootstrap core CSS <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'bootstrap/css/bootstrap.min.css'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> IE10 viewport hack <span class="token keyword">for</span> Surface<span class="token operator">/</span>desktop Windows <span class="token number">8</span> bug <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'css/ie10-viewport-bug-workaround.css'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Custom styles <span class="token keyword">for</span> <span class="token keyword">this</span> template <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'css/blog.css'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> HTML5 shim and Respond<span class="token punctuation">.</span>js <span class="token keyword">for</span> IE8 support <span class="token keyword">of</span> HTML5 elements and media queries <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token punctuation">[</span><span class="token keyword">if</span> lt IE <span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">></span>        <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>        <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://oss.maxcdn.com/respond/1.4.2/respond.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token punctuation">[</span>endif<span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这很简单，我们只需使用 <a href="https://hexo.io/docs/helpers.html#css" target="_blank" rel="noopener">CSS helper</a> 插入样式表。<br>source 文件夹中的文件将会被复制到站点根目录下，所以不要在路径中包含<code>source/</code><br>我们将让<code>&lt;title&gt;</code>和<code>&lt;meta&gt;</code>标签保持动态，不过现在先暂且不管它们。</p><h3 id="底部标签"><a href="#底部标签" class="headerlink" title="底部标签"></a>底部标签</h3><p>底部标签位于<code>&lt;/body&gt;</code>之前。我们将在这个局部视图中包含所有脚本。<br>先修改一下布局：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/layout.ejs</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Head tag <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/head'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> After footer scripts <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/after-footer'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建<code>layout/_partial/after-footer.ejs</code>的内容：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/after-footer.ejs</span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">js</span><span class="token punctuation">(</span><span class="token string">'bootstrap/js/bootstrap.min.js'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> IE10 viewport hack <span class="token keyword">for</span> Surface<span class="token operator">/</span>desktop Windows <span class="token number">8</span> bug <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">js</span><span class="token punctuation">(</span><span class="token string">'js/ie10-viewport-bug-workaround.js'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意 <a href="https://hexo.io/docs/helpers.html#js" target="_blank" rel="noopener">JS helper function</a> 的使用，它将引用本地 js 文件。</p><h3 id="顶部菜单"><a href="#顶部菜单" class="headerlink" title="顶部菜单"></a>顶部菜单</h3><p>类似地，在<code>&lt;body&gt;</code>标签后创建顶部菜单。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/layout.ejs</span><span class="token comment" spellcheck="true">// [...]</span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Menu <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/menu'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token comment" spellcheck="true">// [...]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>layout/_partial/menu.ejs</code>的内容：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/menu.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-masthead"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>nav <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-nav"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> theme<span class="token punctuation">.</span>menu<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>                <span class="token operator">&lt;</span>a <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-nav-item"</span> href<span class="token operator">=</span><span class="token string">"&lt;%- url_for(theme.menu[i]) %>"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> i <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>nav<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意<code>theme</code>全局变量的使用,它指向的是主题的<code>_config.yml</code>文件。为了可以在主题配置中配置菜单，我们需要在<code>_config.yml</code>文件中添加配置：</p><pre class="line-numbers language-js"><code class="language-js">_config<span class="token punctuation">.</span>yml# Headermenu<span class="token punctuation">:</span>  Home<span class="token punctuation">:</span> <span class="token operator">/</span>  Archives<span class="token punctuation">:</span> <span class="token operator">/</span>archives<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>menu.ejs</code>中我们遍历了配置文件中所有的菜单项目并创建对应的链接。</p><h3 id="顶部"><a href="#顶部" class="headerlink" title="顶部"></a>顶部</h3><p>顶部将位于顶部菜单下面，它包含了博客标题和子标题：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/header.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-header"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h1 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-title"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> config<span class="token punctuation">.</span>title <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"lead blog-description"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>subtitle<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> config<span class="token punctuation">.</span>subtitle <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们使用了指向站点<code>_config.yml</code>文件的<code>config</code>变量，它包含了可供配置的标题和子标题属性。<br>注意在布局的<code>&lt;div class=&quot;container&quot;&gt;&lt;div&gt;</code>中嵌套顶部：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/layout.ejs</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Head tag <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/head'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Menu <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/menu'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Blog Header<span class="token punctuation">:</span> title and subtitle <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/header'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token comment" spellcheck="true">// [...]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="底部"><a href="#底部" class="headerlink" title="底部"></a>底部</h3><p>底部现在是完全静态的，内容如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/footer.ejs</span><span class="token operator">&lt;</span>footer <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-footer"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>Blog template built <span class="token keyword">for</span> <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://getbootstrap.com"</span><span class="token operator">></span>Bootstrap<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span> by <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"https://twitter.com/mdo"</span><span class="token operator">></span>@mdo<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>Adapted to Hexo by <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://www.codeblocq.com/"</span><span class="token operator">></span>klugjo<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>Back to top<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>footer<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="主要内容和侧边栏"><a href="#主要内容和侧边栏" class="headerlink" title="主要内容和侧边栏"></a>主要内容和侧边栏</h3><p>此时，我们再加上主要内容和侧边栏，基本就差不多了。<br>下面是最终的<code>layout.ejs</code>：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/layout.ejs</span><span class="token operator">&lt;</span>html<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Head tag <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/head'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Menu <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/menu'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Blog Header<span class="token punctuation">:</span> title and subtitle <span class="token operator">--</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/header'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"row"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Main Content <span class="token operator">--</span><span class="token operator">></span>            <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"col-sm-8 blog-main"</span><span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> body <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Sidebar <span class="token operator">--</span><span class="token operator">></span>            <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"col-sm-3 col-sm-offset-1 blog-sidebar"</span><span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/sidebar'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Footer <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/footer'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> After footer scripts <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/after-footer'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>body</code>变量对应了不同页面类型模板创建的内容（参见上面）。<br>至于侧边栏，我们现在暂且使用来自 bootstrap 模板的硬编码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/sidebar.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sidebar-module sidebar-module-inset"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h4<span class="token operator">></span>About<span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span>    <span class="token operator">&lt;</span>p<span class="token operator">></span>Etiam porta <span class="token operator">&lt;</span>em<span class="token operator">></span>sem malesuada magna<span class="token operator">&lt;</span><span class="token operator">/</span>em<span class="token operator">></span> mollis euismod<span class="token punctuation">.</span> Cras mattis consectetur purus sit amet fermentum<span class="token punctuation">.</span> Aenean lacinia bibendum nulla sed consectetur<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sidebar-module"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h4<span class="token operator">></span>Archives<span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span>    <span class="token operator">&lt;</span>ol <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list-unstyled"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>March <span class="token number">2014</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>February <span class="token number">2014</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>January <span class="token number">2014</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>December <span class="token number">2013</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>November <span class="token number">2013</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>ol<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"sidebar-module"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h4<span class="token operator">></span>Elsewhere<span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">></span>    <span class="token operator">&lt;</span>ol <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"list-unstyled"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>GitHub<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>Twitter<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span><span class="token operator">></span>Facebook<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>ol<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="首页文件"><a href="#首页文件" class="headerlink" title="首页文件"></a>首页文件</h2><p>布局到位后，我们就可以开始创建第一个页面类型模板 inde.ejs 了。<br>这是比较简陋的第一个版本：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/index.ejs</span><span class="token operator">&lt;</span>span<span class="token operator">></span>Content<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>别小瞧它，我们可以用这个在浏览器中测试主题：</p><pre class="line-numbers language-js"><code class="language-js"># Verify that everything is alrighthexo generate# Start hexo serverhexo server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 。哇！<br>注意：不要忘记在站点的 config 文件中更新主题：</p><pre class="line-numbers language-js"><code class="language-js">_config<span class="token punctuation">.</span>yml# Extensions## Plugins<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>hexo<span class="token punctuation">.</span>io<span class="token regex">/plugins/</span>## Themes<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>hexo<span class="token punctuation">.</span>io<span class="token regex">/themes/</span>theme<span class="token punctuation">:</span> bootstrap<span class="token operator">-</span>blog<span class="token operator">-</span>hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历博客文章"><a href="#遍历博客文章" class="headerlink" title="遍历博客文章"></a>遍历博客文章</h3><p>我们想要在首页显示各篇文章的摘要。<br>首先，在我们的 index.ejs 文件中遍历文章：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout.index.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> page<span class="token punctuation">.</span>posts<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-excerpt'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过<code>page.posts</code>获取该页面的所有文章</li><li>通过<code>&lt;%- partial(&#39;name&#39;, args) %&gt;</code>给 partial 传参</li></ul><h3 id="文章布局"><a href="#文章布局" class="headerlink" title="文章布局"></a>文章布局</h3><p>创建<code>article-excerpt.ejs</code>文件，添加适合主题的代码。这是我的布局：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/article-excerpt.ejs</span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Title <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>h2 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-title"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- item.path %>"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>title <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Date and Author <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>p <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"blog-post-meta"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> item<span class="token punctuation">.</span>date<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>date_format<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>author<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            by <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>author <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Content <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> item<span class="token punctuation">.</span>excerpt <span class="token operator">||</span> item<span class="token punctuation">.</span>content <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> Only display the Read More link <span class="token keyword">if</span> we are displaying an excerpt <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>excerpt<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span>p<span class="token operator">></span>            <span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- item.path %>"</span><span class="token operator">></span>                <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> theme<span class="token punctuation">.</span>excerpt_link <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="全文链接"><a href="#全文链接" class="headerlink" title="全文链接"></a>全文链接</h4><p>全文链接是由<code>config.root</code>（配置选项，相当于<code>/</code>）和<code>item.path</code>(相对路径或者绝对路径，指向全文)连接组成的。</p><h4 id="文章作者"><a href="#文章作者" class="headerlink" title="文章作者"></a>文章作者</h4><p>默认情况下， Hexo 没有关于作者属性的的文章变量。不过我们可以在 <a href="https://hexo.io/docs/front-matter.html" target="_blank" rel="noopener">front matter</a> 中添加任意自己想要的变量。<br>如果你想要在文章中显示作者名字，那么文章的 front matter 应该类似如下进行设置：</p><pre class="line-numbers language-js"><code class="language-js">title<span class="token punctuation">:</span> Hello Worldauthor<span class="token punctuation">:</span> Klughertz Jonathan<span class="token operator">--</span><span class="token operator">-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="Item-excerpt-和-Item-content"><a href="#Item-excerpt-和-Item-content" class="headerlink" title="Item excerpt 和 Item content"></a>Item excerpt 和 Item content</h5><p>当用 Hexo 编辑文章时，你可以用<code>&lt;!-- more --&gt;</code>标签从文章内容中截取摘要。在本教程中，因为我们展示的是文章列表，所以选择显示摘要。之后用户可以通过点击文章标题或者“阅读更多”的链接浏览全文。</p><h5 id="“阅读更多”文本"><a href="#“阅读更多”文本" class="headerlink" title="“阅读更多”文本"></a>“阅读更多”文本</h5><p>别忘了，你需要像我这样在主题的配置文件中添加一个新的属性：</p><pre class="line-numbers language-js"><code class="language-js">_config<span class="token punctuation">.</span>yml# Read More textexcerpt_link<span class="token punctuation">:</span> Read More<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>希望接下来的代码容易理解。现在，我建议你写一些除了默认的 Hello World 之外的文章并享受这个结果。</p><h2 id="分页器"><a href="#分页器" class="headerlink" title="分页器"></a>分页器</h2><p>在本篇文章中，我们最后需要处理的是首页的分页器。<br>在<code>index.ejs</code>文件中增加一个分页器的 partial ：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/index.ejs</span><span class="token operator">&lt;</span><span class="token operator">%</span> page<span class="token punctuation">.</span>posts<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/article-excerpt'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>item<span class="token punctuation">:</span> item<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">%</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">-</span> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/pagination'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后开始创建分页器的内容，<code>layout/_partial/pagination.ejs</code>:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// layout/_partial/pagination.ejs</span><span class="token operator">&lt;</span>nav<span class="token operator">></span>    <span class="token operator">&lt;</span>ul <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"pager"</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- page.prev_link %>"</span><span class="token operator">></span>Previous<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>page<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">></span>            <span class="token operator">&lt;</span>li<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"&lt;%- config.root %>&lt;%- page.next_link %>"</span><span class="token operator">></span>Next<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>nav<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>page.prev</code>：上一页的页码。如果当前页是第一页，则为0</li><li><code>page.next</code>：下一页的页码。如果当前页是最后一页，则为0</li><li><code>page.next_link</code>和<code>page.prev_link</code>是什么就不用多说了。</li></ul><p>如果你没有足够的文章用来查看分页器的工作效果，可以在主配置文件中（<code>per_page</code>属性）调整每一页的文章数。</p><p>这就是今天的内容，在下一篇教程中，我们将完成博客剩下的所有页面。</p><blockquote><p>目前可以找到的比较完备的 Hexo 主题制作教程，我自己从中受益良多。有打算自己撸一个主题的都可以参考下，真的写得很不错。如果发现译文存在错误或其他需要改进的地方，欢迎在下面评论指出。</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text3插件简易使用教程</title>
      <link href="/2019/03/26/To-Sublime%20Text3%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/03/26/To-Sublime%20Text3%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Sublime%20Text3%E6%8F%92%E4%BB%B6%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Sublime%20Text3%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-1.png" alt=""></p><a id="more"></a><p>作为一款轻便的编辑器，Sublime Text3的下载和安装都比较简单，这里一并略过，只说安装插件的事情。Sublime Text3支持各种强大的插件，可以在一定程度上提高打码速度。</p><h2 id="1-安装-Package-Control"><a href="#1-安装-Package-Control" class="headerlink" title="1.安装 Package Control"></a>1.安装 Package Control</h2><p>安装插件有两种方式，一种是直接下载插件的安装包，解压缩到编辑器的 Packages 目录中，比较麻烦，不推荐；我们通常用另一种方法，即通过 Package Control 组件来安装插件 。所以第一步，先安装 Package Control 组件 。</p><p>打开编辑器，按 control + ` 打开控制台，粘贴如下代码到命令行并回车；</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">,</span>os<span class="token punctuation">;</span>pf <span class="token operator">=</span> <span class="token string">'Package Control.sublime-package'</span><span class="token punctuation">;</span>ipp <span class="token operator">=</span> sublime<span class="token punctuation">.</span><span class="token function">installed_packages_path</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">install_opener</span><span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">build_opener</span><span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">ProxyHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">open</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>ipp<span class="token punctuation">,</span> pf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">urlopen</span><span class="token punctuation">(</span><span class="token string">'http://sublime.wbond.net/'</span> <span class="token operator">+</span> pf<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span><span class="token string">'%20'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重启编辑器，在 Perferences -&gt;Package Settings 中看到 Package Control，则表示安装成功。</p><p>当然，你有很大的概率会安装失败，遇到下面的报错弹窗：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Sublime%20Text3%E6%8F%92%E4%BB%B6%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Sublime%20Text3%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-2.png" alt=""></p><p>原因不便多说（你懂的），网上有比较多的解决方法，这里提供一种最有效也是最简单的方法。依次点击编辑器的 Preferences –&gt;package settings–&gt;package control–&gt;settings user,进入用户自定义配置文件，修改 channels 的值为</p><pre class="line-numbers language-js"><code class="language-js">http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>miaoqiyuan<span class="token punctuation">.</span>cn<span class="token operator">/</span>products<span class="token operator">/</span>proxy<span class="token punctuation">.</span>php<span class="token operator">/</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>packagecontrol<span class="token punctuation">.</span>io<span class="token operator">/</span>channel_v3<span class="token punctuation">.</span>json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Sublime%20Text3%E6%8F%92%E4%BB%B6%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Sublime%20Text3%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-3.png" alt=""></p><p>这样我们就可以成功安装 package controls 了 。</p><h2 id="2-安装想要的插件"><a href="#2-安装想要的插件" class="headerlink" title="2.安装想要的插件"></a>2.安装想要的插件</h2><p>点击 Preferences –&gt;package control，点选 install package 选项 ，输入自己想要安装的插件的名称，即可进行安装。当然，由于**原因，安装插件的过程一般比较慢，等一会就行了。一般来说，安装成功后会弹出新标签页。</p><h2 id="3-推荐的插件"><a href="#3-推荐的插件" class="headerlink" title="3.推荐的插件"></a>3.推荐的插件</h2><h3 id="3-1-汉化插件"><a href="#3-1-汉化插件" class="headerlink" title="3.1 汉化插件"></a>3.1 汉化插件</h3><p>如果你看不惯英文的话，可以下一个汉化插件。点选 install package 选项后 ，搜索“ChineseLocalization”进行安装。安装完后重启编辑器即可；</p><h3 id="3-2-解决中文乱码问题的插件"><a href="#3-2-解决中文乱码问题的插件" class="headerlink" title="3.2 解决中文乱码问题的插件"></a>3.2 解决中文乱码问题的插件</h3><p>Sublime Text3 不支持 GB 2312和 GBK 编码，会出现中文乱码的情况，所以推荐安装“ConvertToUTF8”插件，安装方法同上；</p><h3 id="3-3-解决输入法输入框不跟随问题的插件"><a href="#3-3-解决输入法输入框不跟随问题的插件" class="headerlink" title="3.3 解决输入法输入框不跟随问题的插件"></a>3.3 解决输入法输入框不跟随问题的插件</h3><p>中文状态下，我们会发现输入法的输入框无法跟随鼠标，看着非常难受，所以这里可以用 IMESupport 插件解决这个问题。这个方法绝大多数情况下是有效的，然而，如果你是 win10用户，并且用的是系统自带输入法，那么你得采取另一种方法。原文链接在此 <a href="https://blog.csdn.net/qq_24345801/article/details/79077902" target="_blank" rel="noopener">https://blog.csdn.net/qq_24345801/article/details/79077902</a> ，这里粘贴一下主要内容。</p><blockquote><p>其实还是要用到插件 IMESupport ，只不过这个插件是国人大神自己修改的，下载地址是：<a href="https://github.com/zcodes/IMESupport" target="_blank" rel="noopener">https://github.com/zcodes/IMESupport</a><br>由于是修改过的源码，不能通过 package control 来在线安装 ，而是需要自己手动安装（安装前请先卸载原来的插件），安装过程如下：</p><ol><li>从上面的网址下载插件，解压</li><li>Preferences-&gt;Browse Packages 打开插件安装的目录</li><li>将解压后的文件夹复制到上一步打开的目录中</li><li>重启 sublime text 3即可</li></ol></blockquote><h3 id="3-4-自动补全代码的插件"><a href="#3-4-自动补全代码的插件" class="headerlink" title="3.4 自动补全代码的插件"></a>3.4 自动补全代码的插件</h3><p>使用“Emmet”插件，可以迅速编写 HTML /CSS 代码 ，例如，只需要用<code>html:5</code>配合 tab 键即可迅速生成 html 的基础结构 ，还可以用诸如<code>nav&gt;ul&gt;li</code>的快捷方式迅速生成嵌套结构，具体其他用法可以百度“Emmet 语法 ”。</p><h3 id="3-5-语法检查插件"><a href="#3-5-语法检查插件" class="headerlink" title="3.5 语法检查插件"></a>3.5 语法检查插件</h3><p>也即 SublimeLinter 插件。但其实我们并不是直接用它进行代码检测——实际上它是一个包含了多种检测插件（sublimelinter-htmlhint，sublimelinter-csslint，sublimelinter-jshint）的“容器”。<br>本步骤的安装会比其他插件麻烦得多，下面介绍一下具体安装过程。</p><h4 id="3-5-1-安装-node-js"><a href="#3-5-1-安装-node-js" class="headerlink" title="3.5.1 安装 node .js"></a>3.5.1 安装 node .js</h4><p>安装 SublimeLinter 前必须先安装 node .js 这一重要前置 。这是因为 sublimelinter -htmlhint，sublimelinter-csslint，sublimelinter-jshint 实际上分别调用的是 node.js 的 htmlhint，csslint 和 jshint。安装 node .js 比较简单 ，这里略过。</p><h4 id="3-5-2-安装-SublimeLinter"><a href="#3-5-2-安装-SublimeLinter" class="headerlink" title="3.5.2 安装 SublimeLinter"></a>3.5.2 安装 SublimeLinter</h4><ul><li>打开 Sublime ，按下 Ctrl+Shift+p 进入 Command Palette;</li><li>输入 install 进入 Package Control: Install Package;</li><li>输入 SublimeLinter ，选择 SublimeLinter 进行安装。</li></ul><h4 id="3-5-3-安装-sublimeLinter-contrib-htmlhint-和-xg-htmlhint"><a href="#3-5-3-安装-sublimeLinter-contrib-htmlhint-和-xg-htmlhint" class="headerlink" title="3.5.3 安装 sublimeLinter-contrib-htmlhint 和 xg-htmlhint"></a>3.5.3 安装 sublimeLinter-contrib-htmlhint 和 xg-htmlhint</h4><p>SublimeLinter 的插件之一 ，用来调用 node .js 的 xg-htmlhint 进行语法检查 。</p><ul><li>前往 Releases 下载最新版本的压缩包，解压并重命名为“SublimeLinter-contrib-htmlhint”，并放入 Sublime 的 Package 目录 (菜单-&gt;Preferences-&gt;BrowsePackages)</li><li>开始菜单—&gt;node.js—&gt;node.js command prompt，输入以下命令 ：<br><code>npm install -g xg-htmlhint</code><br>等待出现一堆数字版本号即为成功安装。</li></ul><h4 id="3-5-4-安装-sublimeLinter-csslint-和-csslint，sublimeLinter-jshint-和-jshint"><a href="#3-5-4-安装-sublimeLinter-csslint-和-csslint，sublimeLinter-jshint-和-jshint" class="headerlink" title="3.5.4 安装 sublimeLinter-csslint 和 csslint，sublimeLinter-jshint 和 jshint"></a>3.5.4 安装 sublimeLinter-csslint 和 csslint，sublimeLinter-jshint 和 jshint</h4><ul><li><p>打开 Sublime Text3,按住 Ctrl +Shift+P 安装<br>SublimeLinter-csslint<br>SublimeLinter-jshint</p></li><li><p>开始菜单—&gt;node.js—&gt;node.js command prompt，输入以下命令：<br><code>npm install -g jshint</code><br><code>npm install -g csslint</code></p></li></ul><p>之后重启编辑器，大功告成。这个插件虽然不是万能的，但是可以鉴别很多错误。</p><h3 id="3-6-热更新插件"><a href="#3-6-热更新插件" class="headerlink" title="3.6 热更新插件"></a>3.6 热更新插件</h3><p>每次修改文件都要刷新一遍浏览器，会不会太麻烦？试试热更新插件吧。</p><ul><li>首先去 chrome 应用商店安装 LiveReload 扩展程序，之后设置允许访问文件网址；</li><li>接着在 sublime 中按 ctrl+shift+p 打开命令面板，并选择“Add Repository”，输入<code>https://github.com/NickWoodhams/LiveReload.Git</code> 并回车；</li><li>接着搜索 LiveReload 插件并安装，之后配置：<pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  <span class="token string">"enabled_plugins"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token string">"SimpleReloadPlugin"</span><span class="token punctuation">,</span>      <span class="token string">"SimpleRefresh"</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>保存并重启 sublime。正常打开文件，点击 chrome 右上角的相关插件开启热更新功能。</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>折腾博客系列之博客搭建：Hexo+Github pages</title>
      <link href="/2019/03/24/T-hexo+github%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3/"/>
      <url>/2019/03/24/T-hexo+github%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>初衷：之前我习惯用印象笔记进行知识的收集和整理，虽然很好用，但终归只适合输入而不适合输出。我需要的是一个更加开放的平台，在这上面可以输出： 1.<strong>学习的收获 ；2.生活的感想 ；3.有价值的分享</strong>，因此有了这个博客网站。</p><p>用hexo+github pages 可以很方便地搭建一个个人博客网站，不需要购买域名和服务器，只需要按部就班操作即可。我自己大概是花了两三个小时搞定，主要是因为对git bash的使用不够熟悉，因此走了一些弯路。实际上动作快的话半个小时就可以搞定。下面是对部署过程的大概介绍，以及<strong>必须注意的事项</strong>（划重点，也就是所谓的“坑”）。由于本文参考了大量博客，所以在文末我会列出原文链接。</p><a id="more"></a><h2 id="一-Github，Github-pages-，Hexo"><a href="#一-Github，Github-pages-，Hexo" class="headerlink" title="一.Github，Github pages ，Hexo"></a>一.Github，Github pages ，Hexo</h2><p>首先介绍一下这三个东西，有大概的了解、知道是什么东西就可以。GitHub是一个面向开源及私有软件项目的托管平台，而GIthub Pages则是github的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，现在大多用来开发和制作个人博客网站。它的好处在于域名和服务器都是免费提供的，并且没有网站数量的限制。而Hexo 是一个快速、简洁且高效的博客框架，它使用Markdown解析文章，在几秒内，就可以利用靓丽的主题生成静态网页。（关于Hexo的详细介绍，请看官方文档 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a> ，这里就不展开了）。因此，可以说github和hexo是绝配。接下来，开始我们的工作。</p><h2 id="二-环境和必要准备"><a href="#二-环境和必要准备" class="headerlink" title="二. 环境和必要准备"></a>二. 环境和必要准备</h2><p>我个人的环境：win10，64bit<br>必要准备：你需要<br><strong>（1）github账号</strong> ：前往<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> 官网注册就好<br><strong>（2）git</strong> ： 最新版本的git（本文发表的时候是2.20.1版本），前往<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 官网下载并安装。安装完后前往git文件夹下打开git bash，运行以下命令：</p><pre class="line-numbers language-js"><code class="language-js">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"username"</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"your mail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：将username替换为自己的github账号名，将your mail替换为自己注册github时绑定的邮箱。这一步非常重要，当时部署的时候我因为遗漏了这一步，导致后面报错.</p><p><strong>（3）node.js</strong> ： 前往 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载并安装。<br>这两个的安装比较简单，一路next就好，不过我推荐还是修改一下路径，尽量放在自己可以找到的位置。<br><strong>（4）hexo</strong> ：打开git文件夹下的git bash，运行 以下命令安装hexo</p><pre class="line-numbers language-js"><code class="language-js">npm install <span class="token operator">-</span>g hexo<span class="token operator">-</span>cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>依次运行以下命令进行hexo的初始化</p><pre class="line-numbers language-js"><code class="language-js">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ cd <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ npm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注：请将上面代码的<code>&lt;folder&gt;</code>替换成你自己想要的文件夹名字，以我为例，我想要在git文件夹下新建一个Myblog文件夹以存放站点文件，那么我这里的代码就应该是</p><pre class="line-numbers language-js"><code class="language-js">$ hexo init Myblog$ cd  Myblog$ npm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>成功之后，我们会在git文件夹下看到新建的Myblog文件夹，这个就是我们的站点文件夹，网站相关文件都存放在这里。<br>这里顺便介绍一下<code>cd Myblog</code>的作用，可以理解为“进入Myblog运行git bash”，你也可以在Myblog中右键运行git bash（如下图），效果是一样的。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%9AHexo%2BGithub%20pages/hexo%2Bgithub%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3-1.png" alt=""></p><p><strong>在之后介绍的操作中，凡是需要输入命令的，请确保你已经cd进自己的站点文件夹。</strong></p><p>接着上面的代码，我们继续运行：</p><pre class="line-numbers language-js"><code class="language-js">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将在本地打开我们的网站，当提示”xxx is running at xxx“的时候，我们可以通过<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 这个网址预览我们的网站，想要切断连接，只需要在命令行窗口按下ctrl+c。至此，hexo博客已经在本地搭建好了。接下来，我们要将hexo和github进行对接。</p><h2 id="三-hexo与github-实现对接"><a href="#三-hexo与github-实现对接" class="headerlink" title="三. hexo与github 实现对接"></a>三. hexo与github 实现对接</h2><p><strong>1.建立仓库</strong></p><p>还记得我们之前注册的github账号吗？现在，请进入github网站，并点击头像选择your repository，我们现在需要创建一个仓库（也就是repository）用于存放相关站点文件。按照下图顺序进行设置：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%9AHexo%2BGithub%20pages/hexo%2Bgithub%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3-2.png" alt=""><br>其中，Repository name也即是我们的仓库名字，必须是 Github账号名称.github.io的格式。比如你的github名字是ccc，那么仓库名字必须是ccc.github.io 。</p><p><strong>2.对接github</strong><br>在git bash中运行以下命令，安装 hexo-deployer-git 插件。</p><pre class="line-numbers language-js"><code class="language-js">npm install hexo<span class="token operator">-</span>deployer<span class="token operator">-</span>git <span class="token operator">--</span>save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行以下命令，创建SSH key。（注：和上面一样，请将your mail替换成github邮箱地址）</p><pre class="line-numbers language-js"><code class="language-js">$ ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"your mail"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前往 C:\Users\Administrator.ssh\id_rsa.pub （注意，这只是大概位置。不同系统路径可能不同，但是大同小异）打开id_rsa.pub文件（可以用记事本打开，但是推荐用sublime text）。复制文件中的全部内容，前往 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a> ，将刚才复制的内容粘贴在New SSH key 的文本框中。</p><p>前往站点目录下（例如：git/ Myblog），打开_config.yml 文件，对文件末尾进行如下修改：</p><pre class="line-numbers language-js"><code class="language-js"># Deployment## Docs<span class="token punctuation">:</span> https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>hexo<span class="token punctuation">.</span>io<span class="token operator">/</span>docs<span class="token operator">/</span>deployment<span class="token punctuation">.</span>htmldeploy<span class="token punctuation">:</span>    type<span class="token punctuation">:</span> git    repo<span class="token punctuation">:</span> git@github<span class="token punctuation">.</span>com<span class="token punctuation">:</span>username<span class="token operator">/</span>username<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span>git    branch<span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里要注意，1）所有的冒号距离右边的内容之间都有一个空格，如果没有空格，则修改是无效的。2）和前面一样，将usename替换成我们自己的github用户名 。 3）repo后面的地址，在旧版本的hexo中是http地址，但在新版本的hexo用的是ssh地址，<strong>我们统一用如上所示的ssh地址</strong>。有些博客由于没有进行更新，在说明这个问题的时候依然用的是http地址，造成了一定程度上的误导。</p><p>运行以下命令，对接并推送内容到github。</p><pre class="line-numbers language-js"><code class="language-js">$ hexo g$ hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>等待片刻，打开 https://&lt;Github账号名称&gt;.github.io （例如 <a href="https://ccc.github.io" target="_blank" rel="noopener">https://ccc.github.io</a> ) 即可进入你搭建好的个人博客网站了。当然，网站默认用的是landscape主题，比较难看，关于主题的美化和后期一些插件的添加，可以参考文章末尾贴出的链接。</p><p><strong>PS：</strong></p><p>这里顺便介绍一下常用的 hexo 命令：<br><code>hexo clean</code> ————————&gt;清除缓存文件和已生成的静态文件<br><code>hexo g</code> 或者 <code>hexo generate</code> ————————&gt;生成静态文件<br><code>hexo d</code> 或者<code>hexo deploy</code> ————————&gt;生成静态文件并部署到仓库<br><code>hexo s</code> 或者 <code>hexo server</code> —————————&gt;在本地打开网站</p><p>一般来说，在对网站进行修改后，我们可以先用hexo g和hexo s 在本地预览效果，如果效果符合预期的话再用hexo d 推送到 github。当然，可能会遇到本地打开和域名打开的效果不一致，这种情况下通常是因为 1. 没有用hexo clean 清除缓存 2. 没有清除浏览器缓存（ctrl+f5 ） 3.忘记用hexo d 将本地文件推送到github 4. 本地和线上的同步本身需要时间，所以上述方法如果无效，可以尝试等几分钟，再打开网站就正常显示了。</p><p>参考自：<br><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a><br><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>折腾博客系列之编辑工具的选择</title>
      <link href="/2019/03/24/To-%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/"/>
      <url>/2019/03/24/To-%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>Hexo是静态博客网站，必须先在本地编辑好md文件再推送到网站上去—md文件也就是所谓的用markdown语法编写内容的文件。“工欲善其事，必先利其器”，因此我们需要一个合适的markdown编辑工具，它必须具备以下特点：<br>1.可导出md文件到本地，并随时进行修改<br>2.可提供分屏预览，支持同步滚动和定位<br>3.启动时响应速度快，编辑时渲染速度快</p><p>以下是一些工具在markdown编写方面的优劣比较，可酌情进行选择。<br>（平台：windows）<br><a id="more"></a></p><h4 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h4><p>印象笔记自带markdown编辑器,如下图：<br><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/编辑工具的选择-1.png" alt=""></p><p>优点：提供分屏预览，无需直接编写md代码，只需点击按钮即可，操作方便<br>缺点：无法导出md文件到本地，这是它的致命缺点。</p><h4 id="sublime-text3"><a href="#sublime-text3" class="headerlink" title="sublime text3"></a>sublime text3</h4><p>优点：安装插件后可以提供分屏预览<br>缺点：预览效果极差，超出的文本内容无法自动换行显示，而是直接隐藏。如下图红框部分<br><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/编辑工具的选择-2.png" alt=""></p><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><p>优点：简洁美观<br>缺点：不提供分屏预览，md代码编辑完成后回车即自动渲染出文本来。（虽然它认为这是优点，很多人习惯的却是分屏）</p><h4 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h4><p>优点：提供分屏预览，有较多可拓展插件<br>缺点：响应速度极慢，编辑时明显感觉卡顿；软件过大，大概100多m；安装插件极其困难，失败率较高</p><h4 id="HexoEditor"><a href="#HexoEditor" class="headerlink" title="HexoEditor"></a>HexoEditor</h4><p>优点：简洁美观，提供分屏预览，图片插入方便<br>缺点：需要用npm指令下载安装，和Atom插件安装如出一辙，很容易卡死</p><h4 id="Hexo-admin"><a href="#Hexo-admin" class="headerlink" title="Hexo-admin"></a>Hexo-admin</h4><p>非工具。Hexo自带的博客后台管理，可以在web ui界面下进行编辑<br>优点：提供分屏预览<br>缺点：界面过于简陋，自定义程度较低，本地服务器必须一直开着才能使用</p><h4 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h4><p>这是这么多工具中我觉得体验最好的，本篇博客也是用vscode编写。<br>优点：提供分屏预览、同步滚动等；较多markdown插件和主题；启动速度快，使用流畅不卡顿，渲染速度很快<br>缺点：需要自己写md代码，不过鉴于md语法并不复杂，我觉得这个缺点完全可以忽略不计。<br><br></p><p><span style="background:#fffa7d">最后是博客编写方面的一点小tip：</span><br>原生markdown语法并不支持定义字体颜色和大小等样式，但是由于在hexo中，我们编写的md文件最后会生成对应的html文件，所以完全可以在编写的时候使用html语法，浏览器会自动解析并渲染文件中包含的标签等。比如，上面就可以通过将句子放在span标签中，再加上内联样式达到荧光高亮的效果。不止是样式，我们还可以用<code>&lt;br&gt;</code>标签实现换行,让每一段不至于太紧凑。（md中空格是会被合并的，这点和html一样）</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一下学期：The Start</title>
      <link href="/2019/03/23/T-%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20Start/"/>
      <url>/2019/03/23/T-%E5%A4%A7%E4%B8%80%E4%B8%8B%E5%AD%A6%E6%9C%9F%EF%BC%9AThe%20Start/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>1.英语<br>准备四级考试，重点是听力和写作；</p><p>2.前端</p><p>2.1. JS 重难点突破：</p><ul><li>培训视频（进阶系列）</li><li>SegmentFault上js进阶的相关文章。由于是js中的难点，并且在面试中出现比较多，所以慢慢来。打算是每周攻克一个或两个<br>【进阶1期】 调用堆栈<br>【进阶2期】 作用域闭包<br>【进阶3期】 this全面解析<br>【进阶4期】 深浅拷贝原理<br>【进阶5期】 原型Prototype<br>【进阶6期】 高阶函数<br>【进阶7期】 事件机制<br>【进阶8期】 Event Loop原理<br>【进阶9期】 Promise原理<br>【进阶10期】Async/Await原理<br>【进阶11期】防抖/节流原理<br>【进阶12期】模块化详解<br>【进阶13期】ES6重难点<br>【进阶14期】计算机网络概述<br>【进阶15期】浏览器渲染原理<a id="more"></a></li></ul><p>2.2.《js高程》的阅读：<br>之所以单独拎出这一点，因为这学期基本不可能读完这么厚的书。所以打算是在学习h5的时候同步阅读本书。</p><p>2.3. 找一个小项目做：<br>初步决定是面向对象的小游戏，也有可能是hexo的一个主题<br>主题已完成，接下来可能会探索一下小程序</p><p>2.4. 新东西：<br>html5+css3，了解新特性，重点放在css动画。如果有时间，就学习ajax和jq。jq不作为重点。</p><p>3.阅读<br>看两本历史相关的书，大概是以下其中两本：<br>中东问题：《奥斯曼帝国六百年》《穿越百年中东》《中东生死门》<br>以色列/犹太人：《我为何放弃做犹太人》《耶路撒冷异乡人》《我的一生》《我的应许之地》《以色列123》《爱与黑暗的故事》《犹太国》《犹太复国主义史》<br>巴勒斯坦：《最后的天空之后》<br>伊拉克：《搅动世界的伊拉克》<br>阿拉伯：《阿拉伯的劳伦斯》<br>战争回忆录：《南瓜花》</p><p>4.游戏<br>可能会把巫师3+dlc打通关，当然，前提是有时间。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏往事</title>
      <link href="/2019/03/18/G-%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/"/>
      <url>/2019/03/18/G-%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-8.png" alt=""></p><a id="more"></a><p>之前就说过这个博客不会纯记录自己的学习心得，而是会适当地聊聊自己的一些感想，其中当然也包括游戏。游戏被称为“第九艺术”，艺术自然不止是带给人娱乐感。</p><h4 id="gt-gt-2012年：《刺客信条II》"><a href="#gt-gt-2012年：《刺客信条II》" class="headerlink" title="&gt;&gt;2012年：《刺客信条II》"></a>&gt;&gt;2012年：《刺客信条II》</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-1.jpg" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-2.jpg" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-3.jpg" alt=""></p><p>译：</p><blockquote><p>当我年少轻狂时，我曾拥有自由，但我并不明白它的意义。<br>我曾拥有时间，但我没有意识到它的珍贵。<br>我曾拥有爱，但我从未用心去体会。<br>数十年的时间考验后，我终于理解了三者的真谛。<br>现在，我已风烛残年，这种理解已经逐渐变成一种满足。<br>爱，自由和时间，曾一度被我挥霍，而今成为了我前进的动力。<br>而我将最特别的爱，献给最亲爱的你和我们的孩子们，以及刺客联盟的兄弟姐妹们，<br>并献给赋予我们生命的那壮美奇妙，让人产生无限遐想的世界。<br>此爱永恒，Mia Sofia<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ——艾吉奥·奥迪托雷</p></blockquote><p>最早接触的游戏之一，有七年之久了。年代久远，写不下太多感慨性的文字，但是—-游戏里的场景还是记忆犹新：耶路撒冷、佛罗伦萨、罗马、君士坦丁堡……更重要的是Ezio这个人物给我留下了深刻的印象。我现在还觉得，能够在游戏中体验一个角色完整的一生是实属难得的事情。</p><h4 id="gt-gt-2013年：《刺客信条IV》"><a href="#gt-gt-2013年：《刺客信条IV》" class="headerlink" title="&gt;&gt;2013年：《刺客信条IV》"></a>&gt;&gt;2013年：《刺客信条IV》</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-4.jpg" alt=""><br><!--more--><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-5.jpg" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-6.jpg" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-7.jpg" alt=""></p><p>荡气回肠的加勒比海之旅以如此平静的方式结束。爱德华在最后摘下一朵红花送给女儿，这一幕在今天看来仍然美妙而浪漫，它带给我的视觉冲击力难以言说。</p><blockquote><p>“如果没有黄金，我们早就是英雄了”</p></blockquote><p>黑胡子的这句话也许是对那个航海时代最好的概括。爱德华最后得到了黄金、跻身上流贵族之列，然而代价之深重恐怕只有他自己清楚。</p><p>大概人总会有一种错觉，以为离去的人其实还活着。在安妮最后弹唱这首《The parting glass》的时候，爱德华恍惚之间仿佛看到昔日的朋友们正在与自己举杯共饮，片刻后才回过神，他们早就不在了。</p><p>“晚安，愿快乐与你们相伴”</p><blockquote><p>Of all the money that ere I had, I’ve spent it in good company,<br>过去我所有的积蓄，我都已和伙伴们一同分享<br>And of all the harm that ere I’ve done, alas was done to none but me.<br>而我做过的所有伤人之事，唉，受伤的只是我自己<br>And all I’ve done for want of wit, to memory now I cannot recall.<br>我为寻求智慧所做的一切，已成了不可追的回忆<br>So fill me the parting glass, goodnight and joy be with you all.<br>就为我添满这杯离别酒吧，晚安，愿快乐与你们常伴<br>Of all the comrades that ere I had, they’re sorry for my going away,<br>我所有的战友们，都不舍我即将离去<br>And of all the sweethearts that ere I’ve had , they wish me one more day to stay,<br>而我所有的情人们，都希望我多留一日<br>But since it falls unto my lot that I should rise and you should not,<br>但因为我深感起身之时已至 诸君安坐<br>I’ll gently rise and I’ll softly call, Goodnight and joy be with you all.<br>我会轻轻站起并柔声祝道，晚安，愿快乐与你们常伴<br>A man may drink and not be drunk,<br>一位男子大可畅饮但不该喝醉<br>A man may fight and may not be slain<br>一位男子大可战斗但不该嗜杀<br>A man may court a pretty girl<br>一位男子大可追求可爱的女孩<br>and perhaps be welcome back again.<br>而且或许还能欣然再相见<br>But since it has so ordered been by a time to rise<br>可是人生注定如此 有时起<br>And a time to fall<br>又有时落<br>Come fill to me the Parting glass, goodnight and joy be with<br>you all.<br>为我添满这杯离别酒，晚安，愿快乐与你们常伴<br>Come fill to me the Parting glass, goodnight and joy be with you all.<br>为我添满这杯离别酒，晚安，愿快乐与你们常伴</p></blockquote><h4 id="gt-gt-2019年：《巫师III》"><a href="#gt-gt-2019年：《巫师III》" class="headerlink" title="&gt;&gt;2019年：《巫师III》"></a>&gt;&gt;2019年：《巫师III》</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-11.png" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-10.png" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-9.png" alt=""></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B-8.png" alt=""></p><p>玩下来的一个感觉就是：满分佳作——-我是一个对游戏很挑剔的人，即使是玩了有5年之久的游戏，我也不会对其缺点避而不谈。但巫师这款游戏意外地推翻了我之前对于RPG游戏的固有认知，让我明白了这个世界上真的有一款RPG游戏近乎完美，从任何方面来看都无可挑剔。<br>比起传统的美式RPG游戏，在游玩过程中深有体会的一点就是：波兰人真的很会讲故事。他们为玩家呈现的不是大量中世纪传说的意象（比如烂大街的骑士和恶龙），而是真真正正底蕴丰厚的故事。或者愤慨，或者无奈，或者悲恸，玩家的情感爆发点仿佛尽在这群鬼才开发者的掌握之中，只等剧情走向的推动去点燃那小小的火苗。用一个老外很喜欢的词来形容再适合不过了—immersive，入味，而且是余韵不绝的那种。<br>游戏里的大部分对话选项都会影响剧情的走向和人物的最终结局，这是我非常喜欢的一点。我个人觉得，开放世界游戏的所谓“开放”，绝不仅仅局限于地图的规模和场景的互动性，更体现在剧情的丰富化。丰富多样的剧情比起单一的剧情，最大的优势就在于大幅度提高了游戏的可探索性，玩家不得不去考虑：如果我做另外一个选择，结果会是怎么样？不同的选择带来不同的后果，这种极具冒险性的尝试恰好像极了我们的现实生活。<br>人们向来喜欢拿《巫师》和《上古卷轴5：天际》进行对比，虽然在情感上我更偏向于后者（因为它对我而言不只是一款游戏），但不得不承认的是，《巫师》的战斗系统尤其值得后者借鉴：针对不同的敌人需要采用不同的打法、角色的技能提高需要玩家做出适当的取舍以找出效果最好的组合方案、魔法和药水需要紧密结合，你几乎不可能靠着单一的技能或者装备撑过整场战斗……总的来说系统设计非常流畅和舒服，而且值得玩家花时间去钻研，这在一定程度上也提高了可玩度。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Gaming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原型式继承和类式继承</title>
      <link href="/2019/03/17/F-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF%E5%92%8C%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/03/17/F-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF%E5%92%8C%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>Java和JavaScript都是面向对象的语言，但二者的继承方式截然不同。前者采用类式继承（classical inheritence），也是大多数面向对象语言的继承方式。而后者采用原型式继承（prototype ineritence），因此称JavaScript为基于对象更加合适。<br><a id="more"></a></p><h3 id="1-JavaScript的继承"><a href="#1-JavaScript的继承" class="headerlink" title="1.JavaScript的继承"></a>1.JavaScript的继承</h3><p>就JavaScript的继承来说，又可以分为es5的继承和es6的继承。参考阮一峰老师在《ES6标准入门》一书中所说的：</p><blockquote><p>在ES6之前，class是保留字，ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p></blockquote><p>虽然在es6中引入了类的概念，但它其实只是简化了原来需要我们自己编写的原型链代码的语法糖，从而让js更趋向于传统的面向对象语言而已。要理解这个过程，首先要明白es6中的class做了什么。</p><h4 id="1-1-class到底做了什么："><a href="#1-1-class到底做了什么：" class="headerlink" title="1.1 class到底做了什么："></a>1.1 class到底做了什么：</h4><ul><li>首先看看class是什么东西</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token keyword">typeof</span> Person   <span class="token comment" spellcheck="true">//  function </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里的class与java中的class不同，它并不是一个全新的数据类型，而是相当于原型继承中的构造函数。</p><ul><li>接着看看es5和es6在实现继承上的区别：</li></ul><p>es5：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//父类</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">SubPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 子类</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 子类继承父类的属性 需要将this指向父类中的name</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// job是子类的新增属性</span><span class="token punctuation">}</span>SubPerson<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 让子类继承父类的方法</span><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token string">'zcl'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//实例化子类对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// zcl（父类属性）</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// zcl（父类方法）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>es6：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">// 父类</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SubPerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//子类</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 用super来调用父类的构造函数</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// job是子类的新增属性</span>    <span class="token punctuation">}</span>    <span class="token function">showJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>job<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token string">'zcl'</span><span class="token punctuation">,</span><span class="token string">'前端开发'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例化子类对象</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// zcl（父类属性）</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// zcl（父类方法）</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前端开发（子类属性）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，es6中采用class后，大大简化了组合继承的步骤。</p><ul><li>class做了什么：</li></ul><p>1.定义父类时</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    constructor<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*constructor*/</span> <span class="token punctuation">}</span>    method<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*method*/</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等价于</span><span class="token keyword">function</span> Person<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*constructor*/</span><span class="token punctuation">}</span>Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>method<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*method*/</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.子类继承父类时：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">SubPerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    onstructor<span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">/*constructor*/</span>       <span class="token comment" spellcheck="true">//子类新增属性</span>         <span class="token punctuation">}</span>    method<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*method*/</span> <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//子类新增方法</span><span class="token punctuation">}</span><span class="token keyword">var</span> subperson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 等价于</span><span class="token keyword">function</span> SubPerson<span class="token punctuation">{</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">/*constructor*/</span>          <span class="token comment" spellcheck="true">//子类新增属性</span><span class="token punctuation">}</span>SubPerson<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>SubPerson<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>method<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*method*/</span>               <span class="token comment" spellcheck="true">//子类新增方法</span><span class="token punctuation">}</span><span class="token keyword">var</span> subperson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于es6继承而言，访问实例化的子类对象的属性或者方法时，依然是沿着原型链进行追溯，并且子类实例创建后，class SubPerson中的this依然会指向该子类，可以看出，这与es5的原型继承的一模一样的。</p><h4 id="1-2-关于this："><a href="#1-2-关于this：" class="headerlink" title="1.2 关于this："></a>1.2 关于this：</h4><p>es5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.call(this)）；es6的继承机制完全不同，实质是先通过调用super方法（super指向父类的构造函数）创造父类的实例对象this，然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加。</p><h3 id="2-Java的继承"><a href="#2-Java的继承" class="headerlink" title="2.Java的继承"></a>2.Java的继承</h3><p>首先了解java中创建对象的方式。java中，类一般包含field(变量)，constructor(构造方法)，method(其他方法)。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 创建父类</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//  field</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// method</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// constructor</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着实现继承</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SubPerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 创建子类</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// field</span>    <span class="token keyword">public</span> String <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// method</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SubPerson</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// constructor</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 通过super调用父类构造方法</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//重写父类方法，发生覆盖</span>        <span class="token keyword">return</span> <span class="token string">"I am not "</span><span class="token operator">+</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" but I am "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建测试类</p><pre class="line-numbers language-java"><code class="language-java">Public <span class="token keyword">class</span> <span class="token class-name">Testclass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Person person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"father"</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//通过new一个构造方法创建父类实例</span>        SubPerson subperson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token string">"son"</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// 创建子类实例</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subperson1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//->I am not father but I am son.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-JavaScript的原型式继承与Java的类式继承"><a href="#3-JavaScript的原型式继承与Java的类式继承" class="headerlink" title="3.JavaScript的原型式继承与Java的类式继承"></a>3.JavaScript的原型式继承与Java的类式继承</h3><p>由上面分析可见，es6中的类式继承其实还是原型式继承。那么它与java中真正的类式继承相比，有什么区别呢？</p><ul><li>类式继承的方法都会存在父对象之中，每一次实例，都会将funciton保存在内存中，这会带来性能上的问题。</li><li>类式继承是不可变的。在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法；相反，原型继承是可以通过改变原型链进而对子类进行修改的。</li><li>类式继承可以实现多重继承（Java是通过接口来实现）；原型式继承一般来说是不支持多继承的（因为原型链），但可以通过Mixin变相实现多继承。</li></ul><h3 id="4-补充：子类如何调用父类被覆盖的同名方法"><a href="#4-补充：子类如何调用父类被覆盖的同名方法" class="headerlink" title="4.补充：子类如何调用父类被覆盖的同名方法"></a>4.补充：子类如何调用父类被覆盖的同名方法</h3><p>首先这是一个比较奇怪的需求，因为既然子类重写了父类方法，就说明父类方法无法实现我们的要求，反过来，假设父类方法可以实现要求，则没必要重写该方法。但是让我们设想一下，假定现在一定要通过子类调用父类被覆盖的那个方法，应该怎么做呢？</p><p>通过上面的例子可以看到，在java中，我们只能在子类的构造方法中通过super关键字调用父类方法，而无法直接用子类的实例调用那个方法，像“子类实例.super.父类方法”，这是无效的；但是在js中，我们是可以做到的。基本思路就是：将父类实例以属性的方式进行保存，且该属性是子类构造函数的原型对象的属性。</p><p>这其实和原型链有关。我们设想有父类A、子类B以及同名方法say，并且设定子类B的原型对象的superClass属性指向父类实例b。那么，子类实例a直接调用say方法，必然是调用重写之后的方法；当它想要调用被覆盖的方法时，我们只需要用<code>a.superClass.say()</code>即可—–对于实例a，我们知道它本身并不具备superClass属性，因此它将沿着自己的原型对象也即子类B的原型对象进行查找，刚好B的原型对象有一个指向b的superClass属性，所以我们拿来用，而b有被覆盖的say方法，所以这里顺利完成了被覆盖方法的调用。</p><p><a href="https://blog.csdn.net/zhy416011189/article/details/50980016?utm_source=blogxgwz0" target="_blank" rel="noopener">附上CSDN的参考链接</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>经典面试题解析</title>
      <link href="/2019/03/17/F-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/03/17/F-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>本篇博客专门用于收集各类经典面试题，并给出相关的解题思路和原理。<br><a id="more"></a></p><h3 id="1-考点：块级作用域和闭包"><a href="#1-考点：块级作用域和闭包" class="headerlink" title="1.考点：块级作用域和闭包"></a>1.考点：块级作用域和闭包</h3><p>先看一道很经典的面试题</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>                     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你认为输出的是6，那么恭喜你答错了。正确答案是10。首先分析一下这段代码的具体执行过程。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 用var声明的变量要么在函数作用域中，要么在全局作用域中，很明显这里是在全局作用域中，因此认为i是全局变量，直接放在全局变量中。*/</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 关键！！这里之所以i为i而不是0；是因为我们只是定义了该函数，并未调用它，所以没有进入该函数执行环境，i当然不会沿着作用域链向上搜索找到自由变量i的值。*/</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 由于不具备块级作用域，所以该函数暴露在全局作用域中。</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//第二次循环，这时var i=1;覆盖了前面的var i=0；即现在全局变量i为1;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//解释同a[0]函数。</span><span class="token punctuation">}</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 第三次循环，这时var i=2;覆盖了前面的var i=1；即现在全局变量i为2;</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token operator">...</span>第四次循环 此时i<span class="token operator">=</span><span class="token number">3</span>  这个以及下面的i不断的覆盖前面的i，因为都在全局作用域中<span class="token operator">...</span><span class="token operator">...</span>第五次循环 此时i<span class="token operator">=</span><span class="token number">4</span><span class="token operator">...</span><span class="token operator">...</span>第六次循环 此时i<span class="token operator">=</span><span class="token number">5</span><span class="token operator">...</span><span class="token operator">...</span>第七次循环 此时i<span class="token operator">=</span><span class="token number">6</span><span class="token operator">...</span><span class="token operator">...</span>第八次循环 此时i<span class="token operator">=</span><span class="token number">7</span><span class="token operator">...</span><span class="token operator">...</span>第九次循环 此时i<span class="token operator">=</span><span class="token number">8</span>   <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这时i为10，因为不满足循环条件，所以停止循环。</span>紧接着在全局环境中继续向下执行。a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 这时调用a[6]函数，所以随即进入a[6]函数的执行上下文环境中，即function(){console.log(i)}中，此时执行函数中的代码console.log(i)，因为在当前的函数执行上下文中不存在变量i，所以i为自由变量，此时会沿着作用域链向上寻找，进而进入了全局作用域中寻找变量i,而全局作用域中的i在循环跑完后已经变成了10，所以a[6]的值就是10了。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么，如果我们想要输出6，应该怎么修改代码呢？两种方法。<br>1.使用let形成块级作用域，配合闭包使用</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//进入第一次循环</span>    <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/*注意：因为使用let使得for循环为块级作用域，此次let i=0    在这个块级作用域中，而不是在全局作用域中。*/</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 注意：由于是用let声明的i,所以使整个块成为块级作用域，又由于a[0]这个函数引用到了上一级作用域中的自由变量，所以a[0]就成了一个闭包。*/</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*声明:这里用｛｝表达并不符合语法，只是希望通过它来说明let存在时，这个for循环块是块级作用域，而不是全局作用域。*/</span>    讲道理，上面这是一个块级作用域，就像函数作用域一样，执行完毕，其中的变量会被销毁，但是因为这个块级作用域中存在一个闭包，且该闭包维持着对自由变量i的引用，所以在闭包被调用之前也就是后续为了测试而console<span class="token punctuation">.</span>log出a<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>之前，此次循环的自由变量i即<span class="token number">0</span>不会被销毁<span class="token punctuation">.</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//进入第二次循环</span>     <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*注意：进入第二次循环即进入第二个代码块，此时处于激活状态的是let i=1。     它位于与let i=0不同的块级作用域中，所以两者不会相互影响。*/</span>     a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同样，这个a[i]也是一个闭包</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token operator">...</span>进入第三次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第四次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第五次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第六次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第七次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第八次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token operator">...</span>进入第九次循环，此时其中<span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">;</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//进入第十次循环</span>    <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//同样，这个a[i]也是一个闭包</span><span class="token punctuation">}</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*不符合条件，不再向下执行，导致此次的块级作用域中不存在闭包，导致let i=10    未像前面的i一样等待被闭包引用，故此次的i没有必要继续存在，随即被销毁。*/</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*调用a[6]()函数，这时执行环境随即进入下面这个代码块中的执行环境：funcion(){console.log(i)};*/</span>即进入：<span class="token punctuation">{</span>      <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">;</span>      a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//同样，这个a[i]也是一个闭包</span><span class="token punctuation">}</span>a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span>函数（闭包）这个执行环境中，它会首先寻找该执行环境中是否存在 i，没有找到，就沿着作用域链继续向上到了函数所在的块级作用域，找到了自由变量i<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>于是输出了<span class="token number">6</span>，即a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的结果为<span class="token number">6</span>。闭包既已被调用，所以整个代码块中的变量i和函数a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>被销毁。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.利用自执行函数<br>说来惭愧，本来如果明白这道题的原理，应该自然想到可以利用自执行函数达到相同的目的，但是最后还是在群里朋友的点拨下才明白的。<br>实际很简单，前面我们说过一句很关键的话：</p><blockquote><p>这里之所以 i 为 i 而不是 0；是因为我们只是定义了该函数，并未调用它，所以没有进入该函数执行环境，i 当然不会沿着作用域链向上搜索找到自由变量 i 的值</p></blockquote><p>那么反过来想一想，假如我们在定义了函数之后即刻对其进行了调用，是否此时将会在环境中寻找 i 的值并马上替换掉 console.log(i) 中的 i 呢？是的。要立刻调用函数，用自执行函数就可以，代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>                     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这里每一次的循环实际上是对当前函数进行一次立即调用，所以在循环的同时对应的值就已经打印出来了，并且这些函数的返回值依次赋值给数组元素。在没有显式指定函数返回值时，默认返回 undefined，因此后续再访问数组元素时只能得到 undefined。</p><h3 id="2-考点：连等、解析和引用类型"><a href="#2-考点：连等、解析和引用类型" class="headerlink" title="2.考点：连等、解析和引用类型"></a>2.考点：连等、解析和引用类型</h3><p>这是某大厂一道知名的面试题，表面简单但是坑很多。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>a<span class="token punctuation">.</span>x <span class="token operator">=</span> a <span class="token operator">=</span><span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// {n:2}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们来分析一下这段代码到底是怎么执行的，就会明白为什么结果与我们预想的完全不同，甚至可以说很怪异。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先，这两句令a和b同时引用了{n:2}对象，接着的<code>a.x = a = {n：2}</code>是关键。尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的<code>{n:1}</code>对象新增了一个属性x，即此时对象将变为<code>{n:1;x:undefined}</code>。之后按正常情况，从右到左进行赋值，此时执行<code>a ={n:2}</code>的时候，a重定向，指向了新对象<code>{n：2}</code>,而b依然指向的是旧对象，这点是不变的。接着的关键来了：执行<code>a.x = {n：2}</code>的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为<code>{n：2}</code>，旧对象为 <code>{n:1;x:{n：2}}</code>，它被b引用着。<br>后面输出a.x的时候，又要解析a了，此时的a当然是重定向后的指向新对象的a，而这个新对象是没有x属性的，故得到undefined；而输出b.x的时候，将输出旧对象的x属性的值，即<code>{n:2}</code>。</p><h3 id="3-考点：异步、作用域、闭包"><a href="#3-考点：异步、作用域、闭包" class="headerlink" title="3.考点：异步、作用域、闭包"></a>3.考点：异步、作用域、闭包</h3><p>如果无法深入到内部，从原理层面上理解代码的运行机制，那么知识只是浮在表面、浅尝辄止。“同步优先，异步靠边，回调垫底”的口诀可以帮助我们迅速判断，但是我希望用自己刚学习的事件循环机制来解释这道题。<br>实际上这也是比较普遍的一道面试题：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 代码最后输出什么？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不熟悉异步，很可能直截了当地回答是：<code>0 0 1 1 2 2</code> 。<br>正确答案应该是 <code>0 1 2 3 3 3</code><br>根据事件循环的机制，跑循环和输出i的值都是主线程上的同步任务，既然是同步任务，当然是按照顺序执行，所以<code>0 1 2</code>是容易理解的。那么setTimeout怎么办呢？setTimeout是异步任务，并不在主线程上，而是在宏任务队列里，它必须等待主线程的执行栈清空，才有自己的“一席之地”，才能去执行，所以这里我们直接忽略setTimeout，将前三次循环的setTimeout都挂在任务队列里。之后，循环跑完了，主线程的同步任务结束。此时i变成了3。<br>轮到任务队列了——&gt; 我们回过头调用setTimeout里的回调函数，进行i的输出。当然，由于i只有一个，即全局变量，所以此时输出的都是3，三次setTimeout即三次3。</p><p>如果我们要输出 <code>0 1 2 0 1 2</code> 呢？<br>其实这里就和第一个考点很像了。这里有三种方法，</p><p>1.将var改为let<br>改为 let 后会形成多个独立的块级作用域，这样，每个setTimeout里的回调函数的i都将对应每一次循环的i（因为是块级作用域）。接着，由于输出和循环依然是同步任务，所以输出 <code>0 1 2</code>；之后轮到任务队列，也是输出<code>0 1 2</code>。</p><p>2.利用自执行函数<br>让函数在定义之后就即刻执行，那么函数中的 i 就会指向当前循环的 i，这个 i 的值为多少在那时就已经确定了，而不再是随着跑循环而动态变化。这里又有两种自执行的方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个是将回调函数作为自执行函数，一个是将setTimeout函数作为自执行函数，效果是一样的。</p><p>3.利用<code>bind()</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>bind()</code> 的第一个参数是 thisArg，用来绑定 this，这里我们不管，直接传参 null，重点在于第二个参数，这个参数也就是回调函数的参数。这里要理解循环做了什么：每一次循环，实际上执行的是 <code>setTimeout()</code> 方法，执行完之后把每次的回调函数挂载在队列里，后续等主任务清空之后，再一一执行。这里添加了 <code>bind()</code> 方法后，每次循环除了挂载回调函数，其实还完成了硬绑定，这时候对应的 i 值已经存在于回调函数的词法作用域里了。所以，后面执行回调函数的时候，每个函数都能在词法作用域中找到自己对应的 i 值。</p><h3 id="4-考点：作用域、NFE的函数名只读性"><a href="#4-考点：作用域、NFE的函数名只读性" class="headerlink" title="4.考点：作用域、NFE的函数名只读性"></a>4.考点：作用域、NFE的函数名只读性</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    b<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 代码最后输出什么？</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有认识到NFE函数的函数名只读性，这道题就会做错。正确答案应该是：</p><pre class="line-numbers language-js"><code class="language-js">f <span class="token punctuation">{</span>    b<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要理解这道题，先来看另一段代码</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> c<span class="token operator">=</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// b is no defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，这是一个具名函数表达式，即NFE。而NFE的函数名只能在函数内部访问，所以我们将该函数的引用赋给变量c之后，就只能通过c()调用该函数，而不能通过b()调用，更不能访问b。并且还要注意，函数名在函数内部类似于一个const常量，只能访问而不能对它进行修改。</p><p>理解这一点之后再来看最开始的代码，这是一段IIFE—–立即执行函数表达式（因为括号是操作符，所以认为括号里的是表达式而不是声明），它同样也是具名函数表达式，自然也有上面的性质。函数自调用，遇到<code>b=20</code>语句时开始在函数作用域中查找b是在哪里声明的，结果发现就是函数b，然后试图对函数名进行修改，因为这种修改相当于是修改一个常量，所以是无效的（非严格模式下静默失败，严格模式下抛出Type错误）。忽略了这段语句后，等于是只输出b，也就是输出函数本身。之后，我们在全局下输出b，根据上面的说法，我们无法在NFE函数外部访问NFE的函数名，所以这里的b代表的不是函数，而是用let声明的那个变量b。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> b<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，如果在函数内部用var或者let重新声明一个同名变量b并赋值，则是允许的，此时的b变量与函数b没有任何关系，仅仅是同名而已。<br>PS：NFE 函数名为什么是只读的？规范有说吗？还真有，看下面：</p><blockquote><p>The production<br>FunctionExpression : function Identifier ( FormalParameterListopt ) { FunctionBody }<br>is evaluated as follows:<br>1.Let funcEnv be the result of calling NewDeclarativeEnvironment passing the running execution context’s Lexical Environment as the argument<br>2.Let envRec be funcEnv’s environment record.<br>3.Call the CreateImmutableBinding concrete method of envRec passing the String value of Identifier as the argument.<br>4.Let closure be the result of creating a new Function object as specified in 13.2 with parameters specified by FormalParameterListopt and body specified by FunctionBody. Pass in funcEnv as the Scope. Pass in true as the Strict flag if the FunctionExpression is contained in strict code or if its FunctionBody is strict code.<br>5.Call the InitializeImmutableBinding concrete method of envRec passing the String value of Identifier and closure as the arguments.<br>6.Return closure.</p></blockquote><blockquote><p>NOTE The Identifier in a FunctionExpression can be referenced from inside the FunctionExpression’s FunctionBody to allow the function to call itself recursively. However, unlike in a FunctionDeclaration, the Identifier in a FunctionExpression cannot be referenced from and does not affect the scope enclosing the FunctionExpression.</p></blockquote><p>重点就在第三和第五的 ImmutableBinding，注意这是一个不可变的绑定。<br>关于这道题的详细解释，移步：<br><a href="https://segmentfault.com/q/1010000002810093" target="_blank" rel="noopener">https://segmentfault.com/q/1010000002810093</a></p><h3 id="5-this-绑定"><a href="#5-this-绑定" class="headerlink" title="5. this 绑定"></a>5. this 绑定</h3><p>某不知来源的面试题一道：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">const</span> a<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> b<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> c<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>globalThis<span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出什么？</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确答案是：</p><pre class="line-numbers language-js"><code class="language-js">windowwindowwindow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这道题的难点在于，<code>forEach()</code> 的 <code>thisArg</code> 指定了回调的 this，而回调本身也有一个 <code>bind()</code> 方法指定 this，那么应该以哪个为准呢？在<a href="https://chorer.github.io/2019/04/17/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A/">这篇文章</a>中曾经讨论过 this 绑定的问题，但是 <code>forEach()</code> 的 this 绑定好像并不符合文章里面的情况。不妨看一下 <code>forEach()</code> 的 <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/forEach" target="_blank" rel="noopener">polyfill</a> 代码：</p><blockquote><p>A polyfill is a piece of code (usually JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it.</p></blockquote><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90-1.jpg" alt=""></p><p>也就是说，<code>forEach()</code> 绑定 this 实际上也是通过 <code>call()</code> 实现的。<br>接下来再来看一下 <code>bind()</code> 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">polyfill</a> 代码：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90-2.jpg" alt=""></p><p><code>bind()</code> 实际上也是通过 <code>apply()</code> 实现的 —— 原理就是返回一个包装函数，这个函数在内部对初始函数完成了 this binding。之后不管怎么调用这个包装函数，this 都是使用 <code>bind()</code> 的thisArg。也就是说，即使是：</p><pre class="line-numbers language-js"><code class="language-js">func<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>func 中的 this 最后也是指向 obj1 而不是 obj2，原因在于 <code>func.bind(obj1)</code> 是一个返回的包装函数，内部的 this 是没有暴露出来的，看上去就像是一个没有 this 的函数，因此后面的 <code>bind(obj2)</code> 对其不生效。这也是为什么说 <code>bind()</code> 是 tight binding 的原因，一旦绑定就很难再改变。<br>理解这一点之后，再来看上面的题就简单了。题目的代码我们可以简化为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> f0 <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">const</span> f1 <span class="token operator">=</span> f0<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>globalThis<span class="token punctuation">)</span>a<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>f0 是初始函数，f1 是包装函数。那么在 forEach 进行迭代的时候，虽然指定了 this 是参数 b，但是由于此时的 f1 是一个内部完成了 this binding 的包装函数，因此其实已经没有 this 什么事了，自然 forEach 的 thisArg 也不生效。既然是 <code>bind()</code> 生效，那么结果自然是输出全局对象了。<br>Tip: 下次思考问题的时候，polyfill 可以作为一个着手方向。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Stack Overflow 规范提问</title>
      <link href="/2019/03/17/T-Stack%20Overflow%E6%8F%90%E9%97%AE%E6%8C%87%E5%8D%97%E5%92%8C%E5%BF%85%E5%A4%87%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB/"/>
      <url>/2019/03/17/T-Stack%20Overflow%E6%8F%90%E9%97%AE%E6%8C%87%E5%8D%97%E5%92%8C%E5%BF%85%E5%A4%87%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%A6%82%E4%BD%95%E5%9C%A8Stack%20Overflow%E8%A7%84%E8%8C%83%E6%8F%90%E9%97%AE/T-Stack%20Overflow%E6%8F%90%E9%97%AE%E6%8C%87%E5%8D%97%E5%92%8C%E5%BF%85%E5%A4%87%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB-1.jpg" alt=""><br><a id="more"></a></p><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>最近学习js的时候看到了一段代码，思考再三之后仍然不是很理解，于是决定到尽可能多的平台进行提问，目的有二：1.最主要的，解决问题；2.借这个机会测试哪些平台可以在短时间内给予提问者反馈和援助，从而作为下次提问的首选之地。最后问题是解决了，但是关于提问这件事再次有了不一样的感想。</p><p>首先从我自身出发—-在中文环境下我能够做到比较规范的提问（我认为的规范），即</p><ul><li>表诉清晰</li><li>必要的答谢</li></ul><p>但是在英文环境下就显得吃力得多，暴露的缺点如下：</p><ul><li>表达不够地道清晰，误导了回答者，导致问题被认为是duplicate而被关闭</li><li>编辑问题后未进行必要的核查，导致了后期的修改</li><li>无法完全理解对方想要表达的意思</li></ul><p>其次从平台出发进行分析，不得不说国内的平台反馈速度和热情的确比不上国外的。知乎因为有邀请机制，所以问题还是有机会得到高手的点拨；SegmentFault本身定位就是中国的Stack Overflow，所以得到专业回答的可能性也比较大。<br>但是类似贴吧和QQ群这些交流平台，得到有效回答的机率却实在太低。本来QQ群是实时互动的，反馈更应该迅速点，但是很多时候问题会被忽略。是什么原因我就不说了，不好直接下定论，但这无疑提示了我：如果急着解决问题，就应该避免在这些地方浪费时间—-一来速度没保障，二来质量参差不齐。</p><p>理想的提问平台应该是SegmentFault或者Stack Overflow。关于如何在Stack Overflow规范提问，这里转载一篇不错的博客：</p><h1 id="规范提问指南"><a href="#规范提问指南" class="headerlink" title="规范提问指南"></a>规范提问指南</h1><hr><h2 id="可以问什么样的主题"><a href="#可以问什么样的主题" class="headerlink" title="可以问什么样的主题"></a>可以问什么样的主题</h2><p>大家都知道 Stack Overflow是编程类的问答社区， 但还真有人把它当成通用的问答社区了， 问些完全无关的问题。 其实， Stack Overflow 是有一系列兄弟网站的（目前已经有100+)， 统称 Stack Exchange， 涵盖很多主题， 比如数学、物理、化学等科学类， 服务器管理、Latex、数据库等计算机类， 中文、俄文、日文等语言类， 详细的列表看这里， 不要让好问题问错地方哦。</p><p>允许的主题包括： 具体的编程问题、软件算法相关、通常只有程序员用的软件工具相关等。</p><p>有些主题是比较容易弄错的， 比如一般的电脑操作问题， 应该去Super User(热门的 Linux/Unix, 和Ubuntu还有独立的站点）， 专业的服务器问题， 应该去Server Fault。这些都不属于编程类的问题， 尽管不少程序员的日常工作也有涉及（想一想“怎么修电脑？”属于编程问题么）。 再举个例子， 同样是编辑器， Vim/Emacs/Atom相关的问题是可以的，因为基本只有程序员会用这些工具， 而 Word/记事本相关的一般就不可以。</p><h2 id="什么样的问题应该避免问"><a href="#什么样的问题应该避免问" class="headerlink" title="什么样的问题应该避免问"></a>什么样的问题应该避免问</h2><p>编程相关还不够， Stack Overflow 要求问题必须是 <strong>「practical, answerable questions based on actual problems that you face」</strong>。</p><p>这是什么意思呢？ 首先， 开放式的问题是不允许的，比如“你为什么喜欢PHP?”， 隔壁Quora会是更合适的对象。 其次， 问题应该不需要很长的篇幅来回答， 如果一个问题期待的回答足够写一本书， 那很可能会被关闭的。 各种寻求资源的问题应该避免，如 “要完成某某工作， 有什么Python的库可以用”， 或者“学习C++应该选择哪本书？”等， 因为答案会主观， 也容易吸引广告。 最后， 问题不要基于凭空的假设，要基于实际的难题。</p><p>需要注意的是，你很可能见过一些违反上面规定的问题还在，而且浏览量很大， 尤其是一些寻求资源的问题， 和非编程相关的计算机问题等。 这是什么原因呢？ 原来，早期的Stack Overflow的规则还比较松，也没有Super User之类的站点。 这些问题往往是08/09年问的，大多数现在已经被关闭了。</p><p>上面的规则如果遵守， 你的问题应该问对地方了。 下面继续说说内容上具体需要注意的。</p><h2 id="直入主题"><a href="#直入主题" class="headerlink" title="直入主题"></a>直入主题</h2><p>Stack Overflow不是论坛， 它的目标是希望成为编程类问答的一个超级数据库， 所以每个问题都不止是为了帮助提问者本人， 更重要的是希望将来能够帮助到每一个遇到同样问题的人。</p><p>所以， 和问题无关的内容都被认为是一种噪音， 包括： 打招呼（比如 Hi, Hello， Good afternoon， Dear Coders等)， 表示感谢（比如 Thanks, Any help would be appreciated等)， 没必要的背景（比如 I’m a newbie in C#等)， 你的签名 等。<br>可能有人会不理解为什么这样规定， 尤其是不要表示感谢这点。 Stack Overflow社区的理由是， 对愿意阅读并尝试解答你问题的人来说， 最好的表达感谢的方式是upvote有帮助的回答， 以及选择其中一个作为答案。 每一句和问题无关的内容都增加了额外的阅读时间， 而一个问题可能会被大量的人阅读。 更多的相关讨论可以参见这里和这里。</p><p>同样道理， 当有人回答你的问题之后， 也不要去添加无用的评论， 比如单纯的表达感谢的话， “+1”， 或者闲聊等。 评论的唯一用处是用来澄清疑问。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>作为一个英语社区， 不论提问、回答还是在评论中和别人互动， 都是要用英语的。</p><p>除非英语水平真的很糟糕， 语法其实并不是最需要担心的，因为并不需要做到完美。Stack Overflow是允许自由的编辑其他人的问题/回答的（编辑者如果rep不到2K，需要经过评审才会生效）。 有很多人会热情的对问题进行编辑的， 包括修复可能的语法错误。 我想说的一点是， 要尽可能的保证单词拼写是正确的。 即使对英语不够好的人来说， 这也只需要多花一点时间检查就可以做到， 但它代表着对阅读你问题的人的尊重。 甚至很多英语母语的人在拼写上也不注意， 会把I’m 写成im, 把 want to写成 wanna之类的非正式英语， 这些都会降低问题被回答的概率。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>在发问题之前， 问自己几个问题：</p><ul><li>你做过足够的研究么？ 有的人连入门指南都没读上10分钟就去提问， 问的问题能有多少价值呢？</li><li>你尝试过搜索么？ 至少要试过Google和站内搜索， 很可能相同的问题已经有答案了</li><li>你试过debug么？ 把你的想法或调试过程写在问题里，否则很可能会看到几条评论“Have you tried anything?”或“We don’t do your homework”之后问题就被downvote得惨不忍睹了。 因为大多数人是拒绝回答没有努力尝试的提问者的。</li></ul><p><strong>标签</strong>： 一个问题可以加1~5个标签， 大多数问题是和某种具体的编程语言相关的， 这个语言的标签通常是必须的， 否则相关语言的关注者们很可能根本见不到问题。</p><p><strong>起一个好标题</strong>： 一般来说， 标题应该尽量用简介的语言描述具体的问题。 比如 C# number confusion就是个反例， 如果改成 Why does using float instead of int give me different results when all of my inputs are integers? 就要具体多了。</p><h2 id="提供代码"><a href="#提供代码" class="headerlink" title="提供代码"></a>提供代码</h2><p>对于编程类问题，的确有问题不需要代码也能表达清楚的， 但大多数问题都需要代码才能清晰的表达。“我声明了一个变量， 调用了几个函数， 然后它的值就变了， 为什么呢？” 这样的问题， 鬼才知道答案。</p><p>提供代码要注意： 不要贴截图， 难道你要回答者去照着截图敲键盘复现你的问题？ 也不要只贴站外的链接， 如果站外链接能够提供一些额外的方便功能， 也要在贴代码的基础上附上该链接。</p><p>对于提供什么样的代码， Stack Overflow给出了一个可参考的标准： MCVE， 即Minimal, Complete, and Verifiable example</p><ul><li>Minimal: 最小的， 也就是尽可能的去掉和问题无关的部分。 如果你贴了一个几百行的代码， 很少有人愿意花时间去仔细看。 构造最小化例子的过程本身也是debug的过程。</li><li>Complete: 完整的， 一个简单的判断是：别人看到问题， 可以通过复制你提供的代码复现出问题吗？</li><li>Verifiable: 可验证， 描述问题尽可能具体， “the code doesn’t work”这样的描述就很不好。 如果编译不过， 要加上编译错误信息； 如果运行报错， 也同样要加上具体的错误信息； 如果结果和你的预期不一致， 要说清楚你的预期结果是什么， 为什么会这样想。</li></ul><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>Stack Overflow的编辑器是Markdown格式的， 如果你还不熟悉， 建议去学一下， 因为Markdown真的是一个只要10分钟就可以学会的语言。</p><p>大多数的格式问题都是出在贴代码的地方， 如果你发现你的代码是普通文本， 而没有语法高亮等功能， 那你很可能是格式搞错了。 最方便的方法就是选择所有代码， 然后按键盘Ctrl + K 即可。</p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>有可能你的问题几分钟内就会有人回答， 也有可能有人对问题有疑问， 在评论中要求你解释。 可以评论@他们解释， 如果问题确实不够清晰， 编辑你的问题吧。 最后， 如果你自己发现了解答方法， 而还没人给出， 那就自己回答自己的问题吧。 自问自答是被鼓励的行为。</p><h1 id="术语词汇"><a href="#术语词汇" class="headerlink" title="术语词汇"></a>术语词汇</h1><p>另外，我认为规范提问建立在规范词汇的基础上，诚如上面所说的，这是一种对回答者应有的尊重。如何积累规范的词汇？我的计划是<del>每周阅读1到2篇MDN上的文档，首先阅读英文并做出自己的理解，之后借助本地化团队的译文加深/修正自己的理解，这个过程既锻炼了阅读技术文档的能力，也可以顺带积累术语词汇，值得尝试</del>。</p><p>2019.5.3 更：</p><p>近期找到了一个更好的平台（掘金翻译计划），它拥有完善的流程把控和工作分配，这其实正是我很久以前试图在汉化工作中寻找但是没有找到的东西。其实这是一件值得长期投资的事情：</p><p>1.最主要的目的，锻炼阅读英文技术文档的能力，同时积累术语词汇；<br>2.熟悉 github 的操作<br>3.据说 200 积分可以换一台kindle（虽然听起来遥遥无期，但是可以作为动力哈哈哈）</p><p>当然，这个工作不会很轻松，不过完事开头难是很正常的，希望我可以坚持下去吧。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础系列：伪类和伪元素</title>
      <link href="/2019/03/10/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
      <url>/2019/03/10/F-CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><h3 id="1-伪类和伪元素的引入"><a href="#1-伪类和伪元素的引入" class="headerlink" title="1.伪类和伪元素的引入"></a>1.伪类和伪元素的引入</h3><blockquote><p>CSS introduces the concepts of pseudo-elements and pseudo-classes to permit formatting based on information that lies outside the document tree.</p></blockquote><p>CSS 引入伪类和伪元素的概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。<br><a id="more"></a></p><h3 id="2-伪类和伪元素的概念"><a href="#2-伪类和伪元素的概念" class="headerlink" title="2.伪类和伪元素的概念"></a>2.伪类和伪元素的概念</h3><h4 id="2-1-伪类："><a href="#2-1-伪类：" class="headerlink" title="2.1 伪类："></a>2.1 伪类：</h4><blockquote><p>伪类用于当已有元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。</p></blockquote><p>例如，当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态。虽然它和普通的 CSS 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p><h4 id="2-2-伪元素"><a href="#2-2-伪元素" class="headerlink" title="2.2 伪元素"></a>2.2 伪元素</h4><blockquote><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。</p></blockquote><p>例如，我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><h3 id="3-伪类列举"><a href="#3-伪类列举" class="headerlink" title="3.伪类列举"></a>3.伪类列举</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0-1.png" alt=""></p><h4 id="3-1-状态伪类"><a href="#3-1-状态伪类" class="headerlink" title="3.1 状态伪类"></a>3.1 状态伪类</h4><p>状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式就会失去。状态伪类的顺序很重要，顺序错误可能会导致没有效果。通常的建议是<span style="background-color:#fffa7d">LVFHA</span>，即—–link，visited，focus，hover，active。</p><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:link</td><td>a:link</td><td>选择所有未访问的链接</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有访问过的链接</td></tr><tr><td>:hover</td><td>a:hover</td><td>选择鼠标悬空的链接</td></tr><tr><td>:active</td><td>a:active</td><td>选择正在活动的链接</td></tr><tr><td>:focus</td><td>input:focus</td><td>选择获得焦点的输入框</td></tr></tbody></table><h4 id="3-2-结构化伪类"><a href="#3-2-结构化伪类" class="headerlink" title="3.2 结构化伪类"></a>3.2 结构化伪类</h4><p>结构化伪类是 CSS3 新增选择器，利用 DOM 树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少 class 和 id 属性的定义，使文档结构更简洁。</p><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:first-child</td><td>p:first-child</td><td>选择符合的p元素，该p元素必须是其父元素的第一个子元素</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择符合的p元素，该p元素必须是其父元素的第一个p子元素</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>选择符合的p元素，该p元素必须是其父元素的最后一个子元素</td></tr><tr><td>:last-of-type</td><td>p:last-of-type</td><td>选择符合的p元素，该p元素必须是其父元素的最后一个p子元素</td></tr><tr><td>:not(selector)</td><td>:not(p)</td><td>选择所有p以外的元素</td></tr><tr><td>:nth-child(n)</td><td>p:nth-child(2)</td><td>选择符合的p元素，该p元素必须是其父元素的第2个子元素</td></tr><tr><td>:nth-last-child(n)</td><td>p:nth-last-child(2)</td><td>选择符合的p元素，该p元素必须是其父元素的倒数第2个子元素</td></tr><tr><td>:nth-last-of-type(n)</td><td>p:nth-last-of-type(2)</td><td>选择符合的p元素，该p元素必须是其父元素的倒数第2个p子元素</td></tr><tr><td>:nth-of-type(n)</td><td>p:nth-of-type(2)</td><td>选择符合的p元素，该p元素必须是其父元素的第2个p子元素</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择符合的p元素，该p元素的父元素可以有多个子元素，但是类型为p的子元素只有一个</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择符合的p元素，该p元素的父元素只有一个子元素，就是该p元素</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动#news元素(点击URL包含锚的名字)</td></tr></tbody></table><h4 id="3-3-表单相关"><a href="#3-3-表单相关" class="headerlink" title="3.3 表单相关"></a>3.3 表单相关</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:disabled</td><td>input:disabled</td><td>选择所有禁用的表单元素</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择没有设置disabled属性的表单元素</td></tr><tr><td>:in-range</td><td>input:in-range</td><td>选择在指定区域内的表单元素</td></tr><tr><td>:out-of-range</td><td>input:out-of-range</td><td>选择不在指定区域内的表单元素</td></tr><tr><td>:valid</td><td>input:valid</td><td>选择条件验证正确的表单元素</td></tr><tr><td>:invalid</td><td>input:invalid</td><td>选择条件验证错误的表单元素</td></tr><tr><td>:required</td><td>input:required</td><td>选择设置required属性的表单元素</td></tr><tr><td>:optional</td><td>input:optional</td><td>选择没有required属性，即设置 optional属性的表单元素</td></tr><tr><td>:read-only</td><td>input:read-only</td><td>选择设置只读属性的表单元素</td></tr><tr><td>:read-write</td><td>input:read-write</td><td>选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态</td></tr><tr><td>:checked</td><td>input:checked</td><td>匹配勾选的input元素，input元素包括 radio 和 checkbox</td></tr><tr><td>:empty</td><td>p:empty</td><td>匹配所有没有子元素的 p 元素</td></tr><tr><td>:default</td><td></td><td>匹配默认选中的元素(提交按钮总是表单的默认按钮)</td></tr><tr><td>:indeterminate</td><td></td><td>当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。</td></tr><tr><td>:scope</td><td></td><td>匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。(试验阶段)</td></tr></tbody></table><h4 id="3-4-语言相关"><a href="#3-4-语言相关" class="headerlink" title="3.4 语言相关"></a>3.4 语言相关</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:lang(language)</td><td>匹配设置了特定语言的元素</td><td>设置特定语言可以是：HTML元素设置lang=” “属性，meta元素设置charset=” “属性，或者是在 http头部上设置语言属性。实际上，lang=” “ 属性不只可以在 html 标签上设置，也可以在其他的元素上设置。</td></tr><tr><td>:dir</td><td>匹配指定阅读方向的元素。</td><td>当 HTML 元素中设置了 dir 属性时该伪类才能生效。现时支持的阅读方向有两种：ltr（从左往右）和 rtl（从右往左）。目前，只有火狐浏览器支持 :dir 伪类，并在火狐浏览器中使用时需要添加前缀( -moz-dir() )(试验阶段)。</td></tr></tbody></table><h4 id="3-5-其他"><a href="#3-5-其他" class="headerlink" title="3.5 其他"></a>3.5 其他</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>:root</td><td>匹配文档的根元素</td><td>一般的 html 文件的根元素是 html 元素。</td></tr><tr><td>:fullscreen</td><td>匹配处于全屏模式下的元素</td><td>全屏模式不是通过按 F11 来打开的全屏模式，而是通过 Javascript 的 Fullscreen API 来打开的，不同的浏览器有不同的 Fullscreen API。目前，:fullscreen 需要添加前缀才能使用。</td></tr></tbody></table><p><strong>！！注意，伪类的名称不区分大小写。</strong></p><h3 id="4-伪元素列举"><a href="#4-伪元素列举" class="headerlink" title="4 伪元素列举"></a>4 伪元素列举</h3><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0-2.png" alt=""></p><h4 id="4-1-单双冒号"><a href="#4-1-单双冒号" class="headerlink" title="4.1 单双冒号"></a>4.1 单双冒号</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>::before/:before</td><td>在被选元素前插入内容</td><td>需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。</td></tr><tr><td>::after/:after</td><td>在被选元素后插入内容</td><td>用法同上</td></tr><tr><td>::first-letter/:first-letter</td><td>匹配元素中文本的首字母</td><td>被修饰的字母不在首字母中</td></tr><tr><td>::first-line/:first-line</td><td>匹配元素中第一行的文本</td><td>这个伪元素只能用在块元素中，不能用在内联元素中</td></tr></tbody></table><h4 id="4-1-仅双冒号"><a href="#4-1-仅双冒号" class="headerlink" title="4.1 仅双冒号"></a>4.1 仅双冒号</h4><table><thead><tr><th>选择器</th><th>示例</th><th>示例说明</th></tr></thead><tbody><tr><td>::selection</td><td>匹配被用户选中或者处于高亮状态的部分</td><td>在FF浏览器使用时需要添加 -moz 前缀</td></tr><tr><td>::placeholder</td><td>匹配占位符的文本</td><td>只有元素设置placeholder 属性时，该伪元素才能生效。该伪元素不是 CSS 的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（IE10 和 Firefox18 及其以下版本）会使用单冒号的形式</td></tr><tr><td>::backdrop</td><td>用于改变全屏模式下的背景颜色</td><td>全屏模式的默认颜色为黑色。(试验阶段)</td></tr></tbody></table><h3 id="5-first-child和-first-of-type的区别"><a href="#5-first-child和-first-of-type的区别" class="headerlink" title="5. :first-child和:first-of-type的区别"></a>5. :first-child和:first-of-type的区别</h3><p>:first-child选择器是css2中定义的选择器，从字面意思上来看也很好理解，就是第一个子元素。比如有段代码：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0-3.png" alt=""></p><p><span style="color:red">p:first-child:</span> 匹配到的是p元素,因为p元素是div的第一个子元素；<br><span style="color:red">h1:first-child:</span> 匹配不到任何元素，因为在这里h1是div的第二个子元素，而不是第一个；<br><span style="color:red">span:first-child:</span> 匹配不到任何元素，因为在这里两个span元素都不是div的第一个子元素；<br><span style="color:red">:first-child:</span> 匹配到的是p元素,因为在这里div的第一个子元素就是p。</p><p>然后，在css3中又定义了:first-of-type这个选择器，这个跟:first-child有什么区别呢？还是看那段代码：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/CSS%20%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0-4.png" alt=""></p><p><span style="color:red">p:first-of-type:</span> 匹配到的是p元素,因为p是div的所有为p的子元素中的第一个，事实上这里也只有一个为p的子元素；<br><span style="color:red">h1:first-of-type:</span> 匹配到的是h1元素，因为h1是div的所有为h1的子元素中的第一个，事实上这里也只有一个为h1的子元素；<br><span style="color:red">span:first-of-type:</span> 匹配到的是第三个子元素span。这里div有两个为span的子元素，匹配到的是第一个。<br><span style="color:red">:first-of-type:</span> 匹配到的是p元素</p><p>所以，通过以上两个例子可以得出结论：</p><blockquote><p>:first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。<br>:first-of-type 匹配的是该类型的第一个，类型是指什么呢，就是冒号前面匹配到的东西，比如 p:first-of-type，就是指所有p元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了，当然这些元素的范围都是属于同一级的，也就是同辈的。</p></blockquote><p>同样类型的选择器 :last-child 和 :last-of-type、:nth-child(n) 和 :nth-of-type(n) 也可以这样去理解。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「译」如何用原生JS打造一款简易谷歌插件</title>
      <link href="/2019/03/10/Trs-%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/"/>
      <url>/2019/03/10/Trs-%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><blockquote><ul><li>原文地址：<a href="https://medium.com/javascript-in-plain-english/https-medium-com-javascript-in-plain-english-how-to-build-a-simple-chrome-extension-in-vanilla-javascript-e52b2994aeeb" target="_blank" rel="noopener">How to Build a Simple Chrome Extension in Vanilla JavaScript</a></li><li>原文作者：Sara Wegman</li><li>译者：Chor<a id="more"></a></li></ul></blockquote><p>今天，我打算向你们展示如何用原生JS—-不依靠任何诸如React、Angular或者Vue框架的原生JS做一款谷歌插件。</p><p>做一款谷歌插件并没有那么困难——在学习编程的第一年，我发布了两个插件，并且都是用HTML、CSS和原生JS做的。在这篇文章中，我会用几分钟的时间教你们怎么完成这件事。</p><p>我将向你们展示如何从零开始打造一款简易的谷歌插件主控面板。如果你对插件有自己的想法、只是想知道应该向已有项目文件中添加什么，从而让其运行在谷歌浏览器中的话，你可以跳到自定义mainfest.json文件和图标的部分。</p><h3 id="关于谷歌插件"><a href="#关于谷歌插件" class="headerlink" title="关于谷歌插件"></a>关于谷歌插件</h3><p>从本质上来说，一款谷歌插件只是一些用来定制浏览体验的文件。有许多不同类型的插件，有些插件仅在某种特定条件下才会激活，比如当你在商店的结账页面的时候；有些插件仅在你点击图标后才会弹出；有些则在你每次打开新标签页的时候才会出现。我今年发布的两款插件都是“新标签页式”插件，第一款是<a href="http://bit.ly/complimentdash" target="_blank" rel="noopener">Compliment Dash</a>,一个可以显示to-do list并问候用户的主控面板；第二款是<a href="http://liturgical.li/" target="_blank" rel="noopener">Liturgical.li</a>,为牧师量身打造的工具。如果你知道如何建设一个基本的网站，那么你就可以很轻松地做出这种插件。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>我们打算一切从简，所以本教程只会使用HTML、CSS和基本的JS，以及下面会讲到的自定义mainfest.json文件。谷歌插件的复杂度各不相同，因此做一款插件可能很简单，也可能很难，这取决于你打算让它实现什么功能。在学习了本篇文章的基础知识后，你将可以活用技能做出更为复杂的东西。</p><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>本教材中，我们将制作一款可以问候用户的简易主控面板，名字就叫Simple Greeting Dashboard好了。<br>首先需要创建三个文件：index.html,main.css和main.js。将这些文件放在各自的文件夹中。接下来，在html文件中书写必要的声明，并引入css文件和js文件：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- =================================Simple Greeting Dashboard================================= //--></span><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Simple Greeting Dashboard<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!-- My code will go here --></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定制你的mainfest-json文件"><a href="#定制你的mainfest-json文件" class="headerlink" title="定制你的mainfest.json文件"></a>定制你的mainfest.json文件</h3><p>仅有这些文件还不能够让你的插件项目正常运行。我们还需要一个mainfest.json文件以定制插件的基本信息。可以在<a href="https://developer.chrome.com/extensions/getstarted" target="_blank" rel="noopener">Google’s developer portal</a>下载该文件，或者复制粘贴如下代码到一个新文件中，另存为manifest.json文件。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Getting Started Example"</span><span class="token punctuation">,</span>  <span class="token string">"version"</span><span class="token punctuation">:</span> <span class="token string">"1.0"</span><span class="token punctuation">,</span>  <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"Build an Extension!"</span><span class="token punctuation">,</span>  <span class="token string">"manifest_version"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们修改上面文件中关于插件信息的内容。只需改变代码中的前三个值：<code>name</code>,<code>version</code>和<code>description</code>。填入插件名称以及相关描述，由于这是第一个版本，所以version项就不需要改了。<code>manifest_version</code>也不需要改动。<br>接着，添加代码行以告诉谷歌浏览器如何操作这个插件。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Simple Greeting Dashboard"</span><span class="token punctuation">,</span>  <span class="token string">"version"</span><span class="token punctuation">:</span> <span class="token string">"1.0"</span><span class="token punctuation">,</span>  <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"This Chrome extension greets the user each time they open a new tab"</span><span class="token punctuation">,</span>  <span class="token string">"manifest_version"</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token string">"incognito"</span><span class="token punctuation">:</span> <span class="token string">"split"</span><span class="token punctuation">,</span>  <span class="token string">"chrome_url_overrides"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"newtab"</span><span class="token punctuation">:</span> <span class="token string">"index.html"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"permissions"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>     <span class="token string">"activeTab"</span>   <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"icons"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"128"</span><span class="token punctuation">:</span> <span class="token string">"icon.png"</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码<code>incognito&quot;: &quot;split</code>告诉谷歌浏览器当它处于匿名模式的时候应该如何操作该插件。“split”将允许插件运行在自己的进程中。其他选项请查阅<a href="https://www.baidu.com/#ie=UTF-8&amp;wd=developer%20documentation." target="_blank" rel="noopener">developer documentation</a></p><p>正如你所看到的，”chrome_url_overrides”指定浏览器打开新标签页的时候打开index.html。将值设定为“permissions”后，将弹出窗口，提示用户安装该插件将会覆盖新标签页。</p><p>最后，设定我们的图标：一个名为icon的png文件，尺寸为128x128像素。</p><h3 id="创建图标"><a href="#创建图标" class="headerlink" title="创建图标"></a>创建图标</h3><p>现在我们还没有Simple Greeting Dash的图标文件，所以来创建一个。你可以用下面我做的图标。如果你想自己做一个的话，用PS或者<a href="http://canva.com/" target="_blank" rel="noopener">Canva</a>都可以。切记图标尺寸为128x128像素，然后另存为名称icon的png文件，与HTML文件、CSS文件、JS文件和Json文件放在同一个文件夹里。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9FJS%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6-1.png" alt=""></p><h3 id="上传你的文件（如果你正在编写自己的页面）"><a href="#上传你的文件（如果你正在编写自己的页面）" class="headerlink" title="上传你的文件（如果你正在编写自己的页面）"></a>上传你的文件（如果你正在编写自己的页面）</h3><p>要创建你的“新标签页式”谷歌插件，只需明悉以上全部信息即可。在你定制了mainfest.json文件后，你可以用HTML、CSS和JS设计任何自己想要的新标签页，之后按照下图所示将其上传。不过，如果你想知道我怎么创建这个简易面板的话，请跳至“创建一个设置菜单”部分。</p><p>一旦你设计好了新标签页，你的谷歌插件就创建完成了，随时可以上传至谷歌浏览器。手动上传，请在浏览器的地址栏输入<code>chrome://extensions/</code>，进入页面后在右上角启用开发者模式。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9FJS%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6-2.png" alt=""></p><p>刷新页面，点击“加载已解压的拓展程序”。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9FJS%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6-3.png" alt=""></p><p>接着，选择存放HTML、CSS、JS、mainfest.json文件和icon.png的文件夹，上传。之后每次打开新标签页的时候该插件都会运行！</p><p>在创建了自己的插件并且通过测试之后，你便可以申请一个开发者账号并将该应用发布到谷歌拓展程序商店。这篇<a href="https://developer.chrome.com/webstore/publish" target="_blank" rel="noopener">教程</a>将指导你如何发布你的插件。</p><p>如果你现在不急着创建插件，只是想看看谷歌插件能够做什么的话，下面将教你如何创建一个非常简易的问候面板。</p><p>创建一个设置菜单</p><p>就这个插件来说，我首先要做的第一件事就是创建一个可供用户添加自己名字的输入框。因为我不打算让它一直显示，所以我将其放在一个名为<code>settings</code>的div下，该div只在用户点击settings按钮的时候才会显示。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>settings-button<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Settings<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>settings<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>settings<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-form<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-form<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-input<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>        <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-input<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Type your name here...<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name-button<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Add<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的页面设置看起来大概是这样的：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9FJS%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6-4.png" alt=""></p><p>…因此很有必要通过CSS给它们添加一些样式。我将给settings按钮和输入框添加内边距和轮廓，之后让settings按钮和输入框之间留有一点空隙。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.settings</span> </span><span class="token punctuation">{</span>   <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>   <span class="token property">flex-direction</span><span class="token punctuation">:</span> row<span class="token punctuation">;</span>   <span class="token property">align-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">input </span><span class="token punctuation">{</span>   <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span>   <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>   <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">150</span>px<span class="token punctuation">;</span>   <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">button </span><span class="token punctuation">{</span>   <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">30</span>px<span class="token punctuation">;</span>   <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">70</span>px<span class="token punctuation">;</span>   <span class="token property">background</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* This removes the default background */</span>   <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#313131</span><span class="token punctuation">;</span>   <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid <span class="token hexcode">#313131</span><span class="token punctuation">;</span>   <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* This gives our button rounded edges */</span>   <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>   <span class="token property">cursor</span><span class="token punctuation">:</span> pointer<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">form </span><span class="token punctuation">{</span>   <span class="token property">padding-top</span><span class="token punctuation">:</span> <span class="token number">20</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在看起来好多了：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9FJS%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6-5.png" alt=""></p><p>不过，我们必须设置一下：用户未点击settings按钮的时候输入框不显示。我将通过给settings类添加下面的代码来完成这个设置，之后输入框将从屏幕上消失：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateX</span><span class="token punctuation">(</span>-<span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">transition</span><span class="token punctuation">:</span> transform <span class="token number">1</span>s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在创建一个名为settings-open的类，在用户点击settings按钮的时候该类名将动态添加或去除。当添加settings-open类给已经有settings类的div时，div将不会隐藏，而是在正常位置显示。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.settings-open.settings</span> </span><span class="token punctuation">{</span>   <span class="token property">transform</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着用JS实现类名的改变。定义一个名为openSettings的函数，它的功能是实现settings-open类名的添加或去除。具体做法是通过div的ID获取到该div元素，之后调用clssLIst.toggle方法添加settings-open类名。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">openSettings</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"settings"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">toggle</span><span class="token punctuation">(</span><span class="token string">"settings-open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在添加一个事件监听器，它将会在settings按钮被点击的时候调用函数</p><pre class="line-numbers language-js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"settings-button"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> openSettings<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在你点击settings按钮后，输入框将显示或隐藏。</p><h3 id="创建一个个性化的问候语"><a href="#创建一个个性化的问候语" class="headerlink" title="创建一个个性化的问候语"></a>创建一个个性化的问候语</h3><p>接下来，我们来创建问候信息。首先在HTML中放入一个空的h2标签，之后用JS中的innerHTML方法来给它增加内容。为方便稍后获取h2元素，我们将给它一个ID，并将其放入一个名为greeting-container的div中。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>greeting-container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>greeting<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>greeting<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，我将在JS中结合用户名创建一个基本的问候信息。首先声明一个空的变量用以稍后存放用户名。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> userName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果就这样把useName变量放在HTML的问候语句中，即使为userName变量赋了值，谷歌浏览器也是不会使用相同的名字的。为了确保浏览器记住用户，我们必须进行本地存储的工作。因此，定义一个名为saveName的函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">saveName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'receivedName'</span><span class="token punctuation">,</span> userName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数<code>localStorage.setItem()</code>接受两个参数：第一个是用于稍后获取信息的关键词，第二个是它需要记住的信息，也即是<code>useName</code>。我将通过<code>localStorage.setItem</code>获取储存的信息，并用该信息来更新useName变量的值。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> userName <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'receivedName'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在将这条语句添加进表单的事件监听器之前，我想要让浏览器默认指定一个用户名，以应对我没有告诉它名字的情况。我将用if语句来完成这件事。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>userName <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   userName <span class="token operator">=</span> <span class="token string">"friend"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，将userName变量与表单连接起来。我们将该操作写进函数里，这样每次名字更新的时候都可以调用该函数。我们给这个函数取名changeName。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">changeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   userName <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"name-input"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>   <span class="token function">saveName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我想要让该函数在用户每次用表单提交名字的时候都被调用。这里用事件监听器，它可以调用changeName函数并防止在表单提交的时候页面默认刷新。</p><pre class="line-numbers language-js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"name-form"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'submit'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token function">changeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后，我们来创建问候语。我将把该语句也放进一个函数中，这样，在页面刷新或者<code>changeName()</code>调用后，我都可以调用该函数。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"greeting"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML  <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Hello, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>userName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">. Enjoy your day!`</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">getGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最后，自定义你的页面"><a href="#最后，自定义你的页面" class="headerlink" title="最后，自定义你的页面"></a>最后，自定义你的页面</h3><p>现在是时候收尾了。我将用flexbox使标题居中，让它变得更大。同时在CSS中给body添加一个渐变背景。为了在渐变背景中突出按钮和h2，我会把它们设置成白色的。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.greeting-container</span> </span><span class="token punctuation">{</span>   <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>   <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>   <span class="token property">align-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.greeting</span> </span><span class="token punctuation">{</span>   <span class="token property">font-family</span><span class="token punctuation">:</span> sans-serif<span class="token punctuation">;</span>   <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">60</span>px<span class="token punctuation">;</span>   <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">body </span><span class="token punctuation">{</span>   <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#c670ca</span><span class="token punctuation">;</span>   <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span><span class="token number">45</span>deg, <span class="token hexcode">#c670ca</span> <span class="token number">0%</span>, <span class="token hexcode">#25a5c8</span> <span class="token number">52%</span>, <span class="token hexcode">#20e275</span> <span class="token number">90%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">html </span><span class="token punctuation">{</span>   <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就这样！你的页面大概会是下面这样子：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E3%80%8C%E8%AF%91%E3%80%8D%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9FJS%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6-6.png" alt=""><br>虽然内容不多，但这是你创建和定义自己的谷歌插件的基础。如果有任何疑问，请告诉我，并随时在推特上@saralaughed 联系我。</p><blockquote><p>纯练手的第一篇译文。如果发现译文存在错误或其他需要改进的地方，欢迎在下面评论指出。</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Translation </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获取DOM节点的方法汇总</title>
      <link href="/2019/03/08/F-%E8%8E%B7%E5%8F%96DOM%E8%8A%82%E7%82%B9%E7%9A%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2019/03/08/F-%E8%8E%B7%E5%8F%96DOM%E8%8A%82%E7%82%B9%E7%9A%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><h3 id="1-原生获取DOM节点的方法"><a href="#1-原生获取DOM节点的方法" class="headerlink" title="1.原生获取DOM节点的方法"></a>1.原生获取DOM节点的方法</h3><h4 id="1-1-通过顶层document节点获取："><a href="#1-1-通过顶层document节点获取：" class="headerlink" title="1.1 通过顶层document节点获取："></a>1.1 通过顶层document节点获取：</h4><ul><li><code>document.getElementById(&quot;ID&quot;)</code></li><li><code>document.getElementsByName(&quot;Name&quot;)</code></li><li><code>document.getElementsByClassName(&quot;className&quot;)</code></li><li><code>document.getElementsByTagName(&quot;tagName&quot;)</code><a id="more"></a> 注意，前两个都是document节点的专有方法，其他节点不能使用，尤其不能在ID下获取ID，这是非常愚蠢的做法。</li></ul><h4 id="1-2-通过父节点获取："><a href="#1-2-通过父节点获取：" class="headerlink" title="1.2 通过父节点获取："></a>1.2 通过父节点获取：</h4><ul><li><p><code>parentObj.firstChild</code>：获取父节点下的第一个子节点（会将空格和换行计入），这个属性是可以递归使用的，即支持<code>parentObj.firstChild.firstChild...</code>的形式，如此就可以获得更深层次的节点。</p></li><li><p><code>parentObj.firstElementChild</code>：获取父节点下的第一个子元素节点</p></li><li><p><code>parentObj.lastChild</code>：获取父节点下的最后一个子节点（会将空格和换行计入）。与<code>firstChild</code>一样，它也可以递归使用。</p></li><li><p><code>parentObj.lastElementChild</code>：获取父节点下的最后一个子元素节点</p></li><li><p><code>parentObj.childNodes</code>：获取父节点下的所有直接子节点（会将空格和换行计入）</p></li><li><p><code>parentObj.children</code>：获取父节点下的直接子元素节点。</p></li><li><p><code>parentObj.getElementsByTagName(&quot;tagName&quot;)</code></p></li><li><p><code>parentObj.getElementsByClassName(&quot;className&quot;)</code></p></li></ul><h4 id="1-3-通过子节点获取："><a href="#1-3-通过子节点获取：" class="headerlink" title="1.3 通过子节点获取："></a>1.3 通过子节点获取：</h4><ul><li><p><code>childObj.parentNode</code> : 获取子节点的直接父节点。w3c标准</p></li><li><p><code>childObj.parentElement</code> : 获取子节点的直接父节点。IE标准</p></li></ul><h4 id="1-4-通过兄弟节点获取："><a href="#1-4-通过兄弟节点获取：" class="headerlink" title="1.4 通过兄弟节点获取："></a>1.4 通过兄弟节点获取：</h4><ul><li><p><code>neighbourObj.parentNode.children[..]</code> :通过父节点间接获取已知节点的兄弟节点</p></li><li><p><code>neighbourObj.previousSibling</code>：获取已知节点的上一个兄弟节点（会将空格和换行计入）</p></li><li><p><code>neighbourObj.previousElementSibling</code>: 获取已知节点的上一个兄弟元素节点</p></li><li><p><code>neighbourObj.nextSibling</code>：获取已知节点的下一个兄弟节点（会将空格和换行计入）</p></li><li><p><code>neighbourObj.nextElementSibling</code>: 获取已知节点的下一个兄弟元素节点</p></li></ul><h4 id="1-5-通过CSS选择器获取："><a href="#1-5-通过CSS选择器获取：" class="headerlink" title="1.5 通过CSS选择器获取："></a>1.5 通过CSS选择器获取：</h4><p>采用CSS选择器的语法，即<code>#abc</code>，<code>div.abc</code>,<code>#abc .abc</code>等。</p><ul><li><p><code>document.querySelector(&quot;...&quot;)</code>: 返回匹配的第一个节点</p></li><li><p><code>document.querySelectorAll(&quot;...&quot;)</code>: 返回匹配的所有节点</p></li></ul><h3 id="2-jQuery-获取-DOM-节点的方法"><a href="#2-jQuery-获取-DOM-节点的方法" class="headerlink" title="2.jQuery 获取 DOM 节点的方法"></a>2.jQuery 获取 DOM 节点的方法</h3><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>祖先</td><td></td></tr><tr><td><code>$(&quot;#A&quot;).parent()</code></td><td>获取A节点的直接父节点</td></tr><tr><td><code>$(&quot;#A&quot;).parents()</code></td><td>获取A节点的所有祖先节点</td></tr><tr><td><code>$(&quot;#A&quot;).parents(&quot;.B&quot;)</code></td><td>获取A节点的所有祖先节点中的B节点</td></tr><tr><td><code>$(&quot;#A&quot;).closet(&quot;B&quot;)</code></td><td>获取A节点的第一个为B的祖先节点</td></tr><tr><td>后代</td><td></td></tr><tr><td><code>$(&quot;#A&quot;).children()</code></td><td>获取A节点的直接子节点</td></tr><tr><td><code>$(&quot;.A&quot;).children(&quot;.B&quot;)</code></td><td>获取A节点的所有为B的直接子节点</td></tr><tr><td><code>$(&quot;#A&quot;).find(&quot;*&quot;)</code></td><td>获取A节点的所有后代节点</td></tr><tr><td><code>$(&quot;#A&quot;).find(&quot;.B&quot;)</code></td><td>获取A节点的所有为B的后代节点</td></tr><tr><td>同胞</td><td></td></tr><tr><td><code>$(&quot;#A&quot;).prev()</code></td><td>获取A节点的上一个兄弟节点</td></tr><tr><td><code>$(&quot;#A&quot;).prevAll()</code></td><td>获取A节点之前的所有兄弟节点</td></tr><tr><td><code>$(&quot;#A&quot;).prevUntil(&quot;.B&quot;)</code></td><td>获取A节点之前、B节点之后的所有兄弟节点</td></tr><tr><td><code>$(&quot;#A&quot;).next()</code></td><td>获取A节点的下一个兄弟节点</td></tr><tr><td><code>$(&quot;#A&quot;).nextAll()</code></td><td>获取A节点之后的所有兄弟节点</td></tr><tr><td><code>$(&quot;#A&quot;).nextUntil(&quot;.B&quot;)</code></td><td>获取A节点之后、B节点之前的所有兄弟节点</td></tr><tr><td><code>$(&quot;#A&quot;).siblings()</code></td><td>获取A节点的所有兄弟节点</td></tr><tr><td><code>$(&quot;#A&quot;).siblings(&quot;.B&quot;)</code></td><td>获取A节点的所有为B的兄弟节点</td></tr><tr><td>过滤</td><td></td></tr><tr><td><code>$(&quot;A B&quot;).first()</code></td><td>获取第一个A节点的第一个B节点</td></tr><tr><td><code>$(&quot;A B&quot;).last()</code></td><td>获取最后一个A节点的最后一个B节点</td></tr><tr><td><code>$(&quot;.A&quot;).eq(0)</code></td><td>获取所有A节点中的第一个A节点</td></tr><tr><td><code>$(&quot;A&quot;).filter(&quot;B&quot;)</code></td><td>获取A节点中的所有B节点</td></tr><tr><td><code>$(&quot;A&quot;).not(&quot;B&quot;)</code></td><td>获取A节点中的不包括B节点的所有节点</td></tr></tbody></table><p><br></p><h3 id="3-HTMLCollection-和-NodeList"><a href="#3-HTMLCollection-和-NodeList" class="headerlink" title="3.HTMLCollection 和 NodeList"></a>3.HTMLCollection 和 NodeList</h3><p>我们都知道，当获得所有节点（如：<code>getElementsByTagName</code>）或者获得所有子元素（如：<code>element.childNodes</code>）时，实际上返回的是包含一些DOM节点的集合，这个集合要么是 <code>HTMLCollection</code>，要么是 <code>NodeList</code>，两者其实都是类数组的对象。</p><h4 id="HTMLCollection和NodeList的共同点："><a href="#HTMLCollection和NodeList的共同点：" class="headerlink" title="HTMLCollection和NodeList的共同点："></a><code>HTMLCollection</code>和<code>NodeList</code>的共同点：</h4><ul><li>都是类数组对象，都有length属性;</li><li>都有共同的方法：<code>item</code>，可以通过<code>item(index)</code>或者<code>item(id)</code>来访问返回结果中的元素;</li><li>一般都是实时变动的（live），document上的更改会反映到相关对象上（！！注意：<code>document.querySelectorAll</code>返回的<code>NodeList</code>不是实时的）;</li></ul><h4 id="HTMLCollection和NodeList的不同点："><a href="#HTMLCollection和NodeList的不同点：" class="headerlink" title="HTMLCollection和NodeList的不同点："></a><code>HTMLCollection</code>和<code>NodeList</code>的不同点：</h4><ul><li><code>NodeList</code>可以包含任何节点类型，<code>HTMLCollection</code>只包含元素节点（elementNode）。</li><li><code>HTMLCollection</code>比<code>NodeList</code>多一项方法：<code>NamedItem</code>，可以通过传递id或name属性来获取节点信息</li></ul><h4 id="规定返回结果："><a href="#规定返回结果：" class="headerlink" title="规定返回结果："></a>规定返回结果：</h4><ol><li><code>node.childNodes</code> 结果返回类型是 <code>NodeList</code>，即所有子节点；</li><li><code>node.children</code> 结果返回类型是 <code>HTMLCollection</code> ，即所有子元素节点；</li><li><code>getElementsByXXX</code> 结果返回类型是<code>HTMLCollection</code></li><li>旧版本浏览器(尤其是IE)中，<code>node.children</code> 结果返回类型是 <code>NodeList</code></li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM Core 与 HTML-DOM</title>
      <link href="/2019/03/08/F-DOM%20Core%20%E5%92%8CHTML%20DOM/"/>
      <url>/2019/03/08/F-DOM%20Core%20%E5%92%8CHTML%20DOM/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><h4 id="1-DOM"><a href="#1-DOM" class="headerlink" title="1.DOM"></a>1.DOM</h4><p>DOM（文档对象模型）是由W3C制定的一套访问和操作XML（eXtensible Markup Language）文档的标准，即API。比如DOM告诉JavaScript引擎如何在浏览器窗口中显示和操作XML创建的标记（Tag）。</p><p>DOM与特定的平台、浏览器、语言无关，很多种语言都实现了DOM，比如因为JavaScript和PHP都实现了DOM，所以 JavaScript中有getElementsByTagName()方法，PHP中也有 getElementsByTagName()，getElementsByTagName()方法是DOM规定的访问XML文档的接口。<br><a id="more"></a></p><h4 id="2-XML、XHTML、HTML"><a href="#2-XML、XHTML、HTML" class="headerlink" title="2.XML、XHTML、HTML"></a>2.XML、XHTML、HTML</h4><p>XML与HTML相似，但两者是有区别。XML和HTML都来自于SGML，它们都含有标记，有着相似的语法，HTML和XML的最大区别在 于：HTML是一个定型的标记语言，用固定的标记来描述和显示数据，比如<code>&lt;h1&gt;</code>表示首行标题，有固定的尺寸；而XML没有固定的标记，只能通过自定义的标记来描述数据的形式和结构，而不能显示。HTML是将数据 和显示混在一起，而XML则是将数据和显示分开来。那为什么能使用DOM访问和操作HTML文档（即网页）呢？Web语义化的一个发展方向是将HTML逐 渐演变为更有语义、能将数据内容与现实分离的XML，但HTML不可能立即演变为XML，目前推荐使用的是一个过渡产物——XHTML。HTML与 XHTML网页形成的节点树（统称为HTML节点树）在结构上与XML节点树一样，可以看做是一个符合DOM的XML文档，因此可以使用实现了DOM的程序语言（如JavaScript、PHP等）来访问和操作HTML文档，即访问和操作那些节点。</p><h4 id="3-DOM-Core和HTML-DOM"><a href="#3-DOM-Core和HTML-DOM" class="headerlink" title="3.DOM Core和HTML-DOM"></a>3.DOM Core和HTML-DOM</h4><p>由于HTML与XML的相似性及差异，JavaScript不仅实现了标准的DOM方法和属性（即由W3C制定的），而且还实现了HTML特有的 DOM方法和属性，前者称为DOM Core，并不专属于JavaScript，后者称为HTML-DOM。不管是DOM Core还是HTML-DOM，我们在使用JavaScript的时候要注意浏览器之间的兼容性，因为不同的浏览器对这两类方法和属性的支持可能不一样。</p><p><span style="background:#fffa7d;font-weight:700">常见的DOM Core方法如下：</span></p><blockquote><p>1、创建节点<br>createElement()<br>createTextNode()<br>2、复制节点<br>cloneNode()<br>3、插入节点<br>appendChild()<br>insertBefore()<br>4、删除节点<br>removeChild()<br>5、替换节点<br>replaceChild()<br>6、查找和设置节点属性<br>setAttribute()<br>getAttribute()<br>7、查找节点<br>getElementById()<br>getElementsByTagName()<br>hasChildNode()</p></blockquote><p><span style="background:#fffa7d;font-weight:700">常见的DOM Core属性如下：</span></p><blockquote><p>node.childNodes<br>node.firstChild<br>node.lastChild<br>node.nextSibling<br>node.previousSibling<br>node.parentNode</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解事件循环</title>
      <link href="/2019/03/05/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2019/03/05/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-1.png" alt=""></p><a id="more"></a><p>本篇博客讲的东西偏底层，较难理解。虽然有的地方不够精准和全面，但是我觉得对于理解js中的异步来说已经够了，所以没有再深究一些概念（比如浏览器在这个过程中充当的角色）。</p><h2 id="1-单线程"><a href="#1-单线程" class="headerlink" title="1.单线程"></a>1.单线程</h2><p>所谓的单线程，可以简单理解为做事情讲究先来后到，要做后面的事情，你得等前面的事情做完—–不管它需要多久。<br>既然如此，js引擎为何还要采取这种单线程的机制呢？<br>js主要是与用户互动，这个过程涉及到对DOM节点的操作，如果js是多线程的，一个在节点上添加内容，一个要对这个dom节点进行删除，到底是以哪个为准？所以这就是为什么js从一出现就秉承着单线程的运行机制。<br>另外还要注意：</p><blockquote><p>“为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质”</p></blockquote><h2 id="2-同步任务和异步任务"><a href="#2-同步任务和异步任务" class="headerlink" title="2.同步任务和异步任务"></a>2.同步任务和异步任务</h2><p>很显然，单线程会带来一个问题：就是代码执行的阻塞。比如：排在前面的任务如果耗时长，则后面的任务不得不一直等待它。 如果说耗时长是因为计算量大、cpu一直忙着计算的话倒也还好，可事实是——大部分时间浪费在了IO上（ajax从网络上获取数据），还有其他的如鼠标点击、setTimeout等等。因此这里提出了同步任务和异步任务的概念。</p><p>在js中，可以将同步和异步简单理解为执行顺序的问题。</p><h3 id="2-1同步（sync）："><a href="#2-1同步（sync）：" class="headerlink" title="2.1同步（sync）："></a>2.1同步（sync）：</h3><p>即上面所说的后面等待前面。同步对应了同步任务（synchronous），即可以按照正常顺序执行的任务，比如加载页面骨架等。</p><h3 id="2-2异步（async）："><a href="#2-2异步（async）：" class="headerlink" title="2.2异步（async）："></a>2.2异步（async）：</h3><p>即把耗时长的任务挂起，先执行耗时短的，再回过头执行耗时长的。<br>异步对应了异步任务（asynchronous），即不适合按照正常顺序执行的任务，主要包括：</p><ul><li>onclick等事件绑定—&gt; 当事件触发时，回调函数会被添加到任务队列中；</li><li>setTimeout / setInterval 等计时器—&gt; (时间延迟)当浏览器完成计时，回调函数会被添加到任务队列中；</li><li>AJAX请求—&gt;当网络请求完成返回时，回调函数会被添加到任务队列中</li></ul><h2 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3.事件循环"></a>3.事件循环</h2><ul><li>事件循环又叫event loop，需要注意的是，事件循环<strong>不是</strong>单线程的js引擎提供的机制，而是来自于js引擎的运行环境（多线程的浏览器或node.js）。</li><li>事件循环是实现异步的一种机制。一个线程中只有一个事件循环，我们将这个循环的每一次循环执行过程称之为tick。 具体每一次循环是怎么执行的，后文会讲。</li></ul><h2 id="4-执行栈和任务队列"><a href="#4-执行栈和任务队列" class="headerlink" title="4.执行栈和任务队列"></a>4.执行栈和任务队列</h2><p>事件循环机制离不开执行栈和任务队列的相互配合。js中将<span style="background-color:#fffa7d">同步任务放到主线程上执行，形成“执行栈”；异步任务则放到任务队列中</span>。</p><p><strong>任务队列的分类标准之一：</strong></p><p>一个线程可以拥有多个任务队列。每一个任务队列都对应某一任务源，并包含了一堆来自该任务源的任务。任务源是什么？像setTimeout/Promise/DOM事件/AJAX等都是任务源，来自同类任务源的任务我们称它们是同源的，比如setTimeout与setInterval就是同源的。</p><p><strong>任务队列的分类标准之二：</strong></p><p>在ES6中，我们用另一种方式对任务队列进行分类。<br><span style="background-color:#fffa7d">宏任务</span>: 即macro-task，包括整体代码script，setTimeout，setInterval、AJAX、用户I\O 等。宏任务会对应地进入宏任务队列中；<br><span style="background-color:#fffa7d">微任务</span>: 即micro-task,包括Promise，process.nextTick(callback)(可以理解为node.js版的setTimeOut)。微任务会对应地进入微任务队列中。</p><h2 id="5-事件循环的具体实现过程？"><a href="#5-事件循环的具体实现过程？" class="headerlink" title="5.事件循环的具体实现过程？"></a>5.事件循环的具体实现过程？</h2><p>总的来说，事件循环的顺序，决定了js代码执行的顺序。</p><ul><li>首先进入<code>&lt;script&gt;</code>包裹的整体代码(这是第一个宏任务)，标志着第一次循环开始。在整体代码的执行过程中，同步任务照旧执行，异步任务分发到对应的任务队列中；</li><li>整体代码执行完，执行栈清空，开始读取任务队列；</li><li>读取所有微观任务队列 -&gt; 执行 -&gt;<br>第一次循环结束，开始第二次循环<br>读取一个宏观任务队列 -&gt; 执行 -&gt;<br>读取所有微观任务队列 -&gt; 执行 -&gt;<br>第二次循环结束，开始第三次循环<br>读取一个宏观任务队列……………..<br>………<br>………<br>队列清空，执行栈清空，事件循环正式结束。</li></ul><p>PS：读取任务时，会执行这些任务指定的回调函数,并且要注意：若回调函数中又有宏任务，则该宏任务会被安排到下一轮循环中。</p><h2 id="6-事件循环的例子"><a href="#6-事件循环的例子" class="headerlink" title="6.事件循环的例子"></a>6.事件循环的例子</h2><p>下面通过三个由易到难的例子来理解上面所说的过程。</p><p><strong>例1</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：<br>跑一下代码，会发现控制台执行task()需要的时间远远超过3秒，这就说明我们有的人理解的”setTimeout的第二个参数指定了多长时间后执行回调函数”的说法是错误的。<br>让我们来分析一下这个过程：</p><ul><li><code>&lt;script&gt;</code>中的整段代码作为第一个宏任务，进入主线程。即开启第一次事件循环；</li><li>首先遇到了setTimeout，将其回调函数task()进入Event Table并注册,同时浏览器开始计时；</li><li>继续，遇到了sleep函数，这是同步任务，所以直接执行。但是速度很慢，非常慢，而浏览器计时仍在继续；</li><li>好了，3秒终于到了，计时事件setTimeout总算完成，可以把task()放入任务队列了;</li><li>但是主线程上的sleep太慢了，还没执行完，于是我们只好等着；</li><li>sleep终于执行完了，执行栈清空,第一次循环的宏任务结束；</li><li>读取微任务队列….不对，没有任何任务被分发到这个队列，于是第一次循环只好这样结束了；</li><li>第二次循环开始，读取宏任务队列，刚好，里面有一个setTimeout对应的task()回调函数，压栈、令其进入主线程执行；</li><li>执行栈清空了，任务队列也清空了，事件循环正式结束。</li></ul><p>现在，我们知道setTimeout的回调函数是一开始就注册进event table的，但是那时并未进入任务队列—-要经过一定的时间，而这个时间由第二个参数来指定。也就是说，第二个参数指定的是“多长时间后将回调函数放入到任务队列中”。<br>另外，即使回调函数已经进入队列，也得先等主线程的执行栈清空后才有可能轮到自己。<br>我们还经常遇到<code>setTimeout(fn,0)</code>(或者干脆没有指定第二个参数)这样的代码，这是不是意味着可以立即执行呢？<br>不是。setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是注册进event table的同时就将任务放入队列中，只要主线程执行栈内的同步任务全部执行完成，且此时没有微任务队列，那么该任务就会马上压栈并执行。</p><p><strong>例2</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'console'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><ul><li><code>&lt;script&gt;</code>中的整段代码作为第一个宏任务，进入主线程。即开启第一次事件循环；</li><li>遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中（第二个参数不设定时，默认延迟为0）；</li><li>接下来遇到new Promise、Promise，立即执行，输出: promise 。将then函数分发到微任务队列中；</li><li>遇到console.log，立即执行，输出: console</li><li>整体代码作为第一个宏任务执行结束，此时去微任务队列中查看有哪些微任务，结果发现了then函数，然后将它推入主线程并执行，输出: then</li><li>第一轮事件循环结束，第二轮事件循环开始；</li><li>先从宏任务开始，去宏任务队列中查看有哪些宏任务，结果发现了setTimeout对应的回调函数，将它推入主线程并执行，输出：setTimeout</li><li>然后去微任务队列中查看是否有事件，结果没有；</li><li>此时第二轮事件循环结束；</li><li>执行栈清空了，任务队列也清空了，事件循环正式结束。</li></ul><p><strong>例3</strong></p><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'7'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'11'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><p>第一轮事件循环:</p><pre class="line-numbers language-html"><code class="language-html">a) 整段`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span>`代码作为第一个宏任务进入主线程，即开启第一轮事件循环b) 遇到console.log，立即执行。输出：1c) 遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中。我们将其标记为setTimeout1d) 遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务队列中。记为process1e) 遇到new Promise、Promise，立即执行；then回调函数放入Event table中注册，然后被分发到微任务队列中。记为then1。输出: 7f) 遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中。我们将其标记为setTimeout2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时第一轮事件循环宏任务结束，下表是第一轮事件循环宏任务结束时各任务队列的情况</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-2.png" alt=""></p><p>可以看到第一轮事件循环宏任务结束后微任务事件队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行</p><pre class="line-numbers language-html"><code class="language-html">g)、执行process1。输出：6h)、执行then1。输出：8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一轮事件循环正式结束！</p><p>第二轮事件循环:</p><pre class="line-numbers language-html"><code class="language-html">a）、第二轮事件循环从宏任务setTimeout1开始。遇到console.log，立即执行。输出: 2b）、遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务队列中。记为process2c）、遇到new Promise，立即执行；then回调函数放入Event table中注册，然后被分发到微任务队列中。记为then2。输出: 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时第二轮事件循环宏任务结束，下表是第二轮事件循环宏任务结束时各任务队列的情况</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-3.png" alt=""></p><p>可以看到第二轮事件循环宏任务结束后微任务事件队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行</p><pre class="line-numbers language-html"><code class="language-html">d)、执行process2。输出：3e)、执行then2。输出：5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二轮事件循环正式结束！</p><p>第三轮事件循环:</p><pre class="line-numbers language-html"><code class="language-html">a)、第三轮事件循环从宏任务setTimeout2开始。遇到console.log，立即执行。输出: 9d)、遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务队列中。记为process3c)、遇到new Promise，立即执行；then回调函数放入Event table中注册，然后被分发到微任务队列中。记为then3。输出: 11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时第三轮事件循环宏任务结束，下表是第三轮事件循环宏任务结束时各任务队列的情况</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-4.png" alt=""></p><p>可以看到第二轮事件循环宏任务结束后微任务队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行</p><pre class="line-numbers language-html"><code class="language-html">d)、执行process3。输出：10e)、执行then3。输出：12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二轮事件循环正式结束！<br>执行栈清空，任务队列清空，事件循环正式结束！</p><p>参考：<br><a href="https://segmentfault.com/a/1190000017970432" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017970432</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包和计数器</title>
      <link href="/2019/03/04/F-%E9%97%AD%E5%8C%85%E5%92%8C%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>/2019/03/04/F-%E9%97%AD%E5%8C%85%E5%92%8C%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>之前想不通的一道题—–主要是不知道思路怎么来的，为何会想到用闭包。本来打算就将原博客转载过来，但是刚刚重新审视这道题的时候，好像看到了以前没有发现的东西，有种恍然大悟的感觉，所以决定用自己的话来解释这道题的思路。<br><a id="more"></a></p><p>假如我们想制作一个计数器，每点击一次就加一，代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把计数器counter设置成全局变量</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> counter<span class="token operator">+</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//此时counter=3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;&gt;</code>固然可以实现功能，但问题就在于其他语句也有可能会改动到counter，这样的计数器是不安全的。</p><p>如果把counter改为外部访问不到的局部变量呢？</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> counter<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>counter<span class="token operator">+</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;&gt;</code>固然保证了counter不会被其他语句影响到，但问题就在于每次调用函数都会重置counter，无法实现计数功能。</p><p>所以我们需要的counter应该满足：1.不会被重置；2.在函数内部</p><p>第2点容易满足，但是由上面的例子我们知道，如果单纯把counter写在一个函数里，则每次调用都会重置，所以我们定义这样一个嵌套函数：将counter放在父函数里，子函数作为操作counter的函数，每次我们只调用子函数。<br>但是，全局作用域是无法访问嵌套函数中的子函数的，所以我们必须将子函数作为闭包返回出来，使其暴露在全局作用域下。依照这个想法，代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> add <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//counter为1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//counter为1</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//counter为1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&gt;&gt;</code>意思是把add函数（父函数）执行后返回的函数（子函数）执行一次（注意这里是两次执行）。但这样的问题在于：每次调用add()()时依然执行了一次父函数，结果就是依然重置了counter。</p><p>那么有没有办法让父函数只执行一次，仅在那一次初始化counter，之后每次都只通过执行子函数来操作counter呢？<br>可以用自执行函数来解决这个问题—–也就是通过自执行函数（而不是通过add()）来调用父函数，在这一次调用初始化counter，之后将返回的子函数赋给add，通过调用add()来操作counter。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> add <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">(</span><span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里add已经是父函数的执行结果了，即add已经是返回的那个子函数了</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//counter为3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来就是闭包的知识了：<br>在每次调用闭包add——-即<code>function(){return(++counter)</code>时，由于add中存在自由变量counter，所以它必须到定义该函数时所在的那个作用域中去寻找该变量，也就是到父函数中去寻找。恰好父函数中有一个为0的counter可以被引用，所以这时候完成加一操作，counter变成1。注意，接下来我们尝试调用了console.log(counter)，但是输出的是undefined，这说明了即使add函数执行后返回了值为1的counter，但是该返回值并不是返回到全局作用域中（不然不会输出undefined），而是覆盖了父函数中原来定义的counter，使counter变为1；第二次调用add函数依然同上，只是此时引用counter时，引用的是为1的counter，加1后变为2；同理第三次，引用的是为2的counter，加1后变为3。<br><br><br>基于这道题，我们不难看出使用闭包函数的好处：</p><p>1、<span style="background-color:#fffa7d">缓存</span>：<br>最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量作为相对于闭包函数的自由变量，在闭包函数里直接使用它。因此该自由变量只初始化一次，但却可以通过多次调用闭包函数来使用。这比起我们直接在闭包函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是上面例子中的—–实现计数功能。</p><p>2、<span style="background-color:#fffa7d">实现封装</span>：<br>自由变量只能被闭包函数本身或者其子函数访问，而不能被闭包函数之外的函数访问。这就实现了面向对象的封装性，更安全更可靠。</p><p>参考：<br><a href="http://www.cnblogs.com/haidaojiege/p/7070560.html" target="_blank" rel="noopener">http://www.cnblogs.com/haidaojiege/p/7070560.html</a><br><a href="https://www.cnblogs.com/leoin2012/p/3978979.html" target="_blank" rel="noopener">https://www.cnblogs.com/leoin2012/p/3978979.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出理解闭包</title>
      <link href="/2019/03/04/F-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/"/>
      <url>/2019/03/04/F-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85-2.jpg" alt=""></p><a id="more"></a><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本篇博客转载自@王福朋 王老师的系列文章。系列文章共计18篇，主要涉及js中的两个重难点—-原型和闭包。由于原型部分我在另外一篇博客有介绍，所以这里只集合了他关于闭包的几篇讲解，包括了作用域、执行上下文等。</p><p>原作者：王福朋<br>来源：<a href="http://www.cnblogs.com/wangfupeng1988/p/3977924.html" target="_blank" rel="noopener">深入理解JavaScript原型和闭包</a><br>转载授权:<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/pro.png" alt=""></p><h2 id="1-简述执行上下文（上）："><a href="#1-简述执行上下文（上）：" class="headerlink" title="1.简述执行上下文（上）："></a>1.简述执行上下文（上）：</h2><p>什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q1.png" alt=""></p><p>第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。</p><p>在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q2.png" alt=""></p><p>这是第一种情况。</p><p>下面还有。先来个简单的。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q3.png" alt=""></p><p>有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。</p><p>与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。</p><p>下面还有。。。第三种情况。</p><p>在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q4.png" alt=""></p><p>看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。<br>没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。</p><p>好了，“准备工作”介绍完毕。</p><p>我们总结一下，在“准备工作”中完成了哪些工作：</p><ul><li><span style="background-color:#fffa7d">变量、函数表达式——变量声明，默认赋值为undefined；</span></li><li><span style="background-color:#fffa7d">this——赋值；</span></li><li><span style="background-color:#fffa7d">函数声明——赋值；</span></li></ul><p><span style="background-color:#fffa7d">这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。</span></p><p style="font-size:14px;font-family:楷体">这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——<span style="background-color:#fffa7d">任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的。</span></p><p>细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。<br>其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。<span style="background-color:#fffa7d">这个“代码段”其实分三种情况——全局代码，函数体，eval代码。</span><br><br></p><p>这里解释一下为什么代码段分为这三种。<br>所谓“代码段”就是一段文本形式的代码。<br>首先，全局代码是一种，这个应该没有非议，本来就是手写文本到<code>&lt;script&gt;</code>标签里面的。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q5.png" alt=""></p><p>其次，eval代码接收的也是一段文本形式的代码。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q6.png" alt=""></p><p>最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q7.png" alt=""></p><p>这样解释应该能理解了。</p><p>最后，eval不常用，也不推荐大家用。</p><h2 id="2-简述执行上下文（下）："><a href="#2-简述执行上下文（下）：" class="headerlink" title="2.简述执行上下文（下）："></a>2.简述执行上下文（下）：</h2><p>继续上面的内容。<br>上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：</p><ul><li>变量、函数表达式——变量声明，默认赋值为undefined；</li><li>this——赋值；</li><li>函数声明——赋值；</li></ul><p>如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q8.png" alt=""></p><p>以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，<span style="background-color:#fffa7d">函数每被调用一次，都会产生一个新的执行上下文环境。</span>因为不同的调用可能就会有不同的参数。</p><p>另外一点不同在于，<span style="background-color:#fffa7d">函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。</span>至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q9.png" alt=""></p><p>好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。</p><p>全局代码的上下文环境数据内容为：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q10.png" alt=""></p><p>如果代码段是函数体，那么在此基础上需要附加：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q11.png" alt=""></p><p>给执行上下文环境下一个通俗的定义——<span style="background-color:#fffa7d">在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。</span></p><p><span style="font-size:14px;font-family:楷体">了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！</span></p><p>讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。</p><h2 id="3-执行上下文栈"><a href="#3-执行上下文栈" class="headerlink" title="3.执行上下文栈"></a>3.执行上下文栈</h2><p>继续上文的内容。</p><p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。<span style="background-color:#fffa7d">处于活动状态的执行上下文环境只有一个。</span></p><p><span style="background-color:#fffa7d">其实这是一个压栈出栈的过程——执行上下文栈</span>。 如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q12.png" alt=""></p><p>可根据以下代码来详细介绍上下文栈的压栈、出栈过程。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q13.png" alt=""><br>如上代码。</p><p>在执行代码之前，首先将创建全局上下文环境。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q14.png" alt=""></p><p>然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q15.png" alt=""></p><p>执行到第13行，调用bar函数。<br>跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q16.png" alt=""></p><p>并将这个执行上下文环境压栈，设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q17.png" alt=""></p><p>执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q18.png" alt=""></p><p>待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q19.png" alt=""></p><p>同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q20.png" alt=""></p><p>好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。</p><p>讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。</p><p>要说闭包，咱们还得先从自由变量和作用域说起。</p><h2 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4.作用域"></a>4.作用域</h2><p>提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q21.png" alt=""></p><p>再比如for语句：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q22.png" alt=""></p><p>所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q23.png" alt=""></p><p>其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——<span style="background-color:#fffa7d;font-weight:700">javascript除了全局作用域之外，只有函数可以创建的作用域。</span></p><p>所以，<span style="background-color:#fffa7d">我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。</span></p><p>jQuery就是一个很好的示例：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q24.png" alt=""></p><p>下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q25.png" alt=""></p><p>如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，<span style="background-color:#fffa7d">作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。</span>例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。<br><br><br><br></p><p><span style="background-color:#fffa7d">作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</span>例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。<br>说到这里，咱们又可以拿出jquery源码来讲讲了。<br>jQuery源码的最外层是一个自动执行的匿名函数：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q26.png" alt=""></p><p>为什么要这样做呢？</p><p>原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。</p><p>全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。</p><p>作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。<br>下一节将把作用域和执行上下文环境结合起来说一说。<br>可见，要理解闭包，不是一两句话能说清楚的。</p><h2 id="5-作用域和上下文环境"><a href="#5-作用域和上下文环境" class="headerlink" title="5.作用域和上下文环境"></a>5.作用域和上下文环境</h2><p>上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q27.png" alt=""></p><p>如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，<span style="background-color:#fffa7d">作用域在函数定义时就已经确定了。而不是在函数调用时确定</span>。</p><p>下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。另外，对上下文环境不了解的朋友，可以回过头看看前面。</p><p>第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q28.png" alt=""></p><p>第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q29.png" alt=""></p><p>第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q30.png" alt=""></p><p>第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q31.png" alt=""></p><p>第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q32.png" alt=""></p><p>第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q33.png" alt=""></p><p>结束了 ！</p><p>最后我们可以把以上这几个图片连接起来看看。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q34.png" alt=""></p><p>连接起来看，还是挺有意思的。<span style="background-color:#fffa7d">作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值</span>。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，<span style="background-color:#fffa7d">作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了</span>。</p><p>所以，<span style="background-color:#fffa7d">如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值</span>。</p><p>虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。</p><p>以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。</p><h2 id="6-从自由变量到作用域链"><a href="#6-从自由变量到作用域链" class="headerlink" title="6.从自由变量到作用域链"></a>6.从自由变量到作用域链</h2><p>先解释一下什么是“自由变量”。</p><p>在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q35.png" alt=""></p><p>如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？<br>有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q36.png" alt=""></p><p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——<span style="background:#fffa7d">要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记</span>——其实这就是所谓的“静态作用域”。</p><p>对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。</p><p>上面描述的只是跨一步作用域去寻找。</p><p>如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。<br>这个一步一步“跨”的路线，我们称之为——<span style="background:#fffa7d">作用域链</span>。<br>我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）</p><ul><li>第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</li><li>第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</li><li>第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</li><li>第四步，跳转到第一步。</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q37.png" alt=""></p><p>以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。</p><p>这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。</p><p>接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。</p><h2 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.闭包</h2><p>前面提到的上下文环境和作用域的知识，一方面是必须了解的知识，一方面也是理解闭包的基础。<br>至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。<br><span style="background-color:#fffa7d">但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递</span>。<br>闭包的作用，简而言之一句话：<span style="background-color:#fffa7d">可以在其他的执行上下文中，访问到函数的内部变量</span>。</p><p><strong>第一，函数作为返回值</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q38.png" alt=""></p><p>如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。</p><p><strong>第二，函数作为参数被传递</strong></p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q39.png" alt=""></p><p>如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p><p>上一节讲到自由变量跨作用域取值时，曾经强调过：<span style="background-color:#fffa7d">要去创建这个函数的作用域取值，而不是“父作用域”</span>。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。</p><p>另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。</p><p>在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。<br>但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。<span style="background-color:#fffa7d">这就是需要理解闭包的核心内容</span>。</p><p>咱们可以拿本文的第一段代码（稍作修改）来分析一下。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q40.png" alt=""></p><p>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q41.png" alt=""></p><p>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q42.png" alt=""></p><p>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。<span style="background-color:#fffa7d">注意，重点来了</span>：因为执行fn()时，<span style="background-color:#fffa7d">返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域</span>.。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</p><p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。</p><p>——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q43.png" alt=""></p><p>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q44.png" alt=""></p><p>执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p><p>这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</p><p><span style="background-color:#fffa7d">使用闭包会增加内容开销，现在很明显了吧</span>！</p><p>第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。</p><p>正如我们所看到的，闭包和作用域、上下文环境有着密不可分的关系。</p><p>另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，<span style="background-color:#fffa7d">像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么</span>，因为这些BUG可能完全在你的知识范围之外。</p><p>到现在闭包就简单介绍完了。</p><h2 id="8-补充：上下文环境和作用域的关系"><a href="#8-补充：上下文环境和作用域的关系" class="headerlink" title="8.补充：上下文环境和作用域的关系"></a>8.补充：上下文环境和作用域的关系</h2><p>本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。</p><p>在说明之前，咱们先用简单的语言来概括一下这两个的区别。</p><h4 id="8-1-上下文环境："><a href="#8-1-上下文环境：" class="headerlink" title="8.1. 上下文环境："></a>8.1. 上下文环境：</h4><p>可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？</p><p>另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？</p><h4 id="8-2-作用域："><a href="#8-2-作用域：" class="headerlink" title="8.2. 作用域："></a>8.2. 作用域：</h4><p>首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。</p><h4 id="8-3-两者："><a href="#8-3-两者：" class="headerlink" title="8.3. 两者："></a>8.3. 两者：</h4><p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。<br><br></p><p>上面的文字不理解没关系，且看下面的例子。</p><p>第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q45.png" alt=""></p><p>第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q46.png" alt=""></p><p>第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q47.png" alt=""></p><p>第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q48.png" alt=""></p><p>第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。<span style="background-color:#fffa7d">但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境</span>。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85/q49.png" alt=""></p><p>讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。</p><p>目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
            <tag> 执行上下文 </tag>
            
            <tag> 作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解line-height</title>
      <link href="/2019/02/20/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/"/>
      <url>/2019/02/20/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><h3 id="1-相关概念普及："><a href="#1-相关概念普及：" class="headerlink" title="1.相关概念普及："></a>1.相关概念普及：</h3><p>1.1 <span style="background-color:#fffa7d">顶线，中线，基线和底线</span> ：<br>直接见下图。inline-block和inline都可以有这四种线。其中，我们重点研究基线，即base line。基线并不是汉字文字的下端沿，而是英文字母“x”的下端沿。<br>1.2 <span style="background-color:#fffa7d">行高</span>：<br>即line-height，是指同一个元素中，两个文本行基线间的垂直距离。<br><a id="more"></a></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span><span class="token number">170</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">16</span>px<span class="token punctuation">;</span><span class="token property">line-height</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     I'm the first line     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">16</span>px<span class="token punctuation">;</span> <span class="token property">line-height</span><span class="token punctuation">:</span><span class="token number">40</span>px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     I'm the second line     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line1.png" alt=""><br>比如上图或者下图中两条红线之间的距离。<br>1.3 <span style="background-color:#fffa7d">行距</span>：上行的底线和下一行的顶线之间的距离就是行距，行距的一半称为半行距<br>1.4 <span style="background-color:#fffa7d">字体大小</span>：即font-size，是指同一行的顶线和底线之间的距离</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line2.png" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line3.png" alt=""><br>从上图我们就可以看出，行距、font-size与行高之间的关系满足</p><blockquote><p>行距 = （行高 - font-size）</p></blockquote><p>当font-size等于行高时，行距 = 0，如下图<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line4.png" alt=""><br>而当font-size大于行高时，行距为负值，则两行重叠，如下图：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line4%20%5B2%5D.png" alt=""></p><p>1.5 <span style="background-color:#fffa7d">CSS boxes的四种类型（containing boxes、inline boxes、line boxes、content area)</span></p><p>1.5.1 content area （内容区）：<br>内容区是包围着文字的一种box，无法显示出来。<br>在没有其他因素 (比如padding) 的影响时，内容区的高度即为font-size。</p><p>1.5.2 inline box (行内框) ：<br>每个行内元素会生成一个行内框，行内框是一个浏览器渲染模型中的一个概念，无法显示出来。<br>在没有其他因素 (比如padding) 的影响时，行内框的高度即为内容区的高度；<br>设定line-height后，实际改变的是行距，行内框的高度将由 内容区 变为 内容区＋行距。因此，此时会有行内框高度=行高。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line5.png" alt=""></p><p>1.5.3 3.line box（行框） ：<br>行框是指本行的一个虚拟的矩形框，由该行中一个个行内框组成。行框也是浏览器渲染模式中的一个概念，无法显示出来。<br>行框高度等于本行中所有行内框高度的最大值。当有多行内容时，每一行都有自己的行框。<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line6.png" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line7.png" alt=""></p><p>1.5.4 containing box（包含框）：<br>包裹着上述三种box的box<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line8.png" alt=""><br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line9.png" alt=""></p><h3 id="2-line-height的取值方法与继承"><a href="#2-line-height的取值方法与继承" class="headerlink" title="2. line-height的取值方法与继承"></a>2. line-height的取值方法与继承</h3><p>一般而言，line-height只影响行内元素( 包括行内替换元素和行内非替换元素，如img和span )，并不能直接应用于块级元素。但是line-height 具有可继承性，块级元素的子元素会继承该特性，并且在行内元素上生效。</p><p>一般情况下，浏览器默认的line-height为1.2。可以自定义 line-height 覆盖这个初始值，那么该怎样设置line-height呢？有以下5种方式：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line10.png" alt=""></p><p>line-height是个<span style="background-color:#fffa7d">可继承</span>属性，它的继承规则比较复杂。需要提前说明的是：line-height的大小与font-size息息相关，除了指定line-height为多少px，剩下的设置方式都是<span style="background-color:#fffa7d">基于font-size</span>算出来的。 下面一一解释。</p><ul><li>inherit ：继承父元素line-height的值，所以父元素的是多少就是多少。 如果其后代元素不设置line-height 的话，也会是这个值。</li><li>数字＋px： 假设设置 line-height 为20px，那么该行的行高就是20px，与 font-size 无关，不会随着 font-size 做相应比例的缩放。 这个长度值（20px）会被后代元素继承，所有的后代元素会使用这个相同的、继承的 line-height (20px)，除非后代元素设定 line-height 。</li><li>数字＋％ ：假设自身的 font-size 为16px，line-height 设为120%。那么其行高为：16 * 120% = 19.2px。即 line-height 是根据自身的 font-size 计算出来的。 子元素会继承父元素的line-height，它继承的不是百分比而是父元素line-height计算后的最终值。</li><li>normal ：假设设置line-height 为 normal ，则会根据浏览器的解析情况给元素分配一个倍数，一般是1.2，即line-height为字体的1.2倍。与上一个不同的是，其子元素不再继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line11.png" alt=""><br>可见，子元素随着自身 font-size 的大小而做相应比例的缩放。</li><li>纯数字/缩放因子 ：如果既想要 normal 的灵活，又想设置一个自定义的值，那就要用 纯数字 。纯数字方式与 normal 唯一的不同，在于数值的大小不一定是1.2，而是完全由你自己决定。同样地，其子元素不是继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~</li></ul><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line12.png" alt=""></p><p>总结如下：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height/line13.png" alt=""></p><p>那么，哪一种是最好的方式呢？ 一般来数，设置行高的值为<span style="background-color:#fffa7d">纯数字</span>是最推荐的方式，因为其会随着对应的 font-size 而缩放。</p><h3 id="3-line-height实现垂直居中的原理"><a href="#3-line-height实现垂直居中的原理" class="headerlink" title="3 line-height实现垂直居中的原理"></a>3 line-height实现垂直居中的原理</h3><p>通常情况下，div中的a标签包含文本，文本将默认出现在div的顶端，如果想要垂直居中，可以设置div的高度等于行高，由于行高不直接作用于块状元素且行高可以继承，所以实际上等效于设置a的行高等于div的高度。</p><p>a的行高即a的行内框高度，即 内容区＋行距。行高默认是浏览器分配的1.2，由于此时重新设置了行高☞☞所以行距跟着改变☞☞所以内容区上下往外延伸☞☞即行内框整体延伸。但是，文字始终在行内框里垂直居中，行内框延伸的终点是div的高度，也就是延伸至行内框高度等于div高度。此时，文本自然会在div中垂直居中。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> HTML &amp; CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery AJAX load()方法中代码执行顺序的问题</title>
      <link href="/2019/02/18/F-jQuery%20AJAX%20load()%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/02/18/F-jQuery%20AJAX%20load()%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p>问题来源于菜鸟教程介绍 jQuery <code>load()</code> 方法时用的一个实例：<br><a id="more"></a><br><strong>JS：</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"button"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#div1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token string">"demo_test.txt"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>responseTxt<span class="token punctuation">,</span>statusTxt<span class="token punctuation">,</span>xhr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>statusTxt<span class="token operator">==</span><span class="token string">"success"</span><span class="token punctuation">)</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"外部内容加载成功!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>statusTxt<span class="token operator">==</span><span class="token string">"error"</span><span class="token punctuation">)</span>      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Error: "</span><span class="token operator">+</span>xhr<span class="token punctuation">.</span>status<span class="token operator">+</span><span class="token string">": "</span><span class="token operator">+</span>xhr<span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>HTML：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>div1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>使用 jQuery AJAX 修改该文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>获取外部内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里作为load方法参数的函数是一个回调函数。什么是回调函数呢？我们先来看看回调的英文定义：</p><blockquote><p>A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。</p></blockquote><p>字面上的理解，回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。那么根据这个解释，这段代码应该是先执行 <code>load(&quot;demo_test.txt&quot;)</code> 加载外部内容，之后再执行回调函数弹出 alert。但是实际运行后发现和预想的不一样：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/jQuery%20AJAX%20load(" alt="">方法中代码执行顺序的问题-1.png)<br><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/jQuery%20AJAX%20load(" alt="">方法中代码执行顺序的问题-2.png)</p><p>从结果来看，是先弹出 alert 再改变文本内容。那么，为什么会这样呢？难道上面的说法有误？为了进一步验证，修改代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#div1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token string">"demo_test.txt"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>responseTxt<span class="token punctuation">,</span>statusTxt<span class="token punctuation">,</span>xhr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span>responseTxt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>statusTxt<span class="token operator">==</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/jQuery%20AJAX%20load(" alt="">方法中代码执行顺序的问题-3.png)<br>很明显文本内容已经改变，说明前面关于回调函数最后执行的说法是没问题的。接着猜想，之所以先弹出 alert 再改变文本内容，可能是因为必须等回调函数执行完后才能把文本渲染到浏览器上。<br>为了进一步验证，修改代码如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#div1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token string">"demo_test.txt"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>responseTxt<span class="token punctuation">,</span>statusTxt<span class="token punctuation">,</span>xhr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>statusTxt<span class="token operator">==</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">debugger</span>；           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/jQuery%20AJAX%20load(" alt="">方法中代码执行顺序的问题-4.png)<br>控制台中没有打印出1，且程序中断，说明此时回调函数还在执行当中，但是文本内容却已经改变了。这说明上面的猜想错误—–即文本渲染到浏览器上不需要等到回调函数执行结束。<br>但是，那只是一般情况！！问题就在于，<strong>alert是可以阻塞浏览器的渲染工作的！</strong></p><p>重新运行最初的代码，可以看到还是先弹出 alert，文本没变，但是这时候点开控制台的 elements，可以看到图中红框显示这时候文本的内容其实已经改变了。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/jQuery%20AJAX%20load(" alt="">方法中代码执行顺序的问题-5.png)<br>虽然文本内容看上去不变——但是实际情况是文本内容已经改变了，也就是 <code>load()</code> 方法已经生效了，只是 alert 阻塞了浏览器将它渲染出来。<br>在这里还要注意，alert 可以阻塞浏览器的渲染，而 debugger 是没办法的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AJAX </tag>
            
            <tag> 浏览器渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解事件</title>
      <link href="/2019/02/18/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/02/18/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6-000.jpg" alt=""></p><a id="more"></a><blockquote><p><strong>事件</strong>：事件是用户或浏览器自身执行的某种动作，如 click,load 和mouseover 都是事件的名字。响应某个事件的函数叫做事件处理函数 / 事件处理程序 / 事件句柄。如果想要绑定多个函数，则需要用到事件监听器。</p></blockquote><h3 id="1-事件绑定的几种方式"><a href="#1-事件绑定的几种方式" class="headerlink" title="1. 事件绑定的几种方式"></a>1. 事件绑定的几种方式</h3><p>javascript 给 DOM 绑定事件处理函数总的来说有2种方式：在 html 文档中绑定、在 js 代码中绑定。下面的方式1、方式2属于在 html 中绑定事件，方式3、方式4和方式5属于在js代码中绑定事件，其中，方式4和5属于事件监听，而方式5是最推荐的做法。</p><h4 id="1）在html文档中绑定"><a href="#1）在html文档中绑定" class="headerlink" title="1）在html文档中绑定"></a>1）在html文档中绑定</h4><p><strong>方式1：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>函数名( )<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>方式2：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>直接写函数内容<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2）在js代码中绑定"><a href="#2）在js代码中绑定" class="headerlink" title="2）在js代码中绑定　　　　"></a>2）在js代码中绑定</h4><p><strong>方式3：</strong></p><pre class="line-numbers language-js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明：方式3也称为“DOM0级事件处理程序”。它无法绑定多个事件，当绑定多个事件的时候，只有最后一个会生效，其他皆被覆盖）</p><p><strong>方式4：</strong><br>[object].attachEvent(“事件类型”,”处理函数”)</p><p>说明：<br>①方式4也称为“IE事件处理程序”。这种方法不属于w3c标准，并且仅IE8及以下支持该方法；<br>②事件类型要加on；<br>③如下图，b中声明a函数时分配了一块内存地址 ，两个<code>dom.attachEvent(&#39;onclick&#39;,a)</code>中的a都指向的是下面定义的a；c中只是两个函数体一样的匿名函数，分别有各自的内存地址，故认为是两个不同的函数对象</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6-1.png" alt=""></p><p><strong>方式5：</strong>[object].addEventListener(“事件类型”,”处理函数”,”冒泡事件或捕获事件”);</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6-2.png" alt=""></p><p>说明：<br>①方式5也称为“DOM2级事件处理程序”。w3c正统标准，IE9及以上、Chrome、Firefox等支持该方法；<br>②事件类型不加on；<br>③第三个参数不设置的时候，默认为false即冒泡；<br>④ 同一个事件处理函数可以绑定2次,一次用于事件捕获，一次用于事件冒泡；如果绑定的是同一个事件处理函数，并且都是事件冒泡类型或者事件捕获类型，那么只能绑定一次；<br>⑤ 不同的事件处理函数可以重复绑定，这点与上面attachEvent是一样的</p><h3 id="2-事件处理函数的执行顺序"><a href="#2-事件处理函数的执行顺序" class="headerlink" title="2. 事件处理函数的执行顺序"></a>2. 事件处理函数的执行顺序</h3><p>方式123都不能实现事件的重复绑定，所以自然也就不存在执行顺序的问题。方式4和方式5可以重复绑定特性，所以需要了解下执行顺序的问题。<br>结论：<br>对于addEventListener，如果给目标的同一个事件绑定多个处理函数，先绑定的先执行。 attachEvent则刚好相反，后绑定的先执行，这是因为采用attachEvent的是IE8-，而IE8-是不支持dom事件流模型的。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">var</span> outA<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"outA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span>    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"outA"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当点击outA的时候，会依次打印出1、2、3、4。这里特别需要注意：我们是同时给outA这个元素绑定了多个onclick事件处理函数，没有涉及父子元素，所以也不涉及事件冒泡和事件捕获的问题，即addEventListener的第三个参数在这种场景下，没有什么用处，直接忽略之。如果是通过事件冒泡或者是事件捕获触发outA的click事件，那么函数的执行顺序会有变化。</p><h3 id="3-事件捕获和事件冒泡"><a href="#3-事件捕获和事件冒泡" class="headerlink" title="3. 事件捕获和事件冒泡"></a>3. 事件捕获和事件冒泡</h3><p>我们知道HTML中的元素是可以嵌套的，形成类似于树的层次关系。比如下面的代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>outA<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>outB<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>outC<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果点击了最内侧的outC，那么外侧的outB和outC算不算被点击了呢？很显然算，不然就没有必要区分事件冒泡和事件捕获了，这一点各个浏览器厂家也没有什么疑义。假如outA、outB、outC都注册了click类型事件处理函数，当点击outC的时候，触发顺序是A–&gt;B–&gt;C，还是C–&gt;B–&gt;A呢？如果浏览器采用的是事件冒泡，那么触发顺序是C–&gt;B–&gt;A，由内而外，像气泡一样，从水底浮向水面；如果采用的是事件捕获，那么触发顺序是A–&gt;B–&gt;C，从上到下，像石头一样，从水面落入水底。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6-3.png" alt=""></p><p>一般来说事件冒泡机制用的更多一些，所以在IE8以及之前，IE只支持事件冒泡。IE9+/FF/Chrome这2种模型都支持，可以通过addEventListener的第三个参数来设定，false代表事件冒泡，true代表事件捕获。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> outA <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"outA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">var</span> outB <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"outB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">var</span> outC <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"outC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 使用事件冒泡</span>        outA<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outB<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        outC<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"outA"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"outB"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"outC"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用的是事件冒泡，当点击outC的时候，打印顺序是3–&gt;2–&gt;1。如果将false改成true使用事件捕获，打印顺序是1–&gt;2–&gt;3。</p><h3 id="4-DOM事件流"><a href="#4-DOM事件流" class="headerlink" title="4. DOM事件流"></a>4. DOM事件流</h3><h4 id="4-1-事件流定义："><a href="#4-1-事件流定义：" class="headerlink" title="4.1  事件流定义："></a>4.1 事件流定义：</h4><p>事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点与根节点之间按照特定的顺序如流水一样传播，路径所经过的所有节点都会收到该事件，这个传播过程即事件流。</p><h4 id="4-2-事件流模型："><a href="#4-2-事件流模型：" class="headerlink" title="4.2 事件流模型："></a>4.2 事件流模型：</h4><p>事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。</p><blockquote><p><strong>冒泡型事件流</strong>：事件的传播是从最特定的事件目标到最不特定的事件目标。即<strong>由内到外</strong><br><strong>捕获型事件流</strong>：事件的传播是从最不特定的事件目标到最特定的事件目标。即<strong>由外到内</strong></p></blockquote><h4 id="4-3-DOM事件流："><a href="#4-3-DOM事件流：" class="headerlink" title="4.3 DOM事件流："></a>4.3 DOM事件流：</h4><h5 id="4-3-1-dom事件流定义："><a href="#4-3-1-dom事件流定义：" class="headerlink" title="4.3.1 dom事件流定义："></a>4.3.1 dom事件流定义：</h5><p>DOM标准采用捕获+冒泡的DOM事件流。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6-4.png" alt=""></p><h5 id="4-3-2-dom事件流包括："><a href="#4-3-2-dom事件流包括：" class="headerlink" title="4.3.2  dom事件流包括："></a>4.3.2 dom事件流包括：</h5><p>DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。<br><em>事件捕获阶段：<strong>实际目标</strong><code>(&lt;div&gt;)</code>在捕获阶段<strong>不会接收事件</strong>。也就是在捕获阶段，事件从document到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>就停止了。上图中为1~3.</em><br><em>处于目标阶段：事件在<code>&lt;div&gt;</code>上发生并处理。但是<strong>事件处理会被看成是冒泡阶段的一部分</strong>。</em><br><em>冒泡阶段：事件又传播回文档。</em></p><h5 id="4-3-3-dom事件流与冒泡、捕获"><a href="#4-3-3-dom事件流与冒泡、捕获" class="headerlink" title="4.3.3 dom事件流与冒泡、捕获"></a>4.3.3 dom事件流与冒泡、捕获</h5><p>将DOM事件流看作整个过程，那么其实 useCapture=false意味着：<span style="color:red;font-weight:700">将该事件处理函数加入到冒泡阶段</span>，在冒泡阶段会被调用；useCapture=true意味着：<span style="color:red;font-weight:700">将该事件处理函数加入到捕获阶段</span>，在捕获阶段会被调用。从DOM事件流模型可以看出，捕获阶段的事件处理函数，一定比冒泡阶段的事件处理函数先执行。</p><h5 id="4-3-4-dom事件流的相关概念"><a href="#4-3-4-dom事件流的相关概念" class="headerlink" title="4.3.4   dom事件流的相关概念"></a>4.3.4 dom事件流的相关概念</h5><p>1） target:<br>触发事件的某个具体对象，固定不变的。<br>2） currentTarget:<br>绑定事件的对象，恒等于this，可能出现在事件流的任意一个阶段中。动态变化的。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6-5.png" alt=""></p><p>控制台：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6-6.png" alt=""></p><p>点击最里面的son3后，可以看到target一直不变，而由于冒泡，导致currentTarget动态变化。</p><p>3） 两者的应用场合<br>通常情况下target和currentTarget是一致的，我们只要使用terget即可，但有一种情况必须区分这三者的关系，那就是在父子嵌套的关系中，父元素绑定了事件，单击了子元素（根据事件流，在不阻止事件流的前提下他会传递至父元素，导致父元素的事件处理函数执行），这时候currentTarget指向的是父元素，因为他是绑定事件的对象，而target指向了子元素，因为他是触发事件的那个具体对象</p><p><strong>PS</strong>：<br>注意！！！并非所有的事件都会经过冒泡阶段 。所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。</p><h3 id="5-DOM事件流中的“事件处理函数的执行顺序”"><a href="#5-DOM事件流中的“事件处理函数的执行顺序”" class="headerlink" title="5. DOM事件流中的“事件处理函数的执行顺序”"></a>5. DOM事件流中的“事件处理函数的执行顺序”</h3><p>我们回头再来说事件处理函数的执行顺序。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6-7.png" alt=""></p><p>点击outC的时候，打印顺序是 :<br>capture1–&gt;capture2–&gt;target2–&gt;target1–&gt;bubble2–&gt;bubble1。<br>由于outC是我们触发事件的目标对象，在outC上注册的几个事件处理函数都属于DOM事件流中的目标阶段。对同一个绑定对象（这里是outC）而言，同处于目标阶段的多个函数的执行顺序：先注册的先执行，后注册的后执行。这就是上面我们说的，在目标对象（outC）上绑定的函数是采用捕获，还是采用冒泡，都没有什么关系，因为冒泡和捕获只是对父元素上的函数执行顺序有影响，对自己没有什么影响。<br>至此我们可以给出事件函数执行顺序的结论了：</p><blockquote><p><strong>捕获阶段的处理函数最先执行，其次是目标阶段的处理函数，最后是冒泡阶段的处理函数。目标阶段的处理函数如果有多个，则先注册的先执行，后注册的后执行。</strong></p></blockquote><h3 id="6-阻止事件冒泡和捕获"><a href="#6-阻止事件冒泡和捕获" class="headerlink" title="6. 阻止事件冒泡和捕获"></a>6. 阻止事件冒泡和捕获</h3><p>默认情况下，多个事件处理函数会按照DOM事件流模型中的顺序执行。如果子元素上发生某个事件，不需要执行父元素上注册的事件处理函数，那么我们可以停止捕获和冒泡，避免没有意义的函数调用。前面提到的5种事件绑定方式，都可以实现阻止事件的传播。由于第5种方式，是最推荐的做法。所以我们基于第5种方式，看看如何阻止事件的传播行为。<br>注意：<br>IE8以及IE8之前可以通过 window.event.cancelBubble=true阻止事件的继续传播；IE9+/FF/Chrome通过event.stopPropagation()阻止事件的继续传播。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6-8.png" alt=""></p><p>当点击outC的时候，打印出capture–&gt;target，不会打印出bubble。<br>因为当事件传播到outC上的处理函数时，通过stopPropagation阻止了事件的继续传播，所以不会继续传播到冒泡阶段。想要在哪个节点阻止传播，就在哪个节点的事件处理函数中添加stopPropagation，记得要传参。</p><h3 id="7-事件代理-事件委托"><a href="#7-事件代理-事件委托" class="headerlink" title="7. 事件代理/事件委托"></a>7. 事件代理/事件委托</h3><h4 id="7-1-概述："><a href="#7-1-概述：" class="headerlink" title="7.1 概述："></a>7.1 概述：</h4><p>事件委托又叫事件代理。JavaScript高级程序设计上讲:事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。我们可以用取快递的例子来理解这个东西。</p><p>假设：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台也会在收到寄给新员工的快递后核实并代为签收。</p><p>这里其实还有2层意思的：<br>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；<br>第二，新员工也是可以被前台代为签收的，即程序中新添加的dom节点也是有事件的。</p><h4 id="7-2-为什么要使用事件委托："><a href="#7-2-为什么要使用事件委托：" class="headerlink" title="7.2 为什么要使用事件委托："></a>7.2 为什么要使用事件委托：</h4><blockquote><p>简单来说，就是为了减少不必要的dom操作，优化性能。</p></blockquote><p>一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？</p><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p><p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了。比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢？如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，自然性能就会更好。</p><h4 id="7-3-事件委托的原理："><a href="#7-3-事件委托的原理：" class="headerlink" title="7.3 事件委托的原理："></a>7.3 事件委托的原理：</h4><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><h4 id="7-4-事件委托如何实现："><a href="#7-4-事件委托如何实现：" class="headerlink" title="7.4 事件委托如何实现："></a>7.4 事件委托如何实现：</h4><p>终于到了本文的核心部分了。在介绍事件委托的方法之前，我们先来看例一：<br>需求：不管点击哪个li，都能弹出123：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ul1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>333<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>444<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>aLi<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作:首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；<br>那么我们用事件委托的方式做又会怎么样呢？</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oUl<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们让父级ul监听点击事件，则不管是哪个li被点击————由于冒泡原理，事件最终都会冒泡到ul上，触发ul上的点击事件，弹出123。当然，这里当点击ul的时候，也是会触发的。</p><p>那么问题就来了，如果我想让<strong>事件代理的效果</strong>跟<strong>直接给某个指定的节点的事件效果</strong>一样怎么办？比如说只有点击li才会触发，不怕，我们有绝招：</p><blockquote><p>事件本身是一个对象，即Event对象，事件发生时该对象作为参数传给回调函数。而Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称之为事件源.</p></blockquote><p>也就是说，target可以表示为当前的事件直接操作的那个dom。当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>　　<span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　oUl<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">{</span>　　　　<span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>　　　　<span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>　　　　<span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>　 　　　　　　 <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　　　　  <span class="token function">alert</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>　　　　<span class="token punctuation">}</span>　　<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！<br>上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？请看例二：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>添加<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>remove<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>删除<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>move<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>移动<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>select<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>选择<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> Add <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> Remove <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"remove"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> Move <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"move"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> Select <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"select"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Add<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'添加'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Remove<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'删除'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Move<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'移动'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Select<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'选择'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面实现的效果很简单，4个按钮对应4个不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oBox <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"box"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oBox<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span><span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLocaleLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'input'</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token string">'add'</span> <span class="token punctuation">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'添加'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token string">'remove'</span> <span class="token punctuation">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'删除'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token string">'move'</span> <span class="token punctuation">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'移动'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token string">'select'</span> <span class="token punctuation">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'选择'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的</p><p>现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？</p><p>请看例三：<br>我们的需求是是：<br>①移入li，li变红，移出li，li变白<br>②对于点击按钮后新增的li节点，仍然具有该效果。</p><p>以下是正常的方法：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>添加<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ul1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>333<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>444<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//鼠标移入变红，移出变白</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>aLi<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onmouseover <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onmouseout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'#fff'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//添加新节点</span>oBtn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">var</span> oLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oLi<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去——这是因为li遍历这一动作发生在新增li这一动作之前，在那个时候已经确定了li的个数是4，因此只绑定了4个li。这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环封装在一个函数里，命名为mHover，如下：</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">function</span> mHover <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//鼠标移入变红，移出变白</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>aLi<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onmouseover <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>onmouseout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'#fff'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>mHover <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加新节点</span>oBtn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">var</span> oLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oLi<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span><span class="token punctuation">;</span>mHover <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与上面方法不同的是，这个方法没有在新增li之前就为原有li绑定事件，而是在新增li后遍历所有的li（包括新增li），并一起绑定事件。虽然功能实现了，看着还挺好，但实际上无疑又增加了一个dom操作，在优化性能方面是不可取的，那么用事件委托的方式，能做到优化吗？</p><pre class="line-numbers language-js"><code class="language-js">window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"ul1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//事件委托，添加的子元素也有事件</span>oUl<span class="token punctuation">.</span>onmouseover <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span><span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">"red"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>oUl<span class="token punctuation">.</span>onmouseout <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span><span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">"#fff"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加新节点</span>oBtn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>num<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">var</span> oLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>oLi<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，新添加的节点是带有事件效果的。根据事件冒泡原理，不管是原有li还是新增li，只要鼠标一移入li中就等同于鼠标移入ul中，自然会触发ul的鼠标移入事件，之后我们只要在ul的事件函数中定义相关行为就可以了。<br>我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了。这样可以大大的减少dom操作，这才是事件委托的精髓所在。</p><h4 id="7-5-总结："><a href="#7-5-总结：" class="headerlink" title="7.5 总结："></a>7.5 总结：</h4><p>那什么样的事件可以用事件委托，什么样的事件不可以用呢？<br>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。<br>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。<br>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，至于focus，blur之类的就更不用说了，本身就没有冒泡的特性，自然就不能用事件委托了。</p><h3 id="8-事件对象"><a href="#8-事件对象" class="headerlink" title="8 事件对象"></a>8 事件对象</h3><h4 id="8-1-认识事件对象"><a href="#8-1-认识事件对象" class="headerlink" title="8.1 认识事件对象"></a>8.1 认识事件对象</h4><p>事件在浏览器中是以对象的形式存在的，即event对象。触发一个事件，就会产生一个event对象，该对象包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。<br>例如：鼠标操作产生的event中会包含鼠标位置的信息；键盘操作产生的event中会包含与按下的键有关的信息。<br>所有浏览器都支持event对象，但支持方式不同，在DOM中event对象必须作为唯一的参数传给事件处理函数，在IE中event是window对象的一个属性。</p><h4 id="8-2-html事件处理程序中的事件对象"><a href="#8-2-html事件处理程序中的事件对象" class="headerlink" title="8.2 html事件处理程序中的事件对象"></a>8.2 html事件处理程序中的事件对象</h4><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>click<span class="token punctuation">"</span></span><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span> console.log(<span class="token punctuation">'</span>html事件处理程序<span class="token punctuation">'</span>+event.type)<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样会创建一个包含局部变量event的函数。可通过event直接访问事件对象。</p><h4 id="8-3-DOM中的事件对象"><a href="#8-3-DOM中的事件对象" class="headerlink" title="8.3 DOM中的事件对象"></a>8.3 DOM中的事件对象</h4><p>DOM0级和DOM2级事件处理程序都会把event作为参数传入。<br>参数命名：随便。习惯上用e，或者ev或者event。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"btn"</span> type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"click"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">var</span> btn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    btn<span class="token punctuation">.</span>onclick<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"DOM0 &amp; click"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//click    }</span>    btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"DOM2 &amp; click"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//click    },false);</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DOM中事件对象的重要属性和方法。<br><strong>属性：</strong></p><ul><li>type属性，用于获取事件类型</li><li>target属性，用于获取事件直接作用的目标（更具体target.nodeName）</li><li>currentTarget属性，用于获取事件实际绑定的目标</li></ul><p><strong>方法：</strong></p><ul><li>stopPropagation()方法,用于阻止事件冒泡</li><li>preventDefault()方法,阻止事件的默认行为 移动端用的多</li></ul><h4 id="8-4-IE中的事件对象"><a href="#8-4-IE中的事件对象" class="headerlink" title="8.4 IE中的事件对象"></a>8.4 IE中的事件对象</h4><p>第一种情况： 通过DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"btn"</span> type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"click"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">var</span> btn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token punctuation">.</span>onclick<span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> event<span class="token operator">=</span>window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//click</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种情况：通过attachEvent()添加的事件处理程序，event对象作为参数传入。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"btn"</span> type<span class="token operator">=</span><span class="token string">"button"</span> value<span class="token operator">=</span><span class="token string">"click"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">var</span> btn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">"onclick"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//click</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="font-weight:bolder">IE中事件对象的重要属性和方法:</span><br>属性：</p><ul><li>type属性，用于获取事件类型(一样)</li><li>srcElement属性，用于获取事件直接作用的目标（更具体srcElement.nodeName）</li><li>cancelBubble属性，用于阻止事件冒泡。IE中cancelBubble为属性而不是方法，true表示阻止冒泡。</li><li>returnValue属性，阻止事件的默认行为。false表示阻止事件的默认行为</li></ul><p>PS：targrt和srcElement的兼容性处理如下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//兼容性处理</span><span class="token keyword">function</span> <span class="token function">showMsg</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">{</span>event<span class="token operator">=</span>event<span class="token operator">||</span>window<span class="token punctuation">.</span>event<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//IE8以前必须通过window获取event，DOM中就是个简单的传参</span><span class="token keyword">var</span> ele<span class="token operator">=</span>event<span class="token punctuation">.</span>target <span class="token operator">||</span> event<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取目标元素，DOM中用target,IE中用srcElement</span><span class="token function">alert</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考链接</strong>：<br><a href="https://blog.csdn.net/aitangyong/article/details/43231111" target="_blank" rel="noopener">https://blog.csdn.net/aitangyong/article/details/43231111</a><br><a href="http://www.cnblogs.com/starof/p/4066381.html" target="_blank" rel="noopener">http://www.cnblogs.com/starof/p/4066381.html</a><br><a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/5616484.html</a><br><a href="http://www.cnblogs.com/starof/p/4077532.html" target="_blank" rel="noopener">http://www.cnblogs.com/starof/p/4077532.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件 </tag>
            
            <tag> dom事件流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提问的智慧</title>
      <link href="/2019/02/18/T-%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/"/>
      <url>/2019/02/18/T-%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7-1.jpg" alt=""></p><a id="more"></a><p>提问领域的“圣经”，虽然很难严格按照里面的标准规范自己的行为，但是可以作为一个提醒的方式。译文应该是很长时间没维护了，因为bug被直接翻译为“臭虫”的情况屡见不鲜，但是总体上还是可以把英文原文要表达的意思说明白的。之所以放在博客，一是阅读体验，因为博客的TOC自动生成目录会使得阅读本文更加轻松；二是迁移，这类长文我认为不适合放在笔记里。主要是个人需要，所以悄悄地copy下来了，没有去要授权。</p><p>原文：<br><a href="http://doc.zengrong.net/smart-questions/cn.html?from=singlemessage" target="_blank" rel="noopener">http://doc.zengrong.net/smart-questions/cn.html?from=singlemessage</a></p><p>下面是正文</p><h2 id="提问前"><a href="#提问前" class="headerlink" title="提问前"></a>提问前</h2><p>在通过电邮、新闻组或论坛提技术问题以前，做以下事情：</p><p>1.尝试在你准备提问论坛的历史文档中搜索答案</p><p>2.尝试搜索互联网以找到答案</p><p>3.尝试阅读手册以找到答案</p><p>4.尝试阅读“常见问题文档”（FAQ）以找到答案</p><p>5.尝试自己检查或试验以找到答案</p><p>6.尝试请教懂行的朋友以找到答案</p><p>如果你是程序员，尝试阅读源代码以找到答案</p><p>提问时，请先表明你已做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中 学到的东西 ，我们喜欢回答那些表现出能从答案中学习的人。</p><p>运用某些策略，比如用谷歌（Google）搜索你遇到的各种错误提示（既搜索 谷歌论坛，也搜索网页）， 这样很可能直接就找到了解决问题的文档或邮件列表线索。 即使没有结果，在邮件列表或新闻组寻求帮助时提一句“我在谷歌中搜过下列句子但没有找到什么有用的东西” 也是件好事，至少它表明了搜索引擎不能提供哪些帮助。将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。</p><p>别着急，不要指望几秒钟的谷歌搜索就能解决一个复杂的问题。读一下常见问题文档。在向专家提问之前，先向后靠靠放松一下，再思考一下问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑抛出，只因你的第一次搜索没有结果（或者结果太多）。</p><p>认真地思考，准备好你的问题。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。</p><p>注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想 “愚蠢的问题……”，一边按将错就错的答案回复你，并且希望这种只是得到你自己“问的问题”而非真正所需的解答，给你一个教训。</p><p>永远不要假设你 有资格 得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社区贡献经验，而不仅仅是消极地要求从别人那获取知识的问题，你将“挣到”答案。</p><p>另一方面，表明你有能力也乐意参与问题的解决是个很好的开端。“有没有人能指个方向？”，我这还差点什么？”，“我应该查哪个网站？”，通常要比 “请给出我可以用的完整步骤”更容易得到回复，因为你表明了只要有人能指个方向，你就很乐意完成剩下的过程。</p><h2 id="提问时"><a href="#提问时" class="headerlink" title="提问时"></a>提问时</h2><p><strong>1.仔细挑选论坛</strong></p><p>要对在哪提问留心，如果你做了下述事情，多半会被一笔勾销或被看成“失败者”：</p><ul><li>张贴与论坛主题无关的问题</li><li>在面向高级技术问题的论坛上张贴肤浅的问题，或者反之。</li><li>在太多不同的新闻组同时张贴</li><li>给既非熟人也没有义务解决你问题的人发送你私人的电邮</li></ul><p>为保护通信的渠道不被无关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想让这种事落到自己头上的。</p><p>因此，第一步是找对论坛。谷歌和其它搜索引擎还是你的朋友，可以用它们搜索你遇到困难的软硬件问题最相关的项目网站。那里通常都有项目的常见问题（FAQ）、邮件列表及文档的链接。如果你的努力（包括 阅读 FAQ）都没有结果，这些邮件列表就是最后能取得帮助的地方。项目的网站也许还有报告bug的流程或链接，如果是这样，去看看。</p><p>向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个内容丰富的网页的作者想充当你的免费顾问，不要对你的问题是否会受到欢迎做太乐观的估计──如果你不确定，向别处发或者压根别发。</p><p>在选择论坛、新闻组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以明确你的问题是否切题。发贴前先翻翻已有的帖子，这样可以让你感受一下那里行事的方式。事实上，张贴前在新闻组或邮件列表的历史文档中搜索与你问题相关的关键词是个极好的主意，也许就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别象机关枪似的一次性“扫射”所有的帮助渠道，这就象大喊大叫一样会令人不快，温柔地一个一个来。</p><p>弄懂主题！最典型的错误之一是在某种致立于跨平台可移植的语言、库或工具的论坛中提关于 Unix 或 Windows 操作系统程序接口的问题。如果你不明白为什么这是大错，最好在搞清楚概念前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回答。有几个道理支持这点，一是看潜在的回复者有多少，二是看论坛的参与者有多少，黑客更愿回答能启发多数人的问题。</p><p>可以理解，老练的黑客和一些流行软件的作者正在承受过多的不当消息。就象那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端──已经好几次了，一些流行软件的作者退出了对自己软件的支持，因为伴随而来的涌入其私人邮箱的垃圾邮件变得无法忍受。</p><p><strong>2.面向新手的论坛和互联网中继聊天（IRC）通常响应最快</strong></p><p>本地的用户组织或者你所用的 Linux 发行版也许正在宣传新手取得帮助的论坛或 IRC 通道（在一些非英语国家，新手论坛很可能还是邮件列表），这些地方是开始提问的好去处，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 通道是公开邀请提问的地方，通常可以得到实时的回复。</p><p>事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的项目论坛或邮件列表，（否则）该项目的黑客可能仅仅回复“用 我们的 代码”。</p><p>在任何论坛发贴以前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 通道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发者保留。所以先在论坛或 IRC 中寻求与该项目相关的帮助。</p><p><strong>3.第二步，使用项目的邮件列表</strong></p><p>当某个项目存在开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文档和主页，找到项目的邮件列表并使用它。采用这种办法有几个很好的理由：</p><p>向个别开发者提的问题（如果）足够好，也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为骚扰个别开发者的理由。</p><p>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导）也许太忙以至于没法回答你的问题。</p><p>大多数邮件列表都要存档，那些存档将被搜索引擎索引，如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</p><p>如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</p><p>如果一个项目既有 “用户” 也有“开发者”（或 “黑客”）邮件列表或论坛，而你又不摆弄那些代码，向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会遭受你的噪音干扰。</p><p>然而，如果你 确信 你的问题不一般，而且在“用户” 列表或论坛中几天都没有回复，可以试试“开发者”列表或论坛。建议你在张贴前最好先暗暗地观察几天,至少看看最近几天保存的帖子,以了解那的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><p><strong>4.使用有意义且明确的主题</strong></p><p>在邮件列表、新闻组或论坛中，主题是你在五十个或更少的字以内吸引有资格专家注意的黄金机会，不要用诸如 “请帮我” （更别提大写的 “请帮我！！！！”，这种主题的消息会被条件反射式地删掉）之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题描述。</p><p>使用主题的好惯例是“对象──偏差”（式的描述），许多技术支持组织就是这样做的。在“对象”部分指明是哪一个或哪一组东西有问题，在“偏差”部分则描述与期望的行为不一致的地方。</p><p>愚蠢：<br>救命啊！我的笔记本视频工作不正常！</p><p>明智：<br>X.org 6.8.1 扭曲鼠标光标，MV1005 型号的某显卡芯片组</p><p>更明智：<br>使用 MV1005 型号的某显卡芯片组在 X.org 6.8.1 的鼠标光标被扭曲</p><p>编写 “对象──偏差”式描述的过程有助于你组织对问题的细致思考。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在 X.org 中出现？或只是在其 6.8.1 版中？是针对某显卡芯片组？或者只是其中的 MV1005 型号？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。</p><p>更一般地，想象一下在一个只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接就找到答案的线索，而不用再次发贴提问。</p><p>如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象 “Re: 测试” 或者 “Re: 新bug”的消息不太可能引起足够的注意。同时，将回复中与新主题不甚相关的引用内容尽量删除。</p><p>对于列表消息，不要直接点击回复（按钮）来开始一个全新的线索，这将限制你的观众。有些邮件阅读程序，比如 mutt，允许用户按线索排序并通过折叠线索来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变主题还不够。mutt 和其它一些邮件阅读程序还要检查邮件头主题以外的其它信息，以便为其指定线索，所以宁可发一个全新的邮件。</p><p>在论坛，因为消息与特定的线索紧密结合，并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧。不是所有论坛都允许在回复中出现分离的主题，而且这样做了基本上没有人会去看。不过，通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该线索的人读到。所以，除非你 只想 在该线索当前活跃的人群中提问，还是另起炉灶比较好。</p><p><strong>5.使问题容易回复</strong></p><p>以“请向……回复”来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，换个好点的；如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是敏感的（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如“留意本线索”、“有回复发送邮件”等功能。</p><p><strong>6.用清晰、语法、拼写正确的语句书写</strong></p><p>经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程（我敢打赌）。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将时间花在其它地方。</p><p>清楚、良好地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意（你的问题）麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它 必须 很准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将“its”混淆为“it’s”，“loose”搞成“lose”或者将“discrete”弄成 “discreet”。不要全部用大写，这会被视为无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox [注：著名黑客，Linux 内核的重要参与者] 也许可以这样做，但你不行。）</p><p>一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。也不要使用即时通讯中的简写，如将“you”简化为“u”会使你看起来象一个为了节约二次击键的半文盲式的傻子。更糟的是，如果象个小孩似地鬼画桃符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在非母语论坛提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍（是的，我们通常看得出其中的差别）。同时，除非你知道回复者使用的语言，请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被阅读就被直接删除的可能性降到最低。</p><p>如果你用英语书写但它是你的第二语言，最好提醒潜在的回复者语言上可能的困难以便绕过这个问题，比如：</p><ul><li>英语不是我的母语，请谅解拼写错误。</li><li>如果您使用某某语言，请电邮/私聊我，也许我需要您的协助翻译我的问题。</li><li>对于这个技术术语本身我很熟悉，但对于它的一些俚语或习惯表达方式就不太明白了。</li><li>我已经同时用某某语及英语提问，如果您使用两者之一回复，我很乐意翻译。</li></ul><p><strong>7.使用易于读取且标准的文件格式发送问题</strong></p><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文本而不是 HTML（超文本标注语言）（ 关闭HTML 并不难）</li><li>使用 MIME（多用途互联网邮件扩展）附件通常没有问题，前提是真正有内容（譬如附带的源文件或补丁），而不仅仅是邮件客户端程序生成的模板（譬如只是消息内容的拷贝）。</li><li>不要发送整段只是单行句子但多次折回的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的文本终端阅读邮件，设置你的行折回点小于 80 列。</li><li>但是，也 <em>不要</em> 用任何固定列折回数据（譬如日志文件拷贝或会话记录）。数据应该原样包含，使回复者确信他们看到的是与你看到的一样的东西。</li><li>在英语论坛中，不要使用’Quoted-Printable’ MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持。当它们分断时，那些文本中四处散布的 “=20”符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>永远 <em>不要</em> 指望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就象有人将还在冒热气的猪粪倒在你门口时你的反应一样。即使他们能够处理，也很厌恶这么做。</li><li>如果你从使用视窗的电脑发送电子邮件，关闭问题颇多的微软“聪明引用”功能（在“工具” -&gt; “自动纠正选项”的“输入时自动格式化”下去掉聪明引用的选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用“表情符号”和“HTML”功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。</li></ul><p>如果你使用图形用户界面的邮件客户端程序(如网景公司的 Messenger、微软公司的 Outlook 或者其它类似的)，注意它们的缺省配置不一定满足这些要求。大多数这类程序有基于菜单的“查看源码”命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。</p><p><strong>8.描述问题应准确且有内容</strong></p><ul><li>仔细、清楚地描述问题的症状</li><li>描述问题发生的环境(主机、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：“Fedora Core 7”、“Slackware 9.1”等）</li><li>描述提问前做过的研究及其理解。</li><li>描述提问前为确定问题而采取的诊断步骤。</li><li>描述最近对计算机或软件配置的任何相关改变。</li><li>如果可能，提供在可控环境下重现问题的方法。</li><li>尽最大努力预测黑客会提到的问题，并提前备好答案。</li></ul><p>如果你认为是代码有问题，向黑客提供在可控环境下重现问题的方法尤其重要。当你这么做时，得到有用且及时回复的可能性将大大增加。</p><p>西蒙.泰瑟姆（Simon Tatham）写过一篇 如何有效报告bug的文章，我强烈推荐各位阅读。</p><p><strong>9.量不在多，精炼则灵</strong></p><p>你应该（写得）精炼且有内容，简单地将一大堆代码或数据罗列在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝试将其裁剪得越小越好。</p><p>至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到 <em>有用的</em> 回复。第三，在提纯bug报告的过程中，你可能自己就找到了解决办法或权宜之计。</p><p>别急于宣称找到bug<br>当你在一个软件中遇到问题，除非你 <em>非常、非常</em> 的有根据，不要动辄声称找到了bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你（声称）发现了文档的“bug”，你应该能提供相应位置的替代文本。</p><p>记住，还有许多其它用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时就应该发现了（你在报怨前已经做了这些，是吧 ？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了bug，也就置疑了他们的能力，即使你是对的，也有可能会使其中的部分人感到不快。（此外，）在主题中嚷嚷“bug”也是特别不老练的。</p><p>提问时，即使你私下非常确信已经发现一个真正的bug，最好写得像是你做错了什么。如果真的有bug，你会在回复中看到这点。这样做的话，如果真的有bug，维护者就会向你道歉，这总比你弄砸了然后欠别人一个道歉要强。</p><p><strong>10.低声下气代替不了做自己的家庭作业</strong></p><p>有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端：“我知道我只是个可怜的新丁，一个失败者，但……”。这既使人困扰，也没有用，当伴随着对实际问题含糊的描述时还特别令人反感。</p><p>别用低级灵长类动物的办法浪费你我的时间，相反，尽可能清楚地描述背景情况和你的问题，这比低声下气更好地摆正了你的位置。</p><p>有时，论坛设有单独的初学者提问版面，如果你真的认为遇到了肤浅的问题，到那去就是了，但一样别低声下气。</p><p><strong>11.描述问题症状而不是猜测</strong></p><p>告诉黑客是什么导致了问题是没用的（如果你的诊断理论是了不起的东西，你还会向别人咨询求助吗？）。所以，确保只是告诉他们问题的原始症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述自己的猜测很重要，应清楚地说明这只是你的猜测并描述为什么它们不起作用。</p><p>愚蠢：<br>我在编译内核时接连遇到 SIG11 错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？</p><p>明智：<br>我组装的电脑（K6/233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机 20 分钟左右、做内核编译时频繁地报 SIG11 错，但在头 20 分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问题，相关的典型编译会话日志附后。</p><p>由于以上这点许多人似乎难以掌握，这里有句话可以提醒你：“所有的诊断专家都来自密苏里州”。美国国务院的官方座右铭则是“让我看看”（出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：“我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。”）针对诊断者而言，这并不是怀疑，而只是一种真实而有用的需求，以便让他们看到与你看到的原始证据尽可能一致的东西，而不是你的猜测与总结。（所以，）让我们看看。</p><p><strong>12.按时间先后罗列问题症状</strong></p><p>刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你、电脑和软件在崩溃前都做了什么。在命令行处理的情况下，有会话日志（如运行脚本工具生成的）并引用相关的若干（如20）行记录会非常有帮助。</p><p>如果崩溃的程序有诊断选项（如-v详述开关），试着选择这些能在记录中增加排错信息的选项。记住，“多”不等于“好”。试着选取适当的排错级别以便提供有用的信息而不是将阅读者淹没在垃圾中。</p><p>如果你的记录很长（如超过四段），在开头简述问题随后按时间先后罗列详细过程也许更有用。这样，黑客在读你的记录时就知道该注意哪些内容了。</p><p><strong>13.描述目标而不是过程</strong></p><p>如果你想弄清楚如何做某事（而不是报告一个bug），在开头就描述你的目标，然后才陈述遇到问题的特定步骤。</p><p>经常出现这种情况，寻求技术帮助的人在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身有问题，结果要费很大的劲才能通过。</p><p>愚蠢：<br>我怎样才能让某图形程序的颜色拾取器取得十六进制的 RGB 值？</p><p>明智：<br>我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的 RGB 值。</p><p>第二种提法是明智的，它使得建议采用更合适的工具以完成任务的回复成为可能。</p><p><strong>14.别要求私下回复电邮</strong></p><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为回复者也因为能力和学识被其它同行看到而得到某种回报。</p><p>当你要求私下回复时，此过程和回报都被中止。别这样做，让 回复者 来决定是否私下回答──如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人毫无意义。</p><p>对这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么“向我发电邮，我将为论坛归纳这些回复”将是神奇的句子。试着将邮件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你必须信守诺言。</p><p><strong>15.提问应明确</strong></p><p>漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人（假如只是因为他们承担了太多工作的话），这些人对于没有止境的时间无底洞极其敏感，所以他们也倾向于讨厌那些漫无边际的问题。</p><p>如果你明确了想让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力并间接地设定了他们为帮助你需要花费的时间和精力上限，这很好。</p><p>要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很忙的专家那里得到解答。</p><p>所以限定你的问题以使专家回答时需要付出的时间最少──这通常与简化问题还不太一样。举个例，“请问可否指点一下哪有好一点的 X 解释？”通常要比“请解释一下 X”明智。如果你的代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。</p><p><strong>16.关于代码的问题</strong></p><p>别要求他人给你出问题的代码排错而不提及应该从何入手。张贴几百行的代码，然后说一声“它不能运行”会让你得不到理睬。只贴几十行代码，然后说一句“在第七行以后，本应该显示<x>，但实际出现的是<y>”非常有可能让你得到回复。</y></x></p><p>最精确描述代码问题的方法是提供一个能展示问题的最小测试样例。什么是最小测试样例？它是对问题的展现，只需要刚好能够重现非预期行为的代码即可。如何生成一个最小测试样例？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样例（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源码并去除那些与问题无关的代码段。你能提供的最小测试样例越小越好（参见 量不在多，精炼则灵 ）。</p><p>生成一个非常小的最小测试样例并不总是可能，但尽力去做是很好的锻练，这有可能帮助你找到需要自己解决的问题。即使你找不到，黑客们喜欢看到你努力过，这将使他们更合作。</p><p>如果你只是想让别人帮忙审一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><p><strong>17.别张贴家庭作业式问题</strong></p><p>黑客们善于发现“家庭作业”式的问题。我们中的大多数人已经做了自己的家庭作业，那是该 你 做的，以便从中学到东西。问一下提示没有关系，但不是要求完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户组、论坛或（作为最后一招）在项目的“用户”邮件列表或论坛中提问。尽管黑客们 会 看出来，一些老用户也许仍会给你提示。</p><p><strong>18.删除无意义的要求</strong></p><p>抵制这种诱惑，即在求助消息末尾加上诸如“有人能帮我吗？”或“有没有答案？”之类在语义上毫无意义的东西。第一，如果问题描述还不完整，这些附加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如“是的，你可以得到帮助”和“不，没有给你的帮助”。</p><p>一般来说，避免提“是或否”类型的问题，除非你想得到 “是或否”类型的回答。</p><p><strong>19.不要把问题标记为“紧急”， 即使对你而言的确如此</strong></p><p>这是你的问题，不要我们的。宣称“紧急”极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关照。而且“紧急”或其它有类似含义的主题有可能触发垃圾过滤规则，潜在的回复者可能永远看不到你的问题！</p><p>有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌地提到这点，人们也许会有足够的兴趣快一点回答。</p><p>当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原因这样做几乎肯定不行。事实上，张贴诸如“紧急：帮我救救这个毛绒绒的小海豹！”肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄懂了再发贴也不迟。</p><p><strong>20.礼貌总是有益的</strong></p><p>礼貌一点，使用“请”和“谢谢你的关注”或者“谢谢你的关照”，让别人明白你感谢他们无偿花时间帮助你。</p><p>坦率地讲，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要（同时也不能替代它们）。黑客们一般宁可读有点唐突但技术鲜明的bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价它的）</p><p>然而，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。</p><p>（我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的“提前谢了”，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的建议是要么先说 “提前谢了”，事后 再 对回复者表示感谢，要么换种方式表达，譬如用“谢谢你的关注”或“谢谢你的关照”）。</p><p><strong>21.问题解决后追加一条简要说明</strong></p><p>问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比较恰当。</p><p>最理想的方式是向最初提问的线索回复此消息，并在主题中包含“已解决”、“已搞定”或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见线索 “问题 X”和“问题 X-已解决”的潜在回复者就明白不用再浪费时间了（除非他个人觉得“问题 X”有趣），因此可以利用此时间去解决其它问题。</p><p>追加的消息用不着太长或太复杂，一句简单的“你好──是网线坏了！谢谢大家──比尔”就比什么都没有要强。事实上，除非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。</p><p>对于有深度的问题，张贴排错历史的摘要是恰当的。描述问题的最终状态，说明是什么解决了问题，在此之后 才指明可以避免的弯路。应避免的弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。</p><p>除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。</p><p>最后，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题叙述到最后不知所终总是令人沮丧的，黑客们痒痒地渴望它们被解决。“挠痒痒”为你挣到的信誉将对你下次再次张贴提问非常非常的有帮助。</p><p>考虑一下怎样才能避免他人将来也遇到类似的问题，问问自己编一份文档或 FAQ 补丁会不会有帮助，如果是的话就将补丁发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。</p><h2 id="如何解读回答"><a href="#如何解读回答" class="headerlink" title="如何解读回答"></a>如何解读回答</h2><p><strong>1.“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸</strong><br>有一个古老而神圣的传统：如果你收到“读读该死的手册”（RTFM） 的回复，发信人认为你应该去“读读该死的手册”。他或她多半是对的，去读一下吧。</p><p>“读读该死的手册”（RTFM）有个年轻一点的亲戚，如果你收到“搜搜该死的网络”（STFW）的回复，发信人认为你应该“搜搜该死的网络”。那人多半也是对的，去搜一下吧。(更温和一点的说法是“谷歌是你的朋友！”)</p><p>在论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种关照，提问前应该先搜索一下文档。</p><p>通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息很容易找到。第二，自已找要比别人喂到嘴里能学得更多。</p><p>你不应该觉得这样就被冒犯了，按黑客的标准，回复者没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。</p><p><strong>2.如果还不明白……</strong></p><p>如果你看不懂回答，不要马上回复一个要求说明的消息，先试试那些最初提问时用过的相同工具（如手册、FAQ、网页、懂行的朋友等）试着搞懂回答。如果还是需要说明，展现你已经明白的。</p><p>譬如，假如我告诉你：“看起来象是某输入项有问题，你需要清除它”，接着是个 不好 的回帖：“什么是某输入项？”。而这是一个 很好 的跟帖：“是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？”</p><p><strong>3.对待无礼</strong></p><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱的人是很自然的。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了过格的事，邮件列表、新闻组或论坛中的前辈多半会招呼他。如果这 没有 发生而你却光火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而 你 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外来者，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，缺少用于润滑人类社会“正常”交往所需的脑电路。这既可能是真也可能是假。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们 喜欢 现在这个样子，并且一般都对病号标记有站得住脚的怀疑。）</p><p>在下一节，我们会谈到另一个问题，当 你 行为不当时会受到的“冒犯”。</p><h2 id="别像失败者那样反应"><a href="#别像失败者那样反应" class="headerlink" title="别像失败者那样反应"></a>别像失败者那样反应</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸──以本文描述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反，你该这样去做：</p><p>熬过去，这很正常。事实上，它是有益健康与恰当的。</p><p>社区的标准不会自己维持，它们是通过参与者积极而 公开 地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称“如果你不想帮助用户就闭嘴”。有思路的参与者纷纷离开的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。</p><p>是夸张的“友谊”（以上述方式）还是有用？挑一个。</p><p>记着：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要容易得多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是别人想象你搞砸了）， 有些人也会无缘无故地攻击你本人。在这种情况下，报怨倒是 真的 会把问题搞砸。</p><p>这些找茬者要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些找茬者在给自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，大多数口水战最好不要理睬──当然，是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其中之后（这也是可能的）。</p><h2 id="提问禁忌"><a href="#提问禁忌" class="headerlink" title="提问禁忌"></a>提问禁忌</h2><p>下面是些典型的愚蠢问题和黑客不回答它们时的想法。</p><p>问：我到哪可以找到某程序或 X 资源？<br>问：我怎样用 X 做 Y？<br>问：如何配置我的 shell 提示？<br>问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？<br>问：我的{程序、配置、SQL 语句}不运行了<br>问：我的视窗电脑出问题了，你能帮忙吗？<br>问：我的程序不运行了，我认为系统工具X有问题<br>问：我安装 Linux 或 X 遇到困难，你能帮忙吗？<br>问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？<br>问：<br>我到哪可以找到某程序或 X 资源？</p><p>答：<br>在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 谷歌 吗？</p><p>问：<br>我怎样用 X 做 Y？</p><p>答：<br>如果你想解决的是 Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对要解决的 Y 问题糊涂，还被特定形势禁锢了思维。等他们把问题弄好再说。</p><p>问：<br>如何配置我的 shell 提示？</p><p>答：<br>如果你有足够的智慧提这个问题，你也该有足够的智慧去 “读读该死的手册”（RTFM），然后自己去找出来。</p><p>问：<br>我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？</p><p>答：<br>试试就知道了。如果你试过，你既知道了答案，又不用浪费我的时间了。</p><p>问：<br>我的{程序、配置、SQL 语句}不运行了</p><p>答：<br>这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下：</p><p>你还有什么补充吗？</p><p>噢，太糟了，希望你能搞定。</p><p>这跟我究竟有什么关系？</p><p>问：<br>我的视窗电脑出问题了，你能帮忙吗？</p><p>答：<br>是的，把视窗垃圾删了，装个象 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方的视窗版或者与视窗有交互(如 Samba)，你 可以 问与视窗相关的问题，只是别对问题是由视窗操作系统而不是程序本身造成的回复感到惊讶，因为视窗一般来说太差，这种说法一般都成立。</p><p>问：<br>我的程序不运行了，我认为系统工具 X 有问题</p><p>答：<br>你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文档作后盾。</p><p>问：<br>我安装 Linux 或 X 遇到困难，你能帮忙吗？</p><p>答：<br>不行，我需要亲手操作你的电脑才能帮你排错，去向当地的 Linux 用户组寻求方便的帮助（你可以在 这里 找到用户组列表）</p><p>注意：如果安装问题与某 Linux 发行版有关，在针对 它 的邮件列表、论坛或本地用户组织中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 “linux”和 所有 被怀疑的硬件 [作关键词] 仔细搜索。</p><p>问：<br>我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？</p><p>答：<br>想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。</p><h2 id="好问题与坏问题"><a href="#好问题与坏问题" class="headerlink" title="好问题与坏问题"></a>好问题与坏问题</h2><p>最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。</p><p>愚蠢：我在哪能找到关于 Foonly Flurbamatic 设备的东西？<br>这个问题在乞求得到 “搜搜该死的网络”（STFW） 式的回复。</p><p>明智： 我用谷歌搜索过“Foonly Flurbamatic 2600”，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？<br>这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。</p><p>愚蠢： 我不能编译某项目的源代码，它为什么这么破？<br>提问者假设是别人搞砸了，太自大了。</p><p>明智： 某项目的源代码不能在某 Linux 6.2 版下编译。我读了常见问题文档，但其中没有与某 Linux 相关的内容。这是编译时的记录，我做错了什么吗？<br>提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，这家伙值得注意。</p><p>愚蠢： 我的主板有问题，谁能帮我？<br>某黑客对此的反应可能是：“是的，还需要帮你拍背和换尿布吗？”，然后是敲下删除键。</p><p>明智： 我在 S2464 主板上试过 X、Y 和 Z，当它们都失败后，又试了 A、B 和 C。注意我试 C 时的奇怪症状，显然某某东西正在做某某事情，这不是期望的行为。通常在 Athlon MP 主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？<br>相反地，这个人看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。</p><p>在最后那个问题中，注意“给我一个回答”与“请帮我看看我还能再做点什么测试以得到启发”之间细微但重要的差别。</p><p>事实上，最后那个问题基本上源于 2001 年 8 月 Linux 内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。</p><p>通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。</p><p>事后，当我感谢大家并评论这次良好的经历时，一个 Linux 内核邮件列表的成员谈到，他认为我得到答案并不是因为我的名字挂在列表上，而只是因为我正确的提问方式。</p><p>黑客们在某种方面是非常不留情面的精英分子。我想在这事上他是对的，如果我 表现得 象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果得不到回答，请不要认为我们不想帮你，有时只是因为被问到的小组成员的确不知道答案。没有回复不等于不被理睬，当然必须承认从外面很难看出两者的差别。</p><p>一般而言，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。</p><p>有许多在线与本地的用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。</p><p>还有众多大小商业公司提供签约支持服务，别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。</p><p>象 Linux 这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。</p><h2 id="如何更好地回答"><a href="#如何更好地回答" class="headerlink" title="如何更好地回答"></a>如何更好地回答</h2><p>态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p>对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 FAQ 都不知道。</p><p>如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p>如果帮不了忙，别妨碍。 不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。</p><p>探索性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫报怨一声“读读该死的手册”（RTFM）是正当的，指出文档的位置（即使只是建议做个谷歌关键词搜索）会更好</p><p>如果你决意回答，给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。</p><p>请回答真正的问题！如果提问者已经做了自己该做的研究，并且说明尝试过X，Y，Z，A，B与C都没有得到想要的結果，那么回复“试试A或B” 或者给出一个内容为 “试一下X，Y，Z，A，B或C”的链接将极其无益！</p><p>帮助你的社区从中学习。当回复一个好问题时，问问自己 “如何修改相关文件或 FAQ 文档以免再次解答同样的问题？”，接着再向文档维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟“授人以鱼，不如授人以渔”。</p><h2 id="补充-XY-Problem-："><a href="#补充-XY-Problem-：" class="headerlink" title="补充(XY Problem)："></a>补充(XY Problem)：</h2><p><strong>1.What is it?</strong></p><blockquote><p>The XY problem is asking about your attempted solution rather than your actual problem. This leads to enormous amounts of wasted time and energy, both on the part of people asking for help, and on the part of those providing help.</p></blockquote><ul><li>User wants to do X.</li><li>User doesn’t know how to do X, but thinks they can fumble their way to a solution if they can just manage to do Y.</li><li>User doesn’t know how to do Y either.</li><li>User asks for help with Y.</li><li>Others try to help user with Y, but are confused because Y seems like a strange problem to want to solve.</li><li>After much interaction and wasted time, it finally becomes clear that the user really wants help with X, and that Y wasn’t even a suitable solution for X.</li></ul><p>The problem occurs when people get stuck on what they believe is the solution and are unable step back and explain the issue in full.</p><p><strong>2.What to do about it?</strong></p><ol><li>Always include information about a broader picture along with any attempted solution.</li><li>If someone asks for more information, do provide details.</li><li>If there are other solutions you’ve already ruled out, share why you’ve ruled them out. This gives more information about your requirements.</li></ol><p>Remember that if your diagnostic theories were accurate, you wouldn’t be asking for help right?</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Thinking </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于dom对象和jq对象的疑问</title>
      <link href="/2019/02/18/F-%E5%85%B3%E4%BA%8Edom%E5%AF%B9%E8%B1%A1%E5%92%8Cjq%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%96%91%E9%97%AE/"/>
      <url>/2019/02/18/F-%E5%85%B3%E4%BA%8Edom%E5%AF%B9%E8%B1%A1%E5%92%8Cjq%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%96%91%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><a id="more"></a><h3 id="1-问题："><a href="#1-问题：" class="headerlink" title="1.问题："></a>1.问题：</h3><h4 id="1-1-问题提出："><a href="#1-1-问题提出：" class="headerlink" title="1.1 问题提出："></a>1.1 问题提出：</h4><p>想要使所有div下的p标签的类名+1.因此采用下列办法：</p><pre class="line-numbers language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">var</span> allp<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>allp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span><span class="token string">"i+2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果控制台报错：<br><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/j1.png" alt=""></p><p>提示<code>allp[i].attr()</code>不是一个方法，而<code>attr()</code>是jq对象的方法，这个报错等于说<code>allp[i]</code>不是一个jq对象。<br>参考<a href="https://stackoverflow.com/questions/33023806/typeerror-1-attr-is-not-a-function" target="_blank" rel="noopener">stackoverflow</a> ，可知<code>$()[i]</code>返回的的确不是jq对象，而是原生dom对象，无法使用jq方法<code>attr()</code> 。</p><p>关于如何判断是jq对象还是dom对象，可以用常用的<code>instanceof</code>方法判断，也可以用只有jq对象才有的jquery属性结合if语句判断。</p><p>那么，如何用jq实现上述功能？</p><h4 id="1-2-问题解决："><a href="#1-2-问题解决：" class="headerlink" title="1.2 问题解决："></a>1.2 问题解决：</h4><p><strong>1）转化为jq对象</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>allp<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span>allp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>allp[i]</code>放在<code>$()</code>中则为jq对象</p><p><strong>2).eq(i)</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span> 。            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为jq collection 对象的<code>eq()</code>方法将返回以参数值为索引值的单个元素.</p><p><strong>3).each遍历</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，因为each()本身可以传参，因此可以写成</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中，i表示index，n表示当前元素（可用this操作）</p><p><strong>4).或者更简单的，配合回调函数使用</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span>，<span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>        n<span class="token operator">=</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是个错误的例子。</p><ul><li><p>jq本身可以隐式迭代，所以这里的for循环完全是多余的，加了for循环反而是错的。</p><blockquote><p>隐式迭代：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用</p></blockquote></li><li><p>在attr中将回调函数作为参数时，回调函数本身接受两个参数。具体到例子中，i为index，n为当前元素的当前值，也就是类名，这里的类名虽然为1到5，但是是string而不是number，所以需要用number( )进行类型转换才可以运算。</p></li><li>n最后必须return。<br>综上，正确代码为</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> allp<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"div p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        allp<span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"class"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token function">Number</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>each( )遍历，控制台打印</p><pre class="line-numbers language-js"><code class="language-js"> allp<span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/myblog/j2.png" alt=""></p><h3 id="2-对象转换："><a href="#2-对象转换：" class="headerlink" title="2 对象转换："></a>2 对象转换：</h3><p>顺便这里总结下jq对象和dom对象的互相转换。<br>我们知道，dom对象只能用dom对象自己的方法，jq对象只能用jq对象自己的方法，因此有时候如果jq对象必须使用原生方法时（或者反过来），就需要进行对象转换。</p><h4 id="2-1-jq对象-gt-dom对象"><a href="#2-1-jq对象-gt-dom对象" class="headerlink" title="2.1 jq对象 = &gt; dom对象"></a>2.1 jq对象 = &gt; dom对象</h4><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> $div<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//jq对象</span><span class="token comment" spellcheck="true">// 或者加索引值返回dom对象单体</span><span class="token keyword">var</span> div<span class="token operator">=</span>$div<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用get()方法返回dom对象单体</span><span class="token keyword">var</span> div<span class="token operator">=</span>$div<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-dom对象-gt-jq对象"><a href="#2-2-dom对象-gt-jq对象" class="headerlink" title="2.2 dom对象 = &gt; jq对象"></a>2.2 dom对象 = &gt; jq对象</h4><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> div<span class="token operator">=</span>documnet<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//dom对象</span><span class="token comment" spellcheck="true">// 直接用$()把dom对象给包装起来</span><span class="token keyword">var</span> $div<span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果需要，可以用eq()返回jq对象单体</span><span class="token comment" spellcheck="true">// $div.eq(i);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量命名规范</title>
      <link href="/2019/02/12/F-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/2019/02/12/F-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><h3 id="一、驼峰命名法："><a href="#一、驼峰命名法：" class="headerlink" title="一、驼峰命名法："></a>一、驼峰命名法：</h3><p><br><strong>①全部小写</strong>：变量名中的每一个逻辑断点/每个单词都用下划线隔开。比如：print_employee_paychecks()；<br><strong>②大小写混合</strong>：<br>1）<em>小驼峰法</em>：<br>变量一般用小驼峰法标识。第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstName、myLastName<br>2）<em>大驼峰法/帕斯卡命名法（Upper Camel Case/pascal）</em>：<br>常用于类名，函数名，属性，命名空间。相比小驼峰法，大驼峰法把第一个单词的首字母也大写了。例如：DataBaseUser<br><a id="more"></a></p><h3 id="二、匈牙利命名法："><a href="#二、匈牙利命名法：" class="headerlink" title="二、匈牙利命名法："></a>二、匈牙利命名法：</h3><p>基本原则是：变量名=类型+对象描述。</p><p>匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。</p><p>匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等。这些符号可以多个同时使用，顺序是先m_（成员变量），再指针，再简单数据类型，再其他。</p><p>例如：m_lpszStr, 表示指向一个以0字符结尾的字符串的长指针成员变量。</p><p>匈牙利命名法中常用的小写字母的前缀：</p><p>前缀 类型<br>a – – — – – —— —————– 数组 (array)<br>b ———————————- 布尔值 (boolean)<br>by———————————- 字节 (byte)<br>c ———————————- 有符号字符 (char)<br>cb ————————– 无符号字符 (char Byte，没有多少人用)<br>cr ———————————- 颜色参考值 (colorRef)<br>fn ———————————- 函数 （function）<br>fl ———————————- 浮点（float）<br>h ———————————- 句柄（handle）<br>i ———————————- 整型 （int）<br>l ———————————- 长整型 (long Int)<br>lp———————————- 长指针（long Pointer）<br>m ———————————- 类的成员 （member）<br>n———————————- 短整型 (short Int)<br>np ———————————- 近指针（near Pointer）<br>o ———————————- 对象（object）<br>p ———————————- 指针（pointer）<br>re ——————————— 正则（regular expression）<br>s ———————————- 字符串型 （string）<br>sz ————————— 以null做结尾的字符串型 (String with Zero End)</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>null 和 undefined</title>
      <link href="/2019/02/12/F-null%E5%92%8Cundefined/"/>
      <url>/2019/02/12/F-null%E5%92%8Cundefined/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><a id="more"></a><h3 id="一-undefined在变量声明中的体现："><a href="#一-undefined在变量声明中的体现：" class="headerlink" title="一. undefined在变量声明中的体现："></a>一. undefined在变量声明中的体现：</h3><p><strong>1）声明了、但是没有初始化的变量：</strong></p><p><code>var aa; alert(aa);</code></p><p>浏览器会弹出窗口显示 <code>undefined</code>。因为对于使用了 <code>var</code> 声明但没有进行初始化定义的变量, 其值默认为 <code>undefined</code>。</p><p><strong>2） 未声明的变量(1)：</strong></p><p><code>alert(aa);</code></p><p>浏览器不会弹出任何东西. 因为 <code>aa</code> 是没有声明的变量。打开 chrome 浏览器的控制台会看到报错如下：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/null和undefined%20-1.png" alt=""><br><strong>3）未声明的变量(2)：</strong></p><p><code>alert(typeof aa);</code></p><p>浏览器会弹出窗口显示 undefined。对于没有声明的变量, 只能执行一种操作，即使用 typeof 操作符检验它的类型.。它的类型和声明了但没有进行初始化的变量的类型一样, 都是 undefined.</p><h3 id="二-null和undefined："><a href="#二-null和undefined：" class="headerlink" title="二. null和undefined："></a>二. null和undefined：</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token function">alert</span><span class="token punctuation">(</span>undefined <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于 <code>undefined</code> 和 <code>null</code> 的相等性测试，返回 true,如上图。这是因为，<code>undefined</code> 是由 <code>null</code> 派生而来的。但是，这两者差别很大，之所以要设置两个值，让我们从历史原因说起吧</p><p><strong>1）历史原因：</strong><br>1995年js诞生时，最初像Java一样，只设置了 <code>null</code> 作为表示”无”的值。根据C语言的传统， <code>null</code> 被设计成可以自动转为0。但是，JavaScript的设计者 Brendan Eich，觉得这样做还不够，有两个原因。首先， <code>null</code> 像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象；其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果 <code>null</code> 自动转为0，很不容易发现错误。<br>因此，Brendan Eich又额外设计了一个 <code>undefined</code>。</p><p><strong>2）最初设计：</strong><br>JavaScript的最初版本是这样区分的： <code>null</code> 是一个表示”无”的对象，转为数值时为0；<code>undefined</code> 是一个表示”无”的原始值，转为数值时为 NaN。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// NaN</span><span class="token number">5</span> <span class="token operator">+</span> undefined<span class="token comment" spellcheck="true">// NaN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3）目前的用法：</strong><br>但是，上面这样的区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。</p><p><strong>① null</strong></p><p><code>null</code> 是基本数据类型之一，值仅有一个，即为 null。表示”空对象”(因此类型检测返回对象)，即如果有对象，就会是一个具体的对象，如果没对象，就是 null。典型用法是：<br>（1） 作为函数的参数，表示该函数的参数不是对象。<br>（2） 作为对象原型链的终点。</p><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// null    </span><span class="token keyword">typeof</span> <span class="token keyword">null</span>     <span class="token comment" spellcheck="true">// object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果定义的变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。这样做不仅可以体现 <code>null</code> 作为空对象指针的惯例，而且也有助于进一步区分 <code>null</code> 和 <code>undefined</code>。<br>只要直接检查 <code>null</code> 值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>abc <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//对abc执行某些操作</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>② undefined</strong></p><p><code>undefined</code> 是基本数据类型之一，值仅有一个，即为 undefined。表示”缺少值”(因此类型检测返回 <code>undefined</code>)，即此处应该有一个值，但是还没有定义。典型用法是：<br>（1）变量被声明了，但没有赋值时，就等于 <code>undefined</code>。<br>（2) 调用函数时，应该提供的参数没有提供，该参数等于 <code>undefined</code>。<br>（3）对象没有赋值的属性，该属性的值为 <code>undefined</code>。<br>（4）函数没有返回值时，默认返回 <code>undefined</code>。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> i<span class="token punctuation">;</span>i <span class="token comment" spellcheck="true">// undefined</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// undefined</span><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>o<span class="token punctuation">.</span>p <span class="token comment" spellcheck="true">// undefined</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> exp <span class="token operator">=</span> undefined<span class="token punctuation">;</span>8x <span class="token comment" spellcheck="true">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③ 如何检测某个变量是 <code>undefined</code>：</strong></p><p>错误的用法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>abc<span class="token operator">==</span>undefined<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 正如上面所说，js规定用`==` 判断时，null和undefined是等同的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>正确的用法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>abc<span class="token punctuation">)</span> <span class="token template-string"><span class="token string">`==`</span></span> <span class="token string">"undefined"</span><span class="token punctuation">)</span>   或者最简单的办法：<span class="token keyword">if</span><span class="token punctuation">(</span>abc<span class="token operator">===</span>undefined<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意！！！ type的用法有运算符形式和函数形式，即if (typeof(abc) <code>==</code> “undefined”) 和 if (typeof abc <code>==</code> “undefined”) 效果是一样的。另外，由于typeof会返回诸如”number”的字符串形式的结果，因此==的右操作数应注意加双引号表示字符串。</p><p><strong>④ 如何检测某个变量是null：</strong></p><p>错误的用法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token number">1</span>、<span class="token keyword">if</span><span class="token punctuation">(</span>abc <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 解释同上。不过：要判断abc是 null 或者 undefined 时可使用本法。</span><span class="token number">2</span>、<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>abc<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 这个的原理是：abc为假值，则 ! abc为真值，条件成立。然而，假值也可能是undefined，0 或 false。不过：要判断 abc是null、undefined、0 或者false 时可使用本法。 </span><span class="token number">3</span>、<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> abc <span class="token operator">==</span> <span class="token string">"null"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//  为了向下兼容，abc 为 null 时，typeof null 总返回 object，所以不能这样判断。</span><span class="token number">4</span>、<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNull</span><span class="token punctuation">(</span>abc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//   VBScript 中有 IsNull 这个函数，但 JavaScript 中没有。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正确的用法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token number">1</span>、<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> abc <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> abc <span class="token operator">!=</span> <span class="token string">"undefined"</span> <span class="token operator">&amp;&amp;</span> abc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 这个的原理是：如果！abc 成立，则 abc 为假值，则 abc 要么是undefined，0，false或者null 。typeof abc!= "undefined" 排除了 undefined；exp != 0 排除了0 和 false （0= =false，0= =0）。所以，abc一定是剩下的null。</span><span class="token number">2</span>、最简单的方法：   <span class="token keyword">if</span> <span class="token punctuation">(</span>abc<span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管如此，我们在 DOM 应用中，一般只需要用 (!abc) 来判断就可以了，因为 DOM 应用中，可能返回 <code>null</code>，可能返回 <code>undefined</code>，如果具体判断 <code>null</code> 还是 <code>undefined</code> 会使程序过于复杂。</p><h3 id="三-测试对象是否存在："><a href="#三-测试对象是否存在：" class="headerlink" title="三. 测试对象是否存在："></a>三. 测试对象是否存在：</h3><p>在 JavaScript 中,<code>null</code> 用于对象, <code>undefined</code> 用于变量，属性和方法。<br>对象只有被定义才有可能为 <code>null</code>，否则为 <code>undefined</code>。因此，如果我们想测试对象是否存在，必须先检测对象是否已定义。<br>因此，这是错误的：<br><code>if (abc !== null &amp;&amp; typeof abc !== &quot;undefined&quot;)</code><br>这是正确的：<br><code>if (typeof abc !== &quot;undefined&quot; &amp;&amp; abc!== null)</code></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英伦摇滚入门：20支英国摇滚乐队</title>
      <link href="/2019/02/11/M-%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/"/>
      <url>/2019/02/11/M-%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-000.jpg" alt=""></p><a id="more"></a><p>之前看到的一篇关于英国摇滚乐队的总结。还挺好的，不全是英伦摇滚。排名不分先后，当然，我还是偏爱 Oasis。</p><h4 id="1-The-Beatles（披头士乐队-甲壳虫乐队）"><a href="#1-The-Beatles（披头士乐队-甲壳虫乐队）" class="headerlink" title="1. The Beatles（披头士乐队/甲壳虫乐队）"></a>1. The Beatles（披头士乐队/甲壳虫乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-1.jpg" alt=""><br>这支才华横溢的英国乐队就不用多说了，几乎是英国摇滚的代名词，屹立半个世纪不倒，他们的作品现在还传颂世界。The Beatles（披头士乐队）虽然早已不复存在，但是他们却奠定了英式摇滚的基本基调，在国际音乐界享有盛誉。他们的贵族式的优雅反击直击摇滚的核心精神：为普通人发出声音和呐喊。爱和自由、反战是披头士永恒的创作主题。披头士有两位灵魂人物，一位是John Lennon（约翰·列侬），一位是James Paul McCartney（保罗·麦卡特尼）。喜欢这支乐队的朋友可以看看乐评《最爱那一世的疯狂——“披头士热”下的英伦风情》<br>经典专辑：《Sergeant Pepper’s Lonely Hearts Club Band》、《Abbey Road》、《Let It Be》、《Rubber Soul》、《Help!》</p><h4 id="2-The-Rolling-Stones（滚石乐队）"><a href="#2-The-Rolling-Stones（滚石乐队）" class="headerlink" title="2. The Rolling Stones（滚石乐队）"></a>2. The Rolling Stones（滚石乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-2.jpg" alt=""><br>The Rolling Stones（滚石乐队）是一支非常长寿的英国摇滚乐队，一直活跃在英国的摇滚乐坛，他们和披头士分庭抗礼，代表着两种不同的摇滚理念：披头士是温和的、优雅的，而滚石则是纯粹的、爆裂性的。滚石乐队成员的平均年龄已经超过了70岁，堪称英国摇滚界的活国宝，他们身先士卒证明了什么叫“老骥伏枥，志在千里”。几个“老头子”处处践行着不服老的摇滚心态，依然能够在舞台上大放光彩，不断推出新作，这才是真正的摇滚精神！绝对的硬摇滚，粗放豪气的摇滚范儿，祝福这支长寿的乐队！<br>经典专辑：《Let It Bleed》、《Beggars Banquet》、《Exile On Main Street》</p><h4 id="3-The-Who（谁人乐队）"><a href="#3-The-Who（谁人乐队）" class="headerlink" title="3. The Who（谁人乐队）"></a>3. The Who（谁人乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-3.jpg" alt=""><br>作为“布兰顿之声”的The Who（谁人乐队），他们代表着反叛与反主流的音乐风格，他们是MOD文化的代言人，四人个性放荡不羁，反叛而激进，为青年而歌，为底层人民而歌。正是The who发明了摇滚乐的砸琴砸摔鼓的表演风格，他们是纯粹硬摇乐队，是反叛的象征，他们的舞台表演风格为后世许多的摇滚乐队所模仿。The Who创造了许多的经典歌曲，至今无人能够超越。<br>经典专辑：《Who’s Next》、《Tommy》、《My Generation》</p><h4 id="4-The-Police（警察乐队）"><a href="#4-The-Police（警察乐队）" class="headerlink" title="4. The Police（警察乐队）"></a>4. The Police（警察乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-4.jpg" alt=""><br>想听慢摇风格的乐迷看过来，这支乐队非常具有传奇色彩，他们靠着借贷创作的第一张专辑就大卖一万多张。他们的乐队风格有一种华丽的英式抒情的感觉，感觉主唱的爆破音特别重，他们的歌曲特别有感染力，另外主唱Sting还会唱西班牙语，非常多才多艺。这支乐队只有三个人，但是曾经获得了六次格莱美奖，乐队在义演散场之后宣布告别，但是灵魂人物Sting现在还活跃在英国乐坛之上，还多次斩获格莱美。<br>经典专辑：《Regatta de Blanc》、《Zenyatta Mondatta》、《Wrapped Around Your Finger》</p><h4 id="5-Pink-Floyd（平克·弗洛伊德）"><a href="#5-Pink-Floyd（平克·弗洛伊德）" class="headerlink" title="5. Pink Floyd（平克·弗洛伊德）"></a>5. Pink Floyd（平克·弗洛伊德）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-5.jpg" alt=""><br>大PF是必须要说的，促使我去了解英国摇滚乐队的就是披头士和Pink Floyd（平克·弗洛伊德）了，PF不算是那种非常有盛誉的那种乐队，但是我就是喜欢。他们的音乐充满哲学的思辨气质和浪漫主义的想象力，专辑的艺术感极强，尤其是他们开创的太空迷幻摇滚，简直是致幻的LSD，令人沉醉其中不能自拔。他们在音乐技术上的突破和对迷幻摇滚新领域的开辟，都在音乐史上不可被磨灭，这支乐队有一支长达23分钟的神奇的单曲——《Echoes》，号称一曲走天下，他们的《月之暗面》（The Dark Side of The Moon）和《迷墙》（The Wall）两张专辑永垂不朽。某种程度上来说，我甚至觉得他们是一支被低估了的乐队。<br>经典专辑：《The Wall》、《The Dark Side of the Moon》、《Ummagumma》</p><h4 id="6-Sex-Pistols（性手枪乐队）"><a href="#6-Sex-Pistols（性手枪乐队）" class="headerlink" title="6. Sex Pistols（性手枪乐队）"></a>6. Sex Pistols（性手枪乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-6.jpg" alt=""><br>要说到英国的朋克摇滚，就必须要说到Sex Pistols，在1976年，性手枪参加了伦敦牛津The 100俱乐部举办的朋克音乐节，至今这个节日还被认为是朋克文化的发源地。这是一支真正的朋克乐队，有人甚至评价道：“性手枪之后再无朋克”，如果你去听了他们的音乐，就会发现这是真的。他们的音乐充满了黑色幽默和调侃，歇斯底里的反叛甚至是下流的感觉，但这就是真正的朋克精神——彻底的毁灭与自我毁灭。他们的歌曾经登上了BBC排行榜榜首，让全英国人民都为朋克摇旗呼喊，让朋克文化高涨兴盛。但是这支乐队好景不长，他们连换了三个唱片公司，但乐队成员相继离开，最终没落令人十分惋惜。<br>经典专辑：《Jubilee》、《Never Mind the Bollocks Here’s the Sex Pistols》</p><h4 id="7-The-Clash（碰撞乐队-冲击乐队-冲撞乐队）"><a href="#7-The-Clash（碰撞乐队-冲击乐队-冲撞乐队）" class="headerlink" title="7. The Clash（碰撞乐队/冲击乐队/冲撞乐队）"></a>7. The Clash（碰撞乐队/冲击乐队/冲撞乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-7.jpg" alt=""><br>与性手枪相比，The Clash并不算是真正的朋克乐队，因为他们后期逐渐商业化，但是The Clash前期对朋克摇滚做出了巨大的贡献。他们的首张同名专辑就一炮成名，被封为朋克圣典。但是后期的碰撞乐队逐渐吸收了许多的流行摇滚的元素，他们的MTV商业运作得很好。The Clash与Sex Pistols一起铸就了朋克乐队的高峰。碰撞关注社会底层人民的生活状况，他们的歌曲里面充满了对失业、种族歧视和黑帮犯罪势力的反抗和控诉，而且碰撞乐队在美国市场上还比较成功，让英国朋克摇滚名声在外。<br>经典专辑：《London Calling》、《The Clash》、《Black Market Clash》</p><h4 id="8-Iron-Maiden（铁娘子乐队）"><a href="#8-Iron-Maiden（铁娘子乐队）" class="headerlink" title="8. Iron Maiden（铁娘子乐队）"></a>8. Iron Maiden（铁娘子乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-8.jpg" alt=""><br>重金属恶魔的铁娘子乐队！生猛的铁娘子！牛逼的铁娘子！正是他们开启了英国的重金属浪潮。他们是一支霸气的重金属乐队，乐队几经分合，但是做了很多的音乐新领域的尝试，他们做了很多摇滚器乐实验，奠定了铁娘子在重金属领域中的地位。Iron Maiden的曲风非常硬朗，听得人情绪高涨，不自觉地High，主唱的声音简直是绝对的歇斯底里，他们的吉他行云流水，贝斯出神入化，想感受下重金属激情的迷妹一定要去听一下，没听过他们你都不好意思说你听过重金属。<br>经典专辑：《Killers》、《Piece Of Mind》、《Iron Maiden》、《Number of the Beast》</p><h4 id="9-Def-Leppard（威豹乐队）"><a href="#9-Def-Leppard（威豹乐队）" class="headerlink" title="9. Def Leppard（威豹乐队）"></a>9. Def Leppard（威豹乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-9.jpg" alt=""><br>威豹也是英国重金属新浪潮中一支非常重要的乐队，这支乐队70年代末期组建，80年代成名，他们在硬摇滚上造诣很高。80-90年代期间是他们商业最成功的阶段，在美国都具有广泛的影响力。威豹也不是那种纯粹的重金属乐队，他们的情歌非常的好听感人，主唱Joe Elliott的声音是略带沧桑的沙哑，这些摇滚汉子唱起情歌分分钟秒杀你的心灵。另外乐队的长发造型很酷炫，而且他们是双吉他演奏，节奏非常动人优美。这个乐队最令人感动的是鼓手，只有一条手臂还怀着一颗坚毅的心重返乐队，我很敬佩这样牛逼的音乐人。另外他们的合声也是相当美丽的，很少有摇滚乐队合声如此好听，默契到位又流畅自然，分分钟刷新你的重金属三观。<br>经典专辑；《Best of Def Leppard》、《Hysteria》、《Retro Active》</p><h4 id="10-Suede（山羊皮乐队）"><a href="#10-Suede（山羊皮乐队）" class="headerlink" title="10. Suede（山羊皮乐队）"></a>10. Suede（山羊皮乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-10.jpg" alt=""><br>Suede（山羊皮乐队）在90年代非常受欢迎，一开始这支乐队其实是倍受质疑的，后来才受到了大众的喜爱。他们的风格是另类摇滚和英式摇滚。这和当时的摇滚大环境有关，90年代，英国传统摇滚乐的巅峰已经接近末声，演化出了英式摇滚，Suede其实就是这些乐队之一。他们的风格比较邪魅狂绢，充满了一种癫狂和风情万种的艺术气质，主唱的声音听多了会怀孕的。山羊皮对华挺友好的，曾经来过中国演出。还有令无数歌迷沉醉的还有主唱的颜值——他年轻的时候简直帅呆了！<br>经典专辑：《The Drowners》、《Suede》、《Coming Up》、《Head Music》</p><h4 id="11-Oasis（绿洲乐队）"><a href="#11-Oasis（绿洲乐队）" class="headerlink" title="11. Oasis（绿洲乐队）"></a>11. Oasis（绿洲乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-11.jpg" alt=""><br>Oasis（绿洲乐队）组建于曼彻斯特，是一支个性狂放的乐队，这和乐队的两兄弟的性格有关系。这支乐队最好的地方在于结合了流行摇滚与传统摇滚，传承了传统摇滚的精髓，乐评家非常钟爱这支乐队，对他们给予很高的评价。一说到英式摇滚人们首先会想到就是绿洲，其次是Blur，他们的吉他简直是神了，奠定了英式摇滚的吉他抒情风格。但是他们也叛逆咆哮，这完全不同于像披头士那样的“乖小孩”，自带一种粗犷的摇滚天性。<br>经典专辑：《Definitely Maybe》、《Morning Glory》</p><h4 id="12-Radiohead（电台司令乐队）"><a href="#12-Radiohead（电台司令乐队）" class="headerlink" title="12. Radiohead（电台司令乐队）"></a>12. Radiohead（电台司令乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-12.jpg" alt=""><br>Radiohead（电台司令）是那种让人绝望抑郁至死的乐队，个人觉得偶尔听一下还是不错啦。这支乐队的评价还是蛮好的，他们的风格很沉郁，在歌词的创作上独具匠心。灵魂人物兼主唱Yorke性格敏感脆弱，他们的作品里充满了一种病态美学的美感，吟唱人性最卑微脆弱之处，像《Creep》这种就是他们风格的集大成之作，这种风格在摇滚乐队里是比较少见的。<br>经典专辑：《The Bends》、《OK Computer》、《 Kid A 》</p><h4 id="13-Muse（缪斯乐队）"><a href="#13-Muse（缪斯乐队）" class="headerlink" title="13. Muse（缪斯乐队）"></a>13. Muse（缪斯乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-13.jpg" alt=""><br>多元的音乐风格、对英式摇滚拿捏到刚刚好的新生代英国摇滚乐队。融合重金属、电子音乐、前卫音乐、太空摇滚等等元素。更难得的是，从缪斯的歌曲里你还能听出千丝万缕的英国古典音乐气息，就像灵魂一样穿插在乐曲之中，非常特别，这在英国这样一个复古气息非常浓厚的国家非常有代表性，所以我认为他们的英式摇滚的头衔是应得的。有人说缪斯主唱Bellamy的唱腔和Yorke很像，细听确实有一点，都有一种浅唱低吟的感觉，但是Bellamy更加积极魅惑一点，不似Yorke给人彻彻底底地绝望之感。<br>经典专辑：《Black Holes and Revelations》、《Absolution》、《The 2nd Law》</p><h4 id="14-Blur（模糊乐队-布勒乐队-污点乐队）"><a href="#14-Blur（模糊乐队-布勒乐队-污点乐队）" class="headerlink" title="14. Blur（模糊乐队/布勒乐队/污点乐队）"></a>14. Blur（模糊乐队/布勒乐队/污点乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-14.jpg" alt=""><br>这支乐队和绿洲一起是一个神奇的存在，最为乐迷津津乐道的就是Blur（模糊乐队）与绿洲的掐架了，因为他们的风格挺像的，都是英式摇滚路线。但是我觉得模糊乐队没有像绿洲那样的狂放个性，显得更加的温和内敛，所以这支乐队被认为具有披头士的神韵。很多人评价一支乐队经常说某某乐队是某某乐队的接班人，我其实并不喜欢这种评价，乐队和乐队之间是一种传承和学习的关系，但是每个乐队都是一个独立的个体，所以我觉得披头士是披头士，Blur是Blur。近几年Blur做了一些比较诡异的尝试，风格越来越让人摸不透了，不过有了自己的经典之作之后，他们想做一些新的突破也是非常勇敢的。<br>经典专辑：《The Best Of Blur》、《The Great Escape》、《Parklife》</p><h4 id="15-Travis（特拉维斯乐队）"><a href="#15-Travis（特拉维斯乐队）" class="headerlink" title="15. Travis（特拉维斯乐队）"></a>15. Travis（特拉维斯乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-15.jpg" alt=""><br>这是来自苏格兰的一支传统摇滚乐队，他们涉足英式摇滚、传统摇滚、Post-Grunge与另类摇滚多个领域。乐队成员都是70后，他们最开始只是一个小地方的乐团，发行第二张专辑之后难掩才华，一时间成为英国摇滚乐坛巨星。其实我觉得主唱的声线是比较忧郁的，唱歌的方式有点浅唱低吟的感觉。他们也尝试过软摇滚，总之是一支听起来比较舒服的乐队。<br>经典专辑：《The Man Who》、《Side》、《Pipe Dreams》</p><h4 id="16-Queen（皇后乐队）"><a href="#16-Queen（皇后乐队）" class="headerlink" title="16. Queen（皇后乐队）"></a>16. Queen（皇后乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-16.jpg" alt=""><br>一支华丽丽的硬摇乐队，作品具有浓厚的歌剧色彩，非常硬，乐队的歌曲都保留了那种老式硬摇滚的精髓，键盘和完美的吉他Solo是他们的特点。主唱Freddie Mercury的声音是摇滚乐坛少有的好嗓，非常高亢嘹亮，天生是摇滚主唱的料，这也给皇后乐队注入了一种恢弘而大气磅礴的音乐感染力，但Freddie Mercury不幸因染上艾滋病辞世，全球歌迷为之震惊心痛。在失去这位灵魂人物之后，皇后乐队还是人气高涨，不断出了好作品，最终被选入摇滚名人堂。<br>经典专辑：《A Night at The Opera》、《Innuendo》、《A Kind of Magic》</p><h4 id="17-Black-Sabbath（黑色安息日乐队）"><a href="#17-Black-Sabbath（黑色安息日乐队）" class="headerlink" title="17. Black Sabbath（黑色安息日乐队）"></a>17. Black Sabbath（黑色安息日乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-17.jpg" alt=""><br>一看名字就知道这是支重金属乐队，乐队组建于伯明翰。这支乐队音色纯正，音乐简单干净又粗暴，但是他们的歌曲具有深刻的现实意义。他们的歌曲关注当时的核战争和死亡，描写毒品、反叛、青年和灰暗的生活命运，反映了底层人的痛苦绝望的生活状态，深受当时年轻人的喜爱。这支乐队的辉煌时期在70年代，后来渐渐地没落。好像70年代的英国朋克乐队都很难长久，不知道这是个什么怪圈，我想这可能是因为朋克自身所带的那种毁灭性，使他们自己也无法长久吧。<br>经典专辑：《Paranoid》、《Vol. 4》、《Master Of Reality》、《Sabbath Bloody Sabbath》</p><h4 id="18-Snow-Patrol（雪地巡游者乐队）"><a href="#18-Snow-Patrol（雪地巡游者乐队）" class="headerlink" title="18. Snow Patrol（雪地巡游者乐队）"></a>18. Snow Patrol（雪地巡游者乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-18.jpg" alt=""><br>Snow Patrol（雪地巡游者乐队）是一支来自苏格兰的乐队，乐队风格清新哀婉，歌词非常的温暖感人，是当代比较成功的英国摇滚乐队。乐队风格是迷幻和另类路线，出了一些很不错的单曲，我个人比较喜欢他们的一些作品，可以拿来听听。听他们的歌曲非常的治愈，给人温暖、干净而清澈的感觉，近几年也是风生水起，至于未来还会怎样发展，还有很多的可能性。<br>经典专辑：《Final Straw》、《Up To Now》</p><h4 id="19-Led-Zeppelin（齐柏林飞船）"><a href="#19-Led-Zeppelin（齐柏林飞船）" class="headerlink" title="19. Led Zeppelin（齐柏林飞船）"></a>19. Led Zeppelin（齐柏林飞船）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-19.jpg" alt=""><br>被誉为重金属鼻祖的一支英国乐队，他们的重金属融合了朋克、中东音乐、蓝调、乡村、雷鬼音乐等等元素。他们的有的歌曲听起来很忧伤，令人神往遐思，代入感极强。有很多歌曲的歌词非常的有深度，甚至是对人性的拷问和追寻。他们的音乐前奏都非常漂亮，节奏感超强。虽然是重金属乐队，但是其并没有像后期的重金属乐队那样太多的嘶吼和器乐嘈杂，很是入耳。<br>经典专辑：《Led Zeppelin Ⅳ》、《Houses of the Holy》、《Physical Graffiti》</p><h4 id="20-The-Kinks（奇想乐队）"><a href="#20-The-Kinks（奇想乐队）" class="headerlink" title="20. The Kinks（奇想乐队）"></a>20. The Kinks（奇想乐队）</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F/%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F-20.jpg" alt=""><br>奇想是一支老乐队了，他们主要活跃在60-70年代，在流行摇滚上造诣颇高，曲风也是蛮广的，迷幻、流行随手拈来。作为“不列颠入侵”的主要乐队之一，奇想与披头士、谁人和滚石并称为英国摇滚乐坛“Big Four”，当时的英国摇滚就是这四个乐队大放异彩、风靡全球。奇想也是摇滚名人堂的成员，但是96年这个乐队就解散了。他们的歌曲听着很舒服，充满怀旧伤感之情。可惜的是，这支本来很优秀的乐队在当时有点被披头士的巨大光芒掩盖了，现在去重新发现下也是不错的。<br>经典专辑：《Face to Face》、《Muswell Hillbillies》、《Arthur》</p><p>英国的摇滚乐队不胜枚举，大大小小的、成名的不成名的、大众的和小众的非常多，他们各有风格，但是真正能够在摇滚史上留下名字的乐队还是少数。总的来说，英国摇滚的特点是自成一派的英式摇滚，还有PF所创立的迷幻摇滚流派，加之上世纪70年代的朋克摇滚，这些都是英国土生土长的摇滚形式。除此外，英国摇滚还有其独有的思想性，从披头士的爱、和平、反战，到朋克对现实的抨击，及众多英式摇滚乐队的壮大复兴，都是英国摇滚乐的迷人之处。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Music </category>
          
          <category> Britpop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/2017/01/19/test/"/>
      <url>/2017/01/19/test/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="111"><a href="#111" class="headerlink" title="111"></a>111</h2><h3 id="1111"><a href="#1111" class="headerlink" title="1111"></a>1111</h3><h2 id="222"><a href="#222" class="headerlink" title="222"></a>222</h2><h3 id="2222"><a href="#2222" class="headerlink" title="2222"></a>2222</h3><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  entry<span class="token punctuation">:</span> <span class="token operator">...</span><span class="token punctuation">,</span>  output<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  module<span class="token punctuation">:</span><span class="token punctuation">{</span>    rules<span class="token punctuation">:</span><span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token operator">...</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'xxx-loader'</span><span class="token punctuation">,</span><span class="token string">'xxx-loader'</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><!-- rebuild by neat -->]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>Tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>About</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><h3>关于这个博客</h3><ul><li><p><a href="https://chorer.github.io/2019/03/24/T-hexo+github%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3/">这个博客是怎么来的</a></p></li><li><p><a href="https://chorer.github.io/2019/03/28/T-%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue/">博客主题的故事</a></p></li></ul><p>总而言之，这个博客算是我写学习笔记的地方，当然也会分享一些自己觉得有意思的事情。</p><h3>关于我</h3><p>我是一名计算机专业的大二学生。</p><p>感兴趣的领域是：<br><i class="fa fa-html5"></i> 前端：想成为一名前端工程师<br><i class="fa fa-music"></i> 音乐：只要你也喜欢 Oasis，我们就是一辈子的好朋友<br><i class="fa fa-etsy"></i> 英语：二流翻译兼退休汉化者<br><i class="fa fa-steam"></i> 游戏：某游戏论坛养老版主。偏爱 RPG 游戏<br><i class="fa fa-book"></i> 历史：对中东历史感兴趣，但了解甚少<br><i class="fa fa-spinner fa-spin"></i> 其它：探索中…</p><p>社区：</p><ul><li><a href="https://juejin.im/user/5cc6beb6f265da039a3d7b0a" target="_blank" rel="noopener">掘金</a></li><li><a href="https://segmentfault.com/u/chor" target="_blank" rel="noopener">SegmentFault</a></li><li><a href="https://github.com/Chorer" target="_blank" rel="noopener">GitHub</a></li></ul><!-- rebuild by neat -->]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Nov 05 2019 23:24:04 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      
    </entry>
    
    
  
</search>
