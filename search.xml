<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[$( )[i]返回的不是jq对象]]></title>
    <url>%2F2019%2F02%2F15%2F%24(%20)%5Bi%5D%E8%BF%94%E5%9B%9E%E7%9A%84%E4%B8%8D%E6%98%AFjq%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[问题：想要使所有div下的p标签的类名+1.因此采用下列办法：1234567&lt;div&gt; &lt;p class="1"&gt;1&lt;/p&gt; &lt;p class="2"&gt;2&lt;/p&gt; &lt;p class="3"&gt;3&lt;/p&gt; &lt;p class="4"&gt;4&lt;/p&gt; &lt;p class="5"&gt;5&lt;/p&gt;&lt;/div&gt;12345678&lt;script src="https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js"&gt;&lt;/script&gt;&lt;script&gt; var allp=$("div p"); for(var i=0;i&lt;allp.length;i++)&#123; allp[i].attr("class","i+2"); console.log(allp[i].attr("class")); &#125;&lt;/script&gt;结果控制台报错：提示allp[i].attr不是一个方法，而attr是jq对象的方法，这个报错等于说allp[i]不是一个jq对象。参考stackoverflow ，可知$()[i]返回的的确不是jq对象，而是原生dom对象，无法使用jq方法attr() 。关于如何判断是jq对象还是dom对象，可以用常用的instanceof方法判断，也可以用只有jq对象才有的jquery属性结合if语句判断。那么，如何用jq实现上述功能？1）转化为jq对象12345678910111213141516171819202122232425262728293031323334353637for(var i=0;i&lt;allp.length;i++)&#123; $(allp[i]).attr("class",i+2); &#125;``` `allp[i]`放在`$()`中则为jq对象**2）.eq(i)**```jsfor(var i=0;i&lt;$("div p").length;i++)&#123; $("div p").eq( i ).attr("class",i+2) 。 &#125;``` 这是因为jq collection 对象的eq( )方法将返回以参数值为索引值的单个元素。**3）each 遍历**```js$("div p").each(function()&#123; $(this).attr("class",$(this).index()+2); &#125;)``` 当然，因为each()本身可以传参，因此可以写成```js$("div p").each(function(i, n)&#123; $(this).attr("class",i+2); &#125;)``` 其中，i表示index，n表示当前元素（可用this操作）**4）或者更简单的，配合回调函数使用**```jsfor(var i=0;i&lt;$("div p").length;i++)&#123; $("div p").attr("class",function(i,n)&#123; n+=2; &#125;)&#125;如果按照上面那么写，将会报错。jq本身可以隐式迭代，所以这里的for循环完全是多余的，加了for循环反而是错的。在attr中将回调函数作为参数时，回调函数本身接受两个参数。具体到例子中，i为index，n为当前元素的当前值，也就是类名，这里的类名虽然为1到5，但是是string而不是number，所以需要用number()进行类型转换才可以运算。n最后必须return。综上，正确代码为1234var allp=$("div p");allp.attr("class",function(i,n)&#123; return Number(n)+1; &#125;);each( )遍历，控制台打印allp.each(function(){ console.log(this); }); tips:隐式迭代：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。如果方法是“获取”操作，则只返回第一个匹配元素的值。如$(&quot;div&quot;).css(&quot;background-color&quot;),这将返回第一个div的背景颜色。另外，隐式迭代一般用于对dom元素进行相同操作的场合中，而each方法多用于对dom元素执行不同操作，会传参。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑工具的选择]]></title>
    <url>%2F2019%2F02%2F15%2F%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[Hexo是静态博客网站，必须先在本地编辑好md文件再推送到网站上去。md文件也就是所谓的用markdown语法编写内容的文件，因此我们需要一个合适的markdown编辑工具，它必须具备以下特点：1.可导出md文件到本地，并随时进行修改2.可提供分屏预览，支持同步滚动和定位3.启动时响应速度快，编辑时渲染速度快以下是一些工具在markdown编写方面的优劣比较，可酌情进行选择。（平台：windows）印象笔记印象笔记自带markdown编辑器,如下图：优点：提供分屏预览，无需直接编写md代码，只需点击按钮即可，操作方便缺点：无法导出md文件到本地，这是它的致命缺点。sublime text3优点：安装插件后可以提供分屏预览缺点：预览效果极差，超出的文本内容无法自动换行显示，而是直接隐藏。如下图红框部分Typora优点：简洁美观缺点：不提供分屏预览，md代码编辑完成后回车即自动渲染出文本来。（虽然它认为这是优点，很多人习惯的却是分屏）Atom优点：提供分屏预览，有较多可拓展插件缺点：响应速度极慢，编辑时明显感觉卡顿；软件过大，大概100多m；安装插件极其困难，失败率较高HexoEditor优点：简洁美观，提供分屏预览，图片插入方便缺点：需要用npm指令下载安装，和Atom插件安装如出一辙，很容易卡死Hexo-admin非工具。Hexo自带的博客后台管理，可以在web ui界面下进行编辑优点：提供分屏预览缺点：界面过于简陋，自定义程度较低，本地服务器必须一直开着才能使用Vscode这是这么多工具中我觉得体验最好的，本篇博客也是用vscode编写。优点：提供分屏预览、同步滚动等；较多markdown插件和主题；启动速度快，使用流畅不卡顿，渲染速度很快缺点：需要自己写md代码，不过鉴于md语法并不复杂，我觉得这个缺点完全可以忽略不计。最后是博客编写方面的一点小tip：原生markdown语法并不支持定义字体颜色和大小等样式，但是由于在hexo中，我们编写的md文件最后会生成对应的html文件，所以完全可以在编写的时候使用html语法，浏览器会自动解析并渲染文件中包含的标签等。比如，上面就可以通过将句子放在span标签中，再加上内联样式达到荧光高亮的效果。不止是样式，我们还可以用&lt;br&gt;标签实现换行,让每一段不至于太紧凑。（md中空格是会被合并的，这点和html一样）]]></content>
      <categories>
        <category>心得和感想</category>
      </categories>
      <tags>
        <tag>编辑工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github pages部署个人博客网站的感想]]></title>
    <url>%2F2019%2F02%2F15%2Fhexo%2Bgithub%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[题外话：之前我习惯用印象笔记进行知识的剪藏和整理，但是印象笔记本身带给我一种相对封闭的感觉，更像是比较私人的产品；而博客则相反，它更多是面向大众的、开放的，有利于个人经验的输出和知识的共享，所以拥有自己的博客非常有必要。拿博客园和CSDN来说，这两者虽然可以满足写博客的需求，但是自定义程度不够高，缺少一些个性tag。既然如此，为什么我们不自己搭建一个个人博客网站呢？用hexo+github pages 搭建个人博客网站是极其方便的，不需要购买域名和服务器，只需要按部就班操作，就可以在短时间内成功拥有自己的一个网站。我自己大概是花了两三个小时搞定，主要是因为对git bash的使用不够熟悉，因此走了一些弯路。实际上动作快的话半个小时就可以搞定。下面是对部署过程的大概介绍，以及必须注意的事项（划重点，也就是所谓的“坑”）。由于本文参考了大量博客，所以在文末我会列出原文链接。一.Github，Github pages ，Hexo首先介绍一下这三个东西，有大概的了解、知道是什么东西就可以。GitHub是一个面向开源及私有软件项目的托管平台，而GIthub Pages则是github的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，现在大多用来开发和制作个人博客网站。它的好处在于域名和服务器都是免费提供的，并且没有网站数量的限制。而Hexo 是一个快速、简洁且高效的博客框架，它使用Markdown解析文章，在几秒内，就可以利用靓丽的主题生成静态网页。（关于Hexo的详细介绍，请看官方文档 https://hexo.io/zh-cn/docs/ ，这里就不展开了）。因此，可以说github和hexo是绝配。接下来，开始我们的工作。二. 环境和必要准备我个人的环境：win10，64bit必要准备：你需要（1）github账号 ：前往https://github.com/ 官网注册就好（2）git 2.20.1 ： 即最新版本的git，前往https://git-scm.com/ 官网下载并安装。安装完后前往git文件夹下打开git bash，运行以下命令：git config --global user.name “username” git config --global user.email “your mail” 注：将username替换为自己的github账号名，将your mail替换为自己注册github时绑定的邮箱。这一步非常重要，当时部署的时候我因为遗漏了这一步，导致后面报错.（3）node.js ： 前往 https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi 下载并安装。这两个的安装比较简单，一路next就好，不过我推荐还是修改一下路径，尽量放在自己可以找到的位置。（4）hexo ：打开git文件夹下的git bash，运行 以下命令 npm install -g hexo-cli，安装hexo。之后，依次运行以下命令进行hexo的初始化$ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 注：请将上面代码的&lt;folder&gt;替换成你自己想要的文件夹名字，以我为例，我想要在git文件夹下新建一个Myblog文件夹以存放站点文件，那么我这里的代码就应该是$ hexo init Myblog $ cd Myblog $ npm install 成功之后，我们会在git文件夹下看到新建的Myblog文件夹，里面存放了大量文件。好了，到了这一步，请把git bash关闭，并进入你的站点文件夹里（例如：Myblog文件夹里），右键选择git bash here。如图：这样，我们会在站点目录下重新打开git bash。你可能会疑惑，这和直接去git文件夹下打开git bash有区别吗？有！！区别非常大，在站点目录下打开git bash才可以找到运行命令所需要的环境。所以这里一定要记住，在之后介绍的操作中，凡是需要输入命令的，我们都是像上图这样先打开git bash再输入。按照上面所说的，我们右键打开git bash，并运行以下代码：1hexo server这将在本地打开我们的网站，当提示”xxx is running at xxx“的时候，我们可以通过http://localhost:4000/ 这个网址预览我们的网站，想要切断连接，只需要在命令行窗口按下ctrl+c。至此，hexo博客已经在本地搭建好了。接下来，我们要将hexo和github进行对接。三. hexo与github 实现对接1.建立仓库还记得我们之前注册的github账号吗？现在，请进入github网站，并点击头像选择your repository，我们现在需要创建一个仓库（也就是repository）用于存放相关站点文件。按照下图顺序进行设置：其中，Repository name也即是我们的仓库名字，必须是 Github账号名称.github.io的格式。比如你的github名字是ccc，那么仓库名字必须是ccc.github.io 。2.对接github在git bash中运行以下命令，安装 hexo-deployer-git 插件。1npm install hexo-deployer-git --save运行以下命令，创建SSH key。（注：和上面一样，请将your mail替换成github邮箱地址）$ ssh-keygen -t rsa -C &quot;your mail&quot; 前往 C:\Users\Administrator.ssh\id_rsa.pub （注意，这只是大概位置。不同系统路径可能不同，但是大同小异）打开id_rsa.pub文件（可以用记事本打开，但是推荐用sublime text）。复制文件中的全部内容，前往 https://github.com/settings/keys ，将刚才复制的内容粘贴在New SSH key 的文本框中。前往站点目录下（例如：git/ Myblog），打开_config.yml 文件，对文件末尾进行如下修改：# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 在这里要注意，1）所有的冒号距离右边的内容之间都有一个空格，如果没有空格，则修改是无效的。2）和前面一样，将usename替换成我们自己的github用户名 。 3）repo后面的地址，在旧版本的hexo中是http地址，但在新版本的hexo用的是ssh地址，我们统一用如上所示的ssh地址。有些博客由于没有进行更新，在说明这个问题的时候依然用的是http地址，造成了一定程度上的误导。运行以下命令，对接并推送内容到github。$ hexo g $ hexo d 等待片刻，打开 https://&lt;Github账号名称&gt;.github.io （例如 https://ccc.github.io ) 即可进入你搭建好的个人博客网站了！当然，网站默认用的是landscape主题，比较难看，关于主题的美化和后期一些插件的添加，可以参考文章末尾贴出的链接。PS：这里顺便介绍一下常用的 hexo 命令：hexo clean ————————&gt;清除缓存文件和已生成的静态文件hexo g 或者 hexo generate ————————&gt;生成静态文件hexo d 或者hexo deploy ————————&gt;生成静态文件并部署到仓库hexo s 或者 hexo server —————————&gt;在本地打开网站一般来说，在对网站进行修改后，我们可以先用hexo g和hexo s 在本地预览效果，如果效果符合预期的话再用hexo d 推送到 github。当然，可能会遇到本地打开和域名打开的效果不一致，这种情况下通常是因为 1. 没有用hexo clean 清除缓存 2. 没有对浏览器用ctrl+f5 清除缓存 3.忘记用hexo d 将本地文件推送到github 4. 本地和线上的同步本身需要时间，所以上述方法如果无效，可以尝试等几分钟，再打开网站就正常显示了。参考自：https://www.jianshu.com/p/3a05351a37dchttps://www.simon96.online/2018/10/12/hexo-tutorial/]]></content>
      <categories>
        <category>心得和感想</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>网站搭建</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM Core 与 HTML-DOM]]></title>
    <url>%2F2019%2F02%2F14%2FDOM%20Core%20%E5%92%8CHTML%20DOM%2F</url>
    <content type="text"><![CDATA[DOM（文档对象模型）是由W3C制定的一套访问和操作XML（eXtensible Markup Language）文档的标准，即API。比如DOM告诉JavaScript引擎如何在浏览器窗口中显示和操作XML创建的标记（Tag）。DOM与特定的平台、浏览器、语言无关，很多种语言都实现了DOM，比如因为JavaScript和PHP都实现了DOM，所以 JavaScript中有getElementsByTagName()方法，PHP中也有 getElementsByTagName()，getElementsByTagName()方法是DOM规定的访问XML文档的接口。XML与HTML相似，但两者是有区别。XML和HTML都来自于SGML，它们都含有标记，有着相似的语法，HTML和XML的最大区别在 于：HTML是一个定型的标记语言，用固定的标记来描述和显示数据，比如&lt;h1&gt;表示首行标题，有固定的尺寸；而XML没有固定的标记，只能通过自定义的标记来描述数据的形式和结构，而不能显示。HTML是将数据 和显示混在一起，而XML则是将数据和显示分开来。那为什么能使用DOM访问和操作HTML文档（即网页）呢？Web语义化的一个发展方向是将HTML逐 渐演变为更有语义、能将数据内容与现实分离的XML，但HTML不可能立即演变为XML，目前推荐使用的是一个过渡产物——XHTML。HTML与 XHTML网页形成的节点树（统称为HTML节点树）在结构上与XML节点树一样，可以看做是一个符合DOM的XML文档，因此可以使用实现了DOM的程 序语言（如JavaScript、PHP等）来访问和操作HTML文档，即访问和操作那些节点。由于HTML与XML的相似性及差异，JavaScript不仅实现了标准的DOM方法和属性（即由W3C制定的），而且还实现了HTML特有的 DOM方法和属性，前者称为DOM Core，并不专属于JavaScript，后者称为HTML-DOM。不管是DOM Core还是HTML-DOM，我们在使用JavaScript的时候要注意浏览器之间的兼容性，因为不同的浏览器对这两类方法和属性的支持可能不一样。 这里不详谈DOM Core和HTML-DOM，以及跨浏览器兼容性，教材上都有详细描述。但一般推荐使用DOM Core方法和属性，尽管稍显繁杂。常见的Core DOM方法如下：1、创建节点createElement()createTextNode()2、复制节点cloneNode()3、插入节点appendChild()insertBefore()4、删除节点removeChild()5、替换节点replaceChild()6、查找和设置节点属性setAttribute()getAttribute()7、查找节点getElementById()getElementsByTagName()hasChildNode()常见的Core DOM属性如下：node.childNodesnode.firstChildnode.lastChildnode.nextSiblingnode.previousSiblingnode.parentNode]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件相关概念详解]]></title>
    <url>%2F2019%2F02%2F13%2F%E4%BA%8B%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[事件：事件是用户或浏览器自身执行的某种动作，如click,load和mouseover都是事件的名字。响应某个事件的函数叫做事件处理函数 / 事件处理程序 / 事件句柄。如果想要绑定多个函数，则需要用到事件监听器。1. 事件绑定的几种方式javascript给DOM绑定事件处理函数总的来说有2种方式：在html文档中绑定、在js代码中绑定。下面的方式1、方式2属于在html中绑定事件，方式3、方式4和方式5属于在js代码中绑定事件，其中，方式4和5属于事件监听，而方式5是最推荐的做法。1）在html文档中绑定方式1：1&lt;input type="button" id="btn" onclick="函数名( )"&gt;方式2：1&lt;input type="button" id="btn" onclick="直接写函数内容"&gt;2）在js代码中绑定方式3：1document.getElementById("btn").onclick=function( )&#123; &#125;;说明：方式3也称为“DOM0级事件处理程序”。它无法绑定多个事件，当绑定多个事件的时候，只有最后一个会生效，其他皆被覆盖）方式4：[object].attachEvent(“事件类型”,”处理函数”)说明：①方式4也称为“IE事件处理程序”。这种方法不属于w3c标准，并且仅IE8及以下支持该方法；②事件类型要加on；③如下图，b中声明a函数时分配了一块内存地址 ，两个dom.attachEvent(&#39;onclick&#39;,a)中的a都指向的是下面定义的a；c中只是两个函数体一样的匿名函数，分别有各自的内存地址，故认为是两个不同的函数对象方式5：[object].addEventListener(“事件类型”,”处理函数”,”冒泡事件或捕获事件”);说明：①方式5也称为“DOM2级事件处理程序”。w3c正统标准，IE9及以上、Chrome、Firefox等支持该方法；②事件类型不加on；③第三个参数不设置的时候，默认为false即冒泡；④ 同一个事件处理函数可以绑定2次,一次用于事件捕获，一次用于事件冒泡；如果绑定的是同一个事件处理函数，并且都是事件冒泡类型或者事件捕获类型，那么只能绑定一次；⑤ 不同的事件处理函数可以重复绑定，这点与上面attachEvent是一样的2. 事件处理函数的执行顺序方式123都不能实现事件的重复绑定，所以自然也就不存在执行顺序的问题。方式4和方式5可以重复绑定特性，所以需要了解下执行顺序的问题。结论：对于addEventListener，如果给目标的同一个事件绑定多个处理函数，先绑定的先执行。 attachEvent则刚好相反，后绑定的先执行，这是因为采用attachEvent的是IE8-，而IE8-是不支持dom事件流模型的。12345678910111213&lt;script&gt; window.onload = function()&#123; var outA=document.getElementById("outA"); outA.addEventListener('click',function()&#123;alert(1);&#125;,false); outA.addEventListener('click',function()&#123;alert(2);&#125;,true); outA.addEventListener('click',function()&#123;alert(3);&#125;,true); outA.addEventListener('click',function()&#123;alert(4);&#125;,true); &#125;;&lt;/script&gt;&lt;body&gt; &lt;div id="outA"&gt; &lt;/div&gt;&lt;/body&gt;当点击outA的时候，会依次打印出1、2、3、4。这里特别需要注意：我们是同时给outA这个元素绑定了多个onclick事件处理函数，没有涉及父子元素，所以也不涉及事件冒泡和事件捕获的问题，即addEventListener的第三个参数在这种场景下，没有什么用处，直接忽略之。如果是通过事件冒泡或者是事件捕获触发outA的click事件，那么函数的执行顺序会有变化。3. 事件捕获和事件冒泡我们知道HTML中的元素是可以嵌套的，形成类似于树的层次关系。比如下面的代码：12345&lt;div id="outA"&gt; &lt;div id="outB"&gt; &lt;div id="outC"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;如果点击了最内侧的outC，那么外侧的outB和outC算不算被点击了呢？很显然算，不然就没有必要区分事件冒泡和事件捕获了，这一点各个浏览器厂家也没有什么疑义。假如outA、outB、outC都注册了click类型事件处理函数，当点击outC的时候，触发顺序是A–&gt;B–&gt;C，还是C–&gt;B–&gt;A呢？如果浏览器采用的是事件冒泡，那么触发顺序是C–&gt;B–&gt;A，由内而外，像气泡一样，从水底浮向水面；如果采用的是事件捕获，那么触发顺序是A–&gt;B–&gt;C，从上到下，像石头一样，从水面落入水底。一般来说事件冒泡机制用的更多一些，所以在IE8以及之前，IE只支持事件冒泡。IE9+/FF/Chrome这2种模型都支持，可以通过addEventListener的第三个参数来设定，false代表事件冒泡，true代表事件捕获。12345678910111213141516171819&lt;script&gt; window.onload = function()&#123; var outA = document.getElementById("outA"); var outB = document.getElementById("outB"); var outC = document.getElementById("outC"); // 使用事件冒泡 outA.addEventListener('click',function()&#123;alert(1);&#125;,false); outB.addEventListener('click',function()&#123;alert(2);&#125;,false); outC.addEventListener('click',function()&#123;alert(3);&#125;,false); &#125;;&lt;/script&gt;&lt;body&gt;&lt;div id="outA"&gt; &lt;div id="outB"&gt; &lt;div id="outC"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;使用的是事件冒泡，当点击outC的时候，打印顺序是3–&gt;2–&gt;1。如果将false改成true使用事件捕获，打印顺序是1–&gt;2–&gt;3。4. DOM事件流4.1 事件流定义：事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点与根节点之间按照特定的顺序如流水一样传播，路径所经过的所有节点都会收到该事件，这个传播过程即事件流。4.2 事件流模型：事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即由内到外捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即由外到内4.3 DOM事件流：4.3.1 dom事件流定义：DOM标准采用捕获+冒泡的DOM事件流。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。4.3.2 dom事件流包括：DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。事件捕获阶段：实际目标(&lt;div&gt;)在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。上图中为1~3.处于目标阶段：事件在&lt;div&gt;上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。冒泡阶段：事件又传播回文档。4.3.3 dom事件流与冒泡、捕获将DOM事件流看作整个过程，那么其实 useCapture=false意味着：将该事件处理函数加入到冒泡阶段，在冒泡阶段会被调用；useCapture=true意味着：将该事件处理函数加入到捕获阶段，在捕获阶段会被调用。从DOM事件流模型可以看出，捕获阶段的事件处理函数，一定比冒泡阶段的事件处理函数先执行。4.3.4 dom事件流的相关概念1） target:触发事件的某个具体对象，固定不变的。2） currentTarget:绑定事件的对象，恒等于this，可能出现在事件流的任意一个阶段中。动态变化的。控制台：点击最里面的son3后，可以看到target一直不变，而由于冒泡，导致currentTarget动态变化。3） 两者的应用场合通常情况下target和currentTarget是一致的，我们只要使用terget即可，但有一种情况必须区分这三者的关系，那就是在父子嵌套的关系中，父元素绑定了事件，单击了子元素（根据事件流，在不阻止事件流的前提下他会传递至父元素，导致父元素的事件处理函数执行），这时候currentTarget指向的是父元素，因为他是绑定事件的对象，而target指向了子元素，因为他是触发事件的那个具体对象PS：注意！！！并非所有的事件都会经过冒泡阶段 。所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。5. DOM事件流中的“事件处理函数的执行顺序”我们回头再来说事件处理函数的执行顺序。点击outC的时候，打印顺序是 :capture1–&gt;capture2–&gt;target2–&gt;target1–&gt;bubble2–&gt;bubble1。由于outC是我们触发事件的目标对象，在outC上注册的几个事件处理函数都属于DOM事件流中的目标阶段。对同一个绑定对象（这里是outC）而言，同处于目标阶段的多个函数的执行顺序：先注册的先执行，后注册的后执行。这就是上面我们说的，在目标对象（outC）上绑定的函数是采用捕获，还是采用冒泡，都没有什么关系，因为冒泡和捕获只是对父元素上的函数执行顺序有影响，对自己没有什么影响。至此我们可以给出事件函数执行顺序的结论了：捕获阶段的处理函数最先执行，其次是目标阶段的处理函数，最后是冒泡阶段的处理函数。目标阶段的处理函数如果有多个，则先注册的先执行，后注册的后执行。6. 阻止事件冒泡和捕获默认情况下，多个事件处理函数会按照DOM事件流模型中的顺序执行。如果子元素上发生某个事件，不需要执行父元素上注册的事件处理函数，那么我们可以停止捕获和冒泡，避免没有意义的函数调用。前面提到的5种事件绑定方式，都可以实现阻止事件的传播。由于第5种方式，是最推荐的做法。所以我们基于第5种方式，看看如何阻止事件的传播行为。注意：IE8以及IE8之前可以通过 window.event.cancelBubble=true阻止事件的继续传播；IE9+/FF/Chrome通过event.stopPropagation()阻止事件的继续传播。当点击outC的时候，打印出capture–&gt;target，不会打印出bubble。因为当事件传播到outC上的处理函数时，通过stopPropagation阻止了事件的继续传播，所以不会继续传播到冒泡阶段。想要在哪个节点阻止传播，就在哪个节点的事件处理函数中添加stopPropagation，记得要传参。7. 事件代理/事件委托7.1 概述：事件委托又叫事件代理。JavaScript高级程序设计上讲:事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。我们可以用取快递的例子来理解这个东西。假设：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台也会在收到寄给新员工的快递后核实并代为签收。这里其实还有2层意思的：第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；第二，新员工也是可以被前台代为签收的，即程序中新添加的dom节点也是有事件的。7.2 为什么要使用事件委托：简单来说，就是为了减少不必要的dom操作，优化性能。一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了。比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢？如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，自然性能就会更好。7.3 事件委托的原理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。7.4 事件委托如何实现：终于到了本文的核心部分了。在介绍事件委托的方法之前，我们先来看例一：需求：不管点击哪个li，都能弹出123：123456&lt;ul id="ul1"&gt;&lt;li&gt;111&lt;/li&gt;&lt;li&gt;222&lt;/li&gt;&lt;li&gt;333&lt;/li&gt;&lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;123456789window.onload = function()&#123;var oUl = document.getElementById("ul1");var aLi = oUl.getElementsByTagName('li');for(var i=0;i&lt;aLi.length;i++)&#123;aLi[i].onclick = function()&#123;alert(123);&#125;&#125;&#125;上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作:首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；那么我们用事件委托的方式做又会怎么样呢？123456window.onload = function()&#123;var oUl = document.getElementById("ul1");oUl.onclick = function()&#123;alert(123);&#125;&#125;我们让父级ul监听点击事件，则不管是哪个li被点击————由于冒泡原理，事件最终都会冒泡到ul上，触发ul上的点击事件，弹出123。当然，这里当点击ul的时候，也是会触发的。那么问题就来了，如果我想让事件代理的效果跟直接给某个指定的节点的事件效果一样怎么办？比如说只有点击li才会触发，不怕，我们有绝招：事件本身是一个对象，即Event对象，事件发生时该对象作为参数传给回调函数。而Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称之为事件源.也就是说，target可以表示为当前的事件直接操作的那个dom。当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：1234567891011window.onload = function()&#123; var oUl = document.getElementById("ul1"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125;这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？请看例二：123456&lt;div id="box"&gt;&lt;input type="button" id="add" value="添加" /&gt;&lt;input type="button" id="remove" value="删除" /&gt;&lt;input type="button" id="move" value="移动" /&gt;&lt;input type="button" id="select" value="选择" /&gt;&lt;/div&gt;123456789101112131415161718window.onload = function()&#123;var Add = document.getElementById("add");var Remove = document.getElementById("remove");var Move = document.getElementById("move");var Select = document.getElementById("select");Add.onclick = function()&#123;alert('添加');&#125;;Remove.onclick = function()&#123;alert('删除');&#125;;Move.onclick = function()&#123;alert('移动');&#125;;Select.onclick = function()&#123;alert('选择');&#125;&#125;上面实现的效果很简单，4个按钮对应4个不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？1234567891011121314151617181920212223window.onload = function()&#123;var oBox = document.getElementById("box");oBox.onclick = function (ev) &#123;var ev = ev || window.event;var target = ev.target || ev.srcElement;if(target.nodeName.toLocaleLowerCase() == 'input')&#123;switch(target.id)&#123;case 'add' :alert('添加');break;case 'remove' :alert('删除');break;case 'move' :alert('移动');break;case 'select' :alert('选择');break;&#125;&#125;&#125;&#125;可见，用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？请看例三：我们的需求是是：①移入li，li变红，移出li，li变白②对于点击按钮后新增的li节点，仍然具有该效果。以下是正常的方法：1234567&lt;input type="button" name="" id="btn" value="添加" /&gt;&lt;ul id="ul1"&gt;&lt;li&gt;111&lt;/li&gt;&lt;li&gt;222&lt;/li&gt;&lt;li&gt;333&lt;/li&gt;&lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;12345678910111213141516171819202122window.onload = function()&#123;var oBtn = document.getElementById("btn");var oUl = document.getElementById("ul1");var aLi = oUl.getElementsByTagName('li');var num = 4;//鼠标移入变红，移出变白for(var i=0; i&lt;aLi.length;i++)&#123;aLi[i].onmouseover = function()&#123;this.style.background = 'red';&#125;;aLi[i].onmouseout = function()&#123;this.style.background = '#fff';&#125;&#125;//添加新节点oBtn.onclick = function()&#123;num++;var oLi = document.createElement('li');oLi.innerHTML = 111*num;oUl.appendChild(oLi);&#125;;&#125;你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去——这是因为li遍历这一动作发生在新增li这一动作之前，在那个时候已经确定了li的个数是4，因此只绑定了4个li。这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环封装在一个函数里，命名为mHover，如下：1234567891011121314151617181920212223242526window.onload = function()&#123;var oBtn = document.getElementById("btn");var oUl = document.getElementById("ul1");var aLi = oUl.getElementsByTagName('li');var num = 4;function mHover () &#123;//鼠标移入变红，移出变白for(var i=0; i&lt;aLi.length;i++)&#123;aLi[i].onmouseover = function()&#123;this.style.background = 'red';&#125;;aLi[i].onmouseout = function()&#123;this.style.background = '#fff';&#125;&#125;&#125;mHover ();//添加新节点oBtn.onclick = function()&#123;num++;var oLi = document.createElement('li');oLi.innerHTML = 111*num;oUl.appendChild(oLi);mHover ();&#125;;&#125;与上面方法不同的是，这个方法没有在新增li之前就为原有li绑定事件，而是在新增li后遍历所有的li（包括新增li），并一起绑定事件。虽然功能实现了，看着还挺好，但实际上无疑又增加了一个dom操作，在优化性能方面是不可取的，那么用事件委托的方式，能做到优化吗？12345678910111213141516171819202122232425262728window.onload = function()&#123;var oBtn = document.getElementById("btn");var oUl = document.getElementById("ul1");var aLi = oUl.getElementsByTagName('li');var num = 4;//事件委托，添加的子元素也有事件oUl.onmouseover = function(ev)&#123;var ev = ev || window.event;var target = ev.target || ev.srcElement;if(target.nodeName.toLowerCase() == 'li')&#123;target.style.background = "red";&#125;&#125;;oUl.onmouseout = function(ev)&#123;var ev = ev || window.event;var target = ev.target || ev.srcElement;if(target.nodeName.toLowerCase() == 'li')&#123;target.style.background = "#fff";&#125;&#125;;//添加新节点oBtn.onclick = function()&#123;num++;var oLi = document.createElement('li');oLi.innerHTML = 111*num;oUl.appendChild(oLi);&#125;;&#125;如上，新添加的节点是带有事件效果的。根据事件冒泡原理，不管是原有li还是新增li，只要鼠标一移入li中就等同于鼠标移入ul中，自然会触发ul的鼠标移入事件，之后我们只要在ul的事件函数中定义相关行为就可以了。我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了。这样可以大大的减少dom操作，这才是事件委托的精髓所在。7.5 总结：那什么样的事件可以用事件委托，什么样的事件不可以用呢？适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，至于focus，blur之类的就更不用说了，本身就没有冒泡的特性，自然就不能用事件委托了。8 事件对象8.1 认识事件对象事件在浏览器中是以对象的形式存在的，即event对象。触发一个事件，就会产生一个event对象，该对象包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如：鼠标操作产生的event中会包含鼠标位置的信息；键盘操作产生的event中会包含与按下的键有关的信息。所有浏览器都支持event对象，但支持方式不同，在DOM中event对象必须作为唯一的参数传给事件处理函数，在IE中event是window对象的一个属性。8.2 html事件处理程序中的事件对象12&lt;input id="btn" type="button" value="click"onclick=" console.log('html事件处理程序'+event.type)"/&gt;这样会创建一个包含局部变量event的函数。可通过event直接访问事件对象。8.3 DOM中的事件对象DOM0级和DOM2级事件处理程序都会把event作为参数传入。参数命名：随便。习惯上用e，或者ev或者event。12345678910111213&lt;body&gt;&lt;input id="btn" type="button" value="click"/&gt;&lt;script&gt; var btn=document.getElementById("btn"); btn.onclick=function(event)&#123; console.log("DOM0 &amp; click"); console.log(event.type); //click &#125; btn.addEventListener("click", function (event) &#123; console.log("DOM2 &amp; click"); console.log(event.type); //click &#125;,false);&lt;/script&gt;&lt;/body&gt;DOM中事件对象的重要属性和方法。属性：type属性，用于获取事件类型target属性，用于获取事件直接作用的目标（更具体target.nodeName）currentTarget属性，用于获取事件实际绑定的目标方法：stopPropagation()方法,用于阻止事件冒泡preventDefault()方法,阻止事件的默认行为 移动端用的多8.4 IE中的事件对象第一种情况： 通过DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。12345678910&lt;body&gt;&lt;input id="btn" type="button" value="click"/&gt;&lt;script&gt;var btn=document.getElementById("btn");btn.onclick= function () &#123;var event=window.event;console.log(event.type); //click&#125;&lt;/script&gt;&lt;/body&gt;第二种情况：通过attachEvent()添加的事件处理程序，event对象作为参数传入。123456789&lt;body&gt;&lt;input id="btn" type="button" value="click"/&gt;&lt;script&gt;var btn=document.getElementById("btn");btn.attachEvent("onclick", function (type) &#123;console.log(event.type); //click&#125;)&lt;/script&gt;&lt;/body&gt;IE中事件对象的重要属性和方法:属性：type属性，用于获取事件类型(一样)srcElement属性，用于获取事件直接作用的目标（更具体srcElement.nodeName）cancelBubble属性，用于阻止事件冒泡。IE中cancelBubble为属性而不是方法，true表示阻止冒泡。returnValue属性，阻止事件的默认行为。false表示阻止事件的默认行为PS：targrt和srcElement的兼容性处理如下12345678//兼容性处理function showMsg(event)&#123;event=event||window.event;//IE8以前必须通过window获取event，DOM中就是个简单的传参var ele=event.target || event.srcElement;//获取目标元素，DOM中用target,IE中用srcElementalert(ele);&#125;参考链接：https://blog.csdn.net/aitangyong/article/details/43231111http://www.cnblogs.com/starof/p/4066381.htmlhttps://www.cnblogs.com/liugang-vip/p/5616484.htmlhttp://www.cnblogs.com/starof/p/4077532.html]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>dom事件流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量的两种命名方式]]></title>
    <url>%2F2019%2F02%2F12%2F%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%91%BD%E5%90%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、驼峰命名法：①全部小写：变量名中的每一个逻辑断点/每个单词都用下划线隔开。比如：print_employee_paychecks()；②大小写混合：1）小驼峰法：变量一般用小驼峰法标识。第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstName、myLastName2）大驼峰法/帕斯卡命名法（Upper Camel Case/pascal）：常用于类名，函数名，属性，命名空间。相比小驼峰法，大驼峰法把第一个单词的首字母也大写了。例如：DataBaseUser二、匈牙利命名法：基本原则是：变量名=类型+对象描述。匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等。这些符号可以多个同时使用，顺序是先m_（成员变量），再指针，再简单数据类型，再其他。例如：m_lpszStr, 表示指向一个以0字符结尾的字符串的长指针成员变量。匈牙利命名法中常用的小写字母的前缀：前缀 类型a – – — – – —— —————– 数组 (array)b ———————————- 布尔值 (boolean)by———————————- 字节 (byte)c ———————————- 有符号字符 (char)cb ————————– 无符号字符 (char Byte，没有多少人用)cr ———————————- 颜色参考值 (colorRef)fn ———————————- 函数 （function）fl ———————————- 浮点（float）h ———————————- 句柄（handle）i ———————————- 整型 （int）l ———————————- 长整型 (long Int)lp———————————- 长指针（long Pointer）m ———————————- 类的成员 （member）n———————————- 短整型 (short Int)np ———————————- 近指针（near Pointer）o ———————————- 对象（object）p ———————————- 指针（pointer）re ——————————— 正则（regular expression）s ———————————- 字符串型 （string）sz ————————— 以null做结尾的字符串型 (String with Zero End)]]></content>
      <tags>
        <tag>命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null和undefined]]></title>
    <url>%2F2019%2F02%2F12%2Fnull%E5%92%8Cundefined%2F</url>
    <content type="text"><![CDATA[一. undefined在变量声明中的体现：1）声明了、但是没有初始化的变量：var aa; alert(aa); 浏览器会弹出窗口显示 undefined。因为对于使用了 var 声明但没有进行初始化定义的变量, 其值默认为 undefined.2） 未声明的变量(1)：alert(aa); 浏览器不会弹出任何东西. 因为 aa 是没有声明的变量。打开 chrome 浏览器的控制台会看到报错如下：3）未声明的变量(2)：alert(typeof aa); 浏览器会弹出窗口显示 undefined。对于没有声明的变量, 只能执行一种操作，即使用 typeof 操作符检验它的类型.。它的类型和声明了但没有进行初始化的变量的类型一样, 都是 undefined.二. null和undefined：alert(undefined == null); // 返回 true 对于undefined 和null 的相等性测试，返回 true,如上图。这是因为，undefined是由null派生而来的。但是，这两者差别很大，之所以要设置两个值，让我们从历史原因说起吧1）历史原因：1995年js诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象；其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。因此，Brendan Eich又额外设计了一个undefined。2）最初设计：JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。Number(undefined) // NaN 5 + undefined // NaN 3）目前的用法：但是，上面这样的区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。①nullnull是基本数据类型之一，值仅有一个，即为null。表示”空对象”(因此类型检测返回对象)，即如果有对象，就会是一个具体的对象，如果没对象，就是null。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。Object.getPrototypeOf(Object.prototype) // null typeof null // object 如果定义的变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子：if(abc != null){ //对abc执行某些操作 } ②undefinedundefined是基本数据类型之一，值仅有一个，即为undefined。表示”缺少值”(因此类型检测返回undefined)，即此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。var i; i // undefined function f(x){console.log(x)}f() // undefined var o = new Object(); o.p // undefined var x = f(); var exp = undefined; 8x // undefined ③如何检测某个变量是undefined：错误的用法：if(abc==undefined) // 正如上面所说，js规定用== 判断时，null和undefined是等同的正确的用法：if (typeof(abc) `==` &quot;undefined&quot;) 或者最简单的办法：if(abc===undefined) 注意！！！ type的用法有运算符形式和函数形式，即if (typeof(abc) == “undefined”) 和 if (typeof abc == “undefined”) 效果是一样的。另外，由于typeof会返回诸如”number”的字符串形式的结果，因此==的右操作数应注意加双引号表示字符串。④如何检测某个变量是null：错误的用法：1、if(abc == null)// 解释同上。不过：要判断abc是 null 或者 undefined 时可使用本法。2、if ( !abc)// 这个的原理是：abc为假值，则 ! abc为真值，条件成立。然而，假值也可能是undefined，0 或 false。不过：要判断 abc是null、undefined、0 或者false 时可使用本法。3、if(typeof abc == &quot;null&quot;)// 为了向下兼容，abc 为 null 时，typeof null 总返回 object，所以不能这样判断。4、 if ( isNull (abc) )// VBScript 中有 IsNull 这个函数，但 JavaScript 中没有。=============================================================================正确的方法：1、 if (! abc &amp;&amp; typeof abc != &quot;undefined&quot; &amp;&amp; abc != 0)// 这个的原理是：如果！abc 成立，则 abc 为假值，则 abc 要么是undefined，0，false或者null 。typeof abc!= “undefined” 排除了 undefined；exp != 0 排除了0 和 false （0= =false，0= =0）。所以，abc一定是剩下的null。2、最简单的方法：if (abc=== null) 尽管如此，我们在 DOM 应用中，一般只需要用 (! abc) 来判断就可以了，因为 DOM 应用中，可能返回 null，可能返回 undefined，如果具体判断 null 还是 undefined 会使程序过于复杂。三. 测试对象是否存在：在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法。对象只有被定义才有可能为 null，否则为 undefined。因此，如果我们想测试对象是否存在，必须先检测对象是否已定义。因此，这是错误的：if (abc !== null &amp;&amp; typeof abc !== “undefined”)这是正确的：if (typeof abc !== &quot;undefined&quot; &amp;&amp; abc!== null)]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript原型等概念的理解]]></title>
    <url>%2F2019%2F02%2F12%2F%E3%80%90%E5%8E%9F%E5%9E%8B%E3%80%91JavaScript%E5%8E%9F%E5%9E%8B%E7%AD%89%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.创建对象的方法在了解原型链之前，首先先了解一下创建对象的几种方式，介绍以下三种。代码：1234567891011121314151617&lt;script type="text/javascript"&gt;// 第一种方式：字面量var o1 = &#123;name: 'o1'&#125;var o2 = new Object(&#123;name: 'o2'&#125;)// 第二种方式：构造函数var M = function (name) &#123; this.name = name; &#125;var o3 = new M('o3')// 第三种方式：Object.createvar p = &#123;name: 'p'&#125;var o4 = Object.create(p)console.log(o1)console.log(o2)console.log(o3)console.log(o4)&lt;/script&gt;打印结果：对象是创建出来了，但你可能对结果很诧异，为什么不同呢？别急，慢慢来。2.构造函数、实例、原型、原型链先来一张图简单了解一下2.1 什么是原型对象？实例？构造函数？概念就不多说了，看代码吧12var M = function (name) &#123; this.name = name; &#125;var o3 = new M('o3')实例就是通过new一个构造函数生成的对象。在本例中o3就是实例，M就是构造函数。每个函数都有prorotype属性（原型），每个对象都有proto 属性（隐式原型）从上图中可以知道，实例的protpo指向原型对象。从上图中可以知道，实例的构造函数的prototype也是指向原型对象。原型对象的construor指向构造函数。再来通过下面这个图来理解一下2.2 什么是原型链？简单理解就是原型组成的链，实例的proto就是原型，而原型也是一个对象，也有proto属性，它会指向另一个原型…………就这样可以一直通过proto向上找，这就是原型链，当向上找找到Object这个构造函数的原型（即null）时，这条原型链就算到头了。也就是说，原型链的尽头是null 。2.3 原型作用何在？原型的存在是为了实现继承。我们先来思考一个问题：假如现在通过一个构造函数创建了多个实例，想要给它们添加同一个方法，该怎么做呢？1.给每个实例去添加。太过麻烦，并不是一个明智的选择；2 . 创建构造函数的时候添加方法。这样做的话在每次用构造函数创建实例时都会大量产生方法的副本，影响性能，且不利于代码复用；3 .这时，就该用上原型了。只要给实例的原型添加一个方法，那么这个原型的所有实例便都有了这个方法。由关系图可知，访问原型有两种方式，一是通过实例的proto ，二是通过构造函数的prototype。一般我们选择后者。接着上面的例子继续演示：12345678910var M = function (name) &#123; this.name = name; &#125;var o3 = new M('o3')var o5 = new M()o3.__proto__.say=furnction()&#123;console.log('hello world')&#125;/ * 或者M.prototype.say=furnction()&#123;console.log('hello world')&#125; */ o3.say() o5.say()打印结果按照JS引擎的分析方式，在访问一个实例的方法的时候，首先在实例本身中找，如果没找到就去它的原型中找，还没找到就再往上找，直到找到。实例使用原型的方法，就是继承的体现。当然，不止是方法可以继承，属性也是可以继承的。既然原型的属性可以被实例继承，那么怎么判断属性是实例本身具有的还是继承的？对实例用 hasOwnProperty( )方法即可。那么实例为何有这个方法？同样是继承来的。 由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法，其中就包括 hasOwnProperty( )方法 。2.4 原型、构造函数、实例、Function、Object的关系前面我们给出了一幅图简单梳理了一下关系，但想追本溯源，光靠那张图是不够的。下面我们给出另一张更详细的图。请先记住，Function和Object 是特殊的构造函数。首先从构造函数Foo（或任意一个普通构造函数）出发，它创建了实例f1和f2等，而实例的proto指向了Foo.prototype这个原型，该原型的proto向上再次指向其他构造函数的原型，一直向上，最终指向Object这个构造函数的原型，即Object.prototype。而Object.prototype的 proto 指向了null，这时我们说到达了原型链的终点null。回过头看，该原型又被Object构造函数的实例的proto指向，而函数的实例就是我们通常通过字面量创建的那些对象，也即是图中的o1，o2。那么，普通构造函数（这里指Foo）和特殊构造函数Object又来自于哪里？答案是，来自于另一个特殊构造函数Function。实际上，所有的函数都是由Function函数创建的实例，而构造函数当然也是函数，所以也来自于Function。从图中可以看到，实例Foo的proto和实例Object的proto 都指向了 Function的prototype，即Function.prototype 。既然所有的函数都是由Function函数创建的实例，那么Function又是怎么来的？答案是，Function自己创造了自己。它既作为创造其他实例函数的构造函数而存在，也作为实例函数而存在，所以可以在图上看到作为实例的Function的proto 指向了作为构造函数的Function的prototype。正如我们前面所说的，Function.prototype的proto也像其他构造函数.prototype的proto一样，最终指向Object.porototype，而Object.porototype的proto最终指向null，原型链结束。可以发现，经过简单梳理，这几者的关系没有我们想象的那么复杂。一句话，看懂这幅图就够了。3.instanceof的原理instanceof 沿着 实例—&gt; proto —&gt; …….. 这条线来找，同时沿着 实例的构造函数的prototype—&gt;proto —&gt; …….. 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。如下图，很显然 f1 instanceof Object 成立注意：正因为 instanceof 的原理如上所述，因此实例的instanceof在比较的时候，与原型链上向上找的的构造函数相比都是true。继续上面的代码那怎么判断实例是由哪个构造函数生成的呢？这时候就要用到constructor了。实例的原型的构造函数， obj.proto.constructor4.new运算符new运算符的原理构造函数在执行的时候，默认会创建并返回一个对象。它继承自 foo.prototype。构造函数在执行的时候，相应的参数会被传入，同时上下文(this)会被指定为这个新的实例。new foo等同于new foo() ，只能用在不传递任何参数的情况如果为构造函数显式指定了一个返回对象( return xxxxx )，那个这个对象会取代整个new出来的结果；如果未显式指定返回对象,那么那个new出来的结果为步骤1创建的对象。下面根据new的工作原理通过代码手动实现一下new运算符123456789var new2 = function (func) &#123;var o = Object.create(func.prototype); //创建对象var k = func.call(o); //改变this指向，把结果付给kif (typeof k === 'object') &#123; //判断k的类型是不是对象return k; //是，返回k&#125; else &#123;return o; //不是，返回构造函数的执行结果&#125;&#125;验证经过上图一系列折腾，不难看出，我们手动编写的new2和new运算符的作用是一样的。5.修复constructor的指向构造函数的prototype属性指向它的prototype对象，也就是原型对象，在原型对象中有一个constructor属性，指向该构造函数。但是我们在使用构造函数时，一般会重写它的原型（如：obj.prototype = new Dog( )），这会导致constructor的指向出现问题，造成继承链的紊乱，因此为了修复这个错误指向，需要显式指定obj.prototype.constructor = obj 。拿下面例子说明：未重写原型对象之前，实例化了一个dog；第6行重写了原型对象，使其指向另一个实例（等式右边是字面量，因此可以看作是由Object构造函数实例化出来的一个对象），之后实例化了一个cat。查看dog和cat的constructor：12console.log(dog.constructor); //function Animal()console.log(cat.constructor); //function Object()12dog.say(); //wancat.say(); //miao首先，实例默认是没有constructor属性的，因此会向上追溯对应的原型对象的constructor属性。dog.constructor可以指向原来的构造函数，说明原来的原型对象还存在；而cat.constructor 指向另一个构造函数，是因为Animal( )的原型被重写，并且作为Object( )构造函数的一个实例而存在，那么由cat实例出发，向上进行constructor属性追溯的时候，最终会找到Object( ) 构造函数。同样的，正因为原型重写前后创建的实例分别对应了初始原型和新的原型，所以我们可以对旧实例调用初始原型的方法、对新实例调用新的原型的方法，放在本例子中，就表现为dog依然可以调用say( )方法发出wan，而cat也可以调用say( )方法发出miao 。总结：重写原型对象之后，会切断构造函数与最初原型之间的连接，使新构造的实例对象的原型指向重写的原型，而先前构造的实例对象的原型还是指向最初原型。在这种情况下，先前的实例对象可以使用最初原型的方法，新的实例对象可以使用重写的原型的方法。参考文章：http://www.cnblogs.com/wangfupeng1988/p/3978131.htmlhttps://www.cnblogs.com/chengzp/p/prototype.htmlPS：这是两篇我认为介绍原型链比较好的博客，尤其是第一篇。作者是富文本编辑器WangEditor项目的发起者。我个人比较喜欢他讲解的方式，推荐看看。我这篇博客的灵感来自于他们，并且结合了个人的一些心得。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>原型</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英伦摇滚入门：20支英国摇滚乐队]]></title>
    <url>%2F2019%2F02%2F11%2F%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F%2F</url>
    <content type="text"><![CDATA[之前看到的一篇关于英国摇滚乐队的总结。还挺好的，不全是英伦摇滚。排名不分先后，当然，我还是偏爱Oasis。1. The Beatles（披头士乐队/甲壳虫乐队）这支才华横溢的英国乐队就不用多说了，几乎是英国摇滚的代名词，屹立半个世纪不倒，他们的作品现在还传颂世界。The Beatles（披头士乐队）虽然早已不复存在，但是他们却奠定了英式摇滚的基本基调，在国际音乐界享有盛誉。他们的贵族式的优雅反击直击摇滚的核心精神：为普通人发出声音和呐喊。爱和自由、反战是披头士永恒的创作主题。披头士有两位灵魂人物，一位是John Lennon（约翰·列侬），一位是James Paul McCartney（保罗·麦卡特尼）。喜欢这支乐队的朋友可以看看乐评《最爱那一世的疯狂——“披头士热”下的英伦风情》经典专辑：《Sergeant Pepper’s Lonely Hearts Club Band》、《Abbey Road》、《Let It Be》、《Rubber Soul》、《Help!》2. The Rolling Stones（滚石乐队）The Rolling Stones（滚石乐队）是一支非常长寿的英国摇滚乐队，一直活跃在英国的摇滚乐坛，他们和披头士分庭抗礼，代表着两种不同的摇滚理念：披头士是温和的、优雅的，而滚石则是纯粹的、爆裂性的。滚石乐队成员的平均年龄已经超过了70岁，堪称英国摇滚界的活国宝，他们身先士卒证明了什么叫“老骥伏枥，志在千里”。几个“老头子”处处践行着不服老的摇滚心态，依然能够在舞台上大放光彩，不断推出新作，这才是真正的摇滚精神！绝对的硬摇滚，粗放豪气的摇滚范儿，祝福这支长寿的乐队！经典专辑：《Let It Bleed》、《Beggars Banquet》、《Exile On Main Street》3. The Who（谁人乐队）作为“布兰顿之声”的The Who（谁人乐队），他们代表着反叛与反主流的音乐风格，他们是MOD文化的代言人，四人个性放荡不羁，反叛而激进，为青年而歌，为底层人民而歌。正是The who发明了摇滚乐的砸琴砸摔鼓的表演风格，他们是纯粹硬摇乐队，是反叛的象征，他们的舞台表演风格为后世许多的摇滚乐队所模仿。The Who创造了许多的经典歌曲，至今无人能够超越。经典专辑：《Who’s Next》、《Tommy》、《My Generation》4. The Police（警察乐队）想听慢摇风格的乐迷看过来，这支乐队非常具有传奇色彩，他们靠着借贷创作的第一张专辑就大卖一万多张。他们的乐队风格有一种华丽的英式抒情的感觉，感觉主唱的爆破音特别重，他们的歌曲特别有感染力，另外主唱Sting还会唱西班牙语，非常多才多艺。这支乐队只有三个人，但是曾经获得了六次格莱美奖，乐队在义演散场之后宣布告别，但是灵魂人物Sting现在还活跃在英国乐坛之上，还多次斩获格莱美。经典专辑：《Regatta de Blanc》、《Zenyatta Mondatta》、《Wrapped Around Your Finger》5. Pink Floyd（平克·弗洛伊德）大PF是必须要说的，促使我去了解英国摇滚乐队的就是披头士和Pink Floyd（平克·弗洛伊德）了，PF不算是那种非常有盛誉的那种乐队，但是我就是喜欢。他们的音乐充满哲学的思辨气质和浪漫主义的想象力，专辑的艺术感极强，尤其是他们开创的太空迷幻摇滚，简直是致幻的LSD，令人沉醉其中不能自拔。他们在音乐技术上的突破和对迷幻摇滚新领域的开辟，都在音乐史上不可被磨灭，这支乐队有一支长达23分钟的神奇的单曲——《Echoes》，号称一曲走天下，他们的《月之暗面》（The Dark Side of The Moon）和《迷墙》（The Wall）两张专辑永垂不朽。某种程度上来说，我甚至觉得他们是一支被低估了的乐队。经典专辑：《The Wall》、《The Dark Side of the Moon》、《Ummagumma》6. Sex Pistols（性手枪乐队）要说到英国的朋克摇滚，就必须要说到Sex Pistols，在1976年，性手枪参加了伦敦牛津The 100俱乐部举办的朋克音乐节，至今这个节日还被认为是朋克文化的发源地。这是一支真正的朋克乐队，有人甚至评价道：“性手枪之后再无朋克”，如果你去听了他们的音乐，就会发现这是真的。他们的音乐充满了黑色幽默和调侃，歇斯底里的反叛甚至是下流的感觉，但这就是真正的朋克精神——彻底的毁灭与自我毁灭。他们的歌曾经登上了BBC排行榜榜首，让全英国人民都为朋克摇旗呼喊，让朋克文化高涨兴盛。但是这支乐队好景不长，他们连换了三个唱片公司，但乐队成员相继离开，最终没落令人十分惋惜。经典专辑：《Jubilee》、《Never Mind the Bollocks Here’s the Sex Pistols》7. The Clash（碰撞乐队/冲击乐队/冲撞乐队）与性手枪相比，The Clash并不算是真正的朋克乐队，因为他们后期逐渐商业化，但是The Clash前期对朋克摇滚做出了巨大的贡献。他们的首张同名专辑就一炮成名，被封为朋克圣典。但是后期的碰撞乐队逐渐吸收了许多的流行摇滚的元素，他们的MTV商业运作得很好。The Clash与Sex Pistols一起铸就了朋克乐队的高峰。碰撞关注社会底层人民的生活状况，他们的歌曲里面充满了对失业、种族歧视和黑帮犯罪势力的反抗和控诉，而且碰撞乐队在美国市场上还比较成功，让英国朋克摇滚名声在外。经典专辑：《London Calling》、《The Clash》、《Black Market Clash》8. Iron Maiden（铁娘子乐队）重金属恶魔的铁娘子乐队！生猛的铁娘子！牛逼的铁娘子！正是他们开启了英国的重金属浪潮。他们是一支霸气的重金属乐队，乐队几经分合，但是做了很多的音乐新领域的尝试，他们做了很多摇滚器乐实验，奠定了铁娘子在重金属领域中的地位。Iron Maiden的曲风非常硬朗，听得人情绪高涨，不自觉地High，主唱的声音简直是绝对的歇斯底里，他们的吉他行云流水，贝斯出神入化，想感受下重金属激情的迷妹一定要去听一下，没听过他们你都不好意思说你听过重金属。经典专辑：《Killers》、《Piece Of Mind》、《Iron Maiden》、《Number of the Beast》9. Def Leppard（威豹乐队）威豹也是英国重金属新浪潮中一支非常重要的乐队，这支乐队70年代末期组建，80年代成名，他们在硬摇滚上造诣很高。80-90年代期间是他们商业最成功的阶段，在美国都具有广泛的影响力。威豹也不是那种纯粹的重金属乐队，他们的情歌非常的好听感人，主唱Joe Elliott的声音是略带沧桑的沙哑，这些摇滚汉子唱起情歌分分钟秒杀你的心灵。另外乐队的长发造型很酷炫，而且他们是双吉他演奏，节奏非常动人优美。这个乐队最令人感动的是鼓手，只有一条手臂还怀着一颗坚毅的心重返乐队，我很敬佩这样牛逼的音乐人。另外他们的合声也是相当美丽的，很少有摇滚乐队合声如此好听，默契到位又流畅自然，分分钟刷新你的重金属三观。经典专辑；《Best of Def Leppard》、《Hysteria》、《Retro Active》10. Suede（山羊皮乐队）Suede（山羊皮乐队）在90年代非常受欢迎，一开始这支乐队其实是倍受质疑的，后来才受到了大众的喜爱。他们的风格是另类摇滚和英式摇滚。这和当时的摇滚大环境有关，90年代，英国传统摇滚乐的巅峰已经接近末声，演化出了英式摇滚，Suede其实就是这些乐队之一。他们的风格比较邪魅狂绢，充满了一种癫狂和风情万种的艺术气质，主唱的声音听多了会怀孕的。山羊皮对华挺友好的，曾经来过中国演出。还有令无数歌迷沉醉的还有主唱的颜值——他年轻的时候简直帅呆了！经典专辑：《The Drowners》、《Suede》、《Coming Up》、《Head Music》11. Oasis（绿洲乐队）Oasis（绿洲乐队）组建于曼彻斯特，是一支个性狂放的乐队，这和乐队的两兄弟的性格有关系。这支乐队最好的地方在于结合了流行摇滚与传统摇滚，传承了传统摇滚的精髓，乐评家非常钟爱这支乐队，对他们给予很高的评价。一说到英式摇滚人们首先会想到就是绿洲，其次是Blur，他们的吉他简直是神了，奠定了英式摇滚的吉他抒情风格。但是他们也叛逆咆哮，这完全不同于像披头士那样的“乖小孩”，自带一种粗犷的摇滚天性。经典专辑：《Definitely Maybe》、《Morning Glory》12. Radiohead（电台司令乐队）Radiohead（电台司令）是那种让人绝望抑郁至死的乐队，个人觉得偶尔听一下还是不错啦。这支乐队的评价还是蛮好的，他们的风格很沉郁，在歌词的创作上独具匠心。灵魂人物兼主唱Yorke性格敏感脆弱，他们的作品里充满了一种病态美学的美感，吟唱人性最卑微脆弱之处，像《Creep》这种就是他们风格的集大成之作，这种风格在摇滚乐队里是比较少见的。经典专辑：《The Bends》、《OK Computer》、《 Kid A 》13. Muse（缪斯乐队）多元的音乐风格、对英式摇滚拿捏到刚刚好的新生代英国摇滚乐队。融合重金属、电子音乐、前卫音乐、太空摇滚等等元素。更难得的是，从缪斯的歌曲里你还能听出千丝万缕的英国古典音乐气息，就像灵魂一样穿插在乐曲之中，非常特别，这在英国这样一个复古气息非常浓厚的国家非常有代表性，所以我认为他们的英式摇滚的头衔是应得的。有人说缪斯主唱Bellamy的唱腔和Yorke很像，细听确实有一点，都有一种浅唱低吟的感觉，但是Bellamy更加积极魅惑一点，不似Yorke给人彻彻底底地绝望之感。经典专辑：《Black Holes and Revelations》、《Absolution》、《The 2nd Law》14. Blur（模糊乐队/布勒乐队/污点乐队）这支乐队和绿洲一起是一个神奇的存在，最为乐迷津津乐道的就是Blur（模糊乐队）与绿洲的掐架了，因为他们的风格挺像的，都是英式摇滚路线。但是我觉得模糊乐队没有像绿洲那样的狂放个性，显得更加的温和内敛，所以这支乐队被认为具有披头士的神韵。很多人评价一支乐队经常说某某乐队是某某乐队的接班人，我其实并不喜欢这种评价，乐队和乐队之间是一种传承和学习的关系，但是每个乐队都是一个独立的个体，所以我觉得披头士是披头士，Blur是Blur。近几年Blur做了一些比较诡异的尝试，风格越来越让人摸不透了，不过有了自己的经典之作之后，他们想做一些新的突破也是非常勇敢的。经典专辑：《The Best Of Blur》、《The Great Escape》、《Parklife》15. Travis（特拉维斯乐队）这是来自苏格兰的一支传统摇滚乐队，他们涉足英式摇滚、传统摇滚、Post-Grunge与另类摇滚多个领域。乐队成员都是70后，他们最开始只是一个小地方的乐团，发行第二张专辑之后难掩才华，一时间成为英国摇滚乐坛巨星。其实我觉得主唱的声线是比较忧郁的，唱歌的方式有点浅唱低吟的感觉。他们也尝试过软摇滚，总之是一支听起来比较舒服的乐队。经典专辑：《The Man Who》、《Side》、《Pipe Dreams》16. Queen（皇后乐队）一支华丽丽的硬摇乐队，作品具有浓厚的歌剧色彩，非常硬，乐队的歌曲都保留了那种老式硬摇滚的精髓，键盘和完美的吉他Solo是他们的特点。主唱Freddie Mercury的声音是摇滚乐坛少有的好嗓，非常高亢嘹亮，天生是摇滚主唱的料，这也给皇后乐队注入了一种恢弘而大气磅礴的音乐感染力，但Freddie Mercury不幸因染上艾滋病辞世，全球歌迷为之震惊心痛。在失去这位灵魂人物之后，皇后乐队还是人气高涨，不断出了好作品，最终被选入摇滚名人堂。经典专辑：《A Night at The Opera》、《Innuendo》、《A Kind of Magic》17. Black Sabbath（黑色安息日乐队）一看名字就知道这是支重金属乐队，乐队组建于伯明翰。这支乐队音色纯正，音乐简单干净又粗暴，但是他们的歌曲具有深刻的现实意义。他们的歌曲关注当时的核战争和死亡，描写毒品、反叛、青年和灰暗的生活命运，反映了底层人的痛苦绝望的生活状态，深受当时年轻人的喜爱。这支乐队的辉煌时期在70年代，后来渐渐地没落。好像70年代的英国朋克乐队都很难长久，不知道这是个什么怪圈，我想这可能是因为朋克自身所带的那种毁灭性，使他们自己也无法长久吧。经典专辑：《Paranoid》、《Vol. 4》、《Master Of Reality》、《Sabbath Bloody Sabbath》18. Snow Patrol（雪地巡游者乐队）Snow Patrol（雪地巡游者乐队）是一支来自苏格兰的乐队，乐队风格清新哀婉，歌词非常的温暖感人，是当代比较成功的英国摇滚乐队。乐队风格是迷幻和另类路线，出了一些很不错的单曲，我个人比较喜欢他们的一些作品，可以拿来听听。听他们的歌曲非常的治愈，给人温暖、干净而清澈的感觉，近几年也是风生水起，至于未来还会怎样发展，还有很多的可能性。经典专辑：《Final Straw》、《Up To Now》19. Led Zeppelin（齐柏林飞船）被誉为重金属鼻祖的一支英国乐队，他们的重金属融合了朋克、中东音乐、蓝调、乡村、雷鬼音乐等等元素。他们的有的歌曲听起来很忧伤，令人神往遐思，代入感极强。有很多歌曲的歌词非常的有深度，甚至是对人性的拷问和追寻。他们的音乐前奏都非常漂亮，节奏感超强。虽然是重金属乐队，但是其并没有像后期的重金属乐队那样太多的嘶吼和器乐嘈杂，很是入耳。经典专辑：《Led Zeppelin Ⅳ》、《Houses of the Holy》、《Physical Graffiti》20. The Kinks（奇想乐队）奇想是一支老乐队了，他们主要活跃在60-70年代，在流行摇滚上造诣颇高，曲风也是蛮广的，迷幻、流行随手拈来。作为“不列颠入侵”的主要乐队之一，奇想与披头士、谁人和滚石并称为英国摇滚乐坛“Big Four”，当时的英国摇滚就是这四个乐队大放异彩、风靡全球。奇想也是摇滚名人堂的成员，但是96年这个乐队就解散了。他们的歌曲听着很舒服，充满怀旧伤感之情。可惜的是，这支本来很优秀的乐队在当时有点被披头士的巨大光芒掩盖了，现在去重新发现下也是不错的。经典专辑：《Face to Face》、《Muswell Hillbillies》、《Arthur》英国的摇滚乐队不胜枚举，大大小小的、成名的不成名的、大众的和小众的非常多，他们各有风格，但是真正能够在摇滚史上留下名字的乐队还是少数。总的来说，英国摇滚的特点是自成一派的英式摇滚，还有PF所创立的迷幻摇滚流派，加之上世纪70年代的朋克摇滚，这些都是英国土生土长的摇滚形式。除此外，英国摇滚还有其独有的思想性，从披头士的爱、和平、反战，到朋克对现实的抨击，及众多英式摇滚乐队的壮大复兴，都是英国摇滚乐的迷人之处。]]></content>
      <categories>
        <category>音乐</category>
        <category>英伦摇滚</category>
      </categories>
  </entry>
</search>
