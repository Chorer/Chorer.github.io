<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从清除浮动和margin塌陷问题谈BFC]]></title>
    <url>%2F2019%2F05%2F17%2FF-%E4%BB%8E%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin%E5%A1%8C%E9%99%B7%E8%B0%88BFC%2F</url>
    <content type="text"><![CDATA[1.清除浮动浮动的元素会影响其兄弟元素的位置，并可能导致父元素的高度塌陷（假如父元素没设置高度），因此需要清除浮动（带来的影响）。1.1 方法常用方法有：给浮动元素的父元素一个固定高度（不推荐）给浮动元素新增一个空的 div 兄弟元素，设置 clear:both给浮动元素新增一个 &lt;br&gt; 兄弟元素，设置 clear 属性为 all给浮动元素的父元素新增一个 after 伪类，设置该伪类和父元素：div{ zoom:1; } div:after{ content:""; display:block; clear:both; } 给浮动元素的父元素设置 display: table（触发BFC）给浮动元素的父元素也设置浮动（触发 BFC。不推荐）给浮动元素的父元素设置 overflow: hidden（触发 BFC）1.2 原理这里主要说下 clear:both。clear:both 意思是说，设置了该属性的元素，其左边和右边不允许存在浮动元素。父元素高度塌陷的情况：子元素浮动后脱离了文档流，未设置高度的父元素在形式上表现为 0 高度，设置了 clear:both 的元素为了满足其左右两边没有浮动元素的这个条件，只能自身下移，从而带动了父元素高度的撑开。兄弟元素覆盖的情况：同理，比如A由于浮动覆盖了 C，我们在 AC 之间新增一个 B 元素，则 BC 位于同一文档流，B 为了满足其左右两边没有浮动元素的这个条件，只能自身下移，从而带动了 C 元素向下移动直到没有被 A 覆盖。那么为什么除了 clear:both 之外，其他方法也能清除浮动呢？因为那些方法大都触发了 BFC，而 BFC 是可以清除浮动的，这个后面再介绍。2.margin 塌陷文档流内，块级元素与块级元素在垂直方向上的 margin 有时会合并（塌陷）为单个 margin，这样的现象称之为 margin 塌陷（margin collapse）。具体包括三种情况：相邻的兄弟元素之间：原因：相邻的兄弟元素默认位于同一个块级上下文中计算规则：正正取大值，正负值相加，负负最小值父元素与第一个/最后一个子元素之间：原因：a.margin-top 重叠父元素非块状格式化上下文元素父元素没有border-top设置父元素没有padding-top值父元素和第一个子元素之间没有inline元素分隔b.margin-bottom 重叠父元素非块状格式化上下文设置父元素没有 border-bottom 设置父元素没有 padding-bottom 值父元素和第一个子元素之间没有inline元素分隔父元素没有 height，min-height，max-height计算规则：子元素和父元素上边界重叠，并且以子元素的 margin-top 作为父元素的 margin-top 整体移动。对于 margin-bottom 同理。空的block元素:原因：元素没有 border 设置元素没有 padding 值里面没有 inline 元素没有 height 或者min-height那么怎么解决 margin 塌陷问题呢？同样是利用接下来要讲到的 BFC。3.BFC3.1 什么是 BFC？BFC 即 Block formatting context，译为块级格式化上下文。简单来说，它是一种属性，这种属性影响着元素的定位以及与其兄弟元素之间的相互作用。因为是属性，所以我们通常说“元素具有 BFC”、“元素触发了 BFC”，而不说“元素是 BFC”。从样式上看，具有 BFC 的元素与普通的容器没有什么区别；但是从功能上，具有 BFC 的元素可以看作是隔离了的独立容器，容器里面的子元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性。3.2 如何触发 BFC？CSS 规定满足下列 CSS 声明之一的元素便会生成 BFC：根元素或其它包含它的元素；float 的值不为 none；overflow 的值不为 visible；position 的值为 absolute 或 fixed；display 的值为 inline-block、table-cell、table-caption、table、flex、inline-flex、flow-roottable 本身不生成 BFC，而是 table 默认生成的匿名 table-cell 会生成 BFC3.3 BFC 的特性从整体上看，BFC 是隔离了的容器，这个具体可以表现为三个特性：3.3.1 BFC 会阻止 margin 塌陷前面我们说过 BFC 可以用于解决 margin 塌陷问题。因为相邻兄弟元素默认位于同一个 BFC 是导致 margin 塌陷的原因，所以我们只需要设法隔离它们两者即可 ———— 假设有兄弟元素 A 和 B，可以使 A 的父元素触发 BFC，此时，触发了 BFC 的父元素里面的 A 子元素不会在布局上影响到 B，也自然不会有 margin 的叠加。同样地，如果是父子嵌套的 margin 塌陷问题，只需要触发父元素的 BFC 即可。3.3.2 BFC 可以包含浮动的元素前面说过，父元素没有设置高度时，子元素的浮动会导致父元素表现为 0 高度，也就是说正常情况下父元素无法包含浮动的子元素。如图：.Fa{ border: 2px solid red; width: 300px; } .son{ width:180px; height:180px; background-color:yellow; float:left; } 但是触发了父元素的 BFC 后，父元素将可以包含浮动的子元素。如图：.Fa{ border: 2px solid red; width: 300px; overflow:hidden; /* 随便一个 BFC 的触发条件 */ } .son{ width:180px; height:180px; background-color:yellow; float:left; } 3.3.3 BFC 可以阻止元素被浮动元素覆盖前面说过浮动元素会影响兄弟元素的位置，具体地说就是浮动之后脱离了文档流，使得兄弟元素上移填补空缺，而这会使得它被浮动元素覆盖。如图：但是触发了兄弟元素的 BFC 后，兄元素将不会被浮动的元素覆盖 ———— 不会被覆盖，意味着兄弟元素出现在浮动元素的旁边或者下面，具体取决于父元素的宽度。如果父元素的宽度足以包含这两个子元素的宽度之和，则子兄弟元素和子浮动元素并排。如图：如果父元素的宽度不足以包含这两个子元素的宽度之和，则子兄弟元素会出现在子浮动元素的下面。如图：4.可视化格式模型让我们进一步拓展一下可视化格式模型的一些概念，由于比较复杂，所以只做了解即可。可视化格式模型规定了客户端（浏览器）如何在媒介（显示器）中渲染文档树(document tree)。如下图，每个节点、元素都有属于自己的可见或不可见、有名或匿名的盒模型，可视化格式模型即规定了这些盒、框框如何整齐地排列在页面中，还有盒子之间的相互作用。可视化格式模型的体系包括：1.包含块 CB(Containing block)2.控制框：块框、行框3.FC(Formatting Context, 格式化上下文)BFC(Block Formatting Context, 块级格式化上下文)IFC(Inline Formatting Context, 行内格式上下文)GFC(Grid Formatting Context, 网格布局格式化上下文)FFC(Flex formatting contexts, 自适应格式上下文)4.定位体系/方案(普通流、定位流、浮动流)5.浮动体系这里只说 FC 和定位体系。4.1 FCFC 即 Formatting context，译为格式化上下文。这是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系、相互作用。除了最常见的 CSS2.1 中的 BFC 和 IFC 之外，CSS3 中还增加了 GFC 和 FFC。4.1.1 BFC：前面已经说过了。4.1.2 IFC：IFC 的 line box 高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。IFC 的line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 IFC 下的多个 line box 高度会不同。IFC 中是不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。那么IFC一般有什么用呢？水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。4.1.3 GFC：当为一个元素设置 display:grid 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么 GFC 有什么用呢，和 table 又有什么区别呢？首先同样是一个二维的表格，但 GridLayout 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。4.1.4 FFC：display:flex 或者 display:inline-flex 的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少 safari 和 chrome 还是 OK 的，毕竟这俩在移动端才是王道。Flex box 由伸缩容器和伸缩项目组成。通过设置元素display:flex 或者 display:inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flex box 定义了伸缩容器内伸缩项目该如何布局。4.2 定位方案在定位的时候，浏览器会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。在 CSS2.1 中，有三种定位方案 ———— 普通流、浮动和绝对定位，下面分别对这三种布局简略说明一下：普通流(Normal flow)在普通流中，盒一个接着一个排列;在块级格式化上下文里面，它们竖着排列；在行内格式化上下文里面，它们横着排列;通常情况下， position 为 static 或 relative，并且 float 为 none ，因而会触发普通流；position 为 static 时，盒的位置是常规流布局里的位置；position 为 relative 时，盒偏移位置由 top，bottom，left 和 right 定义。即使有偏移，仍然保留原有的位置，其它普通流不能占用这个位置。浮动 (Floats)元素脱离普通流，并且影响普通流的布局 ———— 导致普通流环绕在它的周边，除非设置 clear 属性；盒称为浮动盒(floating boxes)；它位于当前行的开头或末尾；绝对定位 (Absolute positioning)元素脱离普通流，并且不影响普通流的布局它的定位相对于它的包含块，相关CSS属性：top，bottom，left 和 right；如果元素为 position:absolute 或 position:fixed，它是绝对定位元素；对于 position: absolute，元素将相对最近的一个非 static 定位的父元素进行定位，如果没有则相对于 body；参考：https://juejin.im/post/59b73d5bf265da064618731d#heading-1https://wz71014q.github.io/2019/03/23/CSS-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B/#more]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
      <tags>
        <tag>BFC</tag>
        <tag>浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「译」JavaScript 究竟是如何工作的？（第一部分）]]></title>
    <url>%2F2019%2F05%2F10%2FTrs-Javascript%20%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文地址：How Does JavaScript Really Work? (Part 1)原文作者：Priyesh Patel译者：Chor如果你是一个 JS 开发者或者是正在学习这门语言的学生，很大概率上你会遇到双字母词”V8”。在这篇文章中，我将会为你简述不同的 JS 引擎并深入探究 V8 引擎的工作机制。文章的第二部分涵盖了内存管理的概念，不久后将发布。这篇文章是由 Bit (GitHub) 带来的。作为一个共享组件的平台，Bit 帮助每个人构建模块化的 JavaScript 应用程序，在项目和团队之间轻松地共享组件，同时实现更好&amp;更快的构建。试试看。1.编程语言是如何工作的？在开始讲解 JavaScript 之前，我们首先要理解任意一门编程语言的基本工作方式。电脑是由微处理器构成的，我们通过书写代码来命令这台小巧但功能强大的机器。但是微处理器能理解什么语言？它们无法理解 Java，Python 等语言，而只懂机器码。用机器语言或汇编语言编写企业级代码是不可行的，因此我们需要像 Java，Python 这样配带一个解释器或者编译器用于将其转换为机器码的高级语言。1.1编译器和解释器编译器/解释器可以用它处理的语言或任何其他语言来编写。解释器： 一行一行地快速读取和翻译文件。这就是 JavaScript 最初的工作原理。编译器： 编译器提前运行并创建一个文件，其中包含了输入文件的机器码转换。有两种途径可以将 JavaScript 代码转换为机器码。编译代码时，机器对代码开始运行前将要发生的事情有更好的理解，这将加快稍后的执行速度。不过，在这个过程之前需要花费时间。另一方面，解释代码时，执行是立即的，因此要更快，但是缺乏优化导致它在大型应用程序下运行缓慢。创建 ECMAScript 引擎的人很聪明，他们集二者之长开发了 JIT(Just-in-time) 编译器。JavaScript 同时被编译和解释，但实际实现和顺序取决于引擎。我们将会看到 V8 团队采用的是什么策略。2.从 JavaScript 到机器码就 JavaScript 而言，有一个引擎将其转换为机器码。和其他语言类似，引擎可以用任何语言来开发，因此这样的引擎不止一个。V8 是谷歌针对 Chorme 浏览器的引擎实现。SpiderMonkey 是第一个引擎，针对网景浏览器开发，现用于驱动 FireFox。JavaScriptCore 是苹果针对 Safari 浏览器使用的引擎。还有很多，如果你想知道 Internet Explorer 背后的引擎，查看这个维基百科页面.2.1 ECMAScript面对这么多的引擎，你可能会问：我可以开发自己的引擎吗？可以，只要遵循 ECMAScript 标准。如果我们打算做一个翻译器，那么就必须知道这两门语言的有效字。我们已经知道机器语言中什么是有效的了，但是对于 JavaScript，这是需要进行标准化的。JavaScript 的标准化工作是由 Ecma 国际组织负责的，相关规范被称为 ECMAScript 或者 ES。因此，当你看到一篇文章/视频提到“ES7 有什么新特性？”时，你就知道它代表的是 ECMAScript 标准中新增的 JS 特性。3.V8 引擎3.1 部分历史谷歌针对浏览器开发了谷歌地图，而这对浏览器的处理能力提出了很高的要求。那时的 JavaScript 实现尚不足以快速地运行地图。谷歌想要吸引更多的用户使用这项服务，从而进行广告销售并牟利。基于这个原因，这项服务必须快速且稳定。因此谷歌自己用 C++ 开发了 V8 引擎并在 2008 年启用，它的速度很快，或者就像一些人说的，它的速度是最快的。3.2 解析和构建树JavaScript 文件进入引擎后，解析器进行词法解析，它将代码分解成 token 以确定它们的含义。这些 token 组成了AST(抽象语法树)。编译器在语义分析中验证语言元素和关键词的正确用法，而 ASTs 在这个过程中扮演着重要的角色。之后，ASTs 被用于生成实际的字节码或者机器码。3.3 引擎的核心我们之前谈到，JavaScript 是由 Ignition 这个解释器解释的，同时由 TurboFan 这个 JIT 优化编译器进行编译。首先，前面步骤生成的 ASTs 传递给解释器，该解释器迅速生成未经过优化的机器码，并且其执行是无延迟的。Profiler 在代码运行时进行观察，找出可以进行优化的地方。例如，一个‘for’循环跑了 100 次，但是每次迭代产生的结果都是一样的。使用这个分析器后，任何未优化的代码都将传递给编译器以进行优化，同时生成机器码，它最终会替换掉之前由解释器生成的未优化代码中的对应部分。随着分析器和编译器不断地更改字节码，JavaScript 的执行性能逐渐提高。3.4 更多历史在V8 的 5.9 版本推出之前，它使用两个优化编译器和一个基线编译器。基线编译器 full-codegen 迅速生成未优化的机器码。两个优化编译器 Crankshaft 和 TurboFan 用于优化代码。JavaScript 增加了新的特性后，架构的复杂度上升，维护相同的管道对 V8 团队来说变得更加困难了。如果你想阅读更多相关的旧方法以及转向新管道的原因，可以访问他们的网站。3.5 放眼未来随着更多进一步提升性能的研究的进行，V8 引擎的工作机制在未来还可能发生变化。此外，随着 Webassembly 逐渐成形，可能会向管道添加额外步骤。4.结论ECMAScript 引擎的实现有很多，其中以谷歌的 V8 最为出名。希望这篇文章的简述不仅可以帮助你理解 JavaScript 的工作原理，还能从大体上了解一门编程语言的工作原理。如果你想了解 V8 团队的未来计划或者引擎的细节，这里有一篇很不错的博客。本文的第二部分将会在不久后发布，其中将谈到内存堆，栈，事件循环以及更多与 JavaScript 代码执行相关的概念。敬请关注！如果你不清楚 Node.js 在其中的作用，我这里碰巧写了一篇不错的文章：What exactly is Node.js?]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻译术语表]]></title>
    <url>%2F2019%2F05%2F03%2FTrs-%E7%BF%BB%E8%AF%91%E6%9C%AF%E8%AF%AD%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[翻译技术文章时积累的术语，可用于阅读，也可用于规范提问。English中文English中文arity参数个数argument实参assignment赋值array of arrays多维数组block scope块级作用域build-in内置的currying柯里化class-based基于类的classical inheritance类式继承closure闭包coexist共存declarative声明式dynamic动态的duplicate重复；副本execution context执行上下文event handler事件处理器event driven事件驱动的function signature函数声明free variable自由变量getter-only只读global scope全局作用域global variable全局变量hoist提升invoke调用identifier标识符iterate遍历iterator迭代器non-extensible不可拓展Object-oriented面向对象的prototypal inheritance原型式继承private property私有属性prototype chain原型链parameter形参scope chain作用域链strict mode严格模式semantics语义statement语句silentl failure静默失败syntactical sugar语法糖throw an exception抛出异常library库framework框架LexicalEnvironment词法环境programming patterns and paradigms编程范式heap堆stack栈sync同步async异步instance实例encapsulation封装implicit隐式explicit显式call by value按值调用call by reference按引用调用override覆盖binding绑定Immediately Invoked Function Expression立即执行函数表达式Named Function Expression具名函数表达式single thread单线程recursive递归snippet代码片段resolve解析LIFO（Last-In-First-Out）先进后出FIFO（First-In-First-Out）先进先出loop循环backward compatibility向下（向后）兼容destructuring assignment解构赋值enumerated可枚举的distributed version control system（VCS）分布式版本控制系统roll back回滚cross-platform跨平台的]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「译」ES6：参数默认值的实现细节]]></title>
    <url>%2F2019%2F05%2F02%2FTrs-ES6%EF%BC%9A%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%2F</url>
    <content type="text"><![CDATA[原文地址：ES6: Default values of parameters原文作者：Dmitry Soshnikov译者：Chor在这篇文章中我们会介绍另一个 ES6 的特性，带默认值的函数参数。正如我们将看到的，有一些微妙的案例。1.ES5 及更低版本的手动默认值以前的默认参数值是通过以下几种可选方式手动处理的：function log(message, level) { level = level || 'warning'; console.log(level, ': ', message); } log('low memory'); // warning: low memory log('out of memory', 'error'); // error: out of memory 为了避免参数未传递的情况，通常可以看到 typeof 检查：if (typeof level == 'undefined') { level = 'warning'; } 有时，你也可以检查 arguments.length :if (arguments.length == 1) { level = 'warning'; } 所有这些方法都行之有效，但是，它们太偏向手动了，并且不够抽象。ES6 标准化了一种句法结构，在函数头直接定义了参数默认值。2.ES6 默认值：基本实例许多语言都存在默认参数值，所以大多数开发人员应该熟悉它的基本形式：function log(message, level = 'warning') { console.log(level, ': ', message); } log('low memory'); // warning: low memory log('out of memory', 'error'); // error: out of memory 这种默认参数用法相当随意，但是却很方便。让我们深入实现细节来理清默认参数可能带来的困惑。3.实现细节以下是一些关于 ES6 函数默认参数值的实现细节。3.1 执行阶段的重新计值一些其他语言（例如 Python）会在定义阶段对默认参数进行一次计值，相比之下，ECMAScript 则会在执行阶段计算默认参数值 —— 每次函数调用的时候。采用这种设计是为了避免与作为默认值的复杂对象混淆。思考下面的 Python 例子：def foo(x = []): x.append(1) return x # 我们可以看到默认值在函数定义时 # 只创建了一次，并且保存于 # 函数对象的属性中 print(foo.__defaults__) # ([],) foo() # [1] foo() # [1, 1] foo() # [1, 1, 1] # 正如我们所说的，原因是： print(foo.__defaults__) # ([1, 1, 1],) 为了避免这种情况，Python 开发者习惯将默认值定义为 None，并且显式检查这个值：def foo(x = None): if x is None: x = [] x.append(1) print(x) print(foo.__defaults__) # (None,) foo() # [1] foo() # [1] foo() # [1] print(foo.__defaults__) # ([None],) 但是，这与手动处理实际默认值的方式是一样不方便的，并且最初的案例让人感到疑惑。因此，为了避免这种情况，ECMAScript 会在每次函数执行时计算默认值：function foo(x = []) { x.push(1); console.log(x); } foo(); // [1] foo(); // [1] foo(); // [1] 一切都很好，很直观。接下来你会发现，如果我们不了解默认值的工作机制，ES 语义可能会让我们感到困惑。3.2 外部作用域的遮蔽思考下面的例子：var x = 1; function foo(x, y = x) { console.log(y); } foo(2); // 2，不是 1！ 正如我们看到的，上面的例子输出的 y 是 2 ，不是 1 。 原因是参数中的 x 与全局的 x 不是同一个。由于执行阶段会计算默认值，在赋值 = x 发生的时候， x 已经在内部作用域被解析了，并且指向了 x 参数自身。具有相同名称的参数 x 遮蔽了全局变量，使得对来自默认值的 x 的所有访问都指向参数。3.3 参数的 TDZ（暂时性死区）ES6 提到了所谓的 TDZ（表示暂时性死区）—— 这是程序的一部分，在这个区域内变量或者参数在初始化（即接受一个值）之前将无法访问。就参数而言，一个参数不能以自身作为默认值：var x = 1; function foo(x = x) { // 抛出错误！ ... } 我们上面提到的赋值 = x 在参数作用域中解析 x ，遮蔽了全局 x 。 但是，参数 x 位于 TDZ 内，在初始化之前无法访问。因此，它无法初始化为自身。注意，上面带有 y 的例子是有效的，因为 x 已经初始化（为隐式默认值 undefined ）了。我们再来看一下：function foo(x, y = x) { // 可行 ... } 之所以可行，是因为 ECMAScript 中的参数是按照从左到右的顺序初始化的，我们已经有可供使用的 x 了。我们提到参数已经与“内部作用域”相关联了，在 ES5 中我们可以假定是函数体的作用域。但是，它实际上更加复杂：它可能是一个函数的作用域，或者是一个为了存储参数绑定而特别创建的中间作用域。我们来思考一下。3.4 特定的参数中间作用域事实上，如果一些（至少有一个）参数具有默认值，ES6 会定义一个中间作用域用于存储参数，并且这个作用域与函数体的作用域不共享。这是与 ES5 存在主要区别的一个方面。我们用例子来证明：var x = 1; function foo(x, y = function() { x = 2; }) { var x = 3; y(); // `x` 被共用了吗？ console.log(x); // 没有，依然是 3，不是 2 } foo(); // 并且外部的 `x` 也不受影响 console.log(x); // 1 在这个例子中，我们有三个作用域：全局环境，参数环境，以及函数环境：: {x: 3} // 内部 -> {x: undefined, y: function() { x = 2; }} // 参数 -> {x: 1} // 全局 我们可以看到，当函数 y 执行时，它在最近的环境（即参数环境）中解析 x ，函数作用域对其并不可见。3.4.1 转译为 ES5如果我们要将 ES6 代码编译为 ES5，并看看这个中间作用域是怎样的，我们会得到下面的结果：// ES6 function foo(x, y = function() { x = 2; }) { var x = 3; y(); // `x` 被共用了吗？ console.log(x); // 没有，依然是 3，不是 2 } // 编译为 ES5 function foo(x, y) { // 设置默认值。 if (typeof y == 'undefined') { y = function() { x = 2; }; // 现在可以清楚地看到，它更新了参数 `x` } return function() { var x = 3; // 现在可以清楚地看到，这个 `x` 来自内部作用域 y(); console.log(x); }.apply(this, arguments); } 3.4.2 参数作用域的源由但是，设置这个参数作用域的确切目的是什么？为什么我们不能像 ES5 那样与函数体共享参数？理由是：函数体中的同名变量不应该因为名字相同而影响到闭包绑定中的捕获行为。我们用下面的例子展示：var x = 1; function foo(y = function() { return x; }) { // 捕获 `x` var x = 2; return y(); } foo(); // 是 1，不是 2 如果我们在函数体的作用域中创建函数 y，它将会捕获内部的 x ,也即 2。但显而易见，它应该捕获的是外部的 x，也即 1(除非它被同名参数遮蔽)。同时，我们无法在外部作用域中创建函数，这意味着我们无法从这样的函数中访问参数。我们可以这样做：var x = 1; function foo(y, z = function() { return x + y; }) { // 可以看到 `x` 和 `y` var x = 3; return z(); } foo(1); // 2，不是 4 3.4.3 何时不会创建参数作用域上述的语义与默认值的手动实现是完全不同的：var x = 1; function foo(x, y) { if (typeof y == 'undefined') { y = function() { x = 2; }; } var x = 3; y(); // `x` 被共用了吗？ console.log(x); // 是的！ 2 } foo(); // 外部的 `x` 依然不受影响 console.log(x); // 1 现在有一个有趣的事实：如果一个函数没有默认值，它就不会创建这个中间作用域，并且会与一个函数环境中的参数绑定共享，即以 ES5 模式运行。为什么要这么复杂呢？为什么不总是创建参数作用域呢？这仅仅和优化有关吗？并非如此。确切地说，这是为了向下兼容 ES5：上述手动实现默认值的代码应该更新函数体中的 x（也就是参数自身，且位于相同作用域中）。同时还要注意，那些重复声明只适用于 var 和函数。用 let 或者 const 重复声明参数是不行的：function foo(x = 5) { let x = 1; // 错误 const x = 2; // 错误 } 3.5 undefined 检查还要注意另一个有趣的事实，是否应用默认值，取决于对参数初始值（其赋值发生在一进入上下文时）的检查结果是否为值 undefined 。我们来证明一下：function foo(x, y = 2) { console.log(x, y); } foo(); // undefined, 2 foo(1); // 1, 2 foo(undefined, undefined); // undefined, 2 foo(1, undefined); // 1, 2 通常，在编程语言中带默认值的参数在必需参数之后，但是，上述事实允许我们在 JavaScript 中使用如下结构：function foo(x = 2, y) { console.log(x, y); } foo(1); // 1, undefined foo(undefined, 1); // 2, 1 3.6 解构组件的默认值涉及默认值的另一个地方是解构组件的默认值。本文不会涉及解构赋值的主题，不过我们会展示一些小例子。不管是在函数参数中使用解构，还是上述的使用简单默认值，处理默认值的方式都是一样的：即在需要的时候创建两个作用域。function foo({x, y = 5}) { console.log(x, y); } foo({}); // undefined, 5 foo({x: 1}); // 1, 5 foo({x: 1, y: 2}); // 1, 2 尽管解构的默认值更加通用，不仅仅用于函数中：var {x, y = 5} = {x: 1}; console.log(x, y); // 1, 5 4 结论希望这篇简短的笔记可以帮助解释 ES6 中默认值的细节。注意，在本文撰写的那一天（2014 年 8 月 21 日），默认值还没有得到真正的实现（它们都只是创建了一个与函数体共享的作用域），因为这个“第二作用域”是在最近才添加到标准草案里的。默认值一定会是一个很有用的特性，它将使我们的代码更加优雅和整洁。另外，你也可以在掘金翻译计划找到本篇译文。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[译文排版规范]]></title>
    <url>%2F2019%2F05%2F01%2FTrs-%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%8E%92%E7%89%88%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言：这是之前还在论坛当版主的时候，给自己定下的汉化规矩：1.按照固定格式来排版；2.能力有限不是机翻和偷工减料的借口；3.尽量得到原作者的转载授权虽然不再参与汉化工作了，但是有一些好的习惯值得继续保持。统一中文文案、排版的相关用法，降低沟通成本，增强译文的规范性和气质，使其更加易读。空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。与大家共勉之。」——vinta/paranoid-auto-spacing中英文之间需要增加空格正确：在 LeanCloud 上，数据存储是围绕 AVObject 进行的。错误：在LeanCloud上，数据存储是围绕AVObject进行的。在 LeanCloud上，数据存储是围绕AVObject 进行的。完整的正确用法：在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。中文与数字之间需要增加空格正确：今天出去买菜花了 5000 元。错误：今天出去买菜花了 5000元。今天出去买菜花了5000元。数字与单位之间需要增加空格正确：我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。错误：我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。例外：度／百分比与数字之间不需要增加空格：正确：今天是 233° 的高温。新 MacBook Pro 有 15% 的 CPU 性能提升。错误：今天是 233 ° 的高温。新 MacBook Pro 有 15 % 的 CPU 性能提升。全角标点与其他字符之间不加空格正确：刚刚买了一部 iPhone，好开心！错误：刚刚买了一部 iPhone ，好开心！标点符号不重复使用标点符号正确：德国队竟然战胜了巴西队！她竟然对你说「喵」？！错误：德国队竟然战胜了巴西队！！德国队竟然战胜了巴西队！！！！！！！！她竟然对你说「喵」？？！！她竟然对你说「喵」？！？！？？！！破折号前后需要增加一个空格正确：你好，我是破折号 —— 一个不苟言笑的符号。错误：你好，我是破折号——一个不苟言笑的符号。全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。使用全角中文标点正确：嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！核磁共振成像（NMRI）是什么原理都不知道？JFGI！错误：嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎!嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎!核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!核磁共振成像(NMRI)是什么原理都不知道?JFGI!数字使用半角字符正确：这件蛋糕只卖 1000 元。错误：这件蛋糕只卖 １０００ 元。例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。遇到完整的英文整句、特殊名词，其內容使用半角标点正确：乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。错误：乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。正确：使用 GitHub 登录我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。错误：使用 github 登录使用 GITHUB 登录使用 Github 登录使用 gitHub 登录使用 gｲんĤЦ8 登录我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。不要使用不地道的缩写正确：我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。错误：我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。排版斜体文字使用加粗样式代替正确：斜体本身是为西文文字所设计，为了保持良好的阅读效果，在中文排版时不应出现斜体，因此统一使用加粗样式代替。错误：斜体本身是为西文文字所设计，为了保持良好的阅读效果，在中文排版时不应出现斜体，因此统一使用加粗样式代替。如果文章中有脚注怎么办英文原文中经常会出现脚注的情况，我们在译者 LeopPro 的推荐下，选择如下的方案：这里是修改后的脚注显示方案 &lt;sup>&lt;a href="#note1">[1]&lt;/a>&lt;/sup> 1. &lt;a name="note1">&lt;/a> [how-to-add-footnotes-to-github-flavoured-markdown](http://stackoverflow.com/questions/25579868/how-to-add-footnotes-to-github-flavoured-markdown) 预览效果如下：这里是修改后的脚注显示方案 [1] how-to-add-footnotes-to-github-flavoured-markdown详见译者 LeopPro 提的 Issue：https://github.com/xitu/gold-miner/issues/3153争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的，但同一篇文章风格要保持一致。链接之间增加空格用法：请 提交一个 issue 并分配给相关同事。访问我们网站的最新动态，请 点击这里 进行订阅！对比用法：请提交一个 issue 并分配给相关同事。访问我们网站的最新动态，请点击这里进行订阅！简体中文使用直角引号用法：「老师，『有条不紊』的『紊』是什么意思？」对比用法：“老师，‘有条不紊’的‘紊’是什么意思？”工具仓库语言vinta/paranoid-auto-spacingJavaScripthuei90/pangu.nodeNode.jshuacnlee/auto-correctRubysparanoid/space-loverPHP (WordPress)nauxliu/auto-correctPHPhotoo/pangu.vimVimsparanoid/grunt-auto-spacingNode.js (Grunt)hjiang/scripts/add-space-between-latin-and-cjkPython参考Chinese Copywriting Guidelines掘金翻译计划译文排版指北]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[分享一些实用工具和平台]]></title>
    <url>%2F2019%2F04%2F23%2FTo-%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[这个帖子用来不定期更新网上收集的一些实用工具和平台，运用得好还是可以提高学习或工作效率的。PS：部分资源国内无法访问，这个问题自己想办法解决。社区和博客 ：StackOverflow ——&gt; 最棒的编程问答社区SegmentFault ——&gt; 国内编程问答社区掘金 ——&gt; 后起之秀，文章质量很高Bits and pieces ——&gt; 不错的技术博客网站（好像和Medium有关系？）CSDN ——&gt; 界面很乱，不是很喜欢博客园 ——&gt; 优秀文章和大牛聚集地FreeCodeCamp ——&gt; FreeCodeCamp中文社区文件编辑类：Online converter ——&gt; 文件格式转换PDF To Word ——&gt; pdf 转 wordOnline PDF to EPUB converter ——&gt; pdf 转 epubTable Convert Online ——&gt; 表格转换Compress images ——&gt; 图片压缩Smart Resize ——&gt; 图片修改Syntax-highlight-word ——&gt; 可以在 word 中使用代码高亮tool.lu ——&gt; 在线编写 markdown 以及 html 和 md 转换电子书：GitHub coding books online reading ——&gt; Github编程相关书籍分享itbook.download ——&gt; 编程相关书籍免费下载Jiumo Search ——&gt; 目前用过最棒的电子书搜索网站Ebookee ——&gt; 编程相关书籍免费下载（外文）搜索引擎：chongbuluo search ——&gt; 集成搜索网站DuckDuckGo ——&gt; 搜索引擎前端相关：MDN Web Doc ——&gt; MDN文档ECMAScript International ——&gt; ECMAScript 标准CSS速查总表 ——&gt; 速查属性Caniuse ——&gt; 前端兼容性自查SM.MS Picture ——&gt; 免费图床Font Awesome ——&gt; 图标库Iconfont ——&gt; 图标网站free icons ——&gt; 图标网站Clippy — CSS clip-path maker ——&gt; 前端clip工具fontke ——&gt; 字体网站ScreenDump ——&gt; 响应式效果测试JavaScript Visualizer ——&gt; 可视化JavaScript执行过程（仅ES6之前）Loupe ——&gt; 可视化事件循环 （Philps Roberts大神的作品）RegExr ——&gt; 可视化正则表达式Regulex ——&gt; 可视化正则表达式Javascript-ast Visualizer ——&gt; 可视化抽象语法树compile javascript online ——&gt; 在线编译GDB online Debugger ——&gt; 在线编译]]></content>
      <categories>
        <category>Tool</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解this绑定]]></title>
    <url>%2F2019%2F04%2F17%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3this%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[最近在阅读《你不知道的JavaScript》，再次补充了一下之前不熟悉的this绑定问题，在这里做一下阅读笔记。（很多晦涩的概念包括闭包、作用域链等都和js中的调用栈有关，所以也得另外找个时间系统学一下了）1.调用位置js中的词法作用域是静态的，需要关注的往往是函数的声明位置而不是调用位置—–例如闭包引用自由变量时，应该注意闭包函数的声明位置；而this却在某种程度上类似于动态作用域，this到底绑定的是谁，要看函数的调用位置（或者说调用方法），只有在函数调用的时候this的指向才能被确定。确定当前执行函数的调用位置，有两种方法：1.1 分析调用栈调用栈即：为了到达当前执行位置所调用的所有函数。而当前执行函数的调用位置就在该函数的前一个调用中。function baz() { //当前调用栈是:baz // 因此，当前调用位置是全局作用域 console.log("baz"); bar(); // bar的调用位置 } function bar() { // 当前调用栈是baz -> bar // 因此，当前调用位置在baz中 console.log("bar"); foo(); // foo的调用位置 } function foo() { // 当前调用栈是baz -> bar -> foo // 因此，当前调用位置在bar中 console.log("foo"); } baz(); // &lt;-- baz的调用位置 如上代码，例如当前执行函数为bar，bar函数的调用位置即bar函数的前一个调用，分析调用栈baz -&gt; bar可知，是baz。1.2 设置断点或debugger上面的方法将调用栈当作了函数调用链，这种方法比较麻烦，且容易出错，所以我们采取设置断点或debugger的方法寻找调用位置。我们在上面代码的foo函数中的第一行插入debugger;，那么运行代码时（当前执行函数是foo），调试器会在那个位置暂停，右侧的call stack展示了当前位置的函数调用列表，即调用栈。而调用位置就是栈中的第二个元素。2.绑定规则2.1 默认绑定可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。独立函数调用（如代码中的foo函数，它是直接使用不带任何修饰的函数引用进行调用的）应用的就是默认绑定规则。function foo(){ console.log(this.a); } var a = 2; foo(); //2 但是，函数运行在严格模式下时，this的默认绑定将无法绑定全局对象，而是绑定到undefined。function foo() { "use strict"; // 函数运行在严格模式下 console.log( this.a ); } var a = 2; foo(); // TypeError: Cannot read property 'a' of undefined 同时，函数在严格模式下调用时，默认绑定不受影响。function foo() { console.log( this.a ); } var a = 2; (function() { "use strict"; //函数在严格模式下调用 foo(); // 2 })(); 2.2 隐式绑定当函数引用有上下文对象时（或者说被某个对象“包含”/“拥有”），隐式绑定规则会把函数中的this绑定到这个上下文对象。function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 对象属性引用链中只有上一层或者说最后一层在调用中起作用。function foo() { console.log( this.a ); } var obj1 = { a: 2, obj2: obj2 }; var obj2={ a: 42 foo: foo } obj1.obj2.foo(); // 42 2.2.1 隐式丢失隐式绑定在一些情况下会丢失绑定对象，应用默认绑定，使this指向全局对象或者undefined。以下情况会发生隐式丢失：将绑定上下文对象的函数的引用赋值给变量并调用function foo(){ console.log(this.a); } var obj = { a:2, foo: foo } var a = 3； var bar = obj.foo; bar(); 虽然bar是obj.foo的一个引用，但实际上是直接引用了foo函数本身，此时的bar()是不带任何修饰的函数调用，因此使用了默认绑定传入回调函数function foo(){ console.log(this.a); } function bar(fn){ fn(); } var obj = { a:2, foo: foo } var a = 3; bar(obj.foo); 传参其实是隐式赋值，即把实参（这里是绑定上下文对象的函数的引用）赋值给形参变量，该变量也是直接引用了foo函数本身，和上面的情况其实是一样的。这也解释了为什么传参给setTimeout函数时会发生隐式丢失：function foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; var a = 3; setTimeout(obj.foo, 100); // 3 因为上面的代码实际上相当于：(function setTimeout(fn,100){ // 100...... fn(); })(obj.foo); 2.3 显式绑定2.3.1 call()和apply()通过call()或者apply()方法接受一个对象参数（如果不是对象，则自动转换为对象形式），将函数的this绑定到该对象。function foo() { console.log(this.a); } var obj = { a: 2 }; foo.call(obj); // 2 2.3.2 硬绑定但是这两种方法依然无法解决绑定丢失的问题，所以有了硬绑定:function foo() { console.log( this.a); } var obj = { a: 2 }; var bar = function() { foo.call(obj); }; bar(); // 2 setTimeout(bar, 100); // 2 bar.call(window); //无效，硬绑定之后的this不可再更改 硬绑定新创建了一个函数，并在该函数内部完成了this的绑定，之后不管怎么调用新建的这个函数，this的绑定都不会丢失。典型应用场景是1.创建一个包裹函数，负责接收参数并返回值。function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a: 2 }; var bar = function() { return foo.apply( obj, arguments ); }; var b = bar( 3 ); // 2 3 console.log( b ); // 5 2.创建一个可以重复使用的辅助函数。function foo(something) { console.log( this.a, something ); return this.a + something; } // 简单的辅助绑定函数 function bind(fn, obj) { return function() { return fn.apply( obj, arguments ); } } var obj = { a: 2 }; var bar = bind( foo, obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 ES5提供了内置方法Function.prototype.bind，对上面这种辅助函数进行了封装：function foo(something) { console.log(this.a, something); return this.a + something; } var obj = { a: 2 }; var bar = foo.bind(obj); var b = bar(3); // 2 3 console.log(b); // 5 bind()方法将返回一个完成硬绑定的新函数。2.3.3 API调用的“上下文”同样可以解决绑定丢失的问题。JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。var obj = { id: "awesome" } var myArray = [1, 2, 3] // 调用foo(..)时把this绑定到obj myArray.forEach( function foo(el) { console.log( el, this.id ); }, obj ); // 1 awesome 2 awesome 3 awesome 2.4 new绑定在这篇文章中，其实已经谈到了new的内部原理，在这里再做一下总结—–使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：1.创建一个新对象2.为该对象执行[[prototype]]链接3.将该对象绑定到构造函数的this4.如果函数没有显式返回对象，则new操作最终将返回步骤1中创建的新对象基于这些步骤，我们就可以手写实现new了，具体过程依然可以参考上面链接的文章。有时候会将硬绑定与new一起使用，目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数（柯里化）function foo(p1, p2) { this.val = p1 + p2; } // 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么 // 反正使用new时this会被修改 var bar = foo.bind( null, "p1" ); var baz = new bar( "p2" ); baz.val; // p1p2 3. this的判断现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条this绑定规则。可以按照下面的顺序来进行判断：函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。var bar = new foo()函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。var bar = foo.call(obj2)函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。var bar = obj1.foo()如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定 到全局对象。var bar = foo()4.绑定例外4.1 被忽略的this把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认规则。下面两种情况下会传入null:使用apply(..)来“展开”一个数组，并当作参数传入一个函数bind(..)可以对参数进行柯里化（预先设置一些参数）function foo(a, b) { console.log( "a:" + a + "，b:" + b ); } // 把数组”展开“成参数 foo.apply( null, [2, 3] ); // a:2，b:3 // 使用bind(..)进行柯里化 var bar = foo.bind( null, 2 ); bar( 3 ); // a:2，b:3 总是传入null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。更安全的做法:传入一个空对象，把this绑定到这个对象不会对你的程序产生任何副作用。function foo(a, b) { console.log( "a:" + a + "，b:" + b ); } // 我们的空对象 var ø = Object.create( null ); // 把数组”展开“成参数 foo.apply( ø, [2, 3] ); // a:2，b:3 // 使用bind(..)进行柯里化 var bar = foo.bind( ø, 2 ); bar( 3 ); // a:2，b:3 4.2 间接引用你可能会有意无意地创建一个函数的间接引用，尤其是在赋值的时候// p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo() function foo() { console.log( this.a ); } var a = 2; var o = { a: 3, foo: foo }; var p = { a: 4}; o.foo(); // 3 (p.foo = o.foo)(); // 2 4.3 软绑定硬绑定可以把this强制绑定到指定的对象（new除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this。如果给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。// 默认绑定规则，优先级排最后 // 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this if(!Function.prototype.softBind) { Function.prototype.softBind = function(obj) { var fn = this; // 捕获所有curried参数 var curried = [].slice.call( arguments, 1 ); var bound = function() { return fn.apply( (!this || this === (window || global)) ? obj : this, curried.concat.apply( curried, arguments ) ); }; bound.prototype = Object.create( fn.prototype ); return bound; }; } 使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。function foo() { console.log("name:" + this.name); } var obj = { name: "obj" }, obj2 = { name: "obj2" }, obj3 = { name: "obj3" }; // 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj var fooOBJ = foo.softBind( obj ); fooOBJ(); // name: obj // 隐式绑定规则 obj2.foo = foo.softBind( obj ); obj2.foo(); // name: obj2 &lt;---- 看！！！ // 显式绑定规则 fooOBJ.call( obj3 ); // name: obj3 &lt;---- 看！！！ // 绑定丢失，应用软绑定 setTimeout( obj2.foo, 10 ); // name: obj 5 this词法5.1 箭头函数ES6新增了箭头函数，上述四条规则对这种函数是不生效的。箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。拿下面的代码举例，箭头函数在词法层面的上一层是foo()，所以它的this和foo()的this是一样的。由于foo()的this绑定到obj1，所以bar(引用箭头函数)的this也会绑定到obj1。需要注意的是，箭头函数的绑定无法被修改(new也不行)。function foo() { // 返回一个箭头函数 return (a) => { // this继承自foo() console.log( this.a ); }; } var obj1 = { a: 2 }; var obj2 = { a: 3 } // 绑定foo()的this为obj var bar = foo.call( obj1 ); bar.call( obj2 ); // 2，不是3！ 箭头函数常用于回调函数中，例如事件处理器或者定时器。function foo() { setTimeout(() => { // 这里的this在词法上继承自foo() console.log( this.a ); },100); } var obj = { a:2 }; foo.call( obj ); // 2 5.2 self = this与箭头函数this在通常情况下都是动态作用域的，而箭头函数很明显是静态（词法）作用域。实际上，在ES6之前，也有类似于箭头函数的模式—–self = this，采用的正是词法作用域：function foo() { var self = this; // lexical capture of this setTimeout( function() { console.log( self.a ); // self只是继承了foo()函数的this绑定 }, 100 ); } var obj = { a: 2 }; foo.call(obj); // 2 5.3 代码风格统一如果你经常编写this风格的代码，但是绝大部分时候都会使用self = this或者箭头函数来否定this机制，那你或许应当：只使用词法作用域并完全抛弃错误 this 风格的代码；完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。当然，包含这两种代码风格的程序可以正常运行，但是在同一个函数或者同一个程序中混合使用这两种风格通常会使代码更难维护，并且可能也会更难编写。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>调用栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由一道题引发的思考]]></title>
    <url>%2F2019%2F04%2F13%2FT-%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[“不惧怕争论，也不要带情绪，保持理性争论才能获得提升。有时候一直以来以为正确的，说不好真实不一定就是你想的那样。”昨天，A群有个人问了一道题：var obj = { say: function() { console.log(obj); // 为什么输出undefined }() }; obj.say(); 先说结果。其实这道题是很简单的，只要注意在自执行函数执行过程中，obj变量尚未完成赋值就行了—–所以这时候打印的是执行上下文创建阶段的obj的值（undefined）；如果是let声明，那就是打印未初始化的变量obj，将在一开始就报错。如果非要用执行上下文来解释的话，详细的过程看下图：但是问题就在于，我坚信A群的看法是正确的，并且把这个问题带到了B群，引发了一场激烈的讨论（幸亏最后没有撕起来），我在那时是完全听不进B群的解释的。虽然下午争论的时候不了了之，但是晚上的时候我还是放不下这道题，于是选择到StackOverflow提问，之后又结合 Javascript visualizer 看到了代码执行的可视化过程，这时候我才明白自己的想法是错误的，B群的解释才是正确的。为什么我会在一开始那么相信A群的说法？我开始思考这个问题。首先是因为我没有从完全空白的状态去独立思考这道题，而是依附别人的看法去建立对这道题的认知；其次是因为我太相信那些看上去很权威的人，A群在我眼中是大佬云集的群，所以我很笃信他们的看法，但是大佬就一定是对的吗？就像那些传播很广的转载和翻译的文章，为什么要在没有任何根据的情况下去相信这些文字？换句话说，为什么不回到信息源头确认一下，打消自己的疑虑？在我看来，这根本不是钻牛角尖，我想表达的意思是：如果你不确定，你就想办法去确定，不要带着连自己都怀疑的东西继续自己的学习；对于A群的过度相信还和对B群的不信任有关，我向来是很讨厌扯高嗓子显得自己最有道理的那类人的，所以当B群的群友（有点激动地）发表自己的意见时，我并没有把他的话太放在心上，而结果却证明他说的才是正确的。另一个值得思考的地方是，如何在交流中保持自己的理性。B群有个群友说了一段话，我觉得很在理，这里拿出来分享一下，共勉：不惧怕争论，也不要带情绪，保持理性争论才能获得提升。有时候一直以来以为正确的，说不好真实不一定就是你想的那样。网络世界中，交谈起来往往是无所顾忌的，这种无所顾忌让撕逼变成了一种常态（我自己加了很多社群，所以清楚不过了）。那么如何做到理性的交流？第一点，找那些值得交流的人。如果你发现一个人在交流中带有太多的个人情绪、对人不对事，那么请不要继续和他浪费口舌。有没有个人情绪看他说话方式和内容就知道了，尤其是不断加各种感叹号以示强调的人，早点远离为好。值得交流的人，是那种即使打心眼里无法认同你的看法，也能安静地听你陈述的人，大有一种“我不赞同你的观点，但我誓死捍卫你说话的权利”的感觉。想一想，能做到这样的人真的多吗？第二点，清楚自己的目的。争论也好，交流也好，不要偏离自己的目的。很多情况下，你不仅仅是为了一个答案，还想要寻求自我认知修正的机会。确实，我们一直以来认为正确的不一定就是我们想的那样，正因为我们的认知有可能是错误的，所以才要在交流中试图找出这个错误，从而获得提升。知识不是一成不变的，所以请随时做好推翻自己想法的准备。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解变量对象、作用域链和闭包]]></title>
    <url>%2F2019%2F04%2F10%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[执行上下文、执行栈、作用域链、闭包，这其实是一整套相关的东西，之前转载的文章也有讲到这些。下面两篇文章会更加详细地解释这些概念。深入理解执行上下文和执行栈深入理解变量对象、作用域链和闭包1.前言首先引用下winter大的原话：在ES3中，执行上下文包含三个部分:1.scope: 作用域，也常常被叫做作用域链。2.variable object:变量对象，用于存储变量的对象。3.this value: this值。在ES5中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子:1.lexical environment:词法环境，当获取变量时使用。2.variable environment:变量环境，当声明变量时使用。3.this value: this值。在ES2018中，this值被归入lexical environment,同时增加了不少内容：1.lexical environment:词法环境，当获取变量或者this值时使用。2.variable environment:变量环境，当声明变量时使用。3…….我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的ES2018中规定的术语定义。所以，你会看到本文讲解的部分与另一篇文章有出入（例如变量对象VS环境记录），只需要知道是不同时期的不同规范就行了，没必要深究。2.执行上下文每个执行上下文都有三个重要的属性：变量对象、作用域链、this。在执行上下文压栈后，将进行初始化，这个过程具体来说就是：创建变量对象创建作用域链确定this指向用代码表示如下：ExecutionContext = { VO: {...}, // 或者 AO this: thisValue, Scope: [ // 所用域链 // 所有变量对象的列表 // 用于标识符查询 ] }; 下面我们针对这三个东西一一进行解释。3.变量对象3.1 定义变量对象即Variable object/VO，它是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。在全局执行上下文中，变量对象即全局对象（在浏览器中是window对象），它是可以访问的。在函数执行上下文中，变量对象是不能直接访问的，此时由活动对象(Activation Object/AO)扮演变量对象的角色，也就是所谓的VO–&gt;AO。总而言之，变量对象和活动对象的区别就是：1、变量对象是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。2、当进入到一个函数执行上下文后，这个变量对象才会被激活，成为活动对象，这时候活动对象上的各种属性才能被访问。3.2 从执行上下文看变量对象首先，执行上下文分为两个阶段：1.进入执行上下文2.代码执行3.2.1 进入执行上下文很明显，这个时候还没有执行代码。此时的变量对象将包含（按照如下顺序初始化）：1.一个指向arguments对象的arguments变量（如果是函数执行上下文）：具体地说，在变量对象内部将创建局部变量arguments和arguments对象，并使该变量指向该对象。arguments对象包括下列属性：callee：指向当前函数的引用length： 真正传递的参数的个数properties-indexes：就是函数的参数值(按参数列表从左到右排列)2.函数的所有形参（如果是函数执行上下文）：有实参则赋值，无实参则为undefined。3.函数声明：如果声明的函数跟已经声明的形参在名称上是相同的，则完全替换这个形参变量。4.变量声明：如果声明的变量跟已经声明的形参/函数在名称上是相同的，则变量声明不会干扰它们，仅赋值部分是生效的。同时明确，变量对象将不包含：函数表达式（与函数声明相对）没有使用var声明的变量（这属于“全局式”的声明方式，只是给全局添加了一个属性，并不在变量对象中）拿下面代码作为例子：function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1); 在调用函数foo后，将进入其对应的函数执行上下文，此时的变量对象（实际上是活动对象）根据上面的说法，应为：AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 可以从arguments对象的properties-indexes属性或者a看出，形参此时已经赋值了，但是变量仍是undefined。3.2.2 代码执行这个阶段会顺序执行代码，修改变量对象的值，执行完成后变量对象如下：AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression "d" } 前面说过，函数表达式和没有使用var声明的变量将不会包含在变量对象里，所以如果添加如下代码：(function x() {}); e = 1； 变量对象是不会变的4.作用域链4.1 定义作用域链其实就是所有执行上下文的变量对象的列表。我们可以将其看作数组，并表示为：var Scope = [VO1, VO2, ..., VOn]; 具体来说，函数执行上下文的作用域链包括该上下文的活动对象和该上下文对应函数的内部[[Scope]]属性。表示为：Scope = AO + [[Scope]] 4.2 作用：作用域链的作用是：在处理标识符的时候进行变量查询。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。4.3 Scope和[[Scope]]：前面我们说的Scope是执行上下文的属性，而[[Scope]]是函数的属性。具体来说，[[Scope]]是一个包含了所有上层变量对象的分层链，它属于当前函数执行上下文，在函数创建伊始就存在了，并保存在函数中。这里要注意的很重要的一点是：[[Scope]]是在函数创建的时候保存起来的——静态的（不变的），只有一次并且一直都存在——直到函数销毁。 比方说，哪怕函数永远都不能被调用到，[[Scope]]属性也已经保存在函数对象上了。4.4 从执行上下文看作用域链：下面用具体的例子回顾一下在执行上下文中，变量对象和作用域链的创建过程var x = 10; function foo() { var y = 20; function bar() { var z = 30; alert(x + y + z); } bar(); } foo(); // 60 首先进入全局执行上下文，创建变量对象（全局对象window）globalContext.VO === Global = { x: undefined foo: &lt;reference to function> }; 之后开始执行代码，变量对象变为：globalContext.VO === Global = { x: 10 foo: &lt;reference to function> }; 其中，在创建foo函数时，确认它的[[Scope]]属性：foo.[[Scope]] = [ globalContext.VO ]; 之后，调用foo函数，进入其对应的函数执行上下文，此时函数的变量对象激活为活动对象：fooContext.AO = { y: undefined, bar: &lt;reference to function> }; 同时确认了foo函数执行上下文的作用域链：fooContext.Scope = fooContext.AO + foo.[[Scope]] // i.e.: fooContext.Scope = [ fooContext.AO, globalContext.VO ]; 之后开始执行代码，变量对象变为：fooContext.AO = { y: 20, bar: &lt;reference to function> }; 其中，在创建bar函数时，确认它的[[Scope]]属性：bar.[[Scope]] = [ fooContext.AO, globalContext.VO ]; 之后，调用bar函数，进入bar函数对应的函数执行上下文，此时函数的变量对象激活为活动对象：barContext.AO = { z: undefined }; 同时确认了bar函数执行上下文的作用域链：barContext.Scope = barContext.AO + bar.[[Scope]] // i.e.: barContext.Scope = [ barContext.AO, fooContext.AO, globalContext.VO ]; 之后开始执行代码，变量对象变为：barContext.AO = { z: 30 }; 在运行alert(x + y + z);这一语句的时候，开始进行变量（或者说标识符）查询：- "x" -- barContext.AO // not found -- fooContext.AO // not found -- globalContext.VO // found - 10 - "y" -- barContext.AO // not found -- fooContext.AO // found - 20 - "z" -- barContext.AO // found - 30 这里需要注意，由于确认执行上下文的作用域链时，总会将当前上下文的变量对象/活动对象推至作用域链的顶端( Scope=当前活动对象+所有上层对象 )，所以变量查询也将从该变量对象开始，而全局对象则一直处于末端，是最后被查询的。bar执行完毕，出栈—&gt;foo执行完毕，出栈—&gt;回到全局执行上下文5.闭包5.1 从向下Funarg问题谈静态作用域“Funarg”即函数式参数，指的是值为函数的参数。如：function exampleFunc(funArg) { funArg(); } 首先看下这段代码：let x = 10; function foo() { console.log(x); } function bar(funArg) { let x = 20; funArg(); // 10, 而不是20! } // 将 `foo` 作为实参传给 `bar`。 bar(foo); 对于函数foo，变量x就是自由变量。当foo函数被调用时，它在哪里解析x绑定呢？是从创建函数的外层作用域，还是从调用函数的外层作用域？这就是所谓的向下funarg问题(downwards funarg problem)，即在判断绑定的环境时的歧义性：它应该是创建时的环境，还是调用时的环境？这是通过达成约定使用静态作用域来解决的。静态作用域也就是词法作用域（这也是词法环境这个名称的由来），它是通过捕获函数创建所在的环境来实现的，因而会到函数创建时保存起来的静态作用域链中进行变量查询。如果一个语言只通过查找源代码，就可以判断绑定在哪个环境中解析，那么该语言就实现了静态作用域。与静态作用域相对的是动态作用域。动态作用域是在当前活跃的动态链（而不是在函数创建时保存起来的静态作用域链）中进行变量查询的。对于上面的代码，如果是动态作用域，将输出20而不是10。5.2 从向上Funarg问题谈闭包另一种Funarg问题是向上funarg问题(upwards funarg problem)。function foo() { let x = 10; // 闭包，捕获`foo`的环境。 function bar() { return x; } // 向上funarg。 return bar; } let x = 20; // 调用`foo`来返回`bar`闭包。 let bar = foo(); bar(); // 10，而不是20! 除了判断绑定环境的歧义性，向上funarg问题面临的另一个问题是：如果JavaScript是面向堆栈的，那么foo函数在调用结束后，其执行上下文将带着变量对象销毁，这样一来，在我们调用bar函数时将发生错误（因为bar函数需要用到自由变量x，而该变量已经随着foo函数变量对象的销毁而消失了）。而且，在面向堆栈实现模型中，要想将bar函数返回根本是不可能的，因为它也是foo函数变量对象的一部分，也会随之销毁。也就是说我们面临两个问题：绑定环境的歧义性被引用的自由变量在上下文销毁后无法得到保留为了解决这两类问题，引入了闭包的概念。5.3 闭包5.3.1 定义ECMAScript中，闭包指的是：从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。从实践角度：以下函数才算是闭包：1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）2.在代码中引用了自由变量JavaScript显然是支持词法作用域的（除了this），所以解决了向下Funarg问题；同时由于闭包的存在，即使创建闭包的执行上下文出栈后被销毁，其变量对象也依然存在，所以闭包函数依然有办法访问到该对象，这就解决了向上Funarg问题。这个过程具体来说就是：通过某种方式（通常是返回值）调用闭包后，创建闭包对应的执行上下文并压栈，该上下文的属性Scope包括了闭包本身的变量对象和闭包的[[Scope]]属性，后者使得闭包执行时有机会访问到自由变量，因为[[Scope]]在闭包的词法创建阶段便已确定，并在那时候保存了其上层变量对象（上层，也就是闭包的父函数）。5.3.2 注意不过这里需要注意，仅变量对象里被引用的自由变量依然存在，不需要用到的变量会被垃圾清除机制清除。可以用下面的代码做个测试：var bar = function() { var hello = "world"; var unused = "nope"; return function(s) { console.log(hello); debugger; return s; }; } var g = bar(); g(1); debugger查看closure，发现只有hello变量，而找不到unused变量:在控制台打印unused变量时，报错：另外一个需要注意的地方是：同一个上下文中可能存在多个闭包，而这些闭包是共用同一个[[Scope]]属性的。也就是说，某个闭包对其中的变量做修改会影响到其他闭包对该变量的读取：var firstClosure; var secondClosure; function foo() { var x = 1; firstClosure = function () { return ++x; }; secondClosure = function () { return --x; }; x = 2; // 对AO["x"]产生了影响, 其值在两个闭包的[[Scope]]中 alert(firstClosure()); // 3, 通过 firstClosure.[[Scope]] } foo(); alert(firstClosure()); // 4 alert(secondClosure()); // 3 这也可以解释经典的for循环问题：var data = []; for (var k = 0; k &lt; 3; k++) { data[k] = function () { alert(k); }; } data[0](); // 3, 而不是 0 data[1](); // 3, 而不是 1 data[2](); // 3, 而不是 2 每一个函数都是一个闭包，拥有同一个[[Scope]]属性，这个属性包含了全局对象，而全局对象包含了变量k，这个k在循环跑完后变成了3，所以闭包调用的时候统一输出3。5.3.3 闭包的运用实际使用的时候，闭包可以创建出非常优雅的设计，允许对funarg上定义的多种计算方式进行定制。 如下就是数组排序的例子，它接受一个排序条件函数作为参数：[1, 2, 3].sort(function (a, b) { ... // 排序条件 }); 同样的例子还有，数组的map方法（并非所有的实现都支持数组map方法，SpiderMonkey从1.6版本开始有支持），该方法根据函数中定义的条件将原数组映射到一个新的数组中：[1, 2, 3].map(function (element) { return element * 2; }); // [2, 4, 6] 使用函数式参数，可以很方便的实现一个搜索方法，并且可以支持无穷多的搜索条件：someCollection.find(function (element) { return element.someProperty == 'searchCondition'; }); 还有应用函数，比如常见的forEach方法，将funarg应用到每个数组元素：[1, 2, 3].forEach(function (element) { if (element % 2 != 0) { alert(element); } }); // 1, 3 顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）：(function () { alert([].join.call(arguments, ';')); // 1;2;3 }).apply(this, [1, 2, 3]); 闭包还有另外一个非常重要的应用 —— 延迟调用：var a = 10; setTimeout(function () { alert(a); // 10, 一秒钟后 }, 1000); 也可以用于回调函数：... var x = 10; // only for example xmlHttpRequestObject.onreadystatechange = function () { // 当数据就绪的时候，才会调用; // 这里，不论是在哪个上下文中创建，变量“x”的值已经存在了 alert(x); // 10 }; .. 还可以用于封装作用域来隐藏辅助对象：var foo = {}; // initialization (function (object) { var x = 10; object.getX = function _getX() { return x; }; })(foo); alert(foo.getX()); // get closured "x" – 10 参考：http://dmitrysoshnikov.com/ecmascripthttp://goddyzhao.tumblr.com/post/11311499651/closuresvar a=1; function fn2(a,b=100){ arguments[0]=20; var a =22; console.log(a); // 输出什么？ console.log(arguments[0]); // 输出什么？ } fn2(a);]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>变量对象</tag>
        <tag>作用域链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解执行上下文和执行栈]]></title>
    <url>%2F2019%2F04%2F08%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88%2F</url>
    <content type="text"><![CDATA[执行上下文、执行栈、作用域链、闭包，这其实是一整套相关的东西，之前转载的文章也有讲到这些。下面两篇文章会更加详细地解释这些概念。深入理解执行上下文和执行栈深入理解变量对象、作用域链和闭包1.执行上下文1.1 定义执行上下文（execution context）是当前 JavaScript 代码被解析和执行时所在环境的抽象概念，1.2 类型全局执行上下文只有一个。它创建了一个全局对象（浏览器中是window对象），并将this指向该对象。函数执行上下文无数个。每次调用函数时，都会为该函数创建一个新的执行上下文。eval函数执行上下文运行在 eval 函数中的代码也获得了自己的执行上下文，eval函数不常用，所以这里不讨论2.执行栈执行栈（execution stack），也即调用栈（call stack），具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。当 JavaScript 引擎首次读取脚本时，它会创建一个全局执行上下文并将其push到当前的执行栈。每当调用函数的时候，都会为该函数创建一个新的执行上下文并将其push到栈顶；在函数执行完毕后，对应的执行上下文将会从栈顶pop出，上下文控制权将移到当前执行栈的下一个执行上下文。let a = 'Hello World!'; function first() { console.log('Inside first function'); second(); console.log('Again inside first function'); } function second() { console.log('Inside second function'); } first(); console.log('Inside Global Execution Context'); // Inside first function // Inside second function // Again inside first function // Inside Global Execution Context 3.执行上下文的创建执行上下文分两个阶段创建：1）创建阶段（The Creation Phase）； 2）执行阶段（The Execution Phase）3.1 创建阶段词法环境组件被创建变量环境组件被创建用伪代码表示就是：ExecutionContext = { LexicalEnvironment = { ... }, // 词法环境 VariableEnvironment = { ... }, // 变量环境 } 3.1.1 词法环境词法环境（Lexical environment）是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用）词法环境有三个组成部分：环境记录：存储变量和函数声明的实际位置对外部环境的引用：可以访问其外部词法环境this绑定：确定this的指向词法环境有两种类型：全局环境：全局执行上下文的词法环境。函数环境：函数执行上下文的词法环境。3.1.1.1 环境记录：根据词法环境的两种类型，环境记录（Environment record）同样也有两种类型：对象环境记录（Object environment record）：全局环境的环境记录类型。存储全局变量和函数声明、全局对象（window 对象）和关联的属性/方法。声明性环境记录（Declarative environment record）：函数环境的环境记录类型。存储局部变量和函数声明、arguments对象。arguments对象包含了索引与参数之间的映射，以及传给函数的参数的个数。function foo(a, b) { var c = a + b; } foo(2, 3); // argument object Arguments: {0: 2, 1: 3, length: 2}, 3.1.1.2 外部环境引用：外部环境引用（Reference to the outer environment）表明当前词法环境能够访问外部词法环境。这意味着如果JavaScript引擎未在当前词法环境找到变量，它将向外部词法环境寻找（这有点类似原型链中的属性查找）全局环境没有外部环境，其外部环境引用为 null。函数环境有外部环境，其外部环境引用可以是全局环境，也可以是包含内部函数的外部函数环境。3.1.1.3 this绑定：全局执行上下文中，this绑定（this binding）到全局对象（对于浏览器，该对象为window）；函数执行上下文中，this绑定到谁将取决于函数的调用位置（或者说调用方法）。我会在另一篇文章总结this的绑定机制，所以这里不再展开。讲完了词法环境的三个组成部分，最后再配合伪代码理解一下：// 全局执行上下文 GlobalExectionContext = { LexicalEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 } outer: &lt;null>, this: &lt;global object> } } // 函数执行上下文 FunctionExectionContext = { LexicalEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 } outer: &lt;Global or outer function environment reference>, this: &lt;depends on how function is called> } } 3.1.2 变量环境变量环境（Variable environment）同样也是词法环境，因此它具有上面定义的词法环境的所有特征。这两者的区别主要在于：在 ES6 中，词法环境用于存储函数声明和变量（let和const）绑定，而变量环境仅用于存储变量（var）绑定。3.2 执行阶段在执行阶段，完成对所有变量的分配，最后执行代码。3.3 举例说明通过一个例子来了解执行上下文的整个创建和执行过程。以下面的代码为例let a = 20; const b = 30; var c; function multiply(e, f) { var g = 20; return e * f * g; } c = multiply(20, 30); 在开始读取代码后，JavaScript引擎创建全局执行上下文并压栈，全局执行上下文的创建阶段的伪代码如下：GlobalExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 a: &lt; uninitialized >, b: &lt; uninitialized >, multiply: &lt; func > } outer: &lt;null>, ThisBinding: &lt;Global Object> }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 c: undefined, } outer: &lt;null>, ThisBinding: &lt;Global Object> } } 之后进入全局执行上下文的执行阶段，开始进行变量分配/赋值，伪代码如下：GlobalExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 a: 20, b: 30, multiply: &lt; func > } outer: &lt;null>, ThisBinding: &lt;Global Object> }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 c: undefined, } outer: &lt;null>, ThisBinding: &lt;Global Object> } } 随着执行阶段的进行，我们遇到了multiply(20, 30)，这是一个函数调用语句，所以此时创建了该函数对应的函数执行上下文并压栈，函数执行上下文的创建阶段的伪代码如下：FunctionExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 Arguments: {0: 20, 1: 30, length: 2}, }, outer: &lt;GlobalLexicalEnvironment>, ThisBinding: &lt;Global Object or undefined>, }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 g: undefined }, outer: &lt;GlobalLexicalEnvironment>, ThisBinding: &lt;Global Object or undefined> } } 之后进入函数执行上下文的执行阶段，开始进行函数内的变量的分配/赋值，伪代码如下：FunctionExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 Arguments: {0: 20, 1: 30, length: 2}, }, outer: &lt;GlobalLexicalEnvironment>, ThisBinding: &lt;Global Object or undefined>, }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Declarative", // 标识符绑定在这里 g: 20 }, outer: &lt;GlobalLexicalEnvironment>, ThisBinding: &lt;Global Object or undefined> } } 函数执行完毕，函数执行上下文出栈，此时的执行上下文是全局执行上下文。由于函数的返回值被赋给变量c，此时全局执行上下文对应的全局词法环境得到更新，伪代码如下：GlobalExectionContext = { // 词法环境 LexicalEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 a: 20, b: 30, multiply: &lt; func > } outer: &lt;null>, ThisBinding: &lt;Global Object> }, // 变量环境 VariableEnvironment: { EnvironmentRecord: { Type: "Object", // 标识符绑定在这里 c: 12000, } outer: &lt;null>, ThisBinding: &lt;Global Object> } } 全局执行上下文的执行阶段结束，程序结束。补充：在全局执行上下文创建阶段的伪代码中我们可以看到，let和const定义的变量没有任何与之关联的值，但var定义的变量设置为undefined。这是因为在创建阶段，JavaScript引擎会扫描一遍代码并解析所有的变量和函数声明，其中函数声明被存储在环境记录中，而变量的情况则比较特殊：var声明的变量将被设置为undefined，let和const声明的变量将保持未初始化。因此，我们可以在声明之前就访问var定义的变量（尽管是undefined ），但如果在声明之前访问let和const定义的变量则会提示引用错误（因为在执行阶段之前其始终是未初始化的）。这就是我们所谓的变量提升。注： 在执行阶段，如果Javascript引擎在源代码中声明的实际位置找不到 let变量的值，那么将为其分配undefined值。注意：如果你发现译文和原文的说法存在出入，例如：在原文中：The execution context is created during the creation phase. Following things happen during the creation phase:1.LexicalEnvironment component is created.2.VariableEnvironment component is created.Each Lexical Environment has three components:1.Environment Record2.Reference to the outer environment,3.This binding在译文中：在任何 JavaScript 代码执行之前，执行环境经历了创建阶段，创建阶段包含以下三个事：1.this 的值确定，也被称为 This Binding.2.Lexical Environment 被创建。3.Variable Environment 被创建。在词法环境中，有两种组件：(1) environment record(2) reference to the outer environment.这是因为（请看这幅图）：总而言之是由于ECAMAScript的标准变更导致的。原文最初是基于ES5编写的，this绑定的确是执行上下文创建阶段的一环，但是在ES2015 ES2018 的规范中，this绑定被并入词法环境的环境记录，所以原作者后来进行了更改，只是各种翻译和转载没有改过来就是了。关于具体内容，可以参考：ES5规范ES6规范上图的文章本文参考：原文译文]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>执行上下文</tag>
        <tag>词法环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PureBlue主题更新记录]]></title>
    <url>%2F2019%2F04%2F04%2FP-PureBlue%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[2019.5.14一直觉得banner光秃秃的，所以换上了随机的背景图利用媒体查询对手机端的样式做了部分调整（虽然还是没有达到想要的效果）。感觉是个大工程，还是以后再来弄吧。2019.5.10一点小改动。翻译文章时突然发现一件事，有的文章标题下是有类似subtitle的东西的，但不是hexo的内置变量，所以自己定义了一个（说实话之前没考虑到这个问题）。2019.4.2优化了部分代码(总算)引入分享插件，只需要在主题的config.yml文件配置即可。之前以为没法在script标签里写ejs，所以采用了在js里拼接字符串的方法，想想真是又笨又奇葩。2019.4.1愚人节快乐~~ 几个优化阅读体验的小变动引入了font-awesome库，增加了一些图标现在TOC目录中的标题会随着屏幕滚动而对应高亮。为了醒目，暂时采用了我比较喜欢的荧光黄采用红色取消纯黑字体，现在阅读文章不会那么晃眼了修复代码块背景显示不正常的问题增加文章字数统计和阅读时长统计，可配置2019.3.31最近确实还是挺忙的。虽说主题做出来了，但是一些大大小小的毛病或者bug总是让我心里不太舒服，所以花了一些功夫进行了修复，并终于发布了第一个版本。现在看起来已经好很多了（也已经与初版完全不同了）。当然，因为能力不足，所以响应式布局一直没做出来（手机党の噩梦）。Version 1.0整体布局：比较直观的感受应该就是布局上的调整。为了让整体更加趋向扁平化，我去除了初版中所有圆润的元素，尤其是那个巨丑的导航栏。还有一个就是稍微美化了一下滑动条，现在和主题更加搭配了。配色：虽然主题叫做PureBlue，但并不是所有人都能接受默认的颜色，所以在以蓝色为主配色的前提下，我提供了其他的几种方案可供选择，只要修改配置文件即可。这个也算是给我的一个tip：为了提高主题的可配置性，应该避免在一些地方采用硬编码，而是代之以变量（stylus本身是支持书写变量的）。阅读体验优化：之前比较尴尬的两个问题，一个是图片无法放大查看（= =无法放大的图片要你何用），一个是没有文章目录（阅读长文非常痛苦）。图片问题我是用fancybox插件解决的，同时支持放大、下载和分享。这里有一点比较关键:因为md文件引用的图片默认是放在&lt;p&gt;&lt;/p&gt;中的，而插件针对的图片必须有&lt;a&gt;&lt;/a&gt;嵌套，所以需要用js给所有的img嵌套上&lt;a&gt;&lt;/a&gt;；至于文章目录，可以用TOC函数生成，之后再编写样式就行。当然，目录是类似侧边栏的存在，所以必须用js做一些判断，之后进行适当的定位。浏览体验优化：首先是修复了分类页无法正常进入的问题（之前的分类点击之后会走archive页面的布局，所以我暂时给了个空链接）；然后是重写了分页器，说到这个，之前的分页器可以说是丑到无以复加，而且非常不人性化，只提供上一页和下一页的选择简直是不像话有木有！好在这个问题解决了，而且也简化了一些不必要的代码；再者一个是导航栏，导航栏条目可以根据当前所在页面的类型对应高亮。第三方插件支持：目前引入了valine评论插件，用起来还是很舒服的。后面看情况可能会增加对gittalk的支持；分享插件，我个人使用的是Addthis，之所以只有个人使用= =，因为这个插件必须要到它的官网去配置，而我要的效果是用户可以通过主题文件进行配置。所以虽然好用，但不会考虑作为主题的分享插件 增加了对Addthis的支持，现在用户可以通过配置pubid使用这个插件了。说到插件，以后也许会增加Algolia站内搜索，现在看搜索功能还是比较鸡肋的，毕竟标签和分类其实已经足够发挥索引功能了。其他小改动：显示标签数、分类数和文章数，至于文章阅读时长和字数的统计可以以后再说；还有就是在after-footer.ejs中统一引用所有的js文件，没有之前那么乱糟糟的了；标签云的标签，之前鼠标移入的时候会“鬼畜”，这个问题也得到了修复。总而言之改动还是挺大的，不过随着越来越多第三方插件的使用，去jq化貌似也变得遥遥无期了，这可能就是代价吧，= =小tip：—-&gt;&gt;最后是一个小tip，如何在js中引用hexo的内置变量：这个得从导航栏效果说起，在做导航栏的时候涉及到了怎么区分不同页面的问题。这个其实也很好解决，因为页面链接和导航栏条目是一一对应的，比如archive页面的链接是/archive，导航栏条目是archive,所以做一个判断就好。然而尴尬的是，首页压根就没有这种链接，首页就是一个/（毕竟是作为博客的入口）。所以这个时候我想到了直接通过config.url拿到首页的完整url，之后再做判断，但是又有一个问题——这是hexo的内置变量，只能在ejs中使用，在js里是不识别的。考虑到ejs会生成dom元素，所以解决的思路是：将内置变量存放在dom元素里并生成，之后在js中获取到这个dom元素。因为我们需要的只是它存放的值，所以在页面中再将这个元素display:none掉 直接作为dom元素的data-*属性即可。后面还有一个地方用到这个办法，就是TOC的说明文本。TOC作为辅助函数，虽说可以自动生成目录，但是少了提示性文本，比如“文章目录”，所以可以用js动态创建dom元素，并作为TOC的子元素。这里同样不适合采用硬编码的方式写提示文本，所以我将文本写在了配置文件里，之后通过&lt;% __(&#39;....&#39;) %&gt;进行引用——这里和上面一样，同样是将其放在dom元素里作为dom元素的data-*属性，再通过js获取它的值。]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>PureBlue</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解原型和继承]]></title>
    <url>%2F2019%2F03%2F31%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[这几天在掘金上阅读到了一篇关于原型的文章，角度较之前看到的几篇博客都不一样，顿时感觉我对于原型的知识点还没有完全吃透。鉴于本篇文章很可能会进行不定期的修订和拓展，故在此附上更新日志，以简单记录我在学习上的认知更新。2019.2.24js继承的几种实现方式2019.2.19完善关于constructor属性的介绍比对new和Object.create()的本质区别纠正隐式原型的错误写法（之前没看仔细，一直写错，今天报错才发现）1.创建对象的方法在了解原型链之前，首先先了解一下创建对象的几种方式，为后面做个铺垫。介绍以下三种。代码： &lt;script type="text/javascript"> // 第一种方式：字面量 var o1 = {name: 'o1'} var o2 = new Object({name: 'o2'}) // 第二种方式：构造函数 var M = function (name) { this.name = name; } var o3 = new M('o3') // 第三种方式：Object.create var p = {name: 'p'} var o4 = Object.create(p) console.log(o1) console.log(o2) console.log(o3) console.log(o4) &lt;/script> 打印结果：2.构造函数、实例、原型、原型链先来一张图简单了解一下2.1 什么是原型？实例？构造函数？首先是代码 var M = function (name) { this.name = name; } var o3 = new M('o3') 实例就是通过new一个构造函数生成的对象。在本例中o3就是实例，M就是构造函数。每个函数都有prorotype属性，每个对象都有proto 属性（隐式原型,读作dunder prototype）从上图中可以知道，实例的protpo指向原型对象。从上图中可以知道，实例的构造函数的prototype也是指向原型对象。原型对象的construor指向构造函数。再来通过下面这个图来理解一下2.2 什么是原型链？简单理解就是原型组成的链，实例的proto就是原型，而原型也是一个对象，也有proto属性，它会指向另一个原型…………就这样可以一直通过proto向上找，这就是原型链，当向上找找到Object这个构造函数的原型（即null）时，这条原型链就算到头了。也就是说，原型链的尽头是null 。2.3 原型作用何在？原型的存在是为了帮助实现继承。我们先来思考一个问题：假如现在通过一个构造函数创建了多个实例，想要给它们添加同一个方法，该怎么做呢？1.给每个实例去添加。太过麻烦，并不是一个明智的选择；2.在构造函数的内部添加方法。这样做的话在每次用构造函数创建实例时都会大量产生方法的副本，这些方法副本功能一样，实际却是不同的。这会影响性能，且不利于代码复用；3.这时，就该用上原型了。只要给构造函数的原型添加一个方法，那么构造函数的所有实例便都有了这个方法。接着上面的例子继续演示： function M(name) {this.name = name;} var o3 = new M('o3') var o5 = new M('o5') M.prototype.say=furnction(){ console.log('hello world')} o3.say() o5.say() console.log(o3.say()==o5.say()); // true 打印结果按照JS引擎的分析方式，在访问一个实例的方法时，首先在实例本身中找，如果找到了就说明其构造函数先前是有定义这个方法的(this)；如果没找到就去实例的原型中找，还没找到就再沿着原型链往上找，直到找到。当然，不止方法，属性也是可以继承自原型的。那么怎么判断属性是实例本身具有的还是继承的？对实例用 hasOwnProperty( )方法即可。那么实例为何有这个方法？同样是继承来的。 由于所有的对象的原型链都会找到追溯到Object.prototype，因此所有的对象都会有Object.prototype的方法，其中就包括 hasOwnProperty( )方法 。2.4 访问原型可以用obj.prototype，obj.__proto__，或者obj.getPrototypeOf()。这里重点说后面两个。__proto__属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，更不推荐通过这种方式修改实例的原型，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用 Object.getPrototypeOf()。2.5 原型、构造函数、实例、Function、Object的关系前面我们给出了一幅图简单梳理了一下关系，但想追本溯源，光靠那张图是不够的。下面我们给出另一张更详细的图。请先记住，Function和Object 是特殊的构造函数。首先从构造函数Foo（或任意一个普通构造函数）出发，它创建了实例f1和f2等，而实例的__proto__指向了Foo.prototype这个原型，该原型的__proto__向上再次指向其他构造函数的原型，一直向上，最终指向Object这个构造函数的原型，即Object.prototype。而Object.prototype的 __proto__指向了null，这时我们说到达了原型链的终点null。回过头看，该原型又被Object构造函数的实例的__proto__指向，而函数的实例就是我们通常通过字面量创建的那些对象，也即是图中的o1，o2。那么，普通构造函数（这里指Foo）和特殊构造函数Object又来自于哪里？答案是，来自于另一个特殊构造函数Function。实际上，所有的函数都是由Function函数创建的实例，而构造函数当然也是函数，所以也来自于Function。从图中可以看到，实例Foo的__proto__和实例Object的__proto__ 都指向了 Function的prototype，即Function.prototype 。既然所有的函数都是由Function函数创建的实例，那么Function又是怎么来的？答案是，Function自己创造了自己。它既作为创造其他实例函数的构造函数而存在，也作为实例函数而存在，所以可以在图上看到作为实例的Function的__proto__ 指向了作为构造函数的Function的prototype,即Function.__proto__ ===Function.prototype正如我们前面所说的，Function.prototype的__proto__也像其他构造函数.prototype的__proto__一样，最终指向Object.porototype，而Object.porototype的__proto__最终指向null，原型链结束。可以发现，经过简单梳理，这几者的关系没有我们想象的那么复杂。一句话，看懂这幅图就够了。3.instanceof的原理instanceof 沿着 实例—&gt; proto —&gt; …….. 这条线来找，同时沿着 实例的构造函数的prototype—&gt;proto —&gt; …….. 这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。如下图，很显然 f1 instanceof Object 成立注意：正因为 instanceof 的原理如上所述，因此实例的instanceof在比较的时候，与原型链上向上找的的构造函数相比都是true。继续上面的代码那怎么判断实例是由哪个构造函数生成的呢？这时候就要用到constructor了。实例的原型的构造函数， obj.proto.constructor4.constructor属性4.1 定义：构造函数的prototype属性指向它的原型对象，在原型对象中有一个constructor属性，指向该构造函数。值类型（除了null和undefined，这两者不具有这个属性）的constructor是只读的，不可修改，引用类型的constructor是可修改的，例如5.2提到的修复指向。4.2 修复constructor的指向：为了实现从父类到子类方法的继承，一般会重写构造函数的原型，如：function Person(){ ......... } function Student(){ ......... } Student.prototype = new Person() var student = new Obj() 这将使得实例student具有构造函数Person的方法，但同时也会导致constructor的指向出现问题，造成继承链的紊乱，因此为了修复这个错误指向，需要显式指定obj.prototype.constructor = obj 。拿下面例子说明：未重写原型对象之前，实例化了一个dog；第6行重写了原型对象，使其指向另一个实例（等式右边是字面量，因此可以看作是由Object构造函数实例化出来的一个对象），之后实例化了一个cat。查看dog和cat的constructor： console.log(dog.constructor); //function Animal() console.log(cat.constructor); //function Object() dog.say(); //wan cat.say(); //miao 首先，构造函数没有constructor属性，这导致了它构造的实例也没有constructor属性，所以，实例将沿着原型链(注意，构造函数不算在原型链里)向上追溯对应的原型对象的constructor属性。dog.constructor可以指向原来的构造函数，说明原来的原型对象还存在；而cat.constructor 指向另一个构造函数，是因为Animal( )的原型被重写，并且作为Object( )构造函数的一个实例而存在，那么由cat实例出发，向上进行constructor属性追溯的时候，最终会找到Object( ) 构造函数。同样的，正因为原型重写前后创建的实例分别对应了初始原型和新的原型，所以我们可以对旧实例调用初始原型的方法、对新实例调用新的原型的方法，放在本例子中，就表现为dog依然可以调用say( )方法发出wan，而cat也可以调用say( )方法发出miao 。总结：重写原型对象之后，会切断构造函数与最初原型之间的连接，使新构造的实例对象的原型指向重写的原型，而先前构造的实例对象的原型还是指向最初原型。在这种情况下，先前的实例对象可以使用最初原型的方法，新的实例对象可以使用重写的原型的方法。5. new和Object.create()的区别：这里，让我们回到文章开头提到的创建对象的三种方式。重点介绍后两种。5.1 newnew一个构造函数时，实际发生的过程是：var o={}; o.__proto__=M.prototype M.call(o) 第一步，创建一个空对象o；第二步，令空对象的proto指向构造函数M的prototype；第三步，令构造函数M中的this指针指向o，使得o具有M的属性或方法，如果M无返回值或返回的不是对象，则最后会返回o 。在这里要注意下面这个坑：var Base = function(){ this.a = 2; }; console.log(Base.a); 构造函数就好比印钞机，而它创建的实例就好比钞票。构造函数中的this.xxxx都是为了实例而准备的属性和方法，这些this在构造函数内，但并不指向构造函数，而是在new构造函数执行的时候转而指向新实例。构造函数自身没有这些属性和方法，像上面那样调用Base的a属性是会报错的，Base根本没有a属性。5.1.1 手写实现new（方法一）下面根据new的工作原理通过代码手动实现一下new运算符 var new2 = function (func) { //创建一个空对象，并链接到原型 var o = Object.create(func.prototype); //改变func中的this指向，把func的结果赋给k var k = func.call(o); //判断func是否显式返回对象 return typeof k === 'object' ? k : o; 验证不难看出，我们手动编写的new2和new运算符的作用是一样的。5.1.2 手动实现new（方法二）考虑到构造函数本身需要传参，这里提供第二种手写new的方法function new3(){ // 获得构造函数func（arguments的第一个参数） var func = [].shift.call(arguments); // 创建一个空对象，并链接到原型 var o = Object.create(func.prototype); // 改变func中的this指向，把func的结果赋给k var k = func.call(o,arguments); // 判断func是否显式返回对象 return k instanceof Object ? k : o; }; function M(){....} // 使用内置new var m = new M(....) // 使用手写new var m = new3(M,.....) 这里要注意数组的shift()方法，它可以删去数组的第一个元素并返回该元素。但是arguments是类数组的对象，无法直接使用这个方法，所以我们使用[].shift.call(arguments),意思是从参数列表（包括构造函数、构造函数的参数）中删去并返回第一个参数（构造函数），将其赋给func，之后的arguments将只包含构造函数func的参数。5.2 Object.create()Object.create()方法创建一个新对象（实例），并使用现有的对象(参数)作为新创建的对象的proto 也就是说，这个方法可以起到指定原型的作用。执行Object.create() 时，实际发生的过程是：Object.create = function (o) { var F = function () {}; F.prototype = o; return new F(); }; 第一步，创建空的构造函数；第二步，令构造函数的prototype指向传入的对象；实际上也相当于 令新实例的proto指向传入的对象第三步，实例化一个对象并返回这里，如果Object.create()接受的参数是null，即var obj = Object.create(null),则obj是真正意义上的空对象，不具有hasOwnProperty(),toString()等方法或属性。6 js实现父类到子类的继承的7种方式6.1.原型链继承核心：重写子类原型，代之以父类的实例function Person(){ this.age=[6,12,24]; } function Worker(){} Worker.prototype = new Person(); 缺点：创建子类实例时，无法向父类构造函数传参；对一个子类实例的引用类型属性的操作将会影响其他子类实例，即引用属性共享var worker1 = new Worker() var worker2 = new Worker() worker1.age.push(48) alert(worker1.age) //[6,12,24,48] alert(worker2.age) //[6,12,24,48] 6.2.借用构造函数继承又称为冒充继承、经典继承、伪造对象继承核心：使用父类的构造函数来增强子类实例，等同于复制父类的实例属性给子类（不使用原型）function Person(name){ this.age=[6,12,24]; this.name=name; } function Worker(name){ Person.call(this,name); } var worker1 = new Worker() var worker2 = new Worker() worker1.age.push(48) alert(worker1.age) //[6,12,24,48] alert(worker2.age) //[6,12,24] 缺点：虽然消除了原型链继承的缺点，但是不利于实现函数复用，每个子类都有父类实例函数的副本，影响性能。6.3.组合继承核心：原型链继承+借用构造函数继承。即使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.function Person(){ this.age=[6,12,24]; } Person.prototype.shout=function(){ alert("Ahhhhhh"); } function Worker(){ Person.call(this); ...其余新增属性。。。 } Worker.prototype=new Person() Worker.prototype.constructor=Worker //别忘记修正constructor的指向 var worker1 = new Worker() 缺点：很常用的继承方式，但也有缺点，就是代码第11、13行合计调用了两次父类函数，造成了不必要的消耗。6.4.原型式继承用到了object()，规范化之后即为Object.create()核心：利用Object.create()对传入其中的对象进行浅拷贝var Person = { age: [6,12,24] } var worker1 = Object.create(Person) var worker2 = Object.create(Person) 缺点：和原型链继承一样，存在引用属性共享的问题。worker1.age.push(48) alert(worker1.age) //[6,12,24,48] alert(worker2.age) //[6,12,24,48] 原因很好解释，因为worker1无age属性，因此向它的原型查找，它的原型恰好就是Person对象。因此实际上是在改动Person的age属性。6.5.寄生继承核心：创建一个函数用于封装继承的过程，在函数内部增强对象，最后将其返回var Person = { age: [6,12,24] } function createAnother(Person){ var worker0 = Object.create(Person); worker0.shout = function(){ alert("Ahhhhh"); }; return worker0; } var worker1 = createAnother(Person) worker1.shout() 缺点：和原型链继承一样，存在引用属性共享的问题;和经典继承一样，无法实现函数复用6.6.寄生组合继承核心：结合寄生式继承和组合继承的优点，避免为了指定子类的原型而二次调用父类的构造函数//封装函数。功能：在避免二次调用父类函数的前提下令子类原型指向父类实例 function inheritPrototype(subType, superType){ var obj = Object.create(superType.prototype); subType.prototype = obj; subType.prototype.constructor = subType; //修正constructor的指向 } // 父类初始化实例属性和原型属性 function Person(){ this.age=[6,12,24] } Person.prototype.shout = function(){ alert("Ahhhhhh"); }; // 借用构造函数传递增强子类实例属性（支持传参和避免篡改） function Worker(){ Person.call(this); } // 调用函数，令子类原型指向父类实例 inheritPrototype(Worker, Person); 优点：基本完美的继承方式，无任何缺点，也是目前库实现的方式。6.7.extends类继承// 父类 class Person { constructor(name,age) { this.name = name; this.age = age; } shout() { alert("Ahhhhhh"); } } //子类继承父类 class Worker extends Person{ constructor(name,age,job){ super(name,age); this.job = job; } work() { alert("I am working"); } } 解释：可以看作是ES6新增的语法糖，使得js中继承的写法更趋向于传统的面向对象语言。super是关键字，代表父类构造函数，只有在子类的构造函数中调用super()函数，才能让父类构造出this给子类去丰富。参考：http://www.cnblogs.com/wangfupeng1988/p/3978131.htmlhttps://www.cnblogs.com/chengzp/p/prototype.htmlhttps://juejin.im/post/5c6a9c10f265da2db87b98f3https://www.cnblogs.com/94pm/p/9113434.htmlhttps://segmentfault.com/a/1190000016891009]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>原型</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾博客系列之发布自己的主题：PureBlue]]></title>
    <url>%2F2019%2F03%2F28%2FT-%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E4%B8%BB%E9%A2%98--PureBlue%2F</url>
    <content type="text"><![CDATA[博客内容固然是最重要的，但是抛开内容不讲，博客本身也应该带有自己的Tag，而不是光会用别人的轮子。最早接触的博客平台是CSDN和博客园，在上面学习到了很多网友的经验，于是萌发了想要创建自己博客的念头，在写了几篇文章后又觉得：为何不自己搭建一个博客平台呢？因此在今年一月份的寒假捣鼓了hexo和github pages，包括下载各种漂亮的主题、添加各种有意思的插件，一时乐在其中。平静下来之后，我开始进行知识迁移的工作，把以前存放在印象笔记中的东西重新修改并整合，转移到个人博客里，于是内容慢慢充实起来。直到十几天前，我用的还是Next主题，这的确是一个相当成熟和漂亮的主题，我特别喜欢它的简洁。直到某天看到一句话：当你看到你用的主题出现在两个以上的博客时，那你就要考虑自己写一个了。别说两个了，Next主题的用户数应该是目前所有主题中最多的，而博客外观的雷同很显然是一件非常尴尬的事情。正好在那时我也陷入了一个纠结，就是我一直处于知识输入的状态却鲜有项目上的输出，简单地说就是学的多、做的少—-这是很要命的事，毕竟“纸上得来终觉浅”。也就是说我面临两个问题：缺少项目实践博客主题缺少个性化这两个问题恰巧有共同的答案，那就是自己制作一个主题。当时想的是这学期能做出来都算好的了，于是立了一个flag：不过很欣慰的是，我赶在月底之前把它完成了，前后大约花了14天。（大概是这个flag给我的动力）这是项目地址。虽然是一个小项目，而且代码也写得比较乱，但是收获颇丰——接触到了两个新的技术，一是模板引擎ejs，二个是css预处理器stylus，还有就是对hexo的原理有了更为深入的理解，至少知道了我写的markdown文件是怎么在网页上渲染出来的，而不是光会用却不知道原理。万事开头难，前期准备工作的时候真的是一头雾水。首先是Hexo的官方文档，写得很不友好，所以读起来云里雾里；其次是不同主题使用的模板引擎和css预编译都不同，主题文件的结构也不同，这大大提高了阅读源码的难度和花在上面的时间成本。虽然经过“搜刮”，我找到了几篇教程，但是大部分还是讲的不够浅显易懂，越看越晕。这时候我意识到两个重要的问题：这些东西不是给纯新手准备的，我需要先了解基础的概念善用搜索引擎，不要将视野局限在国内平台所以我开始去youtube上寻找相关的视频，幸运的是我的确找到了纯新手向的主题制作教程。每集只有几分钟，但是对于理解一些基础概念来说已经足够。不用担心听不懂，因为自带字幕，再配合up主的操作演示，还是很好理解的。之后我又谷歌了相关的文章，成功找到了这个系列教程，这是目前找到的最详细的教程，真真正正的从零开始教你怎么做一个主题，所以说实话真的很感谢这位老外。为了加深对主题制作的理解以及方便其他有需求的人，我将这个系列翻译了过来，可以在我的博客里找到，当然也可以去Segment Fault。目前我只翻译了两篇，第三篇会另外找个时间搞定。教程看下来，发现难点主要集中在两个地方：一是理清项目结构，进行合理的组织，二个是设计样式并具体实现。准备工作差不多之后，就可以开始动工了，不需要太着急，每天完成一部分就行。印象比较深的难点就是垂直时间轴的制作，也就是下面这个东西：一个是要做出样式，主要涉及伪元素的使用，以及考虑怎么让垂直轴随着页面高度增加而延长；二个是逻辑，遍历所有文章并根据年份进行划分，这里需要使用ejs的语法，对Hexo的内置变量也要熟悉。当然，做这个主题的时候也踩了很多坑，这里做一下踩坑记录：路径问题。为了使代码更容易管理，通常制作主题都是采用模块化的方式，因此存在着大量的文件引用。而A文件引用B文件时，不一定是使用B相对于A的路径，而要看最终A文件被谁引用。某篇文章中出现了一行很长的代码，因为没有对它进行换行和溢出处理，导致图片尺寸无法正常设置，同时所有的文本内容都被挤出div。在本地测试的时候某些文章无法显示全文内容，并且底部div消失。这个问题比较奇葩，而且至今无解。猜想应该是渲染出错还是什么= =。写stylus文件时混用了空格和tab，git报错。（这个是真的坑，开了sublime的提示才看出来的）第三方插件失效。返回顶部按钮是用的第三方jq插件，坑的地方就在于，作者引用jq库时是用的http链接，被浏览器阻止了，导致插件失效。一开始以为是缓存问题导致的样式无法修改，在反复修改和刷新了一个半小时后才想到去控制台看报错信息：所以，为了保险一点还是在项目中放jq文件比较好，当然更好的做法应该是直接用原生js来写。改动不生效的问题。比较常见的状况，在本地预览一切正常，通过域名访问的时候改动却迟迟没有生效，而且通常的清除浏览器缓存或者hexo clean还不一定有效。只能说改动的同步还是需要时间的= =page页面共用。这个严格来说不算坑，而是应该留意的一个地方。Hexo中并没有专门的展示所有标签或者所有类别的页面，拿我用的ejs来说，layout文件夹下的tag.ejs实际指的是单一标签下的所有文章，同理categories.ejs指的是单一类别下的所有文章。而我们需要的展示页面实际上是统一放在page.ejs中，再根据条件判断生成对应页面。不过我实际操作的时候发现分类页走的是归档页的布局。所以目前这个主题的分类页无法正常工作，也许之后会找到原因吧问题已解决，目前分类页可以正常工作。主题基本的东西都做好了，剩下的就是上传到github，并且向Hexo官方站点发起pull request—-这些对于我这个菜鸟来说还很陌生，所以不得不去b站找了github和git使用的相关教程。本来应该一切顺利了，但是本地这边一直无法推送到远程仓库，查了很久才发现是两边文件不一致的问题 = = 。当然，git和github是每个技术人的必备技能，所以之后我会另外找个时间系统学习一下这两者的使用。最后当然就是编写说明文档了，很神奇的是在编写的时候不由得想起以前做汉化时写的使用说明。这两者还是有共同之处的，因为你是要写给别人看，所以你必须确保描述清晰和完整——想象自己是一个用户，如果阅读这份文档后没有使用上的疑惑，我觉得就可以了。感触比较深的两点：一个是注意阅读源码。如果实在没有思路，可以先参考别人是怎么写的，一开始制作主题的时候很难理清项目结构，所以我选择了先看看别人是怎么写的；二个是英语的重要性——1/5的答案在百度，4/5的答案在谷歌，学会英语就意味着你找到了解决问题的另一条途径，而且无疑是更加宽广的途径。比如Hexo主题的制作，国内是没有人真的会去为这个而做系列视频的，但是国外有；同样地，提问题时也可以考虑选择国外平台，如果你注意了提问礼仪，很大几率问题会得到秒回。到这里差不多就告一段落了，之后的时间我会慢慢完善和更新这个主题。目前来说用户只有我自己，所以也算是为我自己而去努力地塑造它吧。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>PureBlue</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inline-blcok和float]]></title>
    <url>%2F2019%2F03%2F27%2FF-inline-block%E5%92%8Cfloat%2F</url>
    <content type="text"><![CDATA[1.比对：简单比对一下div+css布局中的inline-block和float的特点，同时附上使用inline-block之后元素之间产生空隙的解决方法。虽然设置浮动跟设置inline-block有些特征类似，但两者的区别还是非常明显的:文档流（Document flow）:浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。水平位置（Horizontal position）：很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。垂直对齐（Vertical alignment）：在两个div的高度不同时，两种方式的对齐效果也不相同：图一：display:inlne-block属性修饰的元素没有脱离文档流，当然会与在正常的文档流中的元素一样采取的底端对齐方式。图二： float属性修饰的元素在一定程度上脱离了普通文档流的限制，只用考虑向某个方向浮动，所以会产生如图的效果。区别来了！！！如果是使用display:inlne-block，则我们可以通过vertical-align来控制两个元素的对齐方式：我们为两个div分别添加一个属性：vertical-align:middle&lt;div class="myContainer"> &lt;div class="div1" style="display: inline-block;vertical-align: middle"> &lt;/div> &lt;div class="div2" style="display: inline-block;vertical-align: middle"> &lt;/div> &lt;/div> 查看一下运行效果：如图，div1出现在了div2的居中位置。假如使用的是float，我们是没办法使div1位于div2的中间位置的。空隙（Whitespace）：inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空隙。而浮动元素会忽略空白节点，互相紧贴。2.总结：什么时候使用inline-block、什么时候使用float，这取决于你的设计稿跟解决方法。通常来说，当你需要控制元素的垂直对齐跟水平排列时，使用inline-block；当你需要让元素环绕某一个元素时，或者需要支持旧版本ie，或者不想处理inline-block带来的空隙问题时，使用浮动。3.如何消除inline-block带来的空隙;3.1 思路一：元素间的间隙出现的原因是元素标签之间的空格，把空格去掉间隙自然就会消失。来看以下几种写法：写法一/不建议使用：&lt;div class="demo"> &lt;span>我是一个span&lt;/span>&lt;span>我是一个span&lt;/span>&lt;span>我是一个span&lt;/span>&lt;span>我是一个span&lt;/span> &lt;/div> 写法二：&lt;div class="demo"> &lt;span>我是一个span &lt;/span>&lt;span>我是一个span &lt;/span>&lt;span>我是一个span &lt;/span>&lt;span>我是一个span&lt;/span> &lt;/div> 写法三：&lt;div class="demo"> &lt;span>我是一个span&lt;/span>&lt;!-- -->&lt;span>我是一个span&lt;/span>&lt;!-- -->&lt;span>我是一个span&lt;/span>&lt;!-- -->&lt;span>我是一个span&lt;/span> &lt;/div> 3.2 思路二：取消span的结束标签，这样间隙就没有了。为了兼容IE6/IE7，最后一个标签需要闭合。&lt;div class="demo"> &lt;span>我是一个span &lt;span>我是一个span &lt;span>我是一个span &lt;span>我是一个span&lt;/span> &lt;/div> .demo span{ background:#ddd; display: inline-block; } 3.3 思路三：不管是思路一还是思路二，都只适用于写静态页面的时候，一旦HTML是后台生成，就不生效了。这时还有一个办法：在父容器上使用font-size:0。&lt;div class="demo"> &lt;span>我是一个span&lt;/span> &lt;span>我是一个span&lt;/span> &lt;span>我是一个span&lt;/span> &lt;span>我是一个span&lt;/span> &lt;/div> .demo {font-size: 0;} .demo span{ background:#ddd; display: inline-block; font-size: 14px; /*要设置相应的字号*/ } 原理：换行和回车会给各个span之间带来空格，而空格会被当成字符处理，因此通过给父元素设置字体大小为0，则空格字符大小也为0，相当于消除了其大小。需要注意的是，一定要额外设置span中的字体大小，否则会继承父元素的0大小字体。3.4 思路四：上面的思路其实已经很完美，但可惜不兼容Safari，以下给出终极方案,即font-size:0配合letter-space:-N px。.finally-solve { letter-spacing: -4px;/*根据不同字体字号或许需要做一定的调整*/ word-spacing: -4px; font-size: 0; } .finally-solve li { font-size: 16px; letter-spacing: normal; word-spacing: normal; display:inline-block; *display: inline; zoom:1; }]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「译」创建一个Hexo主题-Part1:首页]]></title>
    <url>%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart1%2F</url>
    <content type="text"><![CDATA[原文地址：Create an Hexo Theme-Part1: Index原文作者：Jonathan Klughertz译者：Chor在这个系列教程中，你将学习怎么从零开始制作一个 Hexo 主题。我很喜欢 Hexo ，并且每天都在使用，不幸的是，直到今天关于主题制作的文档还是相当稀缺。所以我打算弥补这个空缺。预先准备Hexo 博客的基础使用。如果你是第一次接触，请前往官网阅读教程了解 Bootstrap了解 Javascript 模板引擎（我们将使用 EJS ）项目描述这个项目旨在制作一个 Hexo 主题并详细了解 Hexo 引擎的工作方式。我不想在 HTML 和 CSS 上花费太多时间，所以我们将重置下面这个Hexo主题：https://getbootstrap.com/docs/3.4/examples/blog/ 。它是 Bootstrap 文档中的一个标准初始模板样例。我们将一步步地重用 CSS 、复制粘贴 HTML ，直到最后实现想要的效果。如果你感到困惑或者只对它的代码感兴趣，请前往 github 。项目结构创建一个新的 hexo 博客让我们从搭建一个全新的 hexo 博客开始吧// Create a new folder mkdir hexo-theme-creation cd hexo-theme-creation // Initialise Hexo hexo init 创建主题文件夹// Enter the theme folder cd themes // bootstrap-blog-hexo is also going to be the name of our theme mkdir bootstrap-blog-hexo 注意：如果你想在 git 中保存主题的话（你也应该这么做），请在/themes/bootstrap-blog-hexo/中初始化 git 。文件夹结构这是我们开始工作所需要的文件和文件夹：|-- layout // .ejs templates |-- source // source files (CSS, scripts) |-- _config.yml 创建以下两个文件夹和 _config.yml 文件。/layout/ 将包含我们所有的 EJS 模板/source/ 将包含我们所有的资源（ CSS 文件、外部脚本和库）_config.yml 包含我们的主题配置。现在暂且不写入任何内容。复制 bootstrap blog 资源从 bootstrap blog template 复制所有我们需要的资源并放在 source 文件夹里。你可以选择通过浏览器查看资源并复制下来，或者是下载该压缩包，之后解压到 source 文件夹里。|-- layout |-- source |-- bootstrap // Copy the boostrap library files here |-- css // Copy the blog's css file here |-- favicon |-- favicon.ico // Your choice of favicon |-- js // Copy the blog's js file here |-- _config.yml Hexo 的基本要素在我们开始写第一个模板文件之前，先来看看 Hexo 博客生成过程的基本要素。页面类型我们能够在主题中定义 6 种页面类型，与之相对应地，在 public 文件夹生成的每一个单独的 HTML 页面都属于下面模板中的其中一个：模板回退页面描述index无这是博客的首页，也是网站的主要入口。本教程中我们将让其显示文章摘要列表postindex这是文章的详情页。我们将展示一篇完整的文章以及一个评论区pageindex这是页面的详情页，与 post 一样，但是是 page 类型的 postarchiveindex这是归档页。它将显示我们博客中所有文章的标题和详情页链接categoryarchive这是分类页。与归档页类似，但是会根据类别进行筛选tagarchive这是标签页。与分类页类似，但是会根据标签进行筛选在本篇教程中我们将创建 index 模板。在页面生成过程中， Hexo 将会搜索名字为 index.ejs, post.ejs , page.ejs 等的文件，这些模板之后用于创建静态 HTML 页面。公共布局Hexo 支持使用 公共的布局文件 ，上面的模板都将使用到该文件。该文件命名为 layout.ejs 。不同页面类型的模板会创建一些内容，而这个文件就好比这些内容的“外壳”。在我们的主题中，公共布局将包括：&lt;html&gt;标签、&lt;head&gt;标签、头部、菜单、底部和侧边栏。基本上是所有类型的页面都具备的元素。不同的页面模板将只负责创建实际内容，这些内容将放在我们的主体部位。变量在所有的模板中，我们都可以使用 hexo 引擎提供的内置变量。以下是部分变量：Site：site包含了网站的信息。例如，我们可以通过site.posts访问博客中的所有文章。当我们想要显示统计数据的时候，这将派上用场。Page：page是主要变量，包含了许多与当前页面相关的信息，包括所有的文章标题、日期、内容等。Config：config是一个指向站点_config.yml文件的 JavaScript 对象Theme：theme是一个指向主题_config.yml文件的 JavaScript 对象主题的布局创建上面提及了/layout/layout.ejs文件，现在我们开始来创建它。顶部标签首先创建 layout.ejs 文件并插入&lt;html&gt;&lt;/html&gt;标签//layout/layout.ejs &lt;html> &lt;!-- Head tag --> &lt;%- partial('_partial/head') %> &lt;/html> 这里我们将所有&lt;head&gt;标签里的代码提取出来并放在局部视图中，这有助于实现关注点分离和代码重用。语法是partial(&#39;path&#39; [, arguments])在创建layout/_partial/head.ejs文件后，从 bootstrap 源码中复制 head 标签里的代码：// layout/_partial/head.ejs &lt;head> &lt;meta charset="utf-8"> &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"> &lt;meta name="viewport" content="width=device-width, initial-scale=1"> &lt;meta name="description" content=""> &lt;meta name="author" content=""> &lt;link rel="icon" href="favicon/favicon.ico"> &lt;title>Blog Template for Bootstrap&lt;/title> &lt;!-- Bootstrap core CSS --> &lt;%- css('bootstrap/css/bootstrap.min.css') %> &lt;!-- IE10 viewport hack for Surface/desktop Windows 8 bug --> &lt;%- css('css/ie10-viewport-bug-workaround.css') %> &lt;!-- Custom styles for this template --> &lt;%- css('css/blog.css') %> &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --> &lt;!--[if lt IE 9]> &lt;script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js">&lt;/script> &lt;script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js">&lt;/script> &lt;![endif]--> &lt;/head> 这很简单，我们只需使用 CSS helper 插入样式表。source 文件夹中的文件将会被复制到站点根目录下，所以不要在路径中包含source/我们将让&lt;title&gt;和&lt;meta&gt;标签保持动态，不过现在先暂且不管它们。底部标签底部标签位于&lt;/body&gt;之前。我们将在这个局部视图中包含所有脚本。先修改一下布局：// layout/layout.ejs &lt;html> &lt;!-- Head tag --> &lt;%- partial('_partial/head') %> &lt;body> &lt;!-- After footer scripts --> &lt;%- partial('_partial/after-footer') %> &lt;/body> &lt;/html> 然后创建layout/_partial/after-footer.ejs的内容：// layout/_partial/after-footer.ejs &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js">&lt;/script> &lt;%- js('bootstrap/js/bootstrap.min.js') %> &lt;!-- IE10 viewport hack for Surface/desktop Windows 8 bug --> &lt;%- js('js/ie10-viewport-bug-workaround.js') %> 注意 JS helper function 的使用，它将引用本地 js 文件。顶部菜单类似地，在&lt;body&gt;标签后创建顶部菜单。// layout/layout.ejs // [...] &lt;body> &lt;!-- Menu --> &lt;%- partial('_partial/menu') %> // [...] layout/_partial/menu.ejs的内容：// layout/_partial/menu.ejs &lt;div class="blog-masthead"> &lt;div class="container"> &lt;nav class="blog-nav"> &lt;% for (var i in theme.menu){ %> &lt;a class="blog-nav-item" href="&lt;%- url_for(theme.menu[i]) %>">&lt;%= i %>&lt;/a> &lt;% } %> &lt;/nav> &lt;/div> &lt;/div> 注意theme全局变量的使用,它指向的是主题的_config.yml文件。为了可以在主题配置中配置菜单，我们需要在_config.yml文件中添加配置：_config.yml # Header menu: Home: / Archives: /archives 在menu.ejs中我们遍历了配置文件中所有的菜单项目并创建对应的链接。顶部顶部将位于顶部菜单下面，它包含了博客标题和子标题：// layout/_partial/header.ejs &lt;div class="blog-header"> &lt;h1 class="blog-title">&lt;%= config.title %>&lt;/h1> &lt;p class="lead blog-description">&lt;% if (config.subtitle){ %>&lt;%= config.subtitle %>&lt;% } %>&lt;/p> &lt;/div> 这里我们使用了指向站点_config.yml文件的config变量，它包含了可供配置的标题和子标题属性。注意在布局的&lt;div class=&quot;container&quot;&gt;&lt;div&gt;中嵌套顶部：// layout/layout.ejs &lt;html> &lt;!-- Head tag --> &lt;%- partial('_partial/head') %> &lt;body> &lt;!-- Menu --> &lt;%- partial('_partial/menu') %> &lt;div class="container"> &lt;!-- Blog Header: title and subtitle --> &lt;%- partial('_partial/header') %> &lt;/div> // [...] 底部底部现在是完全静态的，内容如下：// layout/_partial/footer.ejs &lt;footer class="blog-footer"> &lt;p>Blog template built for &lt;a href="http://getbootstrap.com">Bootstrap&lt;/a> by &lt;a href="https://twitter.com/mdo">@mdo&lt;/a>.&lt;/p> &lt;p>Adapted to Hexo by &lt;a href="http://www.codeblocq.com/">klugjo&lt;/a>.&lt;/p> &lt;p>&lt;a href="#">Back to top&lt;/a>&lt;/p> &lt;/footer> 主要内容和侧边栏此时，我们再加上主要内容和侧边栏，基本就差不多了。下面是最终的layout.ejs：// layout/layout.ejs &lt;html> &lt;!-- Head tag --> &lt;%- partial('_partial/head') %> &lt;body> &lt;!-- Menu --> &lt;%- partial('_partial/menu') %> &lt;div class="container"> &lt;!-- Blog Header: title and subtitle --> &lt;%- partial('_partial/header') %> &lt;div class="row"> &lt;!-- Main Content --> &lt;div class="col-sm-8 blog-main"> &lt;%- body %> &lt;/div> &lt;!-- Sidebar --> &lt;div class="col-sm-3 col-sm-offset-1 blog-sidebar"> &lt;%- partial('_partial/sidebar') %> &lt;/div> &lt;/div> &lt;/div> &lt;!-- Footer --> &lt;%- partial('_partial/footer') %> &lt;!-- After footer scripts --> &lt;%- partial('_partial/after-footer') %> &lt;/body> &lt;/html> body变量对应了不同页面类型模板创建的内容（参见上面）。至于侧边栏，我们现在暂且使用来自 bootstrap 模板的硬编码：// layout/_partial/sidebar.ejs &lt;div class="sidebar-module sidebar-module-inset"> &lt;h4>About&lt;/h4> &lt;p>Etiam porta &lt;em>sem malesuada magna&lt;/em> mollis euismod. Cras mattis consectetur purus sit amet fermentum. Aenean lacinia bibendum nulla sed consectetur.&lt;/p> &lt;/div> &lt;div class="sidebar-module"> &lt;h4>Archives&lt;/h4> &lt;ol class="list-unstyled"> &lt;li>&lt;a href="#">March 2014&lt;/a>&lt;/li> &lt;li>&lt;a href="#">February 2014&lt;/a>&lt;/li> &lt;li>&lt;a href="#">January 2014&lt;/a>&lt;/li> &lt;li>&lt;a href="#">December 2013&lt;/a>&lt;/li> &lt;li>&lt;a href="#">November 2013&lt;/a>&lt;/li> &lt;/ol> &lt;/div> &lt;div class="sidebar-module"> &lt;h4>Elsewhere&lt;/h4> &lt;ol class="list-unstyled"> &lt;li>&lt;a href="#">GitHub&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Twitter&lt;/a>&lt;/li> &lt;li>&lt;a href="#">Facebook&lt;/a>&lt;/li> &lt;/ol> &lt;/div> 首页文件布局到位后，我们就可以开始创建第一个页面类型模板 inde.ejs 了。这是比较简陋的第一个版本：// layout/index.ejs &lt;span>Content&lt;/span> 别小瞧它，我们可以用这个在浏览器中测试主题：# Verify that everything is alright hexo generate # Start hexo server hexo server 访问 http://localhost:4000/ 。哇！注意：不要忘记在站点的 config 文件中更新主题：_config.yml # Extensions ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: bootstrap-blog-hexo 遍历博客文章我们想要在首页显示各篇文章的摘要。首先，在我们的 index.ejs 文件中遍历文章：// layout.index.ejs &lt;% page.posts.each(function(item){ %> &lt;%- partial('_partial/article-excerpt', {item: item}) %> &lt;% }); %> 通过page.posts获取该页面的所有文章通过&lt;%- partial(&#39;name&#39;, args) %&gt;给 partial 传参文章布局创建article-excerpt.ejs文件，添加适合主题的代码。这是我的布局：// layout/_partial/article-excerpt.ejs &lt;div class="blog-post"> &lt;!-- Title --> &lt;h2 class="blog-post-title"> &lt;a href="&lt;%- config.root %>&lt;%- item.path %>"> &lt;%- item.title %> &lt;/a> &lt;/h2> &lt;!-- Date and Author --> &lt;p class="blog-post-meta"> &lt;%= item.date.format(config.date_format) %> &lt;% if(item.author) { %> by &lt;%- item.author %> &lt;% } %> &lt;/p> &lt;!-- Content --> &lt;%- item.excerpt || item.content %> &lt;!-- Only display the Read More link if we are displaying an excerpt --> &lt;% if(item.excerpt) { %> &lt;p> &lt;a href="&lt;%- config.root %>&lt;%- item.path %>"> &lt;%= theme.excerpt_link %> &lt;/a> &lt;/p> &lt;% } %> &lt;/div> 全文链接全文链接是由config.root（配置选项，相当于/）和item.path(相对路径或者绝对路径，指向全文)连接组成的。文章作者默认情况下， Hexo 没有关于作者属性的的文章变量。不过我们可以在 front matter 中添加任意自己想要的变量。如果你想要在文章中显示作者名字，那么文章的 front matter 应该类似如下进行设置：title: Hello World author: Klughertz Jonathan --- Item excerpt 和 Item content当用 Hexo 编辑文章时，你可以用&lt;!-- more --&gt;标签从文章内容中截取摘要。在本教程中，因为我们展示的是文章列表，所以选择显示摘要。之后用户可以通过点击文章标题或者“阅读更多”的链接浏览全文。“阅读更多”文本别忘了，你需要像我这样在主题的配置文件中添加一个新的属性：_config.yml # Read More text excerpt_link: Read More 希望接下来的代码容易理解。现在，我建议你写一些除了默认的 Hello World 之外的文章并享受这个结果。分页器在本篇文章中，我们最后需要处理的是首页的分页器。在index.ejs文件中增加一个分页器的 partial ：// layout/index.ejs &lt;% page.posts.each(function(item){ %> &lt;%- partial('_partial/article-excerpt', {item: item}) %> &lt;% }); %> &lt;%- partial('_partial/pagination') %> 之后开始创建分页器的内容，layout/_partial/pagination.ejs:// layout/_partial/pagination.ejs &lt;nav> &lt;ul class="pager"> &lt;% if (page.prev){ %> &lt;li>&lt;a href="&lt;%- config.root %>&lt;%- page.prev_link %>">Previous&lt;/a>&lt;/li> &lt;% } %> &lt;% if (page.next){ %> &lt;li>&lt;a href="&lt;%- config.root %>&lt;%- page.next_link %>">Next&lt;/a>&lt;/li> &lt;% } %> &lt;/ul> &lt;/nav> page.prev：上一页的页码。如果当前页是第一页，则为0page.next：下一页的页码。如果当前页是最后一页，则为0page.next_link和page.prev_link是什么就不用多说了。如果你没有足够的文章用来查看分页器的工作效果，可以在主配置文件中（per_page属性）调整每一页的文章数。这就是今天的内容，在下一篇教程中，我们将完成博客剩下的所有页面。目前可以找到的比较完备的 Hexo 主题制作教程，我自己从中受益良多。有打算自己撸一个主题的都可以参考下，真的写得很不错。如果发现译文存在错误或其他需要改进的地方，欢迎在下面评论指出。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>hexo theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「译」创建一个Hexo主题-Part2:其他页面]]></title>
    <url>%2F2019%2F03%2F27%2FTrs-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAHexo%E4%B8%BB%E9%A2%98%E4%B9%8BPart2%2F</url>
    <content type="text"><![CDATA[原文地址：Create an Hexo Theme-Part2: Other Pages原文作者：Jonathan Klughertz译者：Chor在这个系列教程中，你将学习怎么从零开始制作一个Hexo主题。在part1中，我们已经着手动工并创建了首页。在这篇文章中，我们将运用所学完成剩余的页面。文章详情页让我们继续完成part1中的剩余工作并创建文章详情页。正如我们看到的，为了生成详情页，Hexo将会在/layout/文件夹中寻找一个post.ejs文件。这是我的post.ejs文件：// layout/post.ejs &lt;%- partial('_partial/article-full', {item: page}) %> 为了让代码更加有序，我们会将实际代码放在_partial/article-full.ejs中。现在先来创建这个文件：// layout/_partial/article-full.ejs &lt;div class="blog-post"> &lt;!-- Title --> &lt;h2 class="blog-post-title"> &lt;a href="&lt;%- config.root %>&lt;%- item.path %>"> &lt;%- item.title || item.link%> &lt;/a> &lt;/h2> &lt;!-- Date and Author --> &lt;p class="blog-post-meta"> &lt;%= item.date.format(config.date_format) %> &lt;% if(item.author) { %> by &lt;%- item.author %> &lt;% } %> &lt;/p> &lt;!-- Content --> &lt;%- item.content %> &lt;hr /> &lt;!-- Tags and Categories links --> &lt;%- partial('article-tags', {item: item}) %> &lt;%- partial('article-categories', {item: item}) %> &lt;/div> 这个模板几乎和_partial/article-excerpt.ejs`一样，除了：我们使用&lt;%- item.content %&gt;展示全文内容而不是摘要在底部新增两个部分，分别是标签部分和分类部分。接下来分别创建它们。文章标签文章标签部分将生成一篇文章对应的所有标签：layout/_partial/article-tags.ejs我们想要创建的是一系列的标签和链接，每个链接都将导向对应的标签页面，而标签页面会显示该标签的所有文章。// layout/_partial/article-tags.ejs &lt;% if (item.tags &amp;&amp; item.tags.length){ %> &lt;% var tags = []; item.tags.forEach(function(tag){ tags.push('&lt;a href="' + config.root + tag.path + '">#' + tag.name + '&lt;/a>'); }); %> &lt;div class="blog-tags-container"> &lt;span class="glyphicon glyphicon-tags">&lt;/span> &lt;%- tags.join(' ') %> &lt;/div> &lt;% } %> 很简单，我们通过post.tags遍历文章的所有标签并让这些标签一个接一个地显示。我在每个标签前面加了一个#号，并且在列表前面额外加了一个图标。文章分类layout/_partial/article-categories.ejs的内容和上面很相似// layout/_partial/article-categories.ejs &lt;% if (item.categories &amp;&amp; item.categories.length){ %> &lt;% var categories = []; item.categories.forEach(function(category){ categories.push('&lt;a href="' + config.root + category.path + '">' + category.name + '&lt;/a>'); }); %> &lt;div class="blog-categories-container"> &lt;span class="glyphicon glyphicon-folder-open">&lt;/span> &lt;%- categories.join(' / ') %> &lt;/div> &lt;% } %> 这里不再赘述。文章样式可能有人注意到了，我们分别给了标签部分和分类部分一个类名，这是为了方便给它们设置样式。这是相关代码，将它们添加进blog.css中：// source/css/blog.css .blog-tags-container, .blog-categories-container { margin-top: 30px; font-size: 20px; } .blog-tags-container span.glyphicon, .blog-categories-container span.glyphicon { margin-right: 20px; } 页面类型模板的详情页这个很简单。“页面类型模板”和“文章类型模板”相差无几。就当做练习自定义一下就好，这是我的设置：// layout/page.ejs &lt;%- partial('_partial/article-full', {item: page}) %> 归档页归档页和首页一样会显示文章列表，只是它要更加简略—尽管基础结构和首页是差不多的：// layout/archive.ejs &lt;% page.posts.each(function(item){ %> &lt;%- partial('_partial/article-archive', {item: item}) %> &lt;% }); %> &lt;%- partial('_partial/pagination') %> 文章归档页部分和前面一样，实际的工作是由article-archive.ejs完成的。我使用article-excerpt作为基础结构，做了适当删减，只保留标题、日期和作者。// layout/_partial/article-archive.ejs &lt;div class="blog-post"> &lt;!-- Title --> &lt;h2 class="blog-post-title-archive"> &lt;a href="&lt;%- config.root %>&lt;%- item.path %>"> &lt;%- item.title || item.link%> &lt;/a> &lt;/h2> &lt;!-- Date and Author --> &lt;p class="blog-post-meta"> &lt;%= item.date.format(config.date_format) %> &lt;% if(item.author) { %> by &lt;%- item.author %> &lt;% } %> &lt;/p> &lt;/div> 细心的人可能注意到，我为标题创建了一个新的类名（它们太大了，我不喜欢）：// source/css/blog.css .blog-post-title-archive { margin-bottom: 5px; font-size: 25px; } 标签页和分类页最后我们还需要创建两个页面。标签页将包括某个标签对应的全部文章，分类页同理。如果你还记得的话：| 模板 | 备用模板 | 页面描述 ||—–|—–|—-|| archive | index | 这是归档页。它将显示我们博客中所有文章的标题和详情页链接|| category | archive | 这是分类页。与归档页类似，但是会根据类别进行筛选|| tag | archive | 这是标签页。与分类页类似，但是会根据标签进行筛选|tag.ejs和’category.ejs’的回退页是archive.ejs。我认为这三个页面并无太大区别，我们仅仅是在使用archive.ejs的回退页而已。好处就是代码量减少、提高代码可复用性和可维护性。不过为了区分这三个页面，我们还是给归档页加上标题吧：// layout/archive.ejs &lt;% var title = ''; if (page.category) title = page.category; if (page.tag) title = page.tag; if (page.archive){ if (page.year) title = page.year + (page.month ? '/' + page.month : ''); else title = "Archives"; } %> &lt;% if(title) { %> &lt;h2 class="blog-archive-title">&lt;%- title %>&lt;/h2> &lt;% } %> &lt;% page.posts.each(function(item){ %> &lt;%- partial('_partial/article-archive', {item: item}) %> &lt;% }); %> &lt;%- partial('_partial/pagination') %> 现在我们有了一个漂亮的标题用以描述了归档页的类型。这是对应的CSS样式：// source/css/blog.css .blog-archive-title { margin-bottom: 50px; } 本教程的第二篇文章非常简单，你只需要清楚第一篇文章中提及的概念即可。我强烈推荐你根据自己的口味尝试修改主题。在第三篇文章中，我们将添加评论部分、统计部分、装饰部件并做一些改进。期待与你再次相见！目前可以找到的比较完备的 Hexo 主题制作教程，我自己从中受益良多。有打算自己撸一个主题的都可以参考下，真的写得很不错。如果发现译文存在错误或其他需要改进的地方，欢迎在下面评论指出。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
      <tags>
        <tag>hexo theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text3插件简易使用教程]]></title>
    <url>%2F2019%2F03%2F26%2FTo-Sublime%20Text3%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[作为一款轻便的编辑器，Sublime Text3的下载和安装都比较简单，这里一并略过，只说安装插件的事情。Sublime Text3支持各种强大的插件，可以在一定程度上提高打码速度。1.安装 Package Control安装插件有两种方式，一种是直接下载插件的安装包，解压缩到编辑器的 Packages 目录中，比较麻烦，不推荐；我们通常用另一种方法，即通过 Package Control 组件来安装插件 。所以第一步，先安装 Package Control 组件 。打开编辑器，按 control + ` 打开控制台，粘贴如下代码到命令行并回车；import urllib.request,os;pf = 'Package Control.sublime-package';ipp = sublime.installed_packages_path(); urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen('http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 重启编辑器，在 Perferences -&gt;Package Settings 中看到 Package Control，则表示安装成功。当然，你有很大的概率会安装失败，遇到下面的报错弹窗：原因不便多说（你懂的），网上有比较多的解决方法，这里提供一种最有效也是最简单的方法。依次点击编辑器的 Preferences –&gt;package settings–&gt;package control–&gt;settings user,进入用户自定义配置文件，修改 channels 的值为&quot;http://www.miaoqiyuan.cn/products/proxy.php/https://packagecontrol.io/channel_v3.json&quot;。如下图所示：这样我们就可以成功安装 package controls 了 。2.安装想要的插件点击 Preferences –&gt;package control，点选 install package 选项 ，输入自己想要安装的插件的名称，即可进行安装。当然，由于**原因，安装插件的过程一般比较慢，等一会就行了。一般来说，安装成功后会弹出新标签页。3.推荐的插件3.1 汉化插件如果你看不惯英文的话，可以下一个汉化插件。点选 install package 选项后 ，搜索“ChineseLocalization”进行安装。安装完后重启编辑器即可；3.2 解决中文乱码问题的插件Sublime Text3 不支持 GB 2312和 GBK 编码，会出现中文乱码的情况，所以推荐安装“ConvertToUTF8”插件，安装方法同上；3.3 解决输入法输入框不跟随问题的插件中文状态下，我们会发现输入法的输入框无法跟随鼠标，看着非常难受，所以这里可以用 IMESupport 插件解决这个问题。这个方法绝大多数情况下是有效的，然而，如果你是 win10用户，并且用的是系统自带输入法，那么你得采取另一种方法。原文链接在此 https://blog.csdn.net/qq_24345801/article/details/79077902 ，这里粘贴一下主要内容。其实还是要用到插件 IMESupport ，只不过这个插件是国人大神自己修改的，下载地址是：https://github.com/zcodes/IMESupport由于是修改过的源码，不能通过 package control 来在线安装 ，而是需要自己手动安装（安装前请先卸载原来的插件），安装过程如下：从上面的网址下载插件，解压Preferences-&gt;Browse Packages 打开插件安装的目录将解压后的文件夹复制到上一步打开的目录中重启 sublime text 3即可3.4 自动补全代码的插件使用“Emmet”插件，可以迅速编写 HTML /CSS 代码 ，例如，只需要用html:5配合 tab 键即可迅速生成 html 的基础结构 ，还可以用诸如nav&gt;ul&gt;li的快捷方式迅速生成嵌套结构，具体其他用法可以百度“Emmet 语法 ”。3.5 语法检查插件也即 SublimeLinter 插件。但其实我们并不是直接用它进行代码检测——实际上它是一个包含了多种检测插件（sublimelinter-htmlhint，sublimelinter-csslint，sublimelinter-jshint）的“容器”。本步骤的安装会比其他插件麻烦得多，下面介绍一下具体安装过程。3.5.1 安装 node .js安装 SublimeLinter 前必须先安装 node .js 这一重要前置 。这是因为 sublimelinter -htmlhint，sublimelinter-csslint，sublimelinter-jshint 实际上分别调用的是 node.js 的 htmlhint，csslint 和 jshint。安装 node .js 比较简单 ，这里略过。3.5.2 安装 SublimeLinter打开 Sublime ，按下 Ctrl+Shift+p 进入 Command Palette;输入 install 进入 Package Control: Install Package;输入 SublimeLinter ，选择 SublimeLinter 进行安装。3.5.3 安装 sublimeLinter-contrib-htmlhint 和 xg-htmlhintSublimeLinter 的插件之一 ，用来调用 node .js 的 xg-htmlhint 进行语法检查 。前往 Releases 下载最新版本的压缩包，解压并重命名为“SublimeLinter-contrib-htmlhint”，并放入 Sublime 的 Package 目录 (菜单-&gt;Preferences-&gt;BrowsePackages)开始菜单—&gt;node.js—&gt;node.js command prompt，输入以下命令 ：npm install -g xg-htmlhint等待出现一堆数字版本号即为成功安装。3.5.4 安装 sublimeLinter-csslint 和 csslint，sublimeLinter-jshint 和 jshint打开 Sublime Text3,按住 Ctrl +Shift+P 安装SublimeLinter-csslintSublimeLinter-jshint开始菜单—&gt;node.js—&gt;node.js command prompt，输入以下命令：npm install -g jshintnpm install -g csslint之后重启编辑器，大功告成。这个插件虽然不是万能的，但是可以鉴别很多错误，尤其是中文标点符号错误，有时候不靠插件纠错还真看不出来。]]></content>
      <categories>
        <category>Tool</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[折腾博客系列之博客搭建：Hexo+Github pages]]></title>
    <url>%2F2019%2F03%2F24%2FT-hexo%2Bgithub%20pages%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[初衷：之前我习惯用印象笔记进行知识的收集和整理，虽然很好用，但终归只适合输入而不适合输出。我需要的是一个更加开放的平台，在这上面可以输出： 1.学习的收获 ；2.生活的感想 ；3.有价值的分享，因此有了这个博客网站。用hexo+github pages 可以很方便地搭建一个个人博客网站，不需要购买域名和服务器，只需要按部就班操作即可。我自己大概是花了两三个小时搞定，主要是因为对git bash的使用不够熟悉，因此走了一些弯路。实际上动作快的话半个小时就可以搞定。下面是对部署过程的大概介绍，以及必须注意的事项（划重点，也就是所谓的“坑”）。由于本文参考了大量博客，所以在文末我会列出原文链接。一.Github，Github pages ，Hexo首先介绍一下这三个东西，有大概的了解、知道是什么东西就可以。GitHub是一个面向开源及私有软件项目的托管平台，而GIthub Pages则是github的一项功能，可以放置网页文件到指定文件夹，然后给你一个专属域名用于展示一些项目，现在大多用来开发和制作个人博客网站。它的好处在于域名和服务器都是免费提供的，并且没有网站数量的限制。而Hexo 是一个快速、简洁且高效的博客框架，它使用Markdown解析文章，在几秒内，就可以利用靓丽的主题生成静态网页。（关于Hexo的详细介绍，请看官方文档 https://hexo.io/zh-cn/docs/ ，这里就不展开了）。因此，可以说github和hexo是绝配。接下来，开始我们的工作。二. 环境和必要准备我个人的环境：win10，64bit必要准备：你需要（1）github账号 ：前往https://github.com/ 官网注册就好（2）git ： 最新版本的git（本文发表的时候是2.20.1版本），前往https://git-scm.com/ 官网下载并安装。安装完后前往git文件夹下打开git bash，运行以下命令：git config --global user.name &quot;username&quot; git config --global user.email &quot;your mail&quot; 注：将username替换为自己的github账号名，将your mail替换为自己注册github时绑定的邮箱。这一步非常重要，当时部署的时候我因为遗漏了这一步，导致后面报错.（3）node.js ： 前往 https://nodejs.org/en/ 下载并安装。这两个的安装比较简单，一路next就好，不过我推荐还是修改一下路径，尽量放在自己可以找到的位置。（4）hexo ：打开git文件夹下的git bash，运行 以下命令安装hexonpm install -g hexo-cli依次运行以下命令进行hexo的初始化$ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 注：请将上面代码的&lt;folder&gt;替换成你自己想要的文件夹名字，以我为例，我想要在git文件夹下新建一个Myblog文件夹以存放站点文件，那么我这里的代码就应该是$ hexo init Myblog $ cd Myblog $ npm install 成功之后，我们会在git文件夹下看到新建的Myblog文件夹，这个就是我们的站点文件夹，网站相关文件都存放在这里。这里顺便介绍一下cd Myblog的作用，可以理解为“进入Myblog运行git bash”，你也可以在Myblog中右键运行git bash（如下图），效果是一样的。在之后介绍的操作中，凡是需要输入命令的，请确保你已经cd进自己的站点文件夹。接着上面的代码，我们继续运行：hexo server 这将在本地打开我们的网站，当提示”xxx is running at xxx“的时候，我们可以通过http://localhost:4000/ 这个网址预览我们的网站，想要切断连接，只需要在命令行窗口按下ctrl+c。至此，hexo博客已经在本地搭建好了。接下来，我们要将hexo和github进行对接。三. hexo与github 实现对接1.建立仓库还记得我们之前注册的github账号吗？现在，请进入github网站，并点击头像选择your repository，我们现在需要创建一个仓库（也就是repository）用于存放相关站点文件。按照下图顺序进行设置：其中，Repository name也即是我们的仓库名字，必须是 Github账号名称.github.io的格式。比如你的github名字是ccc，那么仓库名字必须是ccc.github.io 。2.对接github在git bash中运行以下命令，安装 hexo-deployer-git 插件。npm install hexo-deployer-git --save 运行以下命令，创建SSH key。（注：和上面一样，请将your mail替换成github邮箱地址）$ ssh-keygen -t rsa -C &quot;your mail&quot; 前往 C:\Users\Administrator.ssh\id_rsa.pub （注意，这只是大概位置。不同系统路径可能不同，但是大同小异）打开id_rsa.pub文件（可以用记事本打开，但是推荐用sublime text）。复制文件中的全部内容，前往 https://github.com/settings/keys ，将刚才复制的内容粘贴在New SSH key 的文本框中。前往站点目录下（例如：git/ Myblog），打开_config.yml 文件，对文件末尾进行如下修改：# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 在这里要注意，1）所有的冒号距离右边的内容之间都有一个空格，如果没有空格，则修改是无效的。2）和前面一样，将usename替换成我们自己的github用户名 。 3）repo后面的地址，在旧版本的hexo中是http地址，但在新版本的hexo用的是ssh地址，我们统一用如上所示的ssh地址。有些博客由于没有进行更新，在说明这个问题的时候依然用的是http地址，造成了一定程度上的误导。运行以下命令，对接并推送内容到github。$ hexo g $ hexo d 等待片刻，打开 https://&lt;Github账号名称&gt;.github.io （例如 https://ccc.github.io ) 即可进入你搭建好的个人博客网站了。当然，网站默认用的是landscape主题，比较难看，关于主题的美化和后期一些插件的添加，可以参考文章末尾贴出的链接。PS：这里顺便介绍一下常用的 hexo 命令：hexo clean ————————&gt;清除缓存文件和已生成的静态文件hexo g 或者 hexo generate ————————&gt;生成静态文件hexo d 或者hexo deploy ————————&gt;生成静态文件并部署到仓库hexo s 或者 hexo server —————————&gt;在本地打开网站一般来说，在对网站进行修改后，我们可以先用hexo g和hexo s 在本地预览效果，如果效果符合预期的话再用hexo d 推送到 github。当然，可能会遇到本地打开和域名打开的效果不一致，这种情况下通常是因为 1. 没有用hexo clean 清除缓存 2. 没有清除浏览器缓存（ctrl+f5 ） 3.忘记用hexo d 将本地文件推送到github 4. 本地和线上的同步本身需要时间，所以上述方法如果无效，可以尝试等几分钟，再打开网站就正常显示了。参考自：https://www.jianshu.com/p/3a05351a37dchttps://www.simon96.online/2018/10/12/hexo-tutorial/]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾博客系列之编辑工具的选择]]></title>
    <url>%2F2019%2F03%2F24%2FTo-%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[Hexo是静态博客网站，必须先在本地编辑好md文件再推送到网站上去—md文件也就是所谓的用markdown语法编写内容的文件。“工欲善其事，必先利其器”，因此我们需要一个合适的markdown编辑工具，它必须具备以下特点：1.可导出md文件到本地，并随时进行修改2.可提供分屏预览，支持同步滚动和定位3.启动时响应速度快，编辑时渲染速度快以下是一些工具在markdown编写方面的优劣比较，可酌情进行选择。（平台：windows）印象笔记印象笔记自带markdown编辑器,如下图：优点：提供分屏预览，无需直接编写md代码，只需点击按钮即可，操作方便缺点：无法导出md文件到本地，这是它的致命缺点。sublime text3优点：安装插件后可以提供分屏预览缺点：预览效果极差，超出的文本内容无法自动换行显示，而是直接隐藏。如下图红框部分Typora优点：简洁美观缺点：不提供分屏预览，md代码编辑完成后回车即自动渲染出文本来。（虽然它认为这是优点，很多人习惯的却是分屏）Atom优点：提供分屏预览，有较多可拓展插件缺点：响应速度极慢，编辑时明显感觉卡顿；软件过大，大概100多m；安装插件极其困难，失败率较高HexoEditor优点：简洁美观，提供分屏预览，图片插入方便缺点：需要用npm指令下载安装，和Atom插件安装如出一辙，很容易卡死Hexo-admin非工具。Hexo自带的博客后台管理，可以在web ui界面下进行编辑优点：提供分屏预览缺点：界面过于简陋，自定义程度较低，本地服务器必须一直开着才能使用Vscode这是这么多工具中我觉得体验最好的，本篇博客也是用vscode编写。优点：提供分屏预览、同步滚动等；较多markdown插件和主题；启动速度快，使用流畅不卡顿，渲染速度很快缺点：需要自己写md代码，不过鉴于md语法并不复杂，我觉得这个缺点完全可以忽略不计。最后是博客编写方面的一点小tip：原生markdown语法并不支持定义字体颜色和大小等样式，但是由于在hexo中，我们编写的md文件最后会生成对应的html文件，所以完全可以在编写的时候使用html语法，浏览器会自动解析并渲染文件中包含的标签等。比如，上面就可以通过将句子放在span标签中，再加上内联样式达到荧光高亮的效果。不止是样式，我们还可以用&lt;br&gt;标签实现换行,让每一段不至于太紧凑。（md中空格是会被合并的，这点和html一样）]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>编辑工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大一下的一些计划]]></title>
    <url>%2F2019%2F03%2F23%2FT-%E5%A4%A7%E4%B8%80%E4%B8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[1.关于英语准备四级考试，重点是听力和写作；2.前端2.1. 旧东西的收尾，具体来说包括：培训视频（进阶系列）SegmentFault上js进阶的相关文章。由于是js中的难点，并且在面试中出现比较多，所以慢慢来。打算是每周攻克一个或两个【进阶1期】 调用堆栈【进阶2期】 作用域闭包【进阶3期】 this全面解析【进阶4期】 深浅拷贝原理【进阶5期】 原型Prototype【进阶6期】 高阶函数【进阶7期】 事件机制【进阶8期】 Event Loop原理【进阶9期】 Promise原理【进阶10期】Async/Await原理【进阶11期】防抖/节流原理【进阶12期】模块化详解【进阶13期】ES6重难点【进阶14期】计算机网络概述【进阶15期】浏览器渲染原理2.2. 《js高程》的阅读。之所以单独拎出这一点，因为这学期基本不可能读完这么厚的书。所以打算是在学习h5的时候同步阅读本书。2.3. 找一个小项目做。初步决定是面向对象的小游戏，也有可能是hexo的一个主题主题已完成，接下来可能会探索一下小程序2.4. 新东西的开始html5+css3，了解新特性，重点放在css动画。如果有时间，就学习ajax和jq。jq不作为重点。4.关于阅读看两本历史相关的书，大概是以下其中两本：中东问题：《奥斯曼帝国六百年》《穿越百年中东》《中东生死门》以色列/犹太人：《我为何放弃做犹太人》《耶路撒冷异乡人》《我的一生》《我的应许之地》《以色列123》《爱与黑暗的故事》《犹太国》《犹太复国主义史》巴勒斯坦：《最后的天空之后》伊拉克：《搅动世界的伊拉克》阿拉伯：《阿拉伯的劳伦斯》战争回忆录：《南瓜花》5.游戏可能会把巫师3+dlc打通关，当然，前提是有时间。已通关，一句话评价：满分神作]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[游戏往事]]></title>
    <url>%2F2019%2F03%2F18%2FG-%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[之前就说过这个博客不会纯记录自己的学习心得，而是会适当地聊聊自己的一些感想，其中当然也包括游戏。游戏被称为“第九艺术”，艺术自然不止是带给人娱乐感。&gt;&gt;2012年：《刺客信条II》译：当我年少轻狂时，我曾拥有自由，但我并不明白它的意义。我曾拥有时间，但我没有意识到它的珍贵。我曾拥有爱，但我从未用心去体会。数十年的时间考验后，我终于理解了三者的真谛。现在，我已风烛残年，这种理解已经逐渐变成一种满足。爱，自由和时间，曾一度被我挥霍，而今成为了我前进的动力。而我将最特别的爱，献给最亲爱的你和我们的孩子们，以及刺客联盟的兄弟姐妹们，并献给赋予我们生命的那壮美奇妙，让人产生无限遐想的世界。此爱永恒，Mia Sofia&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ——艾吉奥·奥迪托雷最早接触的游戏之一，有七年之久了。年代久远，写不下太多感慨性的文字，但是—-游戏里的场景还是记忆犹新：耶路撒冷、佛罗伦萨、罗马、君士坦丁堡……更重要的是Ezio这个人物给我留下了深刻的印象。我现在还觉得，能够在游戏中体验一个角色完整的一生是实属难得的事情。&gt;&gt;2013年：《刺客信条IV》荡气回肠的加勒比海之旅以如此平静的方式结束。爱德华在最后摘下一朵红花送给女儿，这一幕在今天看来仍然美妙而浪漫，它带给我的视觉冲击力难以言说。“如果没有黄金，我们早就是英雄了”黑胡子的这句话也许是对那个航海时代最好的概括。爱德华最后得到了黄金、跻身上流贵族之列，然而代价之深重恐怕只有他自己清楚。大概人总会有一种错觉，以为离去的人其实还活着。在安妮最后弹唱这首《The parting glass》的时候，爱德华恍惚之间仿佛看到昔日的朋友们正在与自己举杯共饮，片刻后才回过神，他们早就不在了。“晚安，愿快乐与你们相伴”Of all the money that ere I had, I’ve spent it in good company,过去我所有的积蓄，我都已和伙伴们一同分享And of all the harm that ere I’ve done, alas was done to none but me.而我做过的所有伤人之事，唉，受伤的只是我自己And all I’ve done for want of wit, to memory now I cannot recall.我为寻求智慧所做的一切，已成了不可追的回忆So fill me the parting glass, goodnight and joy be with you all.就为我添满这杯离别酒吧，晚安，愿快乐与你们常伴Of all the comrades that ere I had, they’re sorry for my going away,我所有的战友们，都不舍我即将离去And of all the sweethearts that ere I’ve had , they wish me one more day to stay,而我所有的情人们，都希望我多留一日But since it falls unto my lot that I should rise and you should not,但因为我深感起身之时已至 诸君安坐I’ll gently rise and I’ll softly call, Goodnight and joy be with you all.我会轻轻站起并柔声祝道，晚安，愿快乐与你们常伴A man may drink and not be drunk,一位男子大可畅饮但不该喝醉A man may fight and may not be slain一位男子大可战斗但不该嗜杀A man may court a pretty girl一位男子大可追求可爱的女孩and perhaps be welcome back again.而且或许还能欣然再相见But since it has so ordered been by a time to rise可是人生注定如此 有时起And a time to fall又有时落Come fill to me the Parting glass, goodnight and joy be withyou all.为我添满这杯离别酒，晚安，愿快乐与你们常伴Come fill to me the Parting glass, goodnight and joy be with you all.为我添满这杯离别酒，晚安，愿快乐与你们常伴&gt;&gt;2019年：《巫师III》玩下来的一个感觉就是：满分佳作——-我是一个对游戏很挑剔的人，即使是玩了有5年之久的游戏，我也不会对其缺点避而不谈。但巫师这款游戏意外地推翻了我之前对于RPG游戏的固有认知，让我明白了这个世界上真的有一款RPG游戏近乎完美，从任何方面来看都无可挑剔。比起传统的美式RPG游戏，在游玩过程中深有体会的一点就是：波兰人真的很会讲故事。他们为玩家呈现的不是大量中世纪传说的意象（比如烂大街的骑士和恶龙），而是真真正正底蕴丰厚的故事。或者愤慨，或者无奈，或者悲恸，玩家的情感爆发点仿佛尽在这群鬼才开发者的掌握之中，只等剧情走向的推动去点燃那小小的火苗。用一个老外很喜欢的词来形容再适合不过了—immersive，入味，而且是余韵不绝的那种。游戏里的大部分对话选项都会影响剧情的走向和人物的最终结局，这是我非常喜欢的一点。我个人觉得，开放世界游戏的所谓“开放”，绝不仅仅局限于地图的规模和场景的互动性，更体现在剧情的丰富化。丰富多样的剧情比起单一的剧情，最大的优势就在于大幅度提高了游戏的可探索性，玩家不得不去考虑：如果我做另外一个选择，结果会是怎么样？不同的选择带来不同的后果，这种极具冒险性的尝试恰好像极了我们的现实生活。人们向来喜欢拿《巫师》和《上古卷轴5：天际》进行对比，虽然在情感上我更偏向于后者（因为它对我而言不只是一款游戏），但不得不承认的是，《巫师》的战斗系统尤其值得后者借鉴：针对不同的敌人需要采用不同的打法、角色的技能提高需要玩家做出适当的取舍以找出效果最好的组合方案、魔法和药水需要紧密结合，你几乎不可能靠着单一的技能或者装备撑过整场战斗……总的来说系统设计非常流畅和舒服，而且值得玩家花时间去钻研，这在一定程度上也提高了可玩度。]]></content>
      <categories>
        <category>Gaming</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型式继承和类式继承]]></title>
    <url>%2F2019%2F03%2F17%2FF-%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF%E5%92%8C%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[Java和JavaScript都是面向对象的语言，但二者的继承方式截然不同。前者采用类式继承（classical inheritence），也是大多数面向对象语言的继承方式。而后者采用原型式继承（prototype ineritence），因此称JavaScript为基于对象更加合适。1.JavaScript的继承就JavaScript的继承来说，又可以分为es5的继承和es6的继承。参考阮一峰老师在《ES6标准入门》一书中所说的：在ES6之前，class是保留字，ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。虽然在es6中引入了类的概念，但它其实只是简化了原来需要我们自己编写的原型链代码的语法糖，从而让js更趋向于传统的面向对象语言而已。要理解这个过程，首先要明白es6中的class做了什么。1.1 class到底做了什么：首先看看class是什么东西class Person{ ...... } typeof Person // function 这里的class与java中的class不同，它并不是一个全新的数据类型，而是相当于原型继承中的构造函数。接着看看es5和es6在实现继承上的区别：es5：function Person(name){ //父类 this.name = name; } Person.prototype.showName = function(){ return this.name; }; function SubPerson(name,job){ // 子类 Person.call(this,name); // 子类继承父类的属性 需要将this指向父类中的name this.job = job; // job是子类的新增属性 } SubPerson.prototype = new Person(); // 让子类继承父类的方法 var p1 = new SubPerson('zcl'); //实例化子类对象 console.log(p1.name); // zcl（父类属性） console.log(p1.showName()); // zcl（父类方法） es6：class Person{ // 父类 constructor(name){ this.name = name; } showName(){ return this.name; } } class SubPerson extends Person{ //子类 constructor(name,job){ super(name); // 用super来调用父类的构造函数 this.job = job; // job是子类的新增属性 } showJob(){ return this.job; } } var p1 = new SubPerson('zcl','前端开发'); //实例化子类对象 console.log(p1.name); // zcl（父类属性） console.log(p1.showName()); // zcl（父类方法） console.log(p1.job); // 前端开发（子类属性） 可以看到，es6中采用class后，大大简化了组合继承的步骤。class做了什么：1.定义父类时class Person{ constructor{ /*constructor*/ } method{ /*method*/ } } // 等价于 function Person{ /*constructor*/ } Person.prototype.method{ /*method*/ } 2.子类继承父类时：class SubPerson extends Person{ onstructor{ super(...) /*constructor*/ //子类新增属性 } method{ /*method*/ } //子类新增方法 } var subperson1 = new SubPerson() // 等价于 function SubPerson{ Person.call(....) /*constructor*/ //子类新增属性 } SubPerson.prototype = new Person() SubPerson.prototype.method=function{ /*method*/ //子类新增方法 } var subperson1 = new SubPerson() 对于es6继承而言，访问实例化的子类对象的属性或者方法时，依然是沿着原型链进行追溯，并且子类实例创建后，class SubPerson中的this依然会指向该子类，可以看出，这与es5的原型继承的一模一样的。1.2 关于this：es5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.call(this)）；es6的继承机制完全不同，实质是先通过调用super方法（super指向父类的构造函数）创造父类的实例对象this，然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加。2.Java的继承首先了解java中创建对象的方式。java中，类一般包含field(变量)，constructor(构造方法)，method(其他方法)。class Person{ // 创建父类 private String name; // field public String getName(){ // method return this.name; }; public Person(String name){ // constructor this.name = name; }; } 接着实现继承class SubPerson extends Person{ // 创建子类 private int age; // field public String getAge(){ // method return this.age; }; public SubPerson(String name,int age){ // constructor super(name); // 通过super调用父类构造方法 this.age = age; }; public String getName(){ //重写父类方法，发生覆盖 return "I am not "+super.getName()+" but I am "+this.name; } } 创建测试类Public class Testclass{ public static void main(String[] args){ Person person1 = new Person("father") //通过new一个构造方法创建父类实例 SubPerson subperson1 = new SubPerson("son") // 创建子类实例 System.out.println(subperson1.getName()); //->I am not father but I am son. } } 3.JavaScript的原型式继承与Java的类式继承由上面分析可见，es6中的类式继承其实还是原型式继承。那么它与java中真正的类式继承相比，有什么区别呢？类式继承的方法都会存在父对象之中，每一次实例，都会将funciton保存在内存中，这会带来性能上的问题。类式继承是不可变的。在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法；相反，原型继承是可以通过改变原型链进而对子类进行修改的。类式继承可以实现多重继承（Java是通过接口来实现）；原型式继承一般来说是不支持多继承的（因为原型链），但可以通过Mixin变相实现多继承。4.补充：子类如何调用父类被覆盖的同名方法首先这是一个比较奇怪的需求，因为既然子类重写了父类方法，就说明父类方法无法实现我们的要求，反过来，假设父类方法可以实现要求，则没必要重写该方法。但是让我们设想一下，假定现在一定要通过子类调用父类被覆盖的那个方法，应该怎么做呢？通过上面的例子可以看到，在java中，我们只能在子类的构造方法中通过super关键字调用父类方法，而无法直接用子类的实例调用那个方法，像“子类实例.super.父类方法”，这是无效的；但是在js中，我们是可以做到的。基本思路就是：将父类实例以属性的方式进行保存，且该属性是子类构造函数的原型对象的属性。这其实和原型链有关。我们设想有父类A、子类B以及同名方法say，并且设定子类B的原型对象的superClass属性指向父类实例b。那么，子类实例a直接调用say方法，必然是调用重写之后的方法；当它想要调用被覆盖的方法时，我们只需要用a.superClass.say()即可—–对于实例a，我们知道它本身并不具备superClass属性，因此它将沿着自己的原型对象也即子类B的原型对象进行查找，刚好B的原型对象有一个指向b的superClass属性，所以我们拿来用，而b有被覆盖的say方法，所以这里顺利完成了被覆盖方法的调用。附上CSDN的参考链接]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[经典面试题解析]]></title>
    <url>%2F2019%2F03%2F17%2FF-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本篇博客专门用于收集各类经典面试题，并给出相关的解题思路和原理。1.考点：块级作用域和闭包先看一道很经典的面试题var a=[]; for(var i=0;i&lt;10;i++){ a[i] = function(){ console.log(i); } } console.log(a[6]); 如果你认为输出的是6，那么恭喜你答错了。正确答案是10。首先分析一下这段代码的具体执行过程。var a=[]; var i=0; /* 用var声明的变量要么在函数作用域中，要么在全局作用域中，很明显这里是在全局作用域中， 因此认为i是全局变量，直接放在全局变量中。*/ a[0]=function(){ console.log(i); /* 关键！！这里之所以i为i而不是0；是因为我们只是定义了该函数，并未调用它，所以没有进入 该函数执行环境，i当然不会沿着作用域链向上搜索找到自由变量i的值。*/ } // 由于不具备块级作用域，所以该函数暴露在全局作用域中。 var i=1; //第二次循环，这时var i=1;覆盖了前面的var i=0；即现在全局变量i为1; a[1]=function(){ console.log(i); //解释同a[0]函数。 } var i=2; // 第三次循环，这时var i=2;覆盖了前面的var i=1；即现在全局变量i为2; a[2]=function(){ console.log(i); } ......第四次循环 此时i=3 这个以及下面的i不断的覆盖前面的i，因为都在全局作用域中 ......第五次循环 此时i=4 ......第六次循环 此时i=5 ......第七次循环 此时i=6 ......第八次循环 此时i=7 ......第九次循环 此时i=8 var i=9; a[9]=function(){ console.log(i); } var i=10;// 这时i为10，因为不满足循环条件，所以停止循环。 紧接着在全局环境中继续向下执行。 a[6](); /* 这时调用a[6]函数，所以随即进入a[6]函数的执行上下文环境中，即 function(){console.log(i)}中，此时执行函数中的代码console.log(i)， 因为在当前的函数执行上下文中不存在变量i，所以i为自由变量，此时会 沿着作用域链向上寻找，进而进入了全局作用域中寻找变量i,而全局作用域 中的i在循环跑完后已经变成了10，所以a[6]的值就是10了。*/ 那么，如果我们想要输出6，应该怎么修改代码呢？两种方法。1.使用let形成块级作用域，配合闭包使用var a=[]; { //进入第一次循环 let i=0; /*注意：因为使用let使得for循环为块级作用域，此次let i=0 在这个块级作用域中，而不是在全局作用域中。*/ a[0]=function(){ console.log(i); }; /* 注意：由于是用let声明的i,所以使整个块成为块级作用域，又由于a[0]这个函数 引用到了上一级作用域中的自由变量，所以a[0]就成了一个闭包。*/ } /*声明:这里用｛｝表达并不符合语法，只是希望通过它来说明let存在时，这个for循环块 是块级作用域，而不是全局作用域。*/ 讲道理，上面这是一个块级作用域，就像函数作用域一样，执行完毕，其中的变量会被销毁， 但是因为这个块级作用域中存在一个闭包，且该闭包维持着对自由变量i的引用，所以在闭包 被调用之前也就是后续为了测试而console.log出a[..]之前，此次循环的自由变量i即0不会 被销毁. { //进入第二次循环 let i=1; /*注意：进入第二次循环即进入第二个代码块，此时处于激活状态的是let i=1。 它位于与let i=0不同的块级作用域中，所以两者不会相互影响。*/ a[1]=function(){ console.log(i); }; //同样，这个a[i]也是一个闭包 } ......进入第三次循环，此时其中let i=2; ......进入第四次循环，此时其中let i=3; ......进入第五次循环，此时其中let i=4; ......进入第六次循环，此时其中let i=5; ......进入第七次循环，此时其中let i=6; ......进入第八次循环，此时其中let i=7; ......进入第九次循环，此时其中let i=8; {//进入第十次循环 let i=9; a[i]=function(){ console.log(i); };//同样，这个a[i]也是一个闭包 } { let i=10; /*不符合条件，不再向下执行，导致此次的块级作用域中不存在闭包，导致let i=10 未像前面的i一样等待被闭包引用，故此次的i没有必要继续存在，随即被销毁。*/ } a[6](); /*调用a[6]()函数，这时执行环境随即进入下面这个代码块中的执行环境： funcion(){console.log(i)};*/ 即进入： { let i=6; a[6]=function(){ console.log(i); }; //同样，这个a[i]也是一个闭包 } a[6]函数（闭包）这个执行环境中，它会首先寻找该执行环境中是否存在 i，没有找到， 就沿着作用域链继续向上到了函数所在的块级作用域，找到了自由变量i=6,于是输出了6， 即a[6]()的结果为6。闭包既已被调用，所以整个代码块中的变量i和函数a[6]()被销毁。 2.利用自执行函数说来惭愧，本来如果明白这道题的原理，应该自然想到可以利用自执行函数达到相同的目的，但是最后还是在群里朋友的点拨下才明白的。实际很简单，前面我们说过一句很关键的话：这里之所以i为i而不是0；是因为我们只是定义了该函数，并未调用它，所以没有进入该函数执行环境，i当然不会沿着作用域链向上搜索找到自由变量i的值那么反过来想一想，假如我们在定义了函数之后即刻对其进行了调用，是否此时将会在环境中寻找i的值并马上替换掉console.log(i)中的i呢？是的。至于怎么即刻对其调用，我们用自执行函数就可以，代码如下：var a=[]; for(var i=0;i&lt;10;i++){ a[i] = (function(){ console.log(i); })() } console.log(a[6]); 拿第一次循环举例，此时，a[0]函数的内容已经确定了，不再是随着循环的进行而动态变化了。2.考点：连等、解析和引用类型这是某大厂一道知名的面试题，表面简单但是坑很多。var a = {n:1}; var b = a; a.x = a ={n:2}; console.log(a.x); // undefined console.log(b.x); // {n:2} 我们来分析一下这段代码到底是怎么执行的，就会明白为什么结果与我们预想的完全不同，甚至可以说很怪异。var a = {n:1}; var b = a; 首先，这两句令a和b同时引用了{n:2}对象，接着的a.x = a = {n：2}是关键。尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a重定向，指向了新对象{n：2},而b依然指向的是旧对象，这点是不变的。接着的关键来了：执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。后面输出a.x的时候，又要解析a了，此时的a当然是重定向后的指向新对象的a，而这个新对象是没有x属性的，故得到undefined；而输出b.x的时候，将输出旧对象的x属性的值，即{n:2}。3.考点：异步、作用域、闭包如果无法深入到内部，从原理层面上理解代码的运行机制，那么知识只是浮在表面、浅尝辄止。“同步优先，异步靠边，回调垫底”的口诀可以帮助我们迅速判断，但是我希望用自己刚学习的事件循环机制来解释这道题。实际上这也是比较普遍的一道面试题：for (var i = 0; i &lt; 3; i++) { setTimeout(function() { console.log(i); }, 0); console.log(i); } 代码最后输出什么？ 如果不熟悉异步，很可能直截了当地回答是：0 0 1 1 2 2 。正确答案应该是 0 1 2 3 3 3根据事件循环的机制，跑循环和输出i的值都是主线程上的同步任务，既然是同步任务，当然是按照顺序执行，所以0 1 2是容易理解的。那么setTimeout怎么办呢？setTimeout是异步任务，并不在主线程上，而是在宏任务队列里，它必须等待主线程的执行栈清空，才有自己的“一席之地”，才能去执行，所以这里我们直接忽略setTimeout，将前三次循环的setTimeout都挂在任务队列里。之后，循环跑完了，主线程的同步任务结束。此时i变成了3。轮到任务队列了——&gt; 我们回过头调用setTimeout里的回调函数，进行i的输出。当然，由于i只有一个，即全局变量，所以此时输出的都是3，三次setTimeout即三次3。如果我们要输出 0 1 2 0 1 2 呢？其实这里就和第一个考点很像了。这里有两种方法，一是将var改为let，从而形成多个独立的块级作用域，这样，每个setTimeout里的回调函数的i都将对应每一次循环的i（因为是块级作用域）。接着，由于输出和循环依然是同步任务，所以输出 0 1 2；之后轮到任务队列，也是输出0 1 2。二是利用自执行函数，令函数在定义之后就即刻执行，那么函数中的i将会指向当前循环的i，这个i的值为多少在那时就已经确定了，而不再是随着跑循环而动态变化。这里又有两种自执行的方法：for (var i = 0; i &lt; 3; i++) { setTimeout((function(i) { return function() { console.log(i); }; })(i), 0); console.log(i); } 或者for (var i = 0; i &lt; 3; i++){ (function (i) { setTimeout(function () { console.log(i); }, 0) })(i); console.log(i); } 一个是将回调函数作为自执行函数，一个是将setTimeout函数作为自执行函数，效果是一样的。4.考点：作用域、NFE的函数名只读性let b = 10; (function b(){ b=20; console.log(b); })(); console.log(b); // 代码最后输出什么？ 如果没有认识到NFE函数的函数名只读性，这道题就会做错。正确答案应该是：f { b=20; console.log(b); } 10 要理解这道题，先来看另一段代码var c=function b(){ console.log("234"); console.log(b); } console.log(b) // b is no defined 首先，这是一个具名函数表达式，即NFE。而NFE的函数名只能在函数内部访问，所以我们将该函数的引用赋给变量c之后，就只能通过c()调用该函数，而不能通过b()调用，更不能访问b。并且还要注意，函数名在函数内部类似于一个const常量，只能访问而不能对它进行修改。理解这一点之后再来看最开始的代码，这是一段IIFE—–立即执行函数表达式（因为括号是操作符，所以认为括号里的是表达式而不是声明），它同样也是具名函数表达式，自然也有上面的性质。函数自调用，遇到b=20语句时开始在函数作用域中查找b是在哪里声明的，结果发现就是函数b，然后试图对函数名进行修改，因为这种修改相当于是修改一个常量，所以是无效的（非严格模式下静默失败，严格模式下抛出Type错误）。忽略了这段语句后，等于是只输出b，也就是输出函数本身。之后，我们在全局下输出b，根据上面的说法，我们无法在NFE函数外部访问NFE的函数名，所以这里的b代表的不是函数，而是用let声明的那个变量b。let b = 10; (function b(){ var b=20; console.log(b); })(); // 20 当然，如果在函数内部用var或者let重新声明一个同名变量b并赋值，则是允许的，此时的b变量与函数b没有任何关系，仅仅是同名而已。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何在Stack Overflow规范提问]]></title>
    <url>%2F2019%2F03%2F17%2FT-Stack%20Overflow%E6%8F%90%E9%97%AE%E6%8C%87%E5%8D%97%E5%92%8C%E5%BF%85%E5%A4%87%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言：最近学习js的时候看到了一段代码，思考再三之后仍然不是很理解，于是决定到尽可能多的平台进行提问，目的有二：1.最主要的，解决问题；2.借这个机会测试哪些平台可以在短时间内给予提问者反馈和援助，从而作为下次提问的首选之地。最后问题是解决了，但是关于提问这件事再次有了不一样的感想。首先从我自身出发—-在中文环境下我能够做到比较规范的提问（我认为的规范），即表诉清晰必要的答谢但是在英文环境下就显得吃力得多，暴露的缺点如下：表达不够地道清晰，误导了回答者，导致问题被认为是duplicate而被关闭编辑问题后未进行必要的核查，导致了后期的修改无法完全理解对方想要表达的意思其次从平台出发进行分析，不得不说国内的平台反馈速度和热情的确比不上国外的。知乎因为有邀请机制，所以问题还是有机会得到高手的点拨；SegmentFault本身定位就是中国的Stack Overflow，所以得到专业回答的可能性也比较大。但是类似贴吧和QQ群这些交流平台，得到有效回答的机率却实在太低。本来QQ群是实时互动的，反馈更应该迅速点，但是很多时候问题会被忽略。是什么原因我就不说了，不好直接下定论，但这无疑提示了我：如果急着解决问题，就应该避免在这些地方浪费时间—-一来速度没保障，二来质量参差不齐。理想的提问平台应该是SegmentFault或者Stack Overflow。关于如何在Stack Overflow规范提问，这里转载一篇不错的博客：规范提问指南可以问什么样的主题大家都知道 Stack Overflow是编程类的问答社区， 但还真有人把它当成通用的问答社区了， 问些完全无关的问题。 其实， Stack Overflow 是有一系列兄弟网站的（目前已经有100+)， 统称 Stack Exchange， 涵盖很多主题， 比如数学、物理、化学等科学类， 服务器管理、Latex、数据库等计算机类， 中文、俄文、日文等语言类， 详细的列表看这里， 不要让好问题问错地方哦。允许的主题包括： 具体的编程问题、软件算法相关、通常只有程序员用的软件工具相关等。有些主题是比较容易弄错的， 比如一般的电脑操作问题， 应该去Super User(热门的 Linux/Unix, 和Ubuntu还有独立的站点）， 专业的服务器问题， 应该去Server Fault。这些都不属于编程类的问题， 尽管不少程序员的日常工作也有涉及（想一想“怎么修电脑？”属于编程问题么）。 再举个例子， 同样是编辑器， Vim/Emacs/Atom相关的问题是可以的，因为基本只有程序员会用这些工具， 而 Word/记事本相关的一般就不可以。什么样的问题应该避免问编程相关还不够， Stack Overflow 要求问题必须是 「practical, answerable questions based on actual problems that you face」。这是什么意思呢？ 首先， 开放式的问题是不允许的，比如“你为什么喜欢PHP?”， 隔壁Quora会是更合适的对象。 其次， 问题应该不需要很长的篇幅来回答， 如果一个问题期待的回答足够写一本书， 那很可能会被关闭的。 各种寻求资源的问题应该避免，如 “要完成某某工作， 有什么Python的库可以用”， 或者“学习C++应该选择哪本书？”等， 因为答案会主观， 也容易吸引广告。 最后， 问题不要基于凭空的假设，要基于实际的难题。需要注意的是，你很可能见过一些违反上面规定的问题还在，而且浏览量很大， 尤其是一些寻求资源的问题， 和非编程相关的计算机问题等。 这是什么原因呢？ 原来，早期的Stack Overflow的规则还比较松，也没有Super User之类的站点。 这些问题往往是08/09年问的，大多数现在已经被关闭了。上面的规则如果遵守， 你的问题应该问对地方了。 下面继续说说内容上具体需要注意的。直入主题Stack Overflow不是论坛， 它的目标是希望成为编程类问答的一个超级数据库， 所以每个问题都不止是为了帮助提问者本人， 更重要的是希望将来能够帮助到每一个遇到同样问题的人。所以， 和问题无关的内容都被认为是一种噪音， 包括： 打招呼（比如 Hi, Hello， Good afternoon， Dear Coders等)， 表示感谢（比如 Thanks, Any help would be appreciated等)， 没必要的背景（比如 I’m a newbie in C#等)， 你的签名 等。可能有人会不理解为什么这样规定， 尤其是不要表示感谢这点。 Stack Overflow社区的理由是， 对愿意阅读并尝试解答你问题的人来说， 最好的表达感谢的方式是upvote有帮助的回答， 以及选择其中一个作为答案。 每一句和问题无关的内容都增加了额外的阅读时间， 而一个问题可能会被大量的人阅读。 更多的相关讨论可以参见这里和这里。同样道理， 当有人回答你的问题之后， 也不要去添加无用的评论， 比如单纯的表达感谢的话， “+1”， 或者闲聊等。 评论的唯一用处是用来澄清疑问。英语作为一个英语社区， 不论提问、回答还是在评论中和别人互动， 都是要用英语的。除非英语水平真的很糟糕， 语法其实并不是最需要担心的，因为并不需要做到完美。Stack Overflow是允许自由的编辑其他人的问题/回答的（编辑者如果rep不到2K，需要经过评审才会生效）。 有很多人会热情的对问题进行编辑的， 包括修复可能的语法错误。 我想说的一点是， 要尽可能的保证单词拼写是正确的。 即使对英语不够好的人来说， 这也只需要多花一点时间检查就可以做到， 但它代表着对阅读你问题的人的尊重。 甚至很多英语母语的人在拼写上也不注意， 会把I’m 写成im, 把 want to写成 wanna之类的非正式英语， 这些都会降低问题被回答的概率。内容在发问题之前， 问自己几个问题：你做过足够的研究么？ 有的人连入门指南都没读上10分钟就去提问， 问的问题能有多少价值呢？你尝试过搜索么？ 至少要试过Google和站内搜索， 很可能相同的问题已经有答案了你试过debug么？ 把你的想法或调试过程写在问题里，否则很可能会看到几条评论“Have you tried anything?”或“We don’t do your homework”之后问题就被downvote得惨不忍睹了。 因为大多数人是拒绝回答没有努力尝试的提问者的。标签： 一个问题可以加1~5个标签， 大多数问题是和某种具体的编程语言相关的， 这个语言的标签通常是必须的， 否则相关语言的关注者们很可能根本见不到问题。起一个好标题： 一般来说， 标题应该尽量用简介的语言描述具体的问题。 比如 C# number confusion就是个反例， 如果改成 Why does using float instead of int give me different results when all of my inputs are integers? 就要具体多了。提供代码对于编程类问题，的确有问题不需要代码也能表达清楚的， 但大多数问题都需要代码才能清晰的表达。“我声明了一个变量， 调用了几个函数， 然后它的值就变了， 为什么呢？” 这样的问题， 鬼才知道答案。提供代码要注意： 不要贴截图， 难道你要回答者去照着截图敲键盘复现你的问题？ 也不要只贴站外的链接， 如果站外链接能够提供一些额外的方便功能， 也要在贴代码的基础上附上该链接。对于提供什么样的代码， Stack Overflow给出了一个可参考的标准： MCVE， 即Minimal, Complete, and Verifiable exampleMinimal: 最小的， 也就是尽可能的去掉和问题无关的部分。 如果你贴了一个几百行的代码， 很少有人愿意花时间去仔细看。 构造最小化例子的过程本身也是debug的过程。Complete: 完整的， 一个简单的判断是：别人看到问题， 可以通过复制你提供的代码复现出问题吗？Verifiable: 可验证， 描述问题尽可能具体， “the code doesn’t work”这样的描述就很不好。 如果编译不过， 要加上编译错误信息； 如果运行报错， 也同样要加上具体的错误信息； 如果结果和你的预期不一致， 要说清楚你的预期结果是什么， 为什么会这样想。格式Stack Overflow的编辑器是Markdown格式的， 如果你还不熟悉， 建议去学一下， 因为Markdown真的是一个只要10分钟就可以学会的语言。大多数的格式问题都是出在贴代码的地方， 如果你发现你的代码是普通文本， 而没有语法高亮等功能， 那你很可能是格式搞错了。 最方便的方法就是选择所有代码， 然后按键盘Ctrl + K 即可。交流有可能你的问题几分钟内就会有人回答， 也有可能有人对问题有疑问， 在评论中要求你解释。 可以评论@他们解释， 如果问题确实不够清晰， 编辑你的问题吧。 最后， 如果你自己发现了解答方法， 而还没人给出， 那就自己回答自己的问题吧。 自问自答是被鼓励的行为。术语词汇另外，我认为规范提问建立在规范词汇的基础上，诚如上面所说的，这是一种对回答者应有的尊重。如何积累规范的词汇？我的计划是每周阅读1到2篇MDN上的文档，首先阅读英文并做出自己的理解，之后借助本地化团队的译文加深/修正自己的理解，这个过程既锻炼了阅读技术文档的能力，也可以顺带积累术语词汇，值得尝试。2019.5.3 更：近期找到了一个更好的平台（掘金翻译计划），它拥有完善的流程把控和工作分配，这其实正是我很久以前试图在汉化工作中寻找但是没有找到的东西。其实这是一件值得长期投资的事情：1.最主要的目的，锻炼阅读英文技术文档的能力，同时积累术语词汇；2.熟悉 github 的操作3.据说 200 积分可以换一台kindle（虽然听起来遥遥无期，但是可以作为动力哈哈哈）当然，这个工作不会很轻松，不过完事开头难是很正常的，希望我可以坚持下去吧。]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「译」如何用原生JS打造一款简易谷歌插件]]></title>
    <url>%2F2019%2F03%2F10%2FTrs-%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9Fjs%E6%89%93%E9%80%A0%E4%B8%80%E6%AC%BE%E7%AE%80%E6%98%93%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[原文地址：How to Build a Simple Chrome Extension in Vanilla JavaScript原文作者：Sara Wegman译者：Chor今天，我打算向你们展示如何用原生JS—-不依靠任何诸如React、Angular或者Vue框架的原生JS做一款谷歌插件。做一款谷歌插件并没有那么困难——在学习编程的第一年，我发布了两个插件，并且都是用HTML、CSS和原生JS做的。在这篇文章中，我会用几分钟的时间教你们怎么完成这件事。我将向你们展示如何从零开始打造一款简易的谷歌插件主控面板。如果你对插件有自己的想法、只是想知道应该向已有项目文件中添加什么，从而让其运行在谷歌浏览器中的话，你可以跳到自定义mainfest.json文件和图标的部分。关于谷歌插件从本质上来说，一款谷歌插件只是一些用来定制浏览体验的文件。有许多不同类型的插件，有些插件仅在某种特定条件下才会激活，比如当你在商店的结账页面的时候；有些插件仅在你点击图标后才会弹出；有些则在你每次打开新标签页的时候才会出现。我今年发布的两款插件都是“新标签页式”插件，第一款是Compliment Dash,一个可以显示to-do list并问候用户的主控面板；第二款是Liturgical.li,为牧师量身打造的工具。如果你知道如何建设一个基本的网站，那么你就可以很轻松地做出这种插件。前期准备我们打算一切从简，所以本教程只会使用HTML、CSS和基本的JS，以及下面会讲到的自定义mainfest.json文件。谷歌插件的复杂度各不相同，因此做一款插件可能很简单，也可能很难，这取决于你打算让它实现什么功能。在学习了本篇文章的基础知识后，你将可以活用技能做出更为复杂的东西。新建文件本教材中，我们将制作一款可以问候用户的简易主控面板，名字就叫Simple Greeting Dashboard好了。首先需要创建三个文件：index.html,main.css和main.js。将这些文件放在各自的文件夹中。接下来，在html文件中书写必要的声明，并引入css文件和js文件：&lt;!-- ================================= Simple Greeting Dashboard ================================= //--> &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset="utf-8" /> &lt;title>Simple Greeting Dashboard&lt;/title> &lt;link rel="stylesheet" type="text/css" media="screen" href="main.css" /> &lt;/head> &lt;body> &lt;!-- My code will go here --> &lt;script src="main.js">&lt;/script> &lt;/body> &lt;/html> 定制你的mainfest.json文件仅有这些文件还不能够让你的插件项目正常运行。我们还需要一个mainfest.json文件以定制插件的基本信息。可以在Google’s developer portal下载该文件，或者复制粘贴如下代码到一个新文件中，另存为manifest.json文件。{ "name": "Getting Started Example", "version": "1.0", "description": "Build an Extension!", "manifest_version": 2 } 现在，我们修改上面文件中关于插件信息的内容。只需改变代码中的前三个值：name,version和description。填入插件名称以及相关描述，由于这是第一个版本，所以version项就不需要改了。manifest_version也不需要改动。接着，添加代码行以告诉谷歌浏览器如何操作这个插件。{ "name": "Simple Greeting Dashboard", "version": "1.0", "description": "This Chrome extension greets the user each time they open a new tab", "manifest_version": 2 "incognito": "split", "chrome_url_overrides": { "newtab": "index.html" }, "permissions": [ "activeTab" ], "icons": { "128": "icon.png" } } 代码incognito&quot;: &quot;split告诉谷歌浏览器当它处于匿名模式的时候应该如何操作该插件。“split”将允许插件运行在自己的进程中。其他选项请查阅developer documentation正如你所看到的，”chrome_url_overrides”指定浏览器打开新标签页的时候打开index.html。将值设定为“permissions”后，将弹出窗口，提示用户安装该插件将会覆盖新标签页。最后，设定我们的图标：一个名为icon的png文件，尺寸为128x128像素。创建图标现在我们还没有Simple Greeting Dash的图标文件，所以来创建一个。你可以用下面我做的图标。如果你想自己做一个的话，用PS或者Canva都可以。切记图标尺寸为128x128像素，然后另存为名称icon的png文件，与HTML文件、CSS文件、JS文件和Json文件放在同一个文件夹里。上传你的文件（如果你正在编写自己的页面）要创建你的“新标签页式”谷歌插件，只需明悉以上全部信息即可。在你定制了mainfest.json文件后，你可以用HTML、CSS和JS设计任何自己想要的新标签页，之后按照下图所示将其上传。不过，如果你想知道我怎么创建这个简易面板的话，请跳至“创建一个设置菜单”部分。一旦你设计好了新标签页，你的谷歌插件就创建完成了，随时可以上传至谷歌浏览器。手动上传，请在浏览器的地址栏输入chrome://extensions/，进入页面后在右上角启用开发者模式。刷新页面，点击“加载已解压的拓展程序”。接着，选择存放HTML、CSS、JS、mainfest.json文件和icon.png的文件夹，上传。之后每次打开新标签页的时候该插件都会运行！在创建了自己的插件并且通过测试之后，你便可以申请一个开发者账号并将该应用发布到谷歌拓展程序商店。这篇教程将指导你如何发布你的插件。如果你现在不急着创建插件，只是想看看谷歌插件能够做什么的话，下面将教你如何创建一个非常简易的问候面板。创建一个设置菜单就这个插件来说，我首先要做的第一件事就是创建一个可供用户添加自己名字的输入框。因为我不打算让它一直显示，所以我将其放在一个名为settings的div下，该div只在用户点击settings按钮的时候才会显示。&lt;button id="settings-button">Settings&lt;/button> &lt;div class="settings" id="settings"> &lt;form class="name-form" id="name-form" action="#"> &lt;input class="name-input" type="text" id="name-input" placeholder="Type your name here..."> &lt;button type="submit" class="name-button">Add&lt;/button> &lt;/form> &lt;/div> 我们的页面设置看起来大概是这样的：…因此很有必要通过CSS给它们添加一些样式。我将给settings按钮和输入框添加内边距和轮廓，之后让settings按钮和输入框之间留有一点空隙。.settings { display: flex; flex-direction: row; align-content: center; } input { padding: 5px; font-size: 12px; width: 150px; height: 20px; } button { height: 30px; width: 70px; background: none; /* This removes the default background */ color: #313131; border: 1px solid #313131; border-radius: 50px; /* This gives our button rounded edges */ font-size: 12px; cursor: pointer; } form { padding-top: 20px; } 现在看起来好多了：不过，我们必须设置一下：用户未点击settings按钮的时候输入框不显示。我将通过给settings类添加下面的代码来完成这个设置，之后输入框将从屏幕上消失：transform: translateX(-100%); transition: transform 1s; 现在创建一个名为settings-open的类，在用户点击settings按钮的时候该类名将动态添加或去除。当添加settings-open类给已经有settings类的div时，div将不会隐藏，而是在正常位置显示。.settings-open.settings { transform: none; } 接着用JS实现类名的改变。定义一个名为openSettings的函数，它的功能是实现settings-open类名的添加或去除。具体做法是通过div的ID获取到该div元素，之后调用clssLIst.toggle方法添加settings-open类名。function openSettings() { document.getElementById("settings").classList.toggle("settings-open"); } 现在添加一个事件监听器，它将会在settings按钮被点击的时候调用函数document.getElementById("settings-button").addEventListener('click', openSettings) 在你点击settings按钮后，输入框将显示或隐藏。创建一个个性化的问候语接下来，我们来创建问候信息。首先在HTML中放入一个空的h2标签，之后用JS中的innerHTML方法来给它增加内容。为方便稍后获取h2元素，我们将给它一个ID，并将其放入一个名为greeting-container的div中。&lt;div class="greeting-container"> &lt;h2 class="greeting" id="greeting">&lt;/h2> &lt;/div> 现在，我将在JS中结合用户名创建一个基本的问候信息。首先声明一个空的变量用以稍后存放用户名。var userName; 如果就这样把useName变量放在HTML的问候语句中，即使为userName变量赋了值，谷歌浏览器也是不会使用相同的名字的。为了确保浏览器记住用户，我们必须进行本地存储的工作。因此，定义一个名为saveName的函数。function saveName() { localStorage.setItem('receivedName', userName); } 函数localStorage.setItem()接受两个参数：第一个是用于稍后获取信息的关键词，第二个是它需要记住的信息，也即是useName。我将通过localStorage.setItem获取储存的信息，并用该信息来更新useName变量的值。var userName = localStorage.getItem('receivedName'); 在将这条语句添加进表单的事件监听器之前，我想要让浏览器默认指定一个用户名，以应对我没有告诉它名字的情况。我将用if语句来完成这件事。if (userName == null) { userName = "friend"; } 现在，将userName变量与表单连接起来。我们将该操作写进函数里，这样每次名字更新的时候都可以调用该函数。我们给这个函数取名changeName。function changeName() { userName = document.getElementById("name-input").value; saveName(); } 我想要让该函数在用户每次用表单提交名字的时候都被调用。这里用事件监听器，它可以调用changeName函数并防止在表单提交的时候页面默认刷新。document.getElementById("name-form").addEventListener('submit', function(e) { e.preventDefault() changeName(); }); 最后，我们来创建问候语。我将把该语句也放进一个函数中，这样，在页面刷新或者changeName()调用后，我都可以调用该函数。function getGreeting() { document.getElementById("greeting").innerHTML = `Hello, ${userName}. Enjoy your day!`; } getGreeting() 最后，自定义你的页面现在是时候收尾了。我将用flexbox使标题居中，让它变得更大。同时在CSS中给body添加一个渐变背景。为了在渐变背景中突出按钮和h2，我会把它们设置成白色的。.greeting-container { display: flex; justify-content: center; align-content: center; } .greeting { font-family: sans-serif; font-size: 60px; color: #fff; } body { background-color: #c670ca; background-image: linear-gradient(45deg, #c670ca 0%, #25a5c8 52%, #20e275 90%); } html { height: 100%; } 就这样！你的页面大概会是下面这样子：虽然内容不多，但这是你创建和定义自己的谷歌插件的基础。如果有任何疑问，请告诉我，并随时在推特上@saralaughed 联系我。纯练手的第一篇译文。如果发现译文存在错误或其他需要改进的地方，欢迎在下面评论指出。]]></content>
      <categories>
        <category>Translation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[伪类和伪元素]]></title>
    <url>%2F2019%2F03%2F10%2FF-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[1.伪类和伪元素的引入CSS introduces the concepts of pseudo-elements and pseudo-classes to permit formatting based on information that lies outside the document tree.CSS 引入伪类和伪元素的概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。2.伪类和伪元素的概念2.1 伪类：伪类用于当已有元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。例如，当用户悬停在指定的元素时，我们可以通过 :hover 来描述这个元素的状态。虽然它和普通的 CSS 类相似，可以为已有的元素添加样式，但是它只有处于 DOM 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。2.2 伪元素伪元素用于创建一些不在文档树中的元素，并为其添加样式。例如，我们可以通过 :before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。3.伪类列举3.1 状态伪类状态伪类是基于元素当前状态进行选择的。在与用户的交互过程中元素的状态是动态变化的，因此该元素会根据其状态呈现不同的样式。当元素处于某状态时会呈现该样式，而进入另一状态后，该样式就会失去。状态伪类的顺序很重要，顺序错误可能会导致没有效果。通常的建议是LVFHA，即—–link，visited，focus，hover，active。选择器示例示例说明:linka:link选择所有未访问的链接:visiteda:visited选择所有访问过的链接:hovera:hover选择鼠标悬空的链接:activea:active选择正在活动的链接:focusinput:focus选择获得焦点的输入框3.2 结构化伪类结构化伪类是 CSS3 新增选择器，利用 DOM 树进行元素过滤，通过文档结构的互相关系来匹配元素，能够减少 class 和 id 属性的定义，使文档结构更简洁。选择器示例示例说明:first-childp:first-child选择符合的p元素，该p元素必须是其父元素的第一个子元素:first-of-typep:first-of-type选择符合的p元素，该p元素必须是其父元素的第一个p子元素:last-childp:last-child选择符合的p元素，该p元素必须是其父元素的最后一个子元素:last-of-typep:last-of-type选择符合的p元素，该p元素必须是其父元素的最后一个p子元素:not(selector):not(p)选择所有p以外的元素:nth-child(n)p:nth-child(2)选择符合的p元素，该p元素必须是其父元素的第2个子元素:nth-last-child(n)p:nth-last-child(2)选择符合的p元素，该p元素必须是其父元素的倒数第2个子元素:nth-last-of-type(n)p:nth-last-of-type(2)选择符合的p元素，该p元素必须是其父元素的倒数第2个p子元素:nth-of-type(n)p:nth-of-type(2)选择符合的p元素，该p元素必须是其父元素的第2个p子元素:only-of-typep:only-of-type选择符合的p元素，该p元素的父元素可以有多个子元素，但是类型为p的子元素只有一个:only-childp:only-child选择符合的p元素，该p元素的父元素只有一个子元素，就是该p元素:target#news:target选择当前活动#news元素(点击URL包含锚的名字)3.3 表单相关选择器示例示例说明:disabledinput:disabled选择所有禁用的表单元素:enabledinput:enabled选择没有设置disabled属性的表单元素:in-rangeinput:in-range选择在指定区域内的表单元素:out-of-rangeinput:out-of-range选择不在指定区域内的表单元素:validinput:valid选择条件验证正确的表单元素:invalidinput:invalid选择条件验证错误的表单元素:requiredinput:required选择设置required属性的表单元素:optionalinput:optional选择没有required属性，即设置 optional属性的表单元素:read-onlyinput:read-only选择设置只读属性的表单元素:read-writeinput:read-write选择处于编辑状态的元素；input，textarea 和设置 contenteditable 的 HTML 元素获取焦点时即处于编辑状态:checkedinput:checked匹配勾选的input元素，input元素包括 radio 和 checkbox:emptyp:empty匹配所有没有子元素的 p 元素:default匹配默认选中的元素(提交按钮总是表单的默认按钮):indeterminate当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。:scope匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。(试验阶段)3.4 语言相关选择器示例示例说明:lang(language)匹配设置了特定语言的元素设置特定语言可以是：HTML元素设置lang=” “属性，meta元素设置charset=” “属性，或者是在 http头部上设置语言属性。实际上，lang=” “ 属性不只可以在 html 标签上设置，也可以在其他的元素上设置。:dir匹配指定阅读方向的元素。当 HTML 元素中设置了 dir 属性时该伪类才能生效。现时支持的阅读方向有两种：ltr（从左往右）和 rtl（从右往左）。目前，只有火狐浏览器支持 :dir 伪类，并在火狐浏览器中使用时需要添加前缀( -moz-dir() )(试验阶段)。3.5 其他选择器示例示例说明:root匹配文档的根元素一般的 html 文件的根元素是 html 元素。:fullscreen匹配处于全屏模式下的元素全屏模式不是通过按 F11 来打开的全屏模式，而是通过 Javascript 的 Fullscreen API 来打开的，不同的浏览器有不同的 Fullscreen API。目前，:fullscreen 需要添加前缀才能使用。！！注意，伪类的名称不区分大小写。4 伪元素列举4.1 单双冒号选择器示例示例说明::before/:before在被选元素前插入内容需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。::after/:after在被选元素后插入内容用法同上::first-letter/:first-letter匹配元素中文本的首字母被修饰的字母不在首字母中::first-line/:first-line匹配元素中第一行的文本这个伪元素只能用在块元素中，不能用在内联元素中4.1 仅双冒号选择器示例示例说明::selection匹配被用户选中或者处于高亮状态的部分在FF浏览器使用时需要添加 -moz 前缀::placeholder匹配占位符的文本只有元素设置placeholder 属性时，该伪元素才能生效。该伪元素不是 CSS 的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（IE10 和 Firefox18 及其以下版本）会使用单冒号的形式::backdrop用于改变全屏模式下的背景颜色全屏模式的默认颜色为黑色。(试验阶段)5. :first-child和:first-of-type的区别:first-child选择器是css2中定义的选择器，从字面意思上来看也很好理解，就是第一个子元素。比如有段代码：p:first-child: 匹配到的是p元素,因为p元素是div的第一个子元素；h1:first-child: 匹配不到任何元素，因为在这里h1是div的第二个子元素，而不是第一个；span:first-child: 匹配不到任何元素，因为在这里两个span元素都不是div的第一个子元素；:first-child: 匹配到的是p元素,因为在这里div的第一个子元素就是p。然后，在css3中又定义了:first-of-type这个选择器，这个跟:first-child有什么区别呢？还是看那段代码：p:first-of-type: 匹配到的是p元素,因为p是div的所有为p的子元素中的第一个，事实上这里也只有一个为p的子元素；h1:first-of-type: 匹配到的是h1元素，因为h1是div的所有为h1的子元素中的第一个，事实上这里也只有一个为h1的子元素；span:first-of-type: 匹配到的是第三个子元素span。这里div有两个为span的子元素，匹配到的是第一个。:first-of-type: 匹配到的是p元素所以，通过以上两个例子可以得出结论：:first-child 匹配的是某父元素的第一个子元素，可以说是结构上的第一个子元素。:first-of-type 匹配的是该类型的第一个，类型是指什么呢，就是冒号前面匹配到的东西，比如 p:first-of-type，就是指所有p元素中的第一个。这里不再限制是第一个子元素了，只要是该类型元素的第一个就行了，当然这些元素的范围都是属于同一级的，也就是同辈的。同样类型的选择器 :last-child 和 :last-of-type、:nth-child(n) 和 :nth-of-type(n) 也可以这样去理解。]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM Core 与 HTML-DOM]]></title>
    <url>%2F2019%2F03%2F08%2FF-DOM%20Core%20%E5%92%8CHTML%20DOM%2F</url>
    <content type="text"><![CDATA[1.DOMDOM（文档对象模型）是由W3C制定的一套访问和操作XML（eXtensible Markup Language）文档的标准，即API。比如DOM告诉JavaScript引擎如何在浏览器窗口中显示和操作XML创建的标记（Tag）。DOM与特定的平台、浏览器、语言无关，很多种语言都实现了DOM，比如因为JavaScript和PHP都实现了DOM，所以 JavaScript中有getElementsByTagName()方法，PHP中也有 getElementsByTagName()，getElementsByTagName()方法是DOM规定的访问XML文档的接口。2.XML、XHTML、HTMLXML与HTML相似，但两者是有区别。XML和HTML都来自于SGML，它们都含有标记，有着相似的语法，HTML和XML的最大区别在 于：HTML是一个定型的标记语言，用固定的标记来描述和显示数据，比如&lt;h1&gt;表示首行标题，有固定的尺寸；而XML没有固定的标记，只能通过自定义的标记来描述数据的形式和结构，而不能显示。HTML是将数据 和显示混在一起，而XML则是将数据和显示分开来。那为什么能使用DOM访问和操作HTML文档（即网页）呢？Web语义化的一个发展方向是将HTML逐 渐演变为更有语义、能将数据内容与现实分离的XML，但HTML不可能立即演变为XML，目前推荐使用的是一个过渡产物——XHTML。HTML与 XHTML网页形成的节点树（统称为HTML节点树）在结构上与XML节点树一样，可以看做是一个符合DOM的XML文档，因此可以使用实现了DOM的程序语言（如JavaScript、PHP等）来访问和操作HTML文档，即访问和操作那些节点。3.DOM Core和HTML-DOM由于HTML与XML的相似性及差异，JavaScript不仅实现了标准的DOM方法和属性（即由W3C制定的），而且还实现了HTML特有的 DOM方法和属性，前者称为DOM Core，并不专属于JavaScript，后者称为HTML-DOM。不管是DOM Core还是HTML-DOM，我们在使用JavaScript的时候要注意浏览器之间的兼容性，因为不同的浏览器对这两类方法和属性的支持可能不一样。常见的DOM Core方法如下：1、创建节点createElement()createTextNode()2、复制节点cloneNode()3、插入节点appendChild()insertBefore()4、删除节点removeChild()5、替换节点replaceChild()6、查找和设置节点属性setAttribute()getAttribute()7、查找节点getElementById()getElementsByTagName()hasChildNode()常见的DOM Core属性如下：node.childNodesnode.firstChildnode.lastChildnode.nextSiblingnode.previousSiblingnode.parentNode]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JavaScript获取DOM节点的方法汇总]]></title>
    <url>%2F2019%2F03%2F08%2FF-HTML%20Collection%E5%92%8CNodelist%2F</url>
    <content type="text"><![CDATA[感觉有时候还是会忘记，而且都是原生操作DOM的时候常用的东西，老是查阅文档不太方便，因此在这里做个记录。1.获取DOM节点的方法1.1 通过顶层document节点获取：document.getElementById(&quot;ID&quot;)document.getElementsByName(&quot;Name&quot;)document.getElementsByClassName(&quot;className&quot;)document.getElementsByTagName(&quot;tagName&quot;) 注意，前两个都是document节点的专有方法，其他节点不能使用，尤其不能在ID下获取ID，这是非常愚蠢的做法。1.2 通过父节点获取：parentObj.firstChild：获取父节点下的第一个子节点（会将空格和换行计入），这个属性是可以递归使用的，即支持parentObj.firstChild.firstChild...的形式，如此就可以获得更深层次的节点。parentObj.firstElementChild：获取父节点下的第一个子元素节点parentObj.lastChild：获取父节点下的最后一个子节点（会将空格和换行计入）。与firstChild一样，它也可以递归使用。parentObj.lastElementChild：获取父节点下的最后一个子元素节点parentObj.childNodes：获取父节点下的所有直接子节点（会将空格和换行计入）parentObj.children：获取父节点下的直接子元素节点。parentObj.getElementsByTagName(&quot;tagName&quot;)parentObj.getElementsByClassName(&quot;className&quot;)1.3 通过子节点获取：childObj.parentNode : 获取子节点的直接父节点。w3c标准childObj.parentElement : 获取子节点的直接父节点。IE标准1.4 通过兄弟节点获取：neighbourObj.parentNode.children[..] :通过父节点间接获取已知节点的兄弟节点neighbourObj.previousSibling：获取已知节点的上一个兄弟节点（会将空格和换行计入）neighbourObj.previousElementSibling: 获取已知节点的上一个兄弟元素节点neighbourObj.nextSibling：获取已知节点的下一个兄弟节点（会将空格和换行计入）neighbourObj.nextElementSibling: 获取已知节点的下一个兄弟元素节点1.5 通过CSS选择器获取：采用CSS选择器的语法，即#abc，div.abc,#abc .abc等。document.querySelector(&quot;...&quot;): 返回匹配的第一个节点document.querySelectorAll(&quot;...&quot;): 返回匹配的所有节点2.HTMLCollection 和 NodeList我们都知道，当获得所有节点（如：getElementsByTagName）或者获得所有子元素（如：element.childNodes）时，实际上返回的是包含一些DOM节点的集合，这个集合要么是 HTMLCollection，要么是 NodeList，两者其实都是类数组的对象。2.1 HTMLCollection和NodeList的共同点：都是类数组对象，都有length属性;都有共同的方法：item，可以通过item(index)或者item(id)来访问返回结果中的元素;一般都是实时变动的（live），document上的更改会反映到相关对象上（！！注意：document.querySelectorAll返回的NodeList不是实时的）;2.2 HTMLCollection和NodeList的不同点：NodeList可以包含任何节点类型，HTMLCollection只包含元素节点（elementNode）。HTMLCollection比NodeList多一项方法：NamedItem，可以通过传递id或name属性来获取节点信息2.3 规定返回结果：node.childNodes 结果返回类型是 NodeList，即所有子节点；node.children 结果返回类型是 HTMLCollection ，即所有子元素节点；getElementsByXXX 结果返回类型是HTMLCollection旧版本浏览器(尤其是IE)中，node.children 结果返回类型是 NodeList]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解事件循环]]></title>
    <url>%2F2019%2F03%2F05%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[本篇博客讲的东西偏底层，较难理解。虽然有的地方不够精准和全面，但是我觉得对于理解js中的异步来说已经够了，所以没有再深究一些概念（比如浏览器在这个过程中充当的角色）。1.单线程所谓的单线程，可以简单理解为做事情讲究先来后到，要做后面的事情，你得等前面的事情做完—–不管它需要多久。既然如此，js引擎为何还要采取这种单线程的机制呢？js主要是与用户互动，这个过程涉及到对DOM节点的操作，如果js是多线程的，一个在节点上添加内容，一个要对这个dom节点进行删除，到底是以哪个为准？所以这就是为什么js从一出现就秉承着单线程的运行机制。另外还要注意：“为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质”2.同步任务和异步任务很显然，单线程会带来一个问题：就是代码执行的阻塞。比如：排在前面的任务如果耗时长，则后面的任务不得不一直等待它。 如果说耗时长是因为计算量大、cpu一直忙着计算的话倒也还好，可事实是——大部分时间浪费在了IO上（ajax从网络上获取数据），还有其他的如鼠标点击、setTimeout等等。因此这里提出了同步任务和异步任务的概念。在js中，可以将同步和异步简单理解为执行顺序的问题。2.1同步（sync）：即上面所说的后面等待前面。同步对应了同步任务（synchronous），即可以按照正常顺序执行的任务，比如加载页面骨架等。2.2异步（async）：即把耗时长的任务挂起，先执行耗时短的，再回过头执行耗时长的。异步对应了异步任务（asynchronous），即不适合按照正常顺序执行的任务，主要包括：onclick等事件绑定—&gt; 当事件触发时，回调函数会被添加到任务队列中；setTimeout / setInterval 等计时器—&gt; (时间延迟)当浏览器完成计时，回调函数会被添加到任务队列中；AJAX请求—&gt;当网络请求完成返回时，回调函数会被添加到任务队列中3.事件循环事件循环又叫event loop，需要注意的是，事件循环不是单线程的js引擎提供的机制，而是来自于js引擎的运行环境（多线程的浏览器或node.js）。事件循环是实现异步的一种机制。一个线程中只有一个事件循环，我们将这个循环的每一次循环执行过程称之为tick。 具体每一次循环是怎么执行的，后文会讲。4.执行栈和任务队列事件循环机制离不开执行栈和任务队列的相互配合。js中将同步任务放到主线程上执行，形成“执行栈”；异步任务则放到任务队列中。4.1 任务队列的分类标准之一：一个线程可以拥有多个任务队列。每一个任务队列都对应某一任务源，并包含了一堆来自该任务源的任务。任务源是什么？像setTimeout/Promise/DOM事件/AJAX等都是任务源，来自同类任务源的任务我们称它们是同源的，比如setTimeout与setInterval就是同源的。4.2 任务队列的分类标准之二：在ES6中，我们用另一种方式对任务队列进行分类。宏任务: 即macro-task，包括整体代码script，setTimeout，setInterval、AJAX、用户I\O 等。宏任务会对应地进入宏任务队列中；微任务: 即micro-task,包括Promise，process.nextTick(callback)(可以理解为node.js版的setTimeOut)。微任务会对应地进入微任务队列中。5.事件循环的具体实现过程？总的来说，事件循环的顺序，决定了js代码执行的顺序。首先进入&lt;script&gt;包裹的整体代码(这是第一个宏任务)，标志着第一次循环开始。在整体代码的执行过程中，同步任务照旧执行，异步任务分发到对应的任务队列中；整体代码执行完，执行栈清空，开始读取任务队列；读取所有微观任务队列 -&gt; 执行 -&gt;第一次循环结束，开始第二次循环读取一个宏观任务队列 -&gt; 执行 -&gt;读取所有微观任务队列 -&gt; 执行 -&gt;第二次循环结束，开始第三次循环读取一个宏观任务队列……………..………………队列清空，执行栈清空，事件循环正式结束。PS：读取任务时，会执行这些任务指定的回调函数,并且要注意：若回调函数中又有宏任务，则该宏任务会被安排到下一轮循环中。6.事件循环的例子下面通过三个由易到难的例子来理解上面所说的过程。例1setTimeout(() => { task() },3000) sleep(10000000) 分析：跑一下代码，会发现控制台执行task()需要的时间远远超过3秒，这就说明我们有的人理解的”setTimeout的第二个参数指定了多长时间后执行回调函数”的说法是错误的。让我们来分析一下这个过程：&lt;script&gt;中的整段代码作为第一个宏任务，进入主线程。即开启第一次事件循环；首先遇到了setTimeout，将其回调函数task()进入Event Table并注册,同时浏览器开始计时；继续，遇到了sleep函数，这是同步任务，所以直接执行。但是速度很慢，非常慢，而浏览器计时仍在继续；好了，3秒终于到了，计时事件setTimeout总算完成，可以把task()放入任务队列了;但是主线程上的sleep太慢了，还没执行完，于是我们只好等着；sleep终于执行完了，执行栈清空,第一次循环的宏任务结束；读取微任务队列….不对，没有任何任务被分发到这个队列，于是第一次循环只好这样结束了；第二次循环开始，读取宏任务队列，刚好，里面有一个setTimeout对应的task()回调函数，压栈、令其进入主线程执行；执行栈清空了，任务队列也清空了，事件循环正式结束。现在，我们知道setTimeout的回调函数是一开始就注册进event table的，但是那时并未进入任务队列—-要经过一定的时间，而这个时间由第二个参数来指定。也就是说，第二个参数指定的是“多长时间后将回调函数放入到任务队列中”。另外，即使回调函数已经进入队列，也得先等主线程的执行栈清空后才有可能轮到自己。我们还经常遇到setTimeout(fn,0)(或者干脆没有指定第二个参数)这样的代码，这是不是意味着可以立即执行呢？不是。setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是注册进event table的同时就将任务放入队列中，只要主线程执行栈内的同步任务全部执行完成，且此时没有微任务队列，那么该任务就会马上压栈并执行。例2setTimeout(function() { console.log('setTimeout'); }) new Promise(function(resolve) { console.log('promise'); }).then(function() { console.log('then'); }) console.log('console'); 分析：&lt;script&gt;中的整段代码作为第一个宏任务，进入主线程。即开启第一次事件循环；遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中（第二个参数不设定时，默认延迟为0）；接下来遇到new Promise、Promise，立即执行，输出: promise 。将then函数分发到微任务队列中；遇到console.log，立即执行，输出: console整体代码作为第一个宏任务执行结束，此时去微任务队列中查看有哪些微任务，结果发现了then函数，然后将它推入主线程并执行，输出: then第一轮事件循环结束，第二轮事件循环开始；先从宏任务开始，去宏任务队列中查看有哪些宏任务，结果发现了setTimeout对应的回调函数，将它推入主线程并执行，输出：setTimeout然后去微任务队列中查看是否有事件，结果没有；此时第二轮事件循环结束；执行栈清空了，任务队列也清空了，事件循环正式结束。例3console.log('1'); setTimeout(function() { console.log('2'); process.nextTick(function() { console.log('3'); }) new Promise(function(resolve) { console.log('4'); resolve(); }).then(function() { console.log('5') }) }) process.nextTick(function() { console.log('6'); }) new Promise(function(resolve) { console.log('7'); resolve(); }).then(function() { console.log('8') }) setTimeout(function() { console.log('9'); process.nextTick(function() { console.log('10'); }) new Promise(function(resolve) { console.log('11'); resolve(); }).then(function() { console.log('12') }) }) 分析：第一轮事件循环a) 整段`&lt;script>`代码作为第一个宏任务进入主线程，即开启第一轮事件循环 b) 遇到console.log，立即执行。输出：1 c) 遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中。 我们将其标记为setTimeout1 d) 遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务 队列中。记为process1 e) 遇到new Promise、Promise，立即执行；then回调函数放入Event table中注册，然后 被分发到微任务队列中。记为then1。 输出: 7 f) 遇到setTimeout，将其回调函数放入Event table中注册，然后分发到宏任务队列中。 我们将其标记为setTimeout2 此时第一轮事件循环宏任务结束，下表是第一轮事件循环宏任务结束时各任务队列的情况可以看到第一轮事件循环宏任务结束后微任务事件队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行g)、执行process1。输出：6 h)、执行then1。输出：8 第一轮事件循环正式结束！第二轮事件循环a）、第二轮事件循环从宏任务setTimeout1开始。遇到console.log，立即执行。输出: 2 b）、遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务 队列中。记为process2 c）、遇到new Promise，立即执行；then回调函数放入Event table中注册，然后被分发到 微任务队列中。记为then2。输出: 5 此时第二轮事件循环宏任务结束，下表是第二轮事件循环宏任务结束时各任务队列的情况可以看到第二轮事件循环宏任务结束后微任务事件队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行d)、执行process2。输出：3 e)、执行then2。输出：5 第二轮事件循环正式结束！第三轮事件循环a)、第三轮事件循环从宏任务setTimeout2开始。遇到console.log，立即执行。输出: 9 d)、遇到process.nextTick，其回调函数放入Event table中注册，然后被分发到微任务 队列中。记为process3 c)、遇到new Promise，立即执行；then回调函数放入Event table中注册，然后被分发到 微任务队列中。记为then3。输出: 11 此时第三轮事件循环宏任务结束，下表是第三轮事件循环宏任务结束时各任务队列的情况可以看到第二轮事件循环宏任务结束后微任务队列中还有两个事件待执行，因此这两个事件会被推入主线程，然后执行d)、执行process3。输出：10 e)、执行then3。输出：12 第二轮事件循环正式结束！执行栈清空，任务队列清空，事件循环正式结束！参考：https://segmentfault.com/a/1190000017970432http://www.ruanyifeng.com/blog/2014/10/event-loop.html]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包和计数器]]></title>
    <url>%2F2019%2F03%2F04%2FF-%E9%97%AD%E5%8C%85%E5%92%8C%E8%AE%A1%E6%95%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[之前想不通的一道题—–主要是不知道思路怎么来的，为何会想到用闭包。本来打算就将原博客转载过来，但是刚刚重新审视这道题的时候，好像看到了以前没有发现的东西，有种恍然大悟的感觉，所以决定用自己的话来解释这道题的思路。假如我们想制作一个计数器，每点击一次就加一，代码如下：var counter = 0; //把计数器counter设置成全局变量 function add(){ return counter+=1; } add(); //1 add(); //2 add(); //此时counter=3 &gt;&gt;固然可以实现功能，但问题就在于其他语句也有可能会改动到counter，这样的计数器是不安全的。如果把counter改为外部访问不到的局部变量呢？function add(){ var counter=0; counter+=1; } add(); //counter为1 add(); //counter为1 add(); //counter为1 &gt;&gt;固然保证了counter不会被其他语句影响到，但问题就在于每次调用函数都会重置counter，无法实现计数功能。所以我们需要的counter应该满足：1.不会被重置；2.在函数内部第2点容易满足，但是由上面的例子我们知道，如果单纯把counter写在一个函数里，则每次调用都会重置，所以我们定义这样一个嵌套函数：将counter放在父函数里，子函数作为操作counter的函数，每次我们只调用子函数。但是，全局作用域是无法访问嵌套函数中的子函数的，所以我们必须将子函数作为闭包返回出来，使其暴露在全局作用域下。依照这个想法，代码如下：var add = function(){ var counter = 0; return function(){ return (++counter); } } add()(); //counter为1 add()(); //counter为1 add()(); //counter为1 &gt;&gt;意思是把add函数（父函数）执行后返回的函数（子函数）执行一次（注意这里是两次执行）。但这样的问题在于：每次调用add()()时依然执行了一次父函数，结果就是依然重置了counter。那么有没有办法让父函数只执行一次，仅在那一次初始化counter，之后每次都只通过执行子函数来操作counter呢？可以用自执行函数来解决这个问题—–也就是通过自执行函数（而不是通过add()）来调用父函数，在这一次调用初始化counter，之后将返回的子函数赋给add，通过调用add()来操作counter。var add = (function(){ var counter = 0; return function(){ return(++counter); } })(); //这里add已经是父函数的执行结果了，即add已经是返回的那个子函数了 add(); //counter为1 console.log(counter) //undefined add(); //counter为2 console.log(counter) //undefined add(); //counter为3 console.log(counter) //undefined 接下来就是闭包的知识了：在每次调用闭包add——-即function(){return(++counter)时，由于add中存在自由变量counter，所以它必须到定义该函数时所在的那个作用域中去寻找该变量，也就是到父函数中去寻找。恰好父函数中有一个为0的counter可以被引用，所以这时候完成加一操作，counter变成1。注意，接下来我们尝试调用了console.log(counter)，但是输出的是undefined，这说明了即使add函数执行后返回了值为1的counter，但是该返回值并不是返回到全局作用域中（不然不会输出undefined），而是覆盖了父函数中原来定义的counter，使counter变为1；第二次调用add函数依然同上，只是此时引用counter时，引用的是为1的counter，加1后变为2；同理第三次，引用的是为2的counter，加1后变为3。基于这道题，我们不难看出使用闭包函数的好处：1、缓存：最显而易见的好处，就是可以实现数据缓存，我们可以把一个需要长期用到的变量作为相对于闭包函数的自由变量，在闭包函数里直接使用它。因此该自由变量只初始化一次，但却可以通过多次调用闭包函数来使用。这比起我们直接在闭包函数中定义初始化变量，多次调用则多次初始化的做法，效率更高。闭包函数常见的一种用途就是上面例子中的—–实现计数功能。2、实现封装：自由变量只能被闭包函数本身或者其子函数访问，而不能被闭包函数之外的函数访问。这就实现了面向对象的封装性，更安全更可靠。参考：http://www.cnblogs.com/haidaojiege/p/7070560.htmlhttps://www.cnblogs.com/leoin2012/p/3978979.html]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出理解闭包]]></title>
    <url>%2F2019%2F03%2F04%2FF-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[前言：本篇博客转载自@王福朋 王老师的系列文章。系列文章共计18篇，主要涉及js中的两个重难点—-原型和闭包。由于原型部分我在另外一篇博客有介绍，所以这里只集合了他关于闭包的几篇讲解，包括了作用域、执行上下文等。原作者：王福朋来源：深入理解JavaScript原型和闭包转载授权:1.简述执行上下文（上）：什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：这是第一种情况。下面还有。先来个简单的。有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。下面还有。。。第三种情况。在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。好了，“准备工作”介绍完毕。我们总结一下，在“准备工作”中完成了哪些工作：变量、函数表达式——变量声明，默认赋值为undefined；this——赋值；函数声明——赋值；这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的。细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。这里解释一下为什么代码段分为这三种。所谓“代码段”就是一段文本形式的代码。首先，全局代码是一种，这个应该没有非议，本来就是手写文本到&lt;script&gt;标签里面的。其次，eval代码接收的也是一段文本形式的代码。最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。这样解释应该能理解了。最后，eval不常用，也不推荐大家用。2.简述执行上下文（下）：继续上面的内容。上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如何数据：变量、函数表达式——变量声明，默认赋值为undefined；this——赋值；函数声明——赋值；如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。另外一点不同在于，函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。全局代码的上下文环境数据内容为：如果代码段是函数体，那么在此基础上需要附加：给执行上下文环境下一个通俗的定义——在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。3.执行上下文栈继续上文的内容。执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。其实这是一个压栈出栈的过程——执行上下文栈。 如下图：可根据以下代码来详细介绍上下文栈的压栈、出栈过程。如上代码。在执行代码之前，首先将创建全局上下文环境。然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。执行到第13行，调用bar函数。跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。并将这个执行上下文环境压栈，设置为活动状态。执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。要说闭包，咱们还得先从自由变量和作用域说起。4.作用域提到作用域，有一句话大家（有js开发经验者）可能比较熟悉：“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句：再比如for语句：所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——javascript除了全局作用域之外，只有函数可以创建的作用域。所以，我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。jQuery就是一个很好的示例：下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。说到这里，咱们又可以拿出jquery源码来讲讲了。jQuery源码的最外层是一个自动执行的匿名函数：为什么要这样做呢？原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者其他函数作用域的同名变量产生冲突。全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。下一节将把作用域和执行上下文环境结合起来说一说。可见，要理解闭包，不是一两句话能说清楚的。5.作用域和上下文环境上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。另外，对上下文环境不了解的朋友，可以回过头看看前面。第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。结束了 ！最后我们可以把以上这几个图片连接起来看看。连接起来看，还是挺有意思的。作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。虽然本文很长，但是文字较少，图片居多，图片都有形象的展示，大家花十几分钟也能慢慢看完。但是，这节内容真的很重要。以上代码中，咱们还没有设计到跨作用域取值的情况，即——自由变量。详细内容且听下回分解。6.从自由变量到作用域链先解释一下什么是“自由变量”。在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。如下图如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。上面描述的只是跨一步作用域去寻找。如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。这个一步一步“跨”的路线，我们称之为——作用域链。我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；第四步，跳转到第一步。以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。这一节看似很轻松的把作用域链引出来，并讲完了。之所有轻松是有前几节的基础，否则将很难解释。接下来咱们开始正式说说一直期待依旧的朋友——闭包。敬请期待下一节。7.闭包前面提到的上下文环境和作用域的知识，一方面是必须了解的知识，一方面也是理解闭包的基础。至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。但是你只需要知道应用的两种情况即可——函数作为返回值，函数作为参数传递。闭包的作用，简而言之一句话：可以在其他的执行上下文中，访问到函数的内部变量。第一，函数作为返回值如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。第二，函数作为参数被传递如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。上一节讲到自由变量跨作用域取值时，曾经强调过：要去创建这个函数的作用域取值，而不是“父作用域”。理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。咱们可以拿本文的第一段代码（稍作修改）来分析一下。第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域.。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。使用闭包会增加内容开销，现在很明显了吧！第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。正如我们所看到的，闭包和作用域、上下文环境有着密不可分的关系。另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么，因为这些BUG可能完全在你的知识范围之外。到现在闭包就简单介绍完了。8.补充：上下文环境和作用域的关系本系列用了大量的篇幅讲解了上下文环境和作用域，有些人反映这两个是一回儿事。本文就用一个小例子来说明一下，作用域和上下文环境绝对不是一回事儿。在说明之前，咱们先用简单的语言来概括一下这两个的区别。8.1. 上下文环境：可以理解为一个看不见摸不着的对象（有若干个属性），虽然看不见摸不着，但确实实实在在存在的，因为所有的变量都在里面存储着，要不然咱们定义的变量在哪里存？另外，对于函数来说，上下文环境是在调用时创建的，这个很好理解。拿参数做例子，你不调用函数，我哪儿知道你要给我传什么参数？8.2. 作用域：首先，它很抽象。第二，记住一句话：除了全局作用域，只有函数才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域，就有自己的一个“地盘”。8.3. 两者：一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。上面的文字不理解没关系，且看下面的例子。第一，除了全局作用域外，每个函数都要创建一个作用域。作用域之间的变量是相互独立的。因此，全局作用域中的x和fn作用域中的x，两者毫无关系，互不影响，和平相处。第二，程序执行之前，会生成全局上下文环境，并在程序执行时，对其中的变量赋值。第三，程序执行到第17行，调用fn(5)，会产生fn(5)的上下文环境，并压栈，并设置为活动状态。第四，执行完第17行，fn(5)的返回值赋值给了f1。此时执行上下文环境又重新回到全局，但是fn(5)的上下文环境不能就此销毁，因为其中有闭包的引用（可翻看前面文章，此处不再赘述）。第五，继续执行第18行，再次调用fn函数——fn(10)。产生fn(5)的上下文环境，并压栈，并设置为活动状态。但是此时fn(5)的上下文环境还在内存中——一个作用域下同时存在两个上下文环境。讲到这里，重点已经讲出来了，之后的场景这里就不再赘述了。目的还是希望大家能通过这个例子，来理清楚上下文环境和作用域的关系。当然，也不是非得像个学院派似的一字一文的把概念说出来，简单理解一下，对用闭包是有帮助的。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>执行上下文</tag>
        <tag>作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解line-height]]></title>
    <url>%2F2019%2F02%2F20%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3line-height%2F</url>
    <content type="text"><![CDATA[1.相关概念普及：1.1 顶线，中线，基线和底线 ：直接见下图。inline-block和inline都可以有这四种线。其中，我们重点研究基线，即base line。基线并不是汉字文字的下端沿，而是英文字母“x”的下端沿。1.2 行高：即line-height，是指同一个元素中，两个文本行基线间的垂直距离。&lt;div style="width:170px;"> &lt;span style="font-size:16px;line-height:20px;background:red;"> I'm the first line &lt;/span> &lt;span style="font-size:16px; line-height:40px;background:green;"> I'm the second line &lt;/span> &lt;/div> 比如上图或者下图中两条红线之间的距离。1.3 行距：上行的底线和下一行的顶线之间的距离就是行距，行距的一半称为半行距1.4 字体大小：即font-size，是指同一行的顶线和底线之间的距离从上图我们就可以看出，行距、font-size与行高之间的关系满足行距 = （行高 - font-size）当font-size等于行高时，行距 = 0，如下图而当font-size大于行高时，行距为负值，则两行重叠，如下图：1.5 CSS boxes的四种类型（containing boxes、inline boxes、line boxes、content area)1.5.1 content area （内容区）：内容区是包围着文字的一种box，无法显示出来。在没有其他因素 (比如padding) 的影响时，内容区的高度即为font-size。1.5.2 inline box (行内框) ：每个行内元素会生成一个行内框，行内框是一个浏览器渲染模型中的一个概念，无法显示出来。在没有其他因素 (比如padding) 的影响时，行内框的高度即为内容区的高度；设定line-height后，实际改变的是行距，行内框的高度将由 内容区 变为 内容区＋行距。因此，此时会有行内框高度=行高。1.5.3 3.line box（行框） ：行框是指本行的一个虚拟的矩形框，由该行中一个个行内框组成。行框也是浏览器渲染模式中的一个概念，无法显示出来。行框高度等于本行中所有行内框高度的最大值。当有多行内容时，每一行都有自己的行框。1.5.4 containing box（包含框）：包裹着上述三种box的box2. line-height的取值方法与继承一般而言，line-height只影响行内元素( 包括行内替换元素和行内非替换元素，如img和span )，并不能直接应用于块级元素。但是line-height 具有可继承性，块级元素的子元素会继承该特性，并且在行内元素上生效。一般情况下，浏览器默认的line-height为1.2。可以自定义 line-height 覆盖这个初始值，那么该怎样设置line-height呢？有以下5种方式：line-height是个可继承属性，它的继承规则比较复杂。需要提前说明的是：line-height的大小与font-size息息相关，除了指定line-height为多少px，剩下的设置方式都是基于font-size算出来的。 下面一一解释。inherit ：继承父元素line-height的值，所以父元素的是多少就是多少。 如果其后代元素不设置line-height 的话，也会是这个值。数字＋px： 假设设置 line-height 为20px，那么该行的行高就是20px，与 font-size 无关，不会随着 font-size 做相应比例的缩放。 这个长度值（20px）会被后代元素继承，所有的后代元素会使用这个相同的、继承的 line-height (20px)，除非后代元素设定 line-height 。数字＋％ ：假设自身的 font-size 为16px，line-height 设为120%。那么其行高为：16 * 120% = 19.2px。即 line-height 是根据自身的 font-size 计算出来的。 子元素会继承父元素的line-height，它继承的不是百分比而是父元素line-height计算后的最终值。normal ：假设设置line-height 为 normal ，则会根据浏览器的解析情况给元素分配一个倍数，一般是1.2，即line-height为字体的1.2倍。与上一个不同的是，其子元素不再继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~可见，子元素随着自身 font-size 的大小而做相应比例的缩放。纯数字/缩放因子 ：如果既想要 normal 的灵活，又想设置一个自定义的值，那就要用 纯数字 。纯数字方式与 normal 唯一的不同，在于数值的大小不一定是1.2，而是完全由你自己决定。同样地，其子元素不是继承其line-height计算后的最终值，而是根据子元素自身的 font-size 进行计算。见下表~总结如下：那么，哪一种是最好的方式呢？ 一般来数，设置行高的值为纯数字是最推荐的方式，因为其会随着对应的 font-size 而缩放。3 line-height实现垂直居中的原理通常情况下，div中的a标签包含文本，文本将默认出现在div的顶端，如果想要垂直居中，可以设置div的高度等于行高，由于行高不直接作用于块状元素且行高可以继承，所以实际上等效于设置a的行高等于div的高度。a的行高即a的行内框高度，即 内容区＋行距。行高默认是浏览器分配的1.2，由于此时重新设置了行高☞☞所以行距跟着改变☞☞所以内容区上下往外延伸☞☞即行内框整体延伸。但是，文字始终在行内框里垂直居中，行内框延伸的终点是div的高度，也就是延伸至行内框高度等于div高度。此时，文本自然会在div中垂直居中。]]></content>
      <categories>
        <category>Front-end</category>
        <category>HTML &amp; CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery AJAX load()方法中代码执行顺序的问题]]></title>
    <url>%2F2019%2F02%2F18%2FF-jQuery%20AJAX%20load()%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题来源于菜鸟教程介绍jq load() 方法时用的一个实例：js：$(&quot;button&quot;).click(function(){ $(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){ if(statusTxt==&quot;success&quot;) alert(&quot;外部内容加载成功!&quot;); if(statusTxt==&quot;error&quot;) alert(&quot;Error: &quot;+xhr.status+&quot;: &quot;+xhr.statusText); }); }); html：&lt;div id=&quot;div1&quot;&gt;&lt;h2&gt;使用 jQuery AJAX 修改该文本&lt;/h2&gt;&lt;/div&gt; &lt;button&gt;获取外部内容&lt;/button&gt; 这里作为load方法参数的函数是一个回调函数。什么是回调函数呢？我们先来看看回调的英文定义：A callback is a function that is passed as an argument to another function and is executed after its parent function has completed。字面上的理解，回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。那么根据这个解释，这段代码应该是先执行load(“demo_test.txt”) 加载外部内容，之后再执行回调函数弹出alert。但是实际运行后发现和预想的不一样：从结果来看，是先弹出alert再改变文本内容。那么，为什么会这样呢？难道上面的说法有误？为了进一步验证，修改代码如下： $(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){ alert(responseTxt); if(statusTxt==&quot;success&quot;){ 运行：很明显文本内容已经改变，说明前面关于回调函数最后执行的说法是没问题的。接着猜想，之所以先弹出alert再改变文本内容，可能是因为必须等回调函数执行完后才能把文本渲染到浏览器上。为了进一步验证，修改代码如下：$(&quot;#div1&quot;).load(&quot;demo_test.txt&quot;,function(responseTxt,statusTxt,xhr){ if(statusTxt==&quot;success&quot;){ debugger； console.log(&quot;1&quot;); } 运行：控制台中没有打印出1，且程序中断，说明此时回调函数还在执行当中，但是文本内容却已经改变了。这说明上面的猜想错误—–即文本渲染到浏览器上不需要等到回调函数执行结束。但是，那只是一般情况！！问题就在于，alert是可以阻塞浏览器的渲染工作的！重新运行最初的代码，可以看到还是先弹出alert，文本没变，但是这时候点开控制台的elements，可以看到图中红框显示这时候文本的内容其实已经改变了。虽然文本内容看上去不变——但是实际情况是文本内容已经改变了，也就是load()方法已经生效了，只是alert阻塞了浏览器将它渲染出来。在这里还要注意，alert可以阻塞浏览器的渲染，而debugger是没办法的。]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AJAX</tag>
        <tag>浏览器渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解事件]]></title>
    <url>%2F2019%2F02%2F18%2FF-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件：事件是用户或浏览器自身执行的某种动作，如click,load和mouseover都是事件的名字。响应某个事件的函数叫做事件处理函数 / 事件处理程序 / 事件句柄。如果想要绑定多个函数，则需要用到事件监听器。1. 事件绑定的几种方式javascript给DOM绑定事件处理函数总的来说有2种方式：在html文档中绑定、在js代码中绑定。下面的方式1、方式2属于在html中绑定事件，方式3、方式4和方式5属于在js代码中绑定事件，其中，方式4和5属于事件监听，而方式5是最推荐的做法。1）在html文档中绑定方式1：&lt;input type="button" id="btn" onclick="函数名( )"> 方式2：&lt;input type="button" id="btn" onclick="直接写函数内容"> 2）在js代码中绑定方式3：document.getElementById("btn").onclick=function( ){ }; 说明：方式3也称为“DOM0级事件处理程序”。它无法绑定多个事件，当绑定多个事件的时候，只有最后一个会生效，其他皆被覆盖）方式4：[object].attachEvent(“事件类型”,”处理函数”)说明：①方式4也称为“IE事件处理程序”。这种方法不属于w3c标准，并且仅IE8及以下支持该方法；②事件类型要加on；③如下图，b中声明a函数时分配了一块内存地址 ，两个dom.attachEvent(&#39;onclick&#39;,a)中的a都指向的是下面定义的a；c中只是两个函数体一样的匿名函数，分别有各自的内存地址，故认为是两个不同的函数对象方式5：[object].addEventListener(“事件类型”,”处理函数”,”冒泡事件或捕获事件”);说明：①方式5也称为“DOM2级事件处理程序”。w3c正统标准，IE9及以上、Chrome、Firefox等支持该方法；②事件类型不加on；③第三个参数不设置的时候，默认为false即冒泡；④ 同一个事件处理函数可以绑定2次,一次用于事件捕获，一次用于事件冒泡；如果绑定的是同一个事件处理函数，并且都是事件冒泡类型或者事件捕获类型，那么只能绑定一次；⑤ 不同的事件处理函数可以重复绑定，这点与上面attachEvent是一样的2. 事件处理函数的执行顺序方式123都不能实现事件的重复绑定，所以自然也就不存在执行顺序的问题。方式4和方式5可以重复绑定特性，所以需要了解下执行顺序的问题。结论：对于addEventListener，如果给目标的同一个事件绑定多个处理函数，先绑定的先执行。 attachEvent则刚好相反，后绑定的先执行，这是因为采用attachEvent的是IE8-，而IE8-是不支持dom事件流模型的。&lt;script> window.onload = function(){ var outA=document.getElementById("outA"); outA.addEventListener('click',function(){alert(1);},false); outA.addEventListener('click',function(){alert(2);},true); outA.addEventListener('click',function(){alert(3);},true); outA.addEventListener('click',function(){alert(4);},true); }; &lt;/script> &lt;body> &lt;div id="outA"> &lt;/div> &lt;/body> 当点击outA的时候，会依次打印出1、2、3、4。这里特别需要注意：我们是同时给outA这个元素绑定了多个onclick事件处理函数，没有涉及父子元素，所以也不涉及事件冒泡和事件捕获的问题，即addEventListener的第三个参数在这种场景下，没有什么用处，直接忽略之。如果是通过事件冒泡或者是事件捕获触发outA的click事件，那么函数的执行顺序会有变化。3. 事件捕获和事件冒泡我们知道HTML中的元素是可以嵌套的，形成类似于树的层次关系。比如下面的代码：&lt;div id="outA"> &lt;div id="outB"> &lt;div id="outC">&lt;/div> &lt;/div> &lt;/div> 如果点击了最内侧的outC，那么外侧的outB和outC算不算被点击了呢？很显然算，不然就没有必要区分事件冒泡和事件捕获了，这一点各个浏览器厂家也没有什么疑义。假如outA、outB、outC都注册了click类型事件处理函数，当点击outC的时候，触发顺序是A–&gt;B–&gt;C，还是C–&gt;B–&gt;A呢？如果浏览器采用的是事件冒泡，那么触发顺序是C–&gt;B–&gt;A，由内而外，像气泡一样，从水底浮向水面；如果采用的是事件捕获，那么触发顺序是A–&gt;B–&gt;C，从上到下，像石头一样，从水面落入水底。一般来说事件冒泡机制用的更多一些，所以在IE8以及之前，IE只支持事件冒泡。IE9+/FF/Chrome这2种模型都支持，可以通过addEventListener的第三个参数来设定，false代表事件冒泡，true代表事件捕获。&lt;script> window.onload = function(){ var outA = document.getElementById("outA"); var outB = document.getElementById("outB"); var outC = document.getElementById("outC"); // 使用事件冒泡 outA.addEventListener('click',function(){alert(1);},false); outB.addEventListener('click',function(){alert(2);},false); outC.addEventListener('click',function(){alert(3);},false); }; &lt;/script> &lt;body> &lt;div id="outA"> &lt;div id="outB"> &lt;div id="outC">&lt;/div> &lt;/div> &lt;/div> &lt;/body> 使用的是事件冒泡，当点击outC的时候，打印顺序是3–&gt;2–&gt;1。如果将false改成true使用事件捕获，打印顺序是1–&gt;2–&gt;3。4. DOM事件流4.1 事件流定义：事件流描述的是从页面中接收事件的顺序。 事件发生时会在元素节点与根节点之间按照特定的顺序如流水一样传播，路径所经过的所有节点都会收到该事件，这个传播过程即事件流。4.2 事件流模型：事件传播的顺序对应浏览器的两种事件流模型：捕获型事件流和冒泡型事件流。冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即由内到外捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即由外到内4.3 DOM事件流：4.3.1 dom事件流定义：DOM标准采用捕获+冒泡的DOM事件流。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。4.3.2 dom事件流包括：DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。事件捕获阶段：实际目标(&lt;div&gt;)在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。上图中为1~3.处于目标阶段：事件在&lt;div&gt;上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。冒泡阶段：事件又传播回文档。4.3.3 dom事件流与冒泡、捕获将DOM事件流看作整个过程，那么其实 useCapture=false意味着：将该事件处理函数加入到冒泡阶段，在冒泡阶段会被调用；useCapture=true意味着：将该事件处理函数加入到捕获阶段，在捕获阶段会被调用。从DOM事件流模型可以看出，捕获阶段的事件处理函数，一定比冒泡阶段的事件处理函数先执行。4.3.4 dom事件流的相关概念1） target:触发事件的某个具体对象，固定不变的。2） currentTarget:绑定事件的对象，恒等于this，可能出现在事件流的任意一个阶段中。动态变化的。控制台：点击最里面的son3后，可以看到target一直不变，而由于冒泡，导致currentTarget动态变化。3） 两者的应用场合通常情况下target和currentTarget是一致的，我们只要使用terget即可，但有一种情况必须区分这三者的关系，那就是在父子嵌套的关系中，父元素绑定了事件，单击了子元素（根据事件流，在不阻止事件流的前提下他会传递至父元素，导致父元素的事件处理函数执行），这时候currentTarget指向的是父元素，因为他是绑定事件的对象，而target指向了子元素，因为他是触发事件的那个具体对象PS：注意！！！并非所有的事件都会经过冒泡阶段 。所有的事件都要经过捕获阶段和处于目标阶段，但是有些事件会跳过冒泡阶段：如，获得输入焦点的focus事件和失去输入焦点的blur事件。5. DOM事件流中的“事件处理函数的执行顺序”我们回头再来说事件处理函数的执行顺序。点击outC的时候，打印顺序是 :capture1–&gt;capture2–&gt;target2–&gt;target1–&gt;bubble2–&gt;bubble1。由于outC是我们触发事件的目标对象，在outC上注册的几个事件处理函数都属于DOM事件流中的目标阶段。对同一个绑定对象（这里是outC）而言，同处于目标阶段的多个函数的执行顺序：先注册的先执行，后注册的后执行。这就是上面我们说的，在目标对象（outC）上绑定的函数是采用捕获，还是采用冒泡，都没有什么关系，因为冒泡和捕获只是对父元素上的函数执行顺序有影响，对自己没有什么影响。至此我们可以给出事件函数执行顺序的结论了：捕获阶段的处理函数最先执行，其次是目标阶段的处理函数，最后是冒泡阶段的处理函数。目标阶段的处理函数如果有多个，则先注册的先执行，后注册的后执行。6. 阻止事件冒泡和捕获默认情况下，多个事件处理函数会按照DOM事件流模型中的顺序执行。如果子元素上发生某个事件，不需要执行父元素上注册的事件处理函数，那么我们可以停止捕获和冒泡，避免没有意义的函数调用。前面提到的5种事件绑定方式，都可以实现阻止事件的传播。由于第5种方式，是最推荐的做法。所以我们基于第5种方式，看看如何阻止事件的传播行为。注意：IE8以及IE8之前可以通过 window.event.cancelBubble=true阻止事件的继续传播；IE9+/FF/Chrome通过event.stopPropagation()阻止事件的继续传播。当点击outC的时候，打印出capture–&gt;target，不会打印出bubble。因为当事件传播到outC上的处理函数时，通过stopPropagation阻止了事件的继续传播，所以不会继续传播到冒泡阶段。想要在哪个节点阻止传播，就在哪个节点的事件处理函数中添加stopPropagation，记得要传参。7. 事件代理/事件委托7.1 概述：事件委托又叫事件代理。JavaScript高级程序设计上讲:事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。我们可以用取快递的例子来理解这个东西。假设：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台也会在收到寄给新员工的快递后核实并代为签收。这里其实还有2层意思的：第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；第二，新员工也是可以被前台代为签收的，即程序中新添加的dom节点也是有事件的。7.2 为什么要使用事件委托：简单来说，就是为了减少不必要的dom操作，优化性能。一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了。比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢？如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，自然性能就会更好。7.3 事件委托的原理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。7.4 事件委托如何实现：终于到了本文的核心部分了。在介绍事件委托的方法之前，我们先来看例一：需求：不管点击哪个li，都能弹出123：&lt;ul id="ul1"> &lt;li>111&lt;/li> &lt;li>222&lt;/li> &lt;li>333&lt;/li> &lt;li>444&lt;/li> &lt;/ul> window.onload = function(){ var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); for(var i=0;i&lt;aLi.length;i++){ aLi[i].onclick = function(){ alert(123); } } } 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作:首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；那么我们用事件委托的方式做又会怎么样呢？window.onload = function(){ var oUl = document.getElementById("ul1"); oUl.onclick = function(){ alert(123); } } 我们让父级ul监听点击事件，则不管是哪个li被点击————由于冒泡原理，事件最终都会冒泡到ul上，触发ul上的点击事件，弹出123。当然，这里当点击ul的时候，也是会触发的。那么问题就来了，如果我想让事件代理的效果跟直接给某个指定的节点的事件效果一样怎么办？比如说只有点击li才会触发，不怕，我们有绝招：事件本身是一个对象，即Event对象，事件发生时该对象作为参数传给回调函数。而Event对象提供了一个属性叫target，可以返回事件的目标节点，我们称之为事件源.也就是说，target可以表示为当前的事件直接操作的那个dom。当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：window.onload = function(){ var oUl = document.getElementById("ul1"); oUl.onclick = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li'){ alert(123); alert(target.innerHTML); } } } 这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？请看例二：&lt;div id="box"> &lt;input type="button" id="add" value="添加" /> &lt;input type="button" id="remove" value="删除" /> &lt;input type="button" id="move" value="移动" /> &lt;input type="button" id="select" value="选择" /> &lt;/div> window.onload = function(){ var Add = document.getElementById("add"); var Remove = document.getElementById("remove"); var Move = document.getElementById("move"); var Select = document.getElementById("select"); Add.onclick = function(){ alert('添加'); }; Remove.onclick = function(){ alert('删除'); }; Move.onclick = function(){ alert('移动'); }; Select.onclick = function(){ alert('选择'); } } 上面实现的效果很简单，4个按钮对应4个不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？window.onload = function(){ var oBox = document.getElementById("box"); oBox.onclick = function (ev) { var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == 'input'){ switch(target.id){ case 'add' : alert('添加'); break; case 'remove' : alert('删除'); break; case 'move' : alert('移动'); break; case 'select' : alert('选择'); break; } } } } 可见，用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？请看例三：我们的需求是是：①移入li，li变红，移出li，li变白②对于点击按钮后新增的li节点，仍然具有该效果。以下是正常的方法：&lt;input type="button" name="" id="btn" value="添加" /> &lt;ul id="ul1"> &lt;li>111&lt;/li> &lt;li>222&lt;/li> &lt;li>333&lt;/li> &lt;li>444&lt;/li> &lt;/ul> window.onload = function(){ var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++){ aLi[i].onmouseover = function(){ this.style.background = 'red'; }; aLi[i].onmouseout = function(){ this.style.background = '#fff'; } } //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); }; } 你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去——这是因为li遍历这一动作发生在新增li这一动作之前，在那个时候已经确定了li的个数是4，因此只绑定了4个li。这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环封装在一个函数里，命名为mHover，如下：window.onload = function(){ var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; function mHover () { //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++){ aLi[i].onmouseover = function(){ this.style.background = 'red'; }; aLi[i].onmouseout = function(){ this.style.background = '#fff'; } } } mHover (); //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); mHover (); }; } 与上面方法不同的是，这个方法没有在新增li之前就为原有li绑定事件，而是在新增li后遍历所有的li（包括新增li），并一起绑定事件。虽然功能实现了，看着还挺好，但实际上无疑又增加了一个dom操作，在优化性能方面是不可取的，那么用事件委托的方式，能做到优化吗？window.onload = function(){ var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li'){ target.style.background = "red"; } }; oUl.onmouseout = function(ev){ var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li'){ target.style.background = "#fff"; } }; //添加新节点 oBtn.onclick = function(){ num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); }; } 如上，新添加的节点是带有事件效果的。根据事件冒泡原理，不管是原有li还是新增li，只要鼠标一移入li中就等同于鼠标移入ul中，自然会触发ul的鼠标移入事件，之后我们只要在ul的事件函数中定义相关行为就可以了。我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了。这样可以大大的减少dom操作，这才是事件委托的精髓所在。7.5 总结：那什么样的事件可以用事件委托，什么样的事件不可以用呢？适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，至于focus，blur之类的就更不用说了，本身就没有冒泡的特性，自然就不能用事件委托了。8 事件对象8.1 认识事件对象事件在浏览器中是以对象的形式存在的，即event对象。触发一个事件，就会产生一个event对象，该对象包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如：鼠标操作产生的event中会包含鼠标位置的信息；键盘操作产生的event中会包含与按下的键有关的信息。所有浏览器都支持event对象，但支持方式不同，在DOM中event对象必须作为唯一的参数传给事件处理函数，在IE中event是window对象的一个属性。8.2 html事件处理程序中的事件对象&lt;input id="btn" type="button" value="click" onclick=" console.log('html事件处理程序'+event.type)"/> 这样会创建一个包含局部变量event的函数。可通过event直接访问事件对象。8.3 DOM中的事件对象DOM0级和DOM2级事件处理程序都会把event作为参数传入。参数命名：随便。习惯上用e，或者ev或者event。&lt;body> &lt;input id="btn" type="button" value="click"/> &lt;script> var btn=document.getElementById("btn"); btn.onclick=function(event){ console.log("DOM0 &amp; click"); console.log(event.type); //click } btn.addEventListener("click", function (event) { console.log("DOM2 &amp; click"); console.log(event.type); //click },false); &lt;/script> &lt;/body> DOM中事件对象的重要属性和方法。属性：type属性，用于获取事件类型target属性，用于获取事件直接作用的目标（更具体target.nodeName）currentTarget属性，用于获取事件实际绑定的目标方法：stopPropagation()方法,用于阻止事件冒泡preventDefault()方法,阻止事件的默认行为 移动端用的多8.4 IE中的事件对象第一种情况： 通过DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。&lt;body> &lt;input id="btn" type="button" value="click"/> &lt;script> var btn=document.getElementById("btn"); btn.onclick= function () { var event=window.event; console.log(event.type); //click } &lt;/script> &lt;/body> 第二种情况：通过attachEvent()添加的事件处理程序，event对象作为参数传入。&lt;body> &lt;input id="btn" type="button" value="click"/> &lt;script> var btn=document.getElementById("btn"); btn.attachEvent("onclick", function (type) { console.log(event.type); //click }) &lt;/script> &lt;/body> IE中事件对象的重要属性和方法:属性：type属性，用于获取事件类型(一样)srcElement属性，用于获取事件直接作用的目标（更具体srcElement.nodeName）cancelBubble属性，用于阻止事件冒泡。IE中cancelBubble为属性而不是方法，true表示阻止冒泡。returnValue属性，阻止事件的默认行为。false表示阻止事件的默认行为PS：targrt和srcElement的兼容性处理如下//兼容性处理 function showMsg(event){ event=event||window.event; //IE8以前必须通过window获取event，DOM中就是个简单的传参 var ele=event.target || event.srcElement; //获取目标元素，DOM中用target,IE中用srcElement alert(ele); } 参考链接：https://blog.csdn.net/aitangyong/article/details/43231111http://www.cnblogs.com/starof/p/4066381.htmlhttps://www.cnblogs.com/liugang-vip/p/5616484.htmlhttp://www.cnblogs.com/starof/p/4077532.html]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>事件</tag>
        <tag>dom事件流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提问的智慧]]></title>
    <url>%2F2019%2F02%2F18%2FT-%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7%2F</url>
    <content type="text"><![CDATA[提问领域的“圣经”，虽然很难严格按照里面的标准规范自己的行为，但是可以作为一个提醒的方式。译文应该是很长时间没维护了，因为bug被直接翻译为“臭虫”的情况屡见不鲜，但是总体上还是可以把英文原文要表达的意思说明白的。之所以放在博客，一是阅读体验，因为博客的TOC自动生成目录会使得阅读本文更加轻松；二是迁移，这类长文我认为不适合放在笔记里。主要是个人需要，所以悄悄地copy下来了，没有去要授权。原文：http://doc.zengrong.net/smart-questions/cn.html?from=singlemessage下面是正文提问前在通过电邮、新闻组或论坛提技术问题以前，做以下事情：1.尝试在你准备提问论坛的历史文档中搜索答案2.尝试搜索互联网以找到答案3.尝试阅读手册以找到答案4.尝试阅读“常见问题文档”（FAQ）以找到答案5.尝试自己检查或试验以找到答案6.尝试请教懂行的朋友以找到答案如果你是程序员，尝试阅读源代码以找到答案提问时，请先表明你已做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中 学到的东西 ，我们喜欢回答那些表现出能从答案中学习的人。运用某些策略，比如用谷歌（Google）搜索你遇到的各种错误提示（既搜索 谷歌论坛，也搜索网页）， 这样很可能直接就找到了解决问题的文档或邮件列表线索。 即使没有结果，在邮件列表或新闻组寻求帮助时提一句“我在谷歌中搜过下列句子但没有找到什么有用的东西” 也是件好事，至少它表明了搜索引擎不能提供哪些帮助。将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。别着急，不要指望几秒钟的谷歌搜索就能解决一个复杂的问题。读一下常见问题文档。在向专家提问之前，先向后靠靠放松一下，再思考一下问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑抛出，只因你的第一次搜索没有结果（或者结果太多）。认真地思考，准备好你的问题。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想 “愚蠢的问题……”，一边按将错就错的答案回复你，并且希望这种只是得到你自己“问的问题”而非真正所需的解答，给你一个教训。永远不要假设你 有资格 得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社区贡献经验，而不仅仅是消极地要求从别人那获取知识的问题，你将“挣到”答案。另一方面，表明你有能力也乐意参与问题的解决是个很好的开端。“有没有人能指个方向？”，我这还差点什么？”，“我应该查哪个网站？”，通常要比 “请给出我可以用的完整步骤”更容易得到回复，因为你表明了只要有人能指个方向，你就很乐意完成剩下的过程。提问时仔细挑选论坛要对在哪提问留心，如果你做了下述事情，多半会被一笔勾销或被看成“失败者”：张贴与论坛主题无关的问题在面向高级技术问题的论坛上张贴肤浅的问题，或者反之。在太多不同的新闻组同时张贴给既非熟人也没有义务解决你问题的人发送你私人的电邮为保护通信的渠道不被无关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想让这种事落到自己头上的。因此，第一步是找对论坛。谷歌和其它搜索引擎还是你的朋友，可以用它们搜索你遇到困难的软硬件问题最相关的项目网站。那里通常都有项目的常见问题（FAQ）、邮件列表及文档的链接。如果你的努力（包括 阅读 FAQ）都没有结果，这些邮件列表就是最后能取得帮助的地方。项目的网站也许还有报告bug的流程或链接，如果是这样，去看看。向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个内容丰富的网页的作者想充当你的免费顾问，不要对你的问题是否会受到欢迎做太乐观的估计──如果你不确定，向别处发或者压根别发。在选择论坛、新闻组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以明确你的问题是否切题。发贴前先翻翻已有的帖子，这样可以让你感受一下那里行事的方式。事实上，张贴前在新闻组或邮件列表的历史文档中搜索与你问题相关的关键词是个极好的主意，也许就找到答案了。即使没有，也能帮助你归纳出更好的问题。别象机关枪似的一次性“扫射”所有的帮助渠道，这就象大喊大叫一样会令人不快，温柔地一个一个来。弄懂主题！最典型的错误之一是在某种致立于跨平台可移植的语言、库或工具的论坛中提关于 Unix 或 Windows 操作系统程序接口的问题。如果你不明白为什么这是大错，最好在搞清楚概念前什么也别问。一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回答。有几个道理支持这点，一是看潜在的回复者有多少，二是看论坛的参与者有多少，黑客更愿回答能启发多数人的问题。可以理解，老练的黑客和一些流行软件的作者正在承受过多的不当消息。就象那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端──已经好几次了，一些流行软件的作者退出了对自己软件的支持，因为伴随而来的涌入其私人邮箱的垃圾邮件变得无法忍受。面向新手的论坛和互联网中继聊天（IRC）通常响应最快本地的用户组织或者你所用的 Linux 发行版也许正在宣传新手取得帮助的论坛或 IRC 通道（在一些非英语国家，新手论坛很可能还是邮件列表），这些地方是开始提问的好去处，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 通道是公开邀请提问的地方，通常可以得到实时的回复。事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的项目论坛或邮件列表，（否则）该项目的黑客可能仅仅回复“用 我们的 代码”。在任何论坛发贴以前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。通过论坛或 IRC 通道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发者保留。所以先在论坛或 IRC 中寻求与该项目相关的帮助。第二步，使用项目的邮件列表当某个项目存在开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文档和主页，找到项目的邮件列表并使用它。采用这种办法有几个很好的理由：向个别开发者提的问题（如果）足够好，也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为骚扰个别开发者的理由。向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导）也许太忙以至于没法回答你的问题。大多数邮件列表都要存档，那些存档将被搜索引擎索引，如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。如果一个项目既有 “用户” 也有“开发者”（或 “黑客”）邮件列表或论坛，而你又不摆弄那些代码，向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会遭受你的噪音干扰。然而，如果你 确信 你的问题不一般，而且在“用户” 列表或论坛中几天都没有回复，可以试试“开发者”列表或论坛。建议你在张贴前最好先暗暗地观察几天,至少看看最近几天保存的帖子,以了解那的行事方式（事实上这是参与任何私有或半私有列表的好主意）如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。使用有意义且明确的主题在邮件列表、新闻组或论坛中，主题是你在五十个或更少的字以内吸引有资格专家注意的黄金机会，不要用诸如 “请帮我” （更别提大写的 “请帮我！！！！”，这种主题的消息会被条件反射式地删掉）之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题描述。使用主题的好惯例是“对象──偏差”（式的描述），许多技术支持组织就是这样做的。在“对象”部分指明是哪一个或哪一组东西有问题，在“偏差”部分则描述与期望的行为不一致的地方。愚蠢：救命啊！我的笔记本视频工作不正常！明智：X.org 6.8.1 扭曲鼠标光标，MV1005 型号的某显卡芯片组更明智：使用 MV1005 型号的某显卡芯片组在 X.org 6.8.1 的鼠标光标被扭曲编写 “对象──偏差”式描述的过程有助于你组织对问题的细致思考。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在 X.org 中出现？或只是在其 6.8.1 版中？是针对某显卡芯片组？或者只是其中的 MV1005 型号？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。更一般地，想象一下在一个只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接就找到答案的线索，而不用再次发贴提问。如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象 “Re: 测试” 或者 “Re: 新bug”的消息不太可能引起足够的注意。同时，将回复中与新主题不甚相关的引用内容尽量删除。对于列表消息，不要直接点击回复（按钮）来开始一个全新的线索，这将限制你的观众。有些邮件阅读程序，比如 mutt，允许用户按线索排序并通过折叠线索来隐藏消息，这样做的人永远看不到你发的消息。仅仅改变主题还不够。mutt 和其它一些邮件阅读程序还要检查邮件头主题以外的其它信息，以便为其指定线索，所以宁可发一个全新的邮件。在论坛，因为消息与特定的线索紧密结合，并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧。不是所有论坛都允许在回复中出现分离的主题，而且这样做了基本上没有人会去看。不过，通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该线索的人读到。所以，除非你 只想 在该线索当前活跃的人群中提问，还是另起炉灶比较好。使问题容易回复以“请向……回复”来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，换个好点的；如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。在论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是敏感的（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如“留意本线索”、“有回复发送邮件”等功能。用清晰、语法、拼写正确的语句书写经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程（我敢打赌）。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将时间花在其它地方。清楚、良好地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意（你的问题）麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它 必须 很准确，而且有迹象表明你是在思考和关注问题。正确地拼写、使用标点和大小写，不要将“its”混淆为“it’s”，“loose”搞成“lose”或者将“discrete”弄成 “discreet”。不要全部用大写，这会被视为无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox [注：著名黑客，Linux 内核的重要参与者] 也许可以这样做，但你不行。）一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。也不要使用即时通讯中的简写，如将“you”简化为“u”会使你看起来象一个为了节约二次击键的半文盲式的傻子。更糟的是，如果象个小孩似地鬼画桃符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。如果在非母语论坛提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍（是的，我们通常看得出其中的差别）。同时，除非你知道回复者使用的语言，请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被阅读就被直接删除的可能性降到最低。如果你用英语书写但它是你的第二语言，最好提醒潜在的回复者语言上可能的困难以便绕过这个问题，比如：英语不是我的母语，请谅解拼写错误。如果您使用某某语言，请电邮/私聊我，也许我需要您的协助翻译我的问题。对于这个技术术语本身我很熟悉，但对于它的一些俚语或习惯表达方式就不太明白了。我已经同时用某某语及英语提问，如果您使用两者之一回复，我很乐意翻译。使用易于读取且标准的文件格式发送问题如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：使用纯文本而不是 HTML（超文本标注语言）（ 关闭HTML 并不难）使用 MIME（多用途互联网邮件扩展）附件通常没有问题，前提是真正有内容（譬如附带的源文件或补丁），而不仅仅是邮件客户端程序生成的模板（譬如只是消息内容的拷贝）。不要发送整段只是单行句子但多次折回的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的文本终端阅读邮件，设置你的行折回点小于 80 列。但是，也 不要 用任何固定列折回数据（譬如日志文件拷贝或会话记录）。数据应该原样包含，使回复者确信他们看到的是与你看到的一样的东西。在英语论坛中，不要使用’Quoted-Printable’ MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持。当它们分断时，那些文本中四处散布的 “=20”符号既难看也分散注意力，甚至有可能破坏内容的语意。永远 不要 指望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就象有人将还在冒热气的猪粪倒在你门口时你的反应一样。即使他们能够处理，也很厌恶这么做。如果你从使用视窗的电脑发送电子邮件，关闭问题颇多的微软“聪明引用”功能（在“工具” -&gt; “自动纠正选项”的“输入时自动格式化”下去掉聪明引用的选框），以免在你的邮件中到处散布垃圾字符。在论坛，勿滥用“表情符号”和“HTML”功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。如果你使用图形用户界面的邮件客户端程序(如网景公司的 Messenger、微软公司的 Outlook 或者其它类似的)，注意它们的缺省配置不一定满足这些要求。大多数这类程序有基于菜单的“查看源码”命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。描述问题应准确且有内容仔细、清楚地描述问题的症状描述问题发生的环境(主机、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：“Fedora Core 7”、“Slackware 9.1”等）描述提问前做过的研究及其理解。描述提问前为确定问题而采取的诊断步骤。描述最近对计算机或软件配置的任何相关改变。如果可能，提供在可控环境下重现问题的方法。尽最大努力预测黑客会提到的问题，并提前备好答案。如果你认为是代码有问题，向黑客提供在可控环境下重现问题的方法尤其重要。当你这么做时，得到有用且及时回复的可能性将大大增加。西蒙.泰瑟姆（Simon Tatham）写过一篇 如何有效报告bug的文章，我强烈推荐各位阅读。量不在多，精炼则灵你应该（写得）精炼且有内容，简单地将一大堆代码或数据罗列在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝试将其裁剪得越小越好。至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到 有用的 回复。第三，在提纯bug报告的过程中，你可能自己就找到了解决办法或权宜之计。别急于宣称找到bug当你在一个软件中遇到问题，除非你 非常、非常 的有根据，不要动辄声称找到了bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你（声称）发现了文档的“bug”，你应该能提供相应位置的替代文本。记住，还有许多其它用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时就应该发现了（你在报怨前已经做了这些，是吧 ？）。这也意味着很有可能是你弄错了而不是软件本身有问题。编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了bug，也就置疑了他们的能力，即使你是对的，也有可能会使其中的部分人感到不快。（此外，）在主题中嚷嚷“bug”也是特别不老练的。提问时，即使你私下非常确信已经发现一个真正的bug，最好写得像是你做错了什么。如果真的有bug，你会在回复中看到这点。这样做的话，如果真的有bug，维护者就会向你道歉，这总比你弄砸了然后欠别人一个道歉要强。低声下气代替不了做自己的家庭作业有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端：“我知道我只是个可怜的新丁，一个失败者，但……”。这既使人困扰，也没有用，当伴随着对实际问题含糊的描述时还特别令人反感。别用低级灵长类动物的办法浪费你我的时间，相反，尽可能清楚地描述背景情况和你的问题，这比低声下气更好地摆正了你的位置。有时，论坛设有单独的初学者提问版面，如果你真的认为遇到了肤浅的问题，到那去就是了，但一样别低声下气。描述问题症状而不是猜测告诉黑客是什么导致了问题是没用的（如果你的诊断理论是了不起的东西，你还会向别人咨询求助吗？）。所以，确保只是告诉他们问题的原始症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述自己的猜测很重要，应清楚地说明这只是你的猜测并描述为什么它们不起作用。愚蠢：我在编译内核时接连遇到 SIG11 错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？明智：我组装的电脑（K6/233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机 20 分钟左右、做内核编译时频繁地报 SIG11 错，但在头 20 分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问题，相关的典型编译会话日志附后。由于以上这点许多人似乎难以掌握，这里有句话可以提醒你：“所有的诊断专家都来自密苏里州”。美国国务院的官方座右铭则是“让我看看”（出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：“我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。”）针对诊断者而言，这并不是怀疑，而只是一种真实而有用的需求，以便让他们看到与你看到的原始证据尽可能一致的东西，而不是你的猜测与总结。（所以，）让我们看看。按时间先后罗列问题症状刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你、电脑和软件在崩溃前都做了什么。在命令行处理的情况下，有会话日志（如运行脚本工具生成的）并引用相关的若干（如20）行记录会非常有帮助。如果崩溃的程序有诊断选项（如-v详述开关），试着选择这些能在记录中增加排错信息的选项。记住，“多”不等于“好”。试着选取适当的排错级别以便提供有用的信息而不是将阅读者淹没在垃圾中。如果你的记录很长（如超过四段），在开头简述问题随后按时间先后罗列详细过程也许更有用。这样，黑客在读你的记录时就知道该注意哪些内容了。描述目标而不是过程如果你想弄清楚如何做某事（而不是报告一个bug），在开头就描述你的目标，然后才陈述遇到问题的特定步骤。经常出现这种情况，寻求技术帮助的人在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身有问题，结果要费很大的劲才能通过。愚蠢：我怎样才能让某图形程序的颜色拾取器取得十六进制的 RGB 值？明智：我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的 RGB 值。第二种提法是明智的，它使得建议采用更合适的工具以完成任务的回复成为可能。别要求私下回复电邮黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为回复者也因为能力和学识被其它同行看到而得到某种回报。当你要求私下回复时，此过程和回报都被中止。别这样做，让 回复者 来决定是否私下回答──如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人毫无意义。对这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么“向我发电邮，我将为论坛归纳这些回复”将是神奇的句子。试着将邮件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你必须信守诺言。提问应明确漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人（假如只是因为他们承担了太多工作的话），这些人对于没有止境的时间无底洞极其敏感，所以他们也倾向于讨厌那些漫无边际的问题。如果你明确了想让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力并间接地设定了他们为帮助你需要花费的时间和精力上限，这很好。要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很忙的专家那里得到解答。所以限定你的问题以使专家回答时需要付出的时间最少──这通常与简化问题还不太一样。举个例，“请问可否指点一下哪有好一点的 X 解释？”通常要比“请解释一下 X”明智。如果你的代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。关于代码的问题别要求他人给你出问题的代码排错而不提及应该从何入手。张贴几百行的代码，然后说一声“它不能运行”会让你得不到理睬。只贴几十行代码，然后说一句“在第七行以后，本应该显示，但实际出现的是”非常有可能让你得到回复。最精确描述代码问题的方法是提供一个能展示问题的最小测试样例。什么是最小测试样例？它是对问题的展现，只需要刚好能够重现非预期行为的代码即可。如何生成一个最小测试样例？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样例（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源码并去除那些与问题无关的代码段。你能提供的最小测试样例越小越好（参见 量不在多，精炼则灵 ）。生成一个非常小的最小测试样例并不总是可能，但尽力去做是很好的锻练，这有可能帮助你找到需要自己解决的问题。即使你找不到，黑客们喜欢看到你努力过，这将使他们更合作。如果你只是想让别人帮忙审一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。别张贴家庭作业式问题黑客们善于发现“家庭作业”式的问题。我们中的大多数人已经做了自己的家庭作业，那是该 你 做的，以便从中学到东西。问一下提示没有关系，但不是要求完整的解决方案。如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户组、论坛或（作为最后一招）在项目的“用户”邮件列表或论坛中提问。尽管黑客们 会 看出来，一些老用户也许仍会给你提示。删除无意义的要求抵制这种诱惑，即在求助消息末尾加上诸如“有人能帮我吗？”或“有没有答案？”之类在语义上毫无意义的东西。第一，如果问题描述还不完整，这些附加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如“是的，你可以得到帮助”和“不，没有给你的帮助”。一般来说，避免提“是或否”类型的问题，除非你想得到 “是或否”类型的回答。不要把问题标记为“紧急”， 即使对你而言的确如此这是你的问题，不要我们的。宣称“紧急”极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关照。而且“紧急”或其它有类似含义的主题有可能触发垃圾过滤规则，潜在的回复者可能永远看不到你的问题！有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌地提到这点，人们也许会有足够的兴趣快一点回答。当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原因这样做几乎肯定不行。事实上，张贴诸如“紧急：帮我救救这个毛绒绒的小海豹！”肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄懂了再发贴也不迟。礼貌总是有益的礼貌一点，使用“请”和“谢谢你的关注”或者“谢谢你的关照”，让别人明白你感谢他们无偿花时间帮助你。坦率地讲，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要（同时也不能替代它们）。黑客们一般宁可读有点唐突但技术鲜明的bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价它的）然而，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。（我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的“提前谢了”，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的建议是要么先说 “提前谢了”，事后 再 对回复者表示感谢，要么换种方式表达，譬如用“谢谢你的关注”或“谢谢你的关照”）。问题解决后追加一条简要说明问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比较恰当。最理想的方式是向最初提问的线索回复此消息，并在主题中包含“已解决”、“已搞定”或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见线索 “问题 X”和“问题 X-已解决”的潜在回复者就明白不用再浪费时间了（除非他个人觉得“问题 X”有趣），因此可以利用此时间去解决其它问题。追加的消息用不着太长或太复杂，一句简单的“你好──是网线坏了！谢谢大家──比尔”就比什么都没有要强。事实上，除非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。对于有深度的问题，张贴排错历史的摘要是恰当的。描述问题的最终状态，说明是什么解决了问题，在此之后 才指明可以避免的弯路。应避免的弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。最后，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题叙述到最后不知所终总是令人沮丧的，黑客们痒痒地渴望它们被解决。“挠痒痒”为你挣到的信誉将对你下次再次张贴提问非常非常的有帮助。考虑一下怎样才能避免他人将来也遇到类似的问题，问问自己编一份文档或 FAQ 补丁会不会有帮助，如果是的话就将补丁发给维护者。在黑客中，这种良好的后继行动实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。如何解读回答“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸有一个古老而神圣的传统：如果你收到“读读该死的手册”（RTFM） 的回复，发信人认为你应该去“读读该死的手册”。他或她多半是对的，去读一下吧。“读读该死的手册”（RTFM）有个年轻一点的亲戚，如果你收到“搜搜该死的网络”（STFW）的回复，发信人认为你应该“搜搜该死的网络”。那人多半也是对的，去搜一下吧。(更温和一点的说法是“谷歌是你的朋友！”)在论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种关照，提问前应该先搜索一下文档。通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息很容易找到。第二，自已找要比别人喂到嘴里能学得更多。你不应该觉得这样就被冒犯了，按黑客的标准，回复者没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。如果还不明白……如果你看不懂回答，不要马上回复一个要求说明的消息，先试试那些最初提问时用过的相同工具（如手册、FAQ、网页、懂行的朋友等）试着搞懂回答。如果还是需要说明，展现你已经明白的。譬如，假如我告诉你：“看起来象是某输入项有问题，你需要清除它”，接着是个 不好 的回帖：“什么是某输入项？”。而这是一个 很好 的跟帖：“是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？”对待无礼很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱的人是很自然的。如果你觉得被冒犯了，试着平静地反应。如果有人真的做了过格的事，邮件列表、新闻组或论坛中的前辈多半会招呼他。如果这 没有 发生而你却光火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而 你 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外来者，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。（有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，缺少用于润滑人类社会“正常”交往所需的脑电路。这既可能是真也可能是假。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们 喜欢 现在这个样子，并且一般都对病号标记有站得住脚的怀疑。）在下一节，我们会谈到另一个问题，当 你 行为不当时会受到的“冒犯”。别像失败者那样反应在黑客社区的论坛中有那么几次你可能会搞砸──以本文描述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反，你该这样去做：熬过去，这很正常。事实上，它是有益健康与恰当的。社区的标准不会自己维持，它们是通过参与者积极而 公开 地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称“如果你不想帮助用户就闭嘴”。有思路的参与者纷纷离开的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。是夸张的“友谊”（以上述方式）还是有用？挑一个。记着：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要容易得多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃那样对你。有时候，即使你没有搞砸（或者只是别人想象你搞砸了）， 有些人也会无缘无故地攻击你本人。在这种情况下，报怨倒是 真的 会把问题搞砸。这些找茬者要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些找茬者在给自己找麻烦，这点你不用操心。也别让自己卷入口水战，大多数口水战最好不要理睬──当然，是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其中之后（这也是可能的）。提问禁忌下面是些典型的愚蠢问题和黑客不回答它们时的想法。问：我到哪可以找到某程序或 X 资源？问：我怎样用 X 做 Y？问：如何配置我的 shell 提示？问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？问：我的{程序、配置、SQL 语句}不运行了问：我的视窗电脑出问题了，你能帮忙吗？问：我的程序不运行了，我认为系统工具X有问题问：我安装 Linux 或 X 遇到困难，你能帮忙吗？问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？问：我到哪可以找到某程序或 X 资源？答：在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 谷歌 吗？问：我怎样用 X 做 Y？答：如果你想解决的是 Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对要解决的 Y 问题糊涂，还被特定形势禁锢了思维。等他们把问题弄好再说。问：如何配置我的 shell 提示？答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 “读读该死的手册”（RTFM），然后自己去找出来。问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？答：试试就知道了。如果你试过，你既知道了答案，又不用浪费我的时间了。问：我的{程序、配置、SQL 语句}不运行了答：这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下：你还有什么补充吗？噢，太糟了，希望你能搞定。这跟我究竟有什么关系？问：我的视窗电脑出问题了，你能帮忙吗？答：是的，把视窗垃圾删了，装个象 Linux 或 BSD 的开源操作系统吧。注意：如果程序有官方的视窗版或者与视窗有交互(如 Samba)，你 可以 问与视窗相关的问题，只是别对问题是由视窗操作系统而不是程序本身造成的回复感到惊讶，因为视窗一般来说太差，这种说法一般都成立。问：我的程序不运行了，我认为系统工具 X 有问题答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文档作后盾。问：我安装 Linux 或 X 遇到困难，你能帮忙吗？答：不行，我需要亲手操作你的电脑才能帮你排错，去向当地的 Linux 用户组寻求方便的帮助（你可以在 这里 找到用户组列表）注意：如果安装问题与某 Linux 发行版有关，在针对 它 的邮件列表、论坛或本地用户组织中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 “linux”和 所有 被怀疑的硬件 [作关键词] 仔细搜索。问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？答：想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。好问题与坏问题最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。愚蠢：我在哪能找到关于 Foonly Flurbamatic 设备的东西？这个问题在乞求得到 “搜搜该死的网络”（STFW） 式的回复。明智： 我用谷歌搜索过“Foonly Flurbamatic 2600”，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。愚蠢： 我不能编译某项目的源代码，它为什么这么破？提问者假设是别人搞砸了，太自大了。明智： 某项目的源代码不能在某 Linux 6.2 版下编译。我读了常见问题文档，但其中没有与某 Linux 相关的内容。这是编译时的记录，我做错了什么吗？提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，这家伙值得注意。愚蠢： 我的主板有问题，谁能帮我？某黑客对此的反应可能是：“是的，还需要帮你拍背和换尿布吗？”，然后是敲下删除键。明智： 我在 S2464 主板上试过 X、Y 和 Z，当它们都失败后，又试了 A、B 和 C。注意我试 C 时的奇怪症状，显然某某东西正在做某某事情，这不是期望的行为。通常在 Athlon MP 主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？相反地，这个人看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。在最后那个问题中，注意“给我一个回答”与“请帮我看看我还能再做点什么测试以得到启发”之间细微但重要的差别。事实上，最后那个问题基本上源于 2001 年 8 月 Linux 内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。事后，当我感谢大家并评论这次良好的经历时，一个 Linux 内核邮件列表的成员谈到，他认为我得到答案并不是因为我的名字挂在列表上，而只是因为我正确的提问方式。黑客们在某种方面是非常不留情面的精英分子。我想在这事上他是对的，如果我 表现得 象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。如果得不到回答如果得不到回答，请不要认为我们不想帮你，有时只是因为被问到的小组成员的确不知道答案。没有回复不等于不被理睬，当然必须承认从外面很难看出两者的差别。一般而言，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。有许多在线与本地的用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。还有众多大小商业公司提供签约支持服务，别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。象 Linux 这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。如何更好地回答态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 FAQ 都不知道。如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。如果帮不了忙，别妨碍。 不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。探索性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。尽管对那些懒虫报怨一声“读读该死的手册”（RTFM）是正当的，指出文档的位置（即使只是建议做个谷歌关键词搜索）会更好如果你决意回答，给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。请回答真正的问题！如果提问者已经做了自己该做的研究，并且说明尝试过X，Y，Z，A，B与C都没有得到想要的結果，那么回复“试试A或B” 或者给出一个内容为 “试一下X，Y，Z，A，B或C”的链接将极其无益！帮助你的社区从中学习。当回复一个好问题时，问问自己 “如何修改相关文件或 FAQ 文档以免再次解答同样的问题？”，接着再向文档维护者发一份补丁。如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟“授人以鱼，不如授人以渔”。补充(XY Problem)：What is it?The XY problem is asking about your attempted solution rather than your actual problem. This leads to enormous amounts of wasted time and energy, both on the part of people asking for help, and on the part of those providing help.User wants to do X.User doesn’t know how to do X, but thinks they can fumble their way to a solution if they can just manage to do Y.User doesn’t know how to do Y either.User asks for help with Y.Others try to help user with Y, but are confused because Y seems like a strange problem to want to solve.After much interaction and wasted time, it finally becomes clear that the user really wants help with X, and that Y wasn’t even a suitable solution for X.The problem occurs when people get stuck on what they believe is the solution and are unable step back and explain the issue in full.What to do about it?Always include information about a broader picture along with any attempted solution.If someone asks for more information, do provide details.If there are other solutions you’ve already ruled out, share why you’ve ruled them out. This gives more information about your requirements.Remember that if your diagnostic theories were accurate, you wouldn’t be asking for help right?]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于dom对象和jq对象的疑问]]></title>
    <url>%2F2019%2F02%2F18%2FF-jq%E5%AF%B9%E8%B1%A1%E5%92%8Cdom%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1.问题：1.1 问题提出：想要使所有div下的p标签的类名+1.因此采用下列办法： &lt;div> &lt;p class="1">1&lt;/p> &lt;p class="2">2&lt;/p> &lt;p class="3">3&lt;/p> &lt;p class="4">4&lt;/p> &lt;p class="5">5&lt;/p> &lt;/div> &lt;script src="https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js">&lt;/script> &lt;script> var allp=$("div p"); for(var i=0;i&lt;allp.length;i++){ allp[i].attr("class","i+2"); console.log(allp[i].attr("class")); } &lt;/script> 结果控制台报错：提示allp[i].attr()不是一个方法，而attr()是jq对象的方法，这个报错等于说allp[i]不是一个jq对象。参考stackoverflow ，可知$()[i]返回的的确不是jq对象，而是原生dom对象，无法使用jq方法attr() 。关于如何判断是jq对象还是dom对象，可以用常用的instanceof方法判断，也可以用只有jq对象才有的jquery属性结合if语句判断。那么，如何用jq实现上诉功能？1.2 问题解决：1）转化为jq对象for(var i=0;i&lt;allp.length;i++){ $(allp[i]).attr("class",i+2); } allp[i]放在$()中则为jq对象2).eq(i)for(var i=0;i&lt;$("div p").length;i++){ $("div p").eq(i).attr("class",i+2) 。 } 这是因为jq collection 对象的eq()方法将返回以参数值为索引值的单个元素.3).each遍历$("div p").each(function(){ $(this).attr("class",$(this).index()+2); }) 当然，因为each()本身可以传参，因此可以写成$("div p").each(function(i, n){ $(this).attr("class",i+2); }) 其中，i表示index，n表示当前元素（可用this操作）4).或者更简单的，配合回调函数使用for(var i=0;i&lt;$("div p").length;i++){ $("div p").attr("class"，function(i,n){ n=+2; }) } 以上是个错误的例子。jq本身可以隐式迭代，所以这里的for循环完全是多余的，加了for循环反而是错的。隐式迭代：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用在attr中将回调函数作为参数时，回调函数本身接受两个参数。具体到例子中，i为index，n为当前元素的当前值，也就是类名，这里的类名虽然为1到5，但是是string而不是number，所以需要用number( )进行类型转换才可以运算。n最后必须return。综上，正确代码为var allp=$("div p"); allp.attr("class",function(i,n){ return Number(n)+1; }); each( )遍历，控制台打印allp.each(function(){ console.log(this); }); 2 对象转换：顺便这里总结下jq对象和dom对象的互相转换。我们知道，dom对象只能用dom对象自己的方法，jq对象只能用jq对象自己的方法，因此有时候如果jq对象必须使用原生方法时（或者反过来），就需要进行对象转换。2.1 jq对象 = &gt; dom对象var $div=$(".div"); //jq对象 // 或者加索引值返回dom对象单体 var div=$div[0]; // 调用get()方法返回dom对象单体 var div=$div.get(i); 2.2 dom对象 = &gt; jq对象var div=documnet.getElementsByClassName("div"); //dom对象 // 直接用$()把dom对象给包装起来 var $div=$(div); // 如果需要，可以用eq()返回jq对象单体 // $div.eq(i);]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量命名规范]]></title>
    <url>%2F2019%2F02%2F12%2FF-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[一、驼峰命名法：①全部小写：变量名中的每一个逻辑断点/每个单词都用下划线隔开。比如：print_employee_paychecks()；②大小写混合：1）小驼峰法：变量一般用小驼峰法标识。第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，例如：myFirstName、myLastName2）大驼峰法/帕斯卡命名法（Upper Camel Case/pascal）：常用于类名，函数名，属性，命名空间。相比小驼峰法，大驼峰法把第一个单词的首字母也大写了。例如：DataBaseUser二、匈牙利命名法：基本原则是：变量名=类型+对象描述。匈牙利命名法关键是：标识符的名字以一个或者多个小写字母开头作为前缀；前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。匈牙利命名法通过在变量名前面加上相应的小写字母的符号标识作为前缀，标识出变量的作用域，类型等。这些符号可以多个同时使用，顺序是先m_（成员变量），再指针，再简单数据类型，再其他。例如：m_lpszStr, 表示指向一个以0字符结尾的字符串的长指针成员变量。匈牙利命名法中常用的小写字母的前缀：前缀 类型a – – — – – —— —————– 数组 (array)b ———————————- 布尔值 (boolean)by———————————- 字节 (byte)c ———————————- 有符号字符 (char)cb ————————– 无符号字符 (char Byte，没有多少人用)cr ———————————- 颜色参考值 (colorRef)fn ———————————- 函数 （function）fl ———————————- 浮点（float）h ———————————- 句柄（handle）i ———————————- 整型 （int）l ———————————- 长整型 (long Int)lp———————————- 长指针（long Pointer）m ———————————- 类的成员 （member）n———————————- 短整型 (short Int)np ———————————- 近指针（near Pointer）o ———————————- 对象（object）p ———————————- 指针（pointer）re ——————————— 正则（regular expression）s ———————————- 字符串型 （string）sz ————————— 以null做结尾的字符串型 (String with Zero End)]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null和undefined]]></title>
    <url>%2F2019%2F02%2F12%2FF-null%E5%92%8Cundefined%2F</url>
    <content type="text"><![CDATA[一. undefined在变量声明中的体现：1）声明了、但是没有初始化的变量：var aa; alert(aa); 浏览器会弹出窗口显示 undefined。因为对于使用了 var 声明但没有进行初始化定义的变量, 其值默认为 undefined.2） 未声明的变量(1)：alert(aa); 浏览器不会弹出任何东西. 因为 aa 是没有声明的变量。打开 chrome 浏览器的控制台会看到报错如下：3）未声明的变量(2)：alert(typeof aa); 浏览器会弹出窗口显示 undefined。对于没有声明的变量, 只能执行一种操作，即使用 typeof 操作符检验它的类型.。它的类型和声明了但没有进行初始化的变量的类型一样, 都是 undefined.二. null和undefined：alert(undefined == null); // 返回 true 对于undefined 和null 的相等性测试，返回 true,如上图。这是因为，undefined是由null派生而来的。但是，这两者差别很大，之所以要设置两个值，让我们从历史原因说起吧1）历史原因：1995年js诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象；其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。因此，Brendan Eich又额外设计了一个undefined。2）最初设计：JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。Number(undefined) // NaN 5 + undefined // NaN 3）目前的用法：但是，上面这样的区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。①nullnull是基本数据类型之一，值仅有一个，即为null。表示”空对象”(因此类型检测返回对象)，即如果有对象，就会是一个具体的对象，如果没对象，就是null。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。Object.getPrototypeOf(Object.prototype) // null typeof null // object 如果定义的变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子：if(abc != null){ //对abc执行某些操作 } ②undefinedundefined是基本数据类型之一，值仅有一个，即为undefined。表示”缺少值”(因此类型检测返回undefined)，即此处应该有一个值，但是还没有定义。典型用法是：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。var i; i // undefined function f(x){console.log(x)}f() // undefined var o = new Object(); o.p // undefined var x = f(); var exp = undefined; 8x // undefined ③如何检测某个变量是undefined：错误的用法：if(abc==undefined) // 正如上面所说，js规定用== 判断时，null和undefined是等同的正确的用法：if (typeof(abc) `==` &quot;undefined&quot;) 或者最简单的办法：if(abc===undefined) 注意！！！ type的用法有运算符形式和函数形式，即if (typeof(abc) == “undefined”) 和 if (typeof abc == “undefined”) 效果是一样的。另外，由于typeof会返回诸如”number”的字符串形式的结果，因此==的右操作数应注意加双引号表示字符串。④如何检测某个变量是null：错误的用法：1、if(abc == null)// 解释同上。不过：要判断abc是 null 或者 undefined 时可使用本法。2、if ( !abc)// 这个的原理是：abc为假值，则 ! abc为真值，条件成立。然而，假值也可能是undefined，0 或 false。不过：要判断 abc是null、undefined、0 或者false 时可使用本法。3、if(typeof abc == &quot;null&quot;)// 为了向下兼容，abc 为 null 时，typeof null 总返回 object，所以不能这样判断。4、 if ( isNull (abc) )// VBScript 中有 IsNull 这个函数，但 JavaScript 中没有。=============================================================================正确的方法：1、 if (! abc &amp;&amp; typeof abc != &quot;undefined&quot; &amp;&amp; abc != 0)// 这个的原理是：如果！abc 成立，则 abc 为假值，则 abc 要么是undefined，0，false或者null 。typeof abc!= “undefined” 排除了 undefined；exp != 0 排除了0 和 false （0= =false，0= =0）。所以，abc一定是剩下的null。2、最简单的方法： if (abc=== null) 尽管如此，我们在 DOM 应用中，一般只需要用 (! abc) 来判断就可以了，因为 DOM 应用中，可能返回 null，可能返回 undefined，如果具体判断 null 还是 undefined 会使程序过于复杂。三. 测试对象是否存在：在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法。对象只有被定义才有可能为 null，否则为 undefined。因此，如果我们想测试对象是否存在，必须先检测对象是否已定义。因此，这是错误的：if (abc !== null &amp;&amp; typeof abc !== “undefined”)这是正确的：if (typeof abc !== &quot;undefined&quot; &amp;&amp; abc!== null)]]></content>
      <categories>
        <category>Front-end</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英伦摇滚入门：20支英国摇滚乐队]]></title>
    <url>%2F2019%2F02%2F11%2FM-%E8%8B%B1%E4%BC%A6%E6%91%87%E6%BB%9A%E5%85%A5%E9%97%A8%EF%BC%9A20%E6%94%AF%E8%8B%B1%E5%9B%BD%E6%91%87%E6%BB%9A%E4%B9%90%E9%98%9F%2F</url>
    <content type="text"><![CDATA[之前看到的一篇关于英国摇滚乐队的总结。还挺好的，不全是英伦摇滚。排名不分先后，当然，我还是偏爱Oasis。1. The Beatles（披头士乐队/甲壳虫乐队）这支才华横溢的英国乐队就不用多说了，几乎是英国摇滚的代名词，屹立半个世纪不倒，他们的作品现在还传颂世界。The Beatles（披头士乐队）虽然早已不复存在，但是他们却奠定了英式摇滚的基本基调，在国际音乐界享有盛誉。他们的贵族式的优雅反击直击摇滚的核心精神：为普通人发出声音和呐喊。爱和自由、反战是披头士永恒的创作主题。披头士有两位灵魂人物，一位是John Lennon（约翰·列侬），一位是James Paul McCartney（保罗·麦卡特尼）。喜欢这支乐队的朋友可以看看乐评《最爱那一世的疯狂——“披头士热”下的英伦风情》经典专辑：《Sergeant Pepper’s Lonely Hearts Club Band》、《Abbey Road》、《Let It Be》、《Rubber Soul》、《Help!》2. The Rolling Stones（滚石乐队）The Rolling Stones（滚石乐队）是一支非常长寿的英国摇滚乐队，一直活跃在英国的摇滚乐坛，他们和披头士分庭抗礼，代表着两种不同的摇滚理念：披头士是温和的、优雅的，而滚石则是纯粹的、爆裂性的。滚石乐队成员的平均年龄已经超过了70岁，堪称英国摇滚界的活国宝，他们身先士卒证明了什么叫“老骥伏枥，志在千里”。几个“老头子”处处践行着不服老的摇滚心态，依然能够在舞台上大放光彩，不断推出新作，这才是真正的摇滚精神！绝对的硬摇滚，粗放豪气的摇滚范儿，祝福这支长寿的乐队！经典专辑：《Let It Bleed》、《Beggars Banquet》、《Exile On Main Street》3. The Who（谁人乐队）作为“布兰顿之声”的The Who（谁人乐队），他们代表着反叛与反主流的音乐风格，他们是MOD文化的代言人，四人个性放荡不羁，反叛而激进，为青年而歌，为底层人民而歌。正是The who发明了摇滚乐的砸琴砸摔鼓的表演风格，他们是纯粹硬摇乐队，是反叛的象征，他们的舞台表演风格为后世许多的摇滚乐队所模仿。The Who创造了许多的经典歌曲，至今无人能够超越。经典专辑：《Who’s Next》、《Tommy》、《My Generation》4. The Police（警察乐队）想听慢摇风格的乐迷看过来，这支乐队非常具有传奇色彩，他们靠着借贷创作的第一张专辑就大卖一万多张。他们的乐队风格有一种华丽的英式抒情的感觉，感觉主唱的爆破音特别重，他们的歌曲特别有感染力，另外主唱Sting还会唱西班牙语，非常多才多艺。这支乐队只有三个人，但是曾经获得了六次格莱美奖，乐队在义演散场之后宣布告别，但是灵魂人物Sting现在还活跃在英国乐坛之上，还多次斩获格莱美。经典专辑：《Regatta de Blanc》、《Zenyatta Mondatta》、《Wrapped Around Your Finger》5. Pink Floyd（平克·弗洛伊德）大PF是必须要说的，促使我去了解英国摇滚乐队的就是披头士和Pink Floyd（平克·弗洛伊德）了，PF不算是那种非常有盛誉的那种乐队，但是我就是喜欢。他们的音乐充满哲学的思辨气质和浪漫主义的想象力，专辑的艺术感极强，尤其是他们开创的太空迷幻摇滚，简直是致幻的LSD，令人沉醉其中不能自拔。他们在音乐技术上的突破和对迷幻摇滚新领域的开辟，都在音乐史上不可被磨灭，这支乐队有一支长达23分钟的神奇的单曲——《Echoes》，号称一曲走天下，他们的《月之暗面》（The Dark Side of The Moon）和《迷墙》（The Wall）两张专辑永垂不朽。某种程度上来说，我甚至觉得他们是一支被低估了的乐队。经典专辑：《The Wall》、《The Dark Side of the Moon》、《Ummagumma》6. Sex Pistols（性手枪乐队）要说到英国的朋克摇滚，就必须要说到Sex Pistols，在1976年，性手枪参加了伦敦牛津The 100俱乐部举办的朋克音乐节，至今这个节日还被认为是朋克文化的发源地。这是一支真正的朋克乐队，有人甚至评价道：“性手枪之后再无朋克”，如果你去听了他们的音乐，就会发现这是真的。他们的音乐充满了黑色幽默和调侃，歇斯底里的反叛甚至是下流的感觉，但这就是真正的朋克精神——彻底的毁灭与自我毁灭。他们的歌曾经登上了BBC排行榜榜首，让全英国人民都为朋克摇旗呼喊，让朋克文化高涨兴盛。但是这支乐队好景不长，他们连换了三个唱片公司，但乐队成员相继离开，最终没落令人十分惋惜。经典专辑：《Jubilee》、《Never Mind the Bollocks Here’s the Sex Pistols》7. The Clash（碰撞乐队/冲击乐队/冲撞乐队）与性手枪相比，The Clash并不算是真正的朋克乐队，因为他们后期逐渐商业化，但是The Clash前期对朋克摇滚做出了巨大的贡献。他们的首张同名专辑就一炮成名，被封为朋克圣典。但是后期的碰撞乐队逐渐吸收了许多的流行摇滚的元素，他们的MTV商业运作得很好。The Clash与Sex Pistols一起铸就了朋克乐队的高峰。碰撞关注社会底层人民的生活状况，他们的歌曲里面充满了对失业、种族歧视和黑帮犯罪势力的反抗和控诉，而且碰撞乐队在美国市场上还比较成功，让英国朋克摇滚名声在外。经典专辑：《London Calling》、《The Clash》、《Black Market Clash》8. Iron Maiden（铁娘子乐队）重金属恶魔的铁娘子乐队！生猛的铁娘子！牛逼的铁娘子！正是他们开启了英国的重金属浪潮。他们是一支霸气的重金属乐队，乐队几经分合，但是做了很多的音乐新领域的尝试，他们做了很多摇滚器乐实验，奠定了铁娘子在重金属领域中的地位。Iron Maiden的曲风非常硬朗，听得人情绪高涨，不自觉地High，主唱的声音简直是绝对的歇斯底里，他们的吉他行云流水，贝斯出神入化，想感受下重金属激情的迷妹一定要去听一下，没听过他们你都不好意思说你听过重金属。经典专辑：《Killers》、《Piece Of Mind》、《Iron Maiden》、《Number of the Beast》9. Def Leppard（威豹乐队）威豹也是英国重金属新浪潮中一支非常重要的乐队，这支乐队70年代末期组建，80年代成名，他们在硬摇滚上造诣很高。80-90年代期间是他们商业最成功的阶段，在美国都具有广泛的影响力。威豹也不是那种纯粹的重金属乐队，他们的情歌非常的好听感人，主唱Joe Elliott的声音是略带沧桑的沙哑，这些摇滚汉子唱起情歌分分钟秒杀你的心灵。另外乐队的长发造型很酷炫，而且他们是双吉他演奏，节奏非常动人优美。这个乐队最令人感动的是鼓手，只有一条手臂还怀着一颗坚毅的心重返乐队，我很敬佩这样牛逼的音乐人。另外他们的合声也是相当美丽的，很少有摇滚乐队合声如此好听，默契到位又流畅自然，分分钟刷新你的重金属三观。经典专辑；《Best of Def Leppard》、《Hysteria》、《Retro Active》10. Suede（山羊皮乐队）Suede（山羊皮乐队）在90年代非常受欢迎，一开始这支乐队其实是倍受质疑的，后来才受到了大众的喜爱。他们的风格是另类摇滚和英式摇滚。这和当时的摇滚大环境有关，90年代，英国传统摇滚乐的巅峰已经接近末声，演化出了英式摇滚，Suede其实就是这些乐队之一。他们的风格比较邪魅狂绢，充满了一种癫狂和风情万种的艺术气质，主唱的声音听多了会怀孕的。山羊皮对华挺友好的，曾经来过中国演出。还有令无数歌迷沉醉的还有主唱的颜值——他年轻的时候简直帅呆了！经典专辑：《The Drowners》、《Suede》、《Coming Up》、《Head Music》11. Oasis（绿洲乐队）Oasis（绿洲乐队）组建于曼彻斯特，是一支个性狂放的乐队，这和乐队的两兄弟的性格有关系。这支乐队最好的地方在于结合了流行摇滚与传统摇滚，传承了传统摇滚的精髓，乐评家非常钟爱这支乐队，对他们给予很高的评价。一说到英式摇滚人们首先会想到就是绿洲，其次是Blur，他们的吉他简直是神了，奠定了英式摇滚的吉他抒情风格。但是他们也叛逆咆哮，这完全不同于像披头士那样的“乖小孩”，自带一种粗犷的摇滚天性。经典专辑：《Definitely Maybe》、《Morning Glory》12. Radiohead（电台司令乐队）Radiohead（电台司令）是那种让人绝望抑郁至死的乐队，个人觉得偶尔听一下还是不错啦。这支乐队的评价还是蛮好的，他们的风格很沉郁，在歌词的创作上独具匠心。灵魂人物兼主唱Yorke性格敏感脆弱，他们的作品里充满了一种病态美学的美感，吟唱人性最卑微脆弱之处，像《Creep》这种就是他们风格的集大成之作，这种风格在摇滚乐队里是比较少见的。经典专辑：《The Bends》、《OK Computer》、《 Kid A 》13. Muse（缪斯乐队）多元的音乐风格、对英式摇滚拿捏到刚刚好的新生代英国摇滚乐队。融合重金属、电子音乐、前卫音乐、太空摇滚等等元素。更难得的是，从缪斯的歌曲里你还能听出千丝万缕的英国古典音乐气息，就像灵魂一样穿插在乐曲之中，非常特别，这在英国这样一个复古气息非常浓厚的国家非常有代表性，所以我认为他们的英式摇滚的头衔是应得的。有人说缪斯主唱Bellamy的唱腔和Yorke很像，细听确实有一点，都有一种浅唱低吟的感觉，但是Bellamy更加积极魅惑一点，不似Yorke给人彻彻底底地绝望之感。经典专辑：《Black Holes and Revelations》、《Absolution》、《The 2nd Law》14. Blur（模糊乐队/布勒乐队/污点乐队）这支乐队和绿洲一起是一个神奇的存在，最为乐迷津津乐道的就是Blur（模糊乐队）与绿洲的掐架了，因为他们的风格挺像的，都是英式摇滚路线。但是我觉得模糊乐队没有像绿洲那样的狂放个性，显得更加的温和内敛，所以这支乐队被认为具有披头士的神韵。很多人评价一支乐队经常说某某乐队是某某乐队的接班人，我其实并不喜欢这种评价，乐队和乐队之间是一种传承和学习的关系，但是每个乐队都是一个独立的个体，所以我觉得披头士是披头士，Blur是Blur。近几年Blur做了一些比较诡异的尝试，风格越来越让人摸不透了，不过有了自己的经典之作之后，他们想做一些新的突破也是非常勇敢的。经典专辑：《The Best Of Blur》、《The Great Escape》、《Parklife》15. Travis（特拉维斯乐队）这是来自苏格兰的一支传统摇滚乐队，他们涉足英式摇滚、传统摇滚、Post-Grunge与另类摇滚多个领域。乐队成员都是70后，他们最开始只是一个小地方的乐团，发行第二张专辑之后难掩才华，一时间成为英国摇滚乐坛巨星。其实我觉得主唱的声线是比较忧郁的，唱歌的方式有点浅唱低吟的感觉。他们也尝试过软摇滚，总之是一支听起来比较舒服的乐队。经典专辑：《The Man Who》、《Side》、《Pipe Dreams》16. Queen（皇后乐队）一支华丽丽的硬摇乐队，作品具有浓厚的歌剧色彩，非常硬，乐队的歌曲都保留了那种老式硬摇滚的精髓，键盘和完美的吉他Solo是他们的特点。主唱Freddie Mercury的声音是摇滚乐坛少有的好嗓，非常高亢嘹亮，天生是摇滚主唱的料，这也给皇后乐队注入了一种恢弘而大气磅礴的音乐感染力，但Freddie Mercury不幸因染上艾滋病辞世，全球歌迷为之震惊心痛。在失去这位灵魂人物之后，皇后乐队还是人气高涨，不断出了好作品，最终被选入摇滚名人堂。经典专辑：《A Night at The Opera》、《Innuendo》、《A Kind of Magic》17. Black Sabbath（黑色安息日乐队）一看名字就知道这是支重金属乐队，乐队组建于伯明翰。这支乐队音色纯正，音乐简单干净又粗暴，但是他们的歌曲具有深刻的现实意义。他们的歌曲关注当时的核战争和死亡，描写毒品、反叛、青年和灰暗的生活命运，反映了底层人的痛苦绝望的生活状态，深受当时年轻人的喜爱。这支乐队的辉煌时期在70年代，后来渐渐地没落。好像70年代的英国朋克乐队都很难长久，不知道这是个什么怪圈，我想这可能是因为朋克自身所带的那种毁灭性，使他们自己也无法长久吧。经典专辑：《Paranoid》、《Vol. 4》、《Master Of Reality》、《Sabbath Bloody Sabbath》18. Snow Patrol（雪地巡游者乐队）Snow Patrol（雪地巡游者乐队）是一支来自苏格兰的乐队，乐队风格清新哀婉，歌词非常的温暖感人，是当代比较成功的英国摇滚乐队。乐队风格是迷幻和另类路线，出了一些很不错的单曲，我个人比较喜欢他们的一些作品，可以拿来听听。听他们的歌曲非常的治愈，给人温暖、干净而清澈的感觉，近几年也是风生水起，至于未来还会怎样发展，还有很多的可能性。经典专辑：《Final Straw》、《Up To Now》19. Led Zeppelin（齐柏林飞船）被誉为重金属鼻祖的一支英国乐队，他们的重金属融合了朋克、中东音乐、蓝调、乡村、雷鬼音乐等等元素。他们的有的歌曲听起来很忧伤，令人神往遐思，代入感极强。有很多歌曲的歌词非常的有深度，甚至是对人性的拷问和追寻。他们的音乐前奏都非常漂亮，节奏感超强。虽然是重金属乐队，但是其并没有像后期的重金属乐队那样太多的嘶吼和器乐嘈杂，很是入耳。经典专辑：《Led Zeppelin Ⅳ》、《Houses of the Holy》、《Physical Graffiti》20. The Kinks（奇想乐队）奇想是一支老乐队了，他们主要活跃在60-70年代，在流行摇滚上造诣颇高，曲风也是蛮广的，迷幻、流行随手拈来。作为“不列颠入侵”的主要乐队之一，奇想与披头士、谁人和滚石并称为英国摇滚乐坛“Big Four”，当时的英国摇滚就是这四个乐队大放异彩、风靡全球。奇想也是摇滚名人堂的成员，但是96年这个乐队就解散了。他们的歌曲听着很舒服，充满怀旧伤感之情。可惜的是，这支本来很优秀的乐队在当时有点被披头士的巨大光芒掩盖了，现在去重新发现下也是不错的。经典专辑：《Face to Face》、《Muswell Hillbillies》、《Arthur》英国的摇滚乐队不胜枚举，大大小小的、成名的不成名的、大众的和小众的非常多，他们各有风格，但是真正能够在摇滚史上留下名字的乐队还是少数。总的来说，英国摇滚的特点是自成一派的英式摇滚，还有PF所创立的迷幻摇滚流派，加之上世纪70年代的朋克摇滚，这些都是英国土生土长的摇滚形式。除此外，英国摇滚还有其独有的思想性，从披头士的爱、和平、反战，到朋克对现实的抨击，及众多英式摇滚乐队的壮大复兴，都是英国摇滚乐的迷人之处。]]></content>
      <categories>
        <category>Music</category>
        <category>Britpop</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Test]]></title>
    <url>%2F2017%2F01%2F19%2Ftest%2F</url>
    <content type="text"><![CDATA[Just for a simple test]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
