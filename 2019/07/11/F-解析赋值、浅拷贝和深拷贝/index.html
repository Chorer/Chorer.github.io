<!-- build time:Fri Jul 12 2019 21:54:13 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Chor&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third party/pace-theme-flash.css"><link rel="icon" href="/images/me.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="header"><div class="header_top"><span class="theme"><i class="fa fa-bars"></i> <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">HOME</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">CATEGORIES</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">ARCHIVES</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">TAGS</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">ABOUT</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="/" class="logo">Chor&#39;s Blog</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">解析赋值、浅拷贝和深拷贝</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-07-11&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp13 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/解析赋值、浅拷贝和深拷贝-1.webp" alt=""><br><a id="more"></a></p><h2 id="1-相关数据结构"><a href="#1-相关数据结构" class="headerlink" title="1.相关数据结构"></a>1.相关数据结构</h2><p>堆（stack）和栈（heap）都是内存中划分出来用来存储的区域。</p><ul><li><p>栈数据结构<br>栈遵循后进先出（LIFO），执行上下文的基础结构就是栈。<br><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/解析赋值、浅拷贝和深拷贝-2.webp" alt=""></p></li><li><p>堆数据结构<br>堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的 key-value 可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。</p></li><li><p>队列数据结构<br>队列遵循先进先出（FIFO），事件循环的基础结构就是队列。<br><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/解析赋值、浅拷贝和深拷贝-3.webp" alt=""></p></li></ul><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h2><h3 id="2-1-基本数据类型："><a href="#2-1-基本数据类型：" class="headerlink" title="2.1 基本数据类型："></a>2.1 基本数据类型：</h3><ul><li>js 有 6 种基本数据类型：undefined，null，boolean，number，string，symbol</li><li>基本数据类型在内存中分别占有固定大小的空间，所以都是保存在<strong>栈内存</strong>中的</li><li>基本数据类型是按值访问的</li><li>比较：值的比较</li></ul><h3 id="2-2-引用数据类型："><a href="#2-2-引用数据类型：" class="headerlink" title="2.2 引用数据类型："></a>2.2 引用数据类型：</h3><ul><li>一般指的是 object</li><li>对象在内存中的大小不固定，所以保存在<strong>堆内存</strong>中，又由于对象的地址大小固定，所以地址保存在栈内存中</li><li>引用数据类型是按引用访问的。访问对象时，先从栈中读取内存地址，然后再根据这个地址找到堆中的对象</li><li>比较：引用的比较</li></ul><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/解析赋值、浅拷贝和深拷贝-4.png" alt=""></p><h2 id="3-赋值、浅拷贝和深拷贝的区别"><a href="#3-赋值、浅拷贝和深拷贝的区别" class="headerlink" title="3.赋值、浅拷贝和深拷贝的区别"></a>3.赋值、浅拷贝和深拷贝的区别</h2><h3 id="3-1-赋值"><a href="#3-1-赋值" class="headerlink" title="3.1 赋值"></a>3.1 赋值</h3><p>赋值是将某一数值或对象赋给某个变量的过程，包括两种：</p><ul><li>基本数据类型：<br>就是简单的赋值。因为在内存中开辟了一块新的栈空间，所以赋值之后两个变量独立、互不影响</li><li>引用数据类型：<br>赋<strong>址</strong>。实际操作的是对象内存的地址，最后使两个变量具有相同的引用，都指向同一个对象，因此这两个变量相互之间有影响</li></ul><h3 id="3-2-浅拷贝"><a href="#3-2-浅拷贝" class="headerlink" title="3.2 浅拷贝"></a>3.2 浅拷贝</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>浅拷贝即 swallow copy，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是其内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。<br>简而言之，浅拷贝的“浅”在于它的拷贝只停留在一层，即：拷贝第一层的<strong>基本类型值</strong>，以及<strong>第一层的引用类型地址</strong>。如图：<br>拷贝第一层的基本类型值，以及第一层的引用类型地址。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/解析赋值、浅拷贝和深拷贝-5.png" alt=""></p><h4 id="哪些地方是浅拷贝？"><a href="#哪些地方是浅拷贝？" class="headerlink" title="哪些地方是浅拷贝？"></a>哪些地方是浅拷贝？</h4><ul><li><code>Object.assign()</code></li></ul><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，最后再将目标对象返回。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
    author<span class="token punctuation">:</span> <span class="token string">"Jack"</span><span class="token punctuation">,</span>
    article<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        title<span class="token punctuation">:</span> <span class="token string">"Understanding event loop"</span><span class="token punctuation">,</span>
        date<span class="token punctuation">:</span> <span class="token string">"2019-1-1"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* {
    author: "Jack",
    article: {
        title: "Understanding event loop",
        date: "2019-1-1"
    }
} */</span>
a<span class="token punctuation">.</span>author <span class="token operator">=</span> <span class="token string">"Bob"</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>article<span class="token punctuation">.</span>date <span class="token operator">=</span> <span class="token string">"2019.2.1"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* {
    author: "Bob",
    article: {
        title: "Understanding event loop",
        date: "2019-2-1"
    }
} */</span> 

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* {
    author: "Jack",
    article: {
        title: "Understanding event loop",
        date: "2019-2-1"
    }
} */</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，因为 a 和 b 有各自的基本类型属性，所以对这种属性的修改是独立的；但是由于 a 和 b 的引用类型属性指向内存中的同一个对象，所以 a 对该对象的修改会反映到 b 上，这是浅拷贝的特点。</p><ul><li>展开语法<code>...</code></li></ul><blockquote><p>展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者字符串在语法层面展开；还可以在构造字面量对象时, 将对象表达式按 key-value 的方式展开。</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
    author<span class="token punctuation">:</span> <span class="token string">"Jack"</span><span class="token punctuation">,</span>
    article<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        title<span class="token punctuation">:</span> <span class="token string">"Understanding event loop"</span><span class="token punctuation">,</span>
        date<span class="token punctuation">:</span> <span class="token string">"2019-1-1"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>a<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* {
    author: "Jack",
    article: {
        title: "Understanding event loop",
        date: "2019-1-1"
    }
} */</span>
a<span class="token punctuation">.</span>author <span class="token operator">=</span> <span class="token string">"Bob"</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span>article<span class="token punctuation">.</span>date <span class="token operator">=</span> <span class="token string">"2019.2.1"</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* {
    author: "Bob",
    article: {
        title: "Understanding event loop",
        date: "2019-2-1"
    }
} */</span> 

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* {
    author: "Jack",
    article: {
        title: "Understanding event loop",
        date: "2019-2-1"
    }
} */</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Array.prototype.slice()</code><blockquote><p><code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 begin 和 end（不包括 end ）决定的原数组的浅拷贝。原始数组不会被改变。</p></blockquote></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ["1", [2, 3]]</span>

a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"99"</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// [0, "99", [4, 3]]</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//  ["1", [4, 3]]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，因为 a 和 b 都有各自的基本类型属性，所以修改 a[1] 对 b 没有影响；但是由于 a 和 b 的引用类型属性指向内存中的同一个数组对象，所以对 <code>a[2][0]</code> 的修改会反映到 b 上。</p><h3 id="3-3-深拷贝"><a href="#3-3-深拷贝" class="headerlink" title="3.3 深拷贝"></a>3.3 深拷贝</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>深拷贝即 deep copy，它会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。<br>简而言之，深拷贝的“深”在于它的拷贝不仅仅停留在一层，而是连同里面的子对象也一同拷贝。如图：<br><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/解析赋值、浅拷贝和深拷贝-6666.png" alt=""></p><h4 id="哪些地方是深拷贝？"><a href="#哪些地方是深拷贝？" class="headerlink" title="哪些地方是深拷贝？"></a>哪些地方是深拷贝？</h4><ul><li><code>JSON.parse(JSON.stringify(object))</code><br>对象（包括数组）的序列化和反序列化<br><code>`</code>js<br>let a = {<br>author: “Jack”,<br>article: {<pre><code>  title: &quot;Understanding event loop&quot;,
  date: &quot;2019-1-1&quot;
</code></pre>}<br>}<br>let b = JSON.parse(JSON.stringfy(a));<br>console.log(b);<br>/* {<br>author: “Jack”,<br>article: {<pre><code>  title: &quot;Understanding event loop&quot;,
  date: &quot;2019-1-1&quot;
</code></pre>}<br>} <em>/<br>a.author = “Bob”;<br>a.article.date = “2019.2.1”;<br>console.log(a);<br>/</em> {<br>author: “Bob”,<br>article: {<pre><code>  title: &quot;Understanding event loop&quot;,
  date: &quot;2019-2-1&quot;
</code></pre>}<br>} */</li></ul><p>console.log(b);<br>/<em> {<br>author: “Jack”,<br>article: {<br>title: “Understanding event loop”,<br>date: “2019-1-1”<br>}<br>} </em>/</p><pre><code>改变 `a.article.date` 之后对 b 没有影响，可见这是深拷贝，a 和 b 有各自的 `article` 对象。

不过，`JSON.parse(JSON.stringify(object))` 有以下几个问题：

1、会忽略 undefined

2、会忽略 symbol

3、会忽略函数（不能序列化函数）

4、不能解决循环引用的对象

5、不能正确处理 new Date()

6、不能处理正则

### 3.4 总结

| \-\- | 和原数据是否指向同一对象 | 第一层数据为基本数据类型 | 原数据中包含子对象    |
|------|--------------|--------------|--------------|
| 赋值   | 是            | 改变会使原数据一同改变  | 改变会使原数据一同改变  |
| 浅拷贝  | 否            | 改变**不**会使原数据一同改变 | 改变会使原数据一同改变  |
| 深拷贝  | 否            | 改变**不**会使原数据一同改变 | 改变**不**会使原数据一同改变 |


## 4.模拟实现 `Object.assign()` 的浅拷贝

### 4.1 `Object.assign() 浅拷贝的特点`：

* 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后来的源对象的属性将类似地覆盖早先的属性；
* string、symbol、null 和 undefined 类型的属性都会被拷贝

### 4.2 实现 `Object.assign()` 的基本思路：

1、判断原生 Object 是否支持该函数，如果不存在的话创建一个 assign 函数，并使用 `Object.defineProperty` 将该函数绑定到 Object 上。

2、判断参数是否正确（目标对象不能为空，我们可以直接设置 `{}` 传递进去,但必须设置值）。

3、使用 `Object()` 转成对象，并保存为 `to`，最后返回这个对象 `to`。

4、使用 `for..in` 循环遍历出所有可枚举属性，配合 `hasOwnProperty` 获取所有可枚举自有（非原型链上的）属性，再复制给新的目标对象。


### 4.3 具体实现代码：
下面是 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 上 `assign()` 的 polyfill（注意：此 polyfill 不支持  symbol 属性，因为 ES5 中根本没有 symbol）：
```js
if (typeof Object.assign != &#39;function&#39;) {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, &quot;assign&quot;, {
    value: function assign(target, varArgs) { // .length of function is 2
      &#39;use strict&#39;;
      if (target == null) { // TypeError if undefined or null
        throw new TypeError(&#39;Cannot convert undefined or null to object&#39;);
      }

      let to = Object(target);

      for (var index = 1; index &lt; arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
          for (let nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
</code></pre><h3 id="4-4-重点注意"><a href="#4-4-重点注意" class="headerlink" title="4.4 重点注意"></a>4.4 重点注意</h3><p>经过测试，该模拟实现的 <code>assign()</code> 可以达到和原生 Object 的 <code>assign()</code> 一样的浅拷贝效果。下面说几个重点需要注意的地方：</p><ul><li>为什么使用 <code>Object。defineProperty()</code> 添加方法，而不是直接挂载？</li></ul><p>我们知道，<code>for...in</code> 可以遍历出自身以及原型链上的可枚举属性，而 <code>Object.keys()</code> 只能遍历出自身的可枚举属性</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> Object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 无输出</span>

Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> Object <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// []</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，Object 的属性默认都是不可枚举的，但是，直接挂载在 Object 上面的属性却是可枚举的：</p><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> Object<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 1 </span>

Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> Object <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ["a"]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，只有 <code>assign()</code> 确实是可枚举属性时，才可以将其直接挂载在 <code>assign()</code> 上。但是， <code>assign()</code> 实际上是不可枚举的。<br>我们可以使用 2 种方法查看 <code>assign()</code> 是否可枚举：</p><ul><li><code>Object.getOwnPropertyDescriptor()</code></li><li><code>Object.propertyIsEnumerable()</code><br>其中，后者会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 <code>enumerable: true</code>。</li></ul><p>具体用法如下：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 方法1</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>Object<span class="token punctuation">,</span> <span class="token string">"assign"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// {</span>
<span class="token comment" spellcheck="true">//     value: ƒ, </span>
<span class="token comment" spellcheck="true">//  writable: true,     // 可写</span>
<span class="token comment" spellcheck="true">//  enumerable: false,  // 不可枚举，注意这里是 false</span>
<span class="token comment" spellcheck="true">//  configurable: true    // 可配置</span>
<span class="token comment" spellcheck="true">// }</span>

<span class="token comment" spellcheck="true">// 方法2</span>
Object<span class="token punctuation">.</span><span class="token function">propertyIsEnumerable</span><span class="token punctuation">(</span><span class="token string">"assign"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// false</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码说明 <code>Object.assign()</code> 是不可枚举的。因此，这里适合用<code>Object。defineProperty()</code> 给 Object 添加属性，用这个方法时也可以不显式指定 enumerable 为 false，因为它默认就是 false。</p><ul><li>参数判断：</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> undefined <span class="token operator">||</span> target <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Cannot convert undefined or null to object'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面这种参数判断也可以，但是由于 <code>null</code> 和 <code>undefined</code> 的相等性判断返回 true，所以实际上直接写 <code>if(target == null)</code> 即可</p><ul><li>为什么要用 <code>Obejct()</code> 将 target 参数包装成对象？</li></ul><p>正常情况下传入的参数应该是一个对象，但是模拟实现的时候需要考虑传入参数不一定为对象的情况。<br><strong>如果作为源对象的参数不是对象：</strong></p><p><code>null</code> 和 <code>undefined</code> 会被忽略；除了这两者之外的原始类型则将被包装成对象，在这种情况下，只有<strong>自身拥有可枚举属性</strong>的包装对象才会被拷贝，其它类型的包装对象会被忽略</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> v1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v2 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v3 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v4 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> v1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [ '0', '1', '2' ]</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> v2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// []</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> v3 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// []</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> v4 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// []</span>
<span class="token comment" spellcheck="true">// 可以看到，只有字符串类型的包装对象，才有自身的可枚举属性</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> undefined<span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v3<span class="token punctuation">,</span> v4<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 只有 v1 会被拷贝</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// { "0": "a", "1": "b", "2": "c" }</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果作为目标对象的参数不是对象：</strong><br>同理，我们还要考虑 target 参数也可能不是对象的情况，所以在上面的 polyfill 中，要使用 <code>Object()</code> 将 target 参数包装成对象。</p><ul><li>为什么要用严格模式？<br>使用 <code>Object()</code> 对参数进行包装后，对于得到的包装对象而言，其既有属性的 writable 为 false，也就是说不能对其既有属性进行改写，否则会报错<pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">"def"</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><code>assign()</code> 的内部实现中将 <code>str1</code> 和 <code>str2</code> 包装为对象，因此这两者在内部是这样的：<pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// str1</span>
<span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token punctuation">:</span><span class="token string">"a"</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token punctuation">:</span><span class="token string">"b"</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">"c"</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// str2</span>
<span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token punctuation">:</span><span class="token string">"d"</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token punctuation">:</span><span class="token string">"e"</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token punctuation">:</span><span class="token string">"f"</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><code>Object.assign(str1, str2)</code> 相当于用 <code>str2</code> 的同名属性依次覆盖 <code>str1</code> 的属性，从而实现拷贝。但是由于 <code>str1</code> 是用 <code>Object()</code> 进行包装的，所以这个拷贝是不生效的，会报错。<br>但是，如果在 <code>assign()</code> 的实现内部不使用严格模式，则不会报错：<br><code>`</code>js<br>var myObject = Object(‘abc’);</li></ul><p>Object.getOwnPropertyDescriptor(myObject, ‘0’);<br>// {<br>// value: ‘a’,<br>// writable: false, // 注意这里<br>// enumerable: true,<br>// configurable: false<br>// }</p><p>myObject[0] = ‘d’;<br>// ‘d’</p><p>myObject[0];<br>// ‘a’</p><pre><code>这里并没有报错，原因在于 js 对于不可写的属性值的修改静默失败，只有在严格模式下才会提示错误。为了实现正常的报错，我们必须在内部使用严格模式。

* 为什么要用 `Object.prototype.hasOwnProperty.call()`？

通过 `for...in..` 得到的是源对象自身及其原型链上的可枚举属性，但浅拷贝只需要拷贝自身可枚举属性，所以需要用 `hasOwnProperty()` 筛选，但是直接调用这个方法是不行的。一方面，我们需要考虑到源对象可能重写了这个方法而导致其无法正常调用，另一方面还要考虑到源对象可能是基于 `Object.create(null)` 创建的，而这种方法创建的对象由于不具有与 Object 原型链的联系，因此不具有 `hasOwnProperty()` 方法，在调用的时候会报错。
```js
var myObject = Object.create( null );
myObject.b = 2;

myObject.hasOwnProperty( &quot;b&quot; );
// TypeError: myObject.hasOwnProperty is not a function
</code></pre><p>所以，这里采用 <code>Object.prototype.hasOwnProperty.call()</code>，将 <code>hasOwnProperty()</code> 内部的 this 绑定到源对象上，也可以达到同样的效果。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> myObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<br><a href="https://github.com/yygmind/blog/issues/25" target="_blank" rel="noopener">https://github.com/yygmind/blog/issues/25</a><br><a href="https://github.com/yygmind/blog/issues/26" target="_blank" rel="noopener">https://github.com/yygmind/blog/issues/26</a><br><a href="https://juejin.im/post/59ac1c4ef265da248e75892b#heading-13" target="_blank" rel="noopener">https://juejin.im/post/59ac1c4ef265da248e75892b#heading-13</a></p></div><div class="post-nav"><div class="post-nav-prev"></div><div class="post-nav-next"><a href="/2019/06/30/T-大一下学期：The End/" rel="next" title="大一下学期：The End">大一下学期：The End&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top"><i class="fa fa-th-large"></i>Catalog</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-相关数据结构"><span class="toc-text">1.相关数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-数据类型"><span class="toc-text">2.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-基本数据类型："><span class="toc-text">2.1 基本数据类型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-引用数据类型："><span class="toc-text">2.2 引用数据类型：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-赋值、浅拷贝和深拷贝的区别"><span class="toc-text">3.赋值、浅拷贝和深拷贝的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-赋值"><span class="toc-text">3.1 赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-浅拷贝"><span class="toc-text">3.2 浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义："><span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哪些地方是浅拷贝？"><span class="toc-text">哪些地方是浅拷贝？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-深拷贝"><span class="toc-text">3.3 深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义：-1"><span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哪些地方是深拷贝？"><span class="toc-text">哪些地方是深拷贝？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-重点注意"><span class="toc-text">4.4 重点注意</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/search.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300,"vOffset":-120,"hOffset":-5},"mobile":{"show":false},"react":{"opacityDefault":1000,"opacityOnHover":1000},"log":false});</script></body></html><!-- rebuild by neat -->