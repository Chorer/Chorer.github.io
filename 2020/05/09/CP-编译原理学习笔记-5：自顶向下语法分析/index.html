<!-- build time:Wed Apr 07 2021 20:58:13 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">编译原理学习笔记-5：自顶向下语法分析</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-05-09&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp7.6k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp29 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/0.png" alt=""></p><a id="more"></a><blockquote><p>本篇笔记将继续讲解编译的第二步：自顶向下语法分析。</p></blockquote><p>下面是这篇笔记的思维导图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/11.png" alt=""></p><p>注意：以下的所有分析基于上下文无关文法。</p><h3 id="1-语法分析"><a href="#1-语法分析" class="headerlink" title="1. 语法分析"></a>1. 语法分析</h3><h4 id="1-1-语法分析器"><a href="#1-1-语法分析器" class="headerlink" title="1.1 语法分析器"></a>1.1 语法分析器</h4><p>在词法分析中，我们扫描输入源程序的每个字符，得到多种类型的单词（token），一系列的单词就构成了一条单词流。可以设想，单词流的某个部分有多个并排的单词，它们可能会构成某个句子，但是这个句子是否真的符合语法规则呢？我们需要借助语法分析器才能进行判断。更直接点，我们可以说语法分析器是用来判断<strong>句子是否符合某个给定的上下文无关文法</strong>的。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/1.png" style="zoom:67%"></p><h4 id="1-2-语法分析的方法"><a href="#1-2-语法分析的方法" class="headerlink" title="1.2 语法分析的方法"></a>1.2 语法分析的方法</h4><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/2.png" style="zoom:67%"></p><p>本篇笔记主要讲解自顶向下语法分析。要判断句子是否符合某个给定的上下文无关文法，可以尝试从文法的开始符号出发，若经过一系列推导之后可以得到完全匹配原句子的句子，则可以说原句子来自于给定的文法。</p><h3 id="2-自顶向下语法分析存在的问题"><a href="#2-自顶向下语法分析存在的问题" class="headerlink" title="2. 自顶向下语法分析存在的问题"></a>2. 自顶向下语法分析存在的问题</h3><p>自顶向下分析的核心思路是：对任何需要分析的输入串，从文法的开始符号出发，试图用一切可能的方法，结合文法的产生式，自上而下地构造一棵基于输入串的语法树。但在这个过程中存在着一个问题，这个问题概况地说就是<strong>文法的不确定性</strong>。为什么说具有一种不确定性呢？我们可以从以下三个方面一一分析。</p><h4 id="2-1-左递归"><a href="#2-1-左递归" class="headerlink" title="2.1 左递归"></a>2.1 左递归</h4><p><strong>① 定义</strong></p><p>其一，文法存在的左递归带来了不确定性。</p><p>如果一个文法存在非终结符 P 使得 P +⇒ Pa，那么这个文法就是含有左递归的。它的意思其实是说，当我们试图用 P 的右部去替换 P 这个非终结符的时候，替换得到的结果再次含有 P，若此时无法匹配输入的字符，则我们不得不对 P 进行又一轮的替换，反反复复，陷入了无限循环，始终没有找到递归的出口。</p><p><strong>② 消除</strong></p><p>我们并不希望一个文法存在不确定性，所以需要想办法消除文法的左递归。对于简单的左递归，我们的消除规则如下：若存在递归产生式 <code>P → Pα|β</code>，则将其改写为：<code>P → βP‘</code>，<code>P’ → αP‘| ε</code>。</p><p>比如说存在如下的文法：</p><pre class="line-numbers language-js"><code class="language-js">E →  E <span class="token operator">+</span> T<span class="token operator">|</span>T
T → T <span class="token operator">*</span> F<span class="token operator">|</span>F
F → <span class="token punctuation">(</span>E<span class="token punctuation">)</span><span class="token operator">|</span>i
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它的第一条和第二条产生式都是递归的，需要消除递归。将产生式与规则一一对应，那么 <code>+T</code> 就代表 <code>α</code>，T 就代表 <code>β</code>，所以 <code>E → E + T|T</code> 改写为 <code>E → TE&#39;</code> 和 <code>E&#39;→ +TE&#39;|ε</code>；同理，<code>*F</code> 代表 <code>α</code>，F 代表 <code>β</code>，所以 <code>T → T * F|F</code> 就改写为 <code>T → FT&#39;</code> 和 <code>T → *FT&#39;|ε</code>。</p><p>对于更一般性的左递归，我们的消除规则如下：若存在递归产生式 <code>P → Pα1|Pα2|...|Pαm|β1|β2|β3|βn</code>（右部的一部分含左部，一部分不含），则将其改写为：<code>P → |β1P&#39;|β2P&#39;|...|βnP&#39;</code> 和 <code>P’ → α1P&#39;|α2P‘|...|αmP’| ε</code></p><p>比如说存在如下的文法：</p><pre class="line-numbers language-js"><code class="language-js">S → Qc<span class="token operator">|</span>c
Q → Rb<span class="token operator">|</span>b
R → Sa<span class="token operator">|</span>a
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>看起来它似乎不是左递归文法，但其实经过 <code>S ⇒ Qc ⇒ Rbc ⇒ Sabc</code> 的推导后，会发现它其实也是左递归文法。这种不太明显的、需要经过替换才能体现递归性的，称之为间接左递归。我们将上面推导过程中使用过的产生式逆序排列，得到下面等价的文法：</p><pre class="line-numbers language-js"><code class="language-js">R → Sa<span class="token operator">|</span>a
Q → Rb<span class="token operator">|</span>b
S → Qc<span class="token operator">|</span>c
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如何消除左递归呢？首先将第一条产生式代入第二条，得到 <code>Q → Sab|ab|b</code>，它仍然不包含左递归，所以继续代入第三条，得到 <code>S → Sabc|abc|bc|c</code>，它包含<strong>直接左递归</strong>，所以按照前面说过的一般左递归的消除方法对其进行处理，得到 <code>S → (abc|bc|c)S&#39;</code> 和 <code>S‘ → abcS’|ε</code>。由于 Q 和 R 的相关产生式已经包含在里面，所以这两条产生式就构成了已经消除左递归的等价文法。</p><h4 id="2-2-回溯"><a href="#2-2-回溯" class="headerlink" title="2.2 回溯"></a>2.2 回溯</h4><p>其二，文法存在的回溯带来了不确定性。</p><p>比方说对于文法 <code>{Z → cAd,A → ab|a}</code> 以及输入符号串 <code>S = cad</code>，当 A 面对输入符号 a 的时候，到底应该用 <code>A → ab|a</code> 的第一个还是第二个右部去替换呢？看起来好像都可行，但若选取了第一个右部，则后面会发现 b 无法匹配 d，所以这个选取是错误的。我们需要<strong>回溯</strong>到 A 产生子树之前，令其产生 a 子树而不是 ab 子树。设想产生式的右部如果是 <code>ab|ac|ad|...|az</code>，是不是意味着我们需要做更多的尝试/回溯呢？这会大大降低语法分析的效率，而这是我们不希望看到的。所以有必要消除回溯。</p><p>在这之前，我们先考虑如何更加准确地判断某个文法是否存在回溯的情况。这里我们要引入一个 <strong>First 集</strong>的概念。</p><p><strong>① First</strong> 集</p><p>First 集又叫终结首符集，对<strong>非终结符 A 的每一个右部 m </strong>都存在着一个 First 集，集合中的元素都是 m 的<strong>所有可能推导</strong>的开头终结符或者可能的 <code>ε</code>。比如上面的 <code>A → ab|a</code> ，A 的右部是 ab 或者 a，ab 或者 a 的推导（在这里是它们自身）的开头终结符就是 a，所以 <code>First(ab) = First(a) = {a}</code>。</p><p><strong>② 如何判断无回溯</strong></p><p>对于非终结符 A，它的每一个右部都会产生对应的 First 集，若这些集合两两不相交，即 <code>First(ai) ∩ First(aj) = Ø</code>，那么至少对于 A 而言，它是不存在回溯的。比如，<code>A → ab|cd|ef</code> ，每一个右部的 First 集两两之间都没有交集，那么 A 就是没有回溯的，当它面对一个输入符号（比方说 a，c，e）的时候，它可以确切地让一个右部去进行替换，而无需担心替换失败、需要回过头来选择其它右部的情况。</p><p><strong>③ 如何克服回溯</strong></p><p>不幸的是，大部分情况下，很多非终结符都存在回溯的情况。不过，我们可以通过提取左公因子来克服这种回溯。比如说产生式 <code>A → ab|ac|ad|...|az</code>，可以提取公因子 a，改写为 <code>A → a(b|c|d|...|z)</code>，再改写得到 <code>A → aX</code> 和 <code>X → (b|c|d|...|z)</code>。至少这个时候，对于 A 而言它已经不存在回溯的情况，毕竟它只有一个右部了。当然，对于 X，它依然可能存在回溯，比如说 b=mn，c = ml，诸如此类，若存在这种情况，我们就再次提取公因子。这样反复提取之后，我们可以确保所有非终结符的右部的 First 集都不存在交集，因此得以消除回溯。不过，这样的代价就是引入了大量的非终结符作为替换时的过渡。</p><h4 id="2-3-空符号串"><a href="#2-3-空符号串" class="headerlink" title="2.3 空符号串"></a>2.3 空符号串</h4><p>我们已经消除了左递归和回溯，这样文法是不是就真的确定了呢？其实不是，因为我们还得考虑空符号串的问题。简单地说，假设左部为非终结符 A 的产生式，它有一个右部是 <code>ε</code>，且 A 当前面对的输入符号为 a，那么到底要不要用 <code>ε</code> 去替换掉 A 呢？如果不使用 <code>ε</code>，至少说明了 A 存在其它右部足以处理输入符号 a，也许刚好就是 a，或者是以 a 开头的符号串；如果使用 <code>ε</code>，则意味着 A 放弃了处理 a 的任务，这其中隐含的意思是，<strong>A 自己无法处理 a，但是它确信在语法树中，排在自己右边的非终结符足以处理 a</strong>。不过，这样的非终结符是否确实存在？这时候，我们引入了另一个新的概念，即 Follow 集。</p><p><strong>① Follow</strong> 集</p><p>Follow 集又叫做后跟符号集，对<strong>某个非终结符 A</strong>存在着一个 Follow 集，集合中的所有元素都是<strong>开始符号 S 与 A 之间的相关推导</strong>中，紧跟着出现在 A 右边的终结符。比如说存在文法 <code>{S → Bc,B → Aa,A → de}</code>，要求 A 的 Follow 集，那么 S 与 A 之间就存在着一个相关推导为 <code>S → Aac</code>，紧跟着 A 后面的是终结符 a，所以 <code>Follow(A)={a}</code>；如果是要求 S 的 Follow 集呢？S 与 S 之间的相关推导就是 <code>S → S</code>，可以看到 S 右边没有紧跟着终结符，这时候我们就规定 <code>Follow(S)={ # }</code>。</p><p><strong>② 空符号串的处理</strong></p><p>有没有注意到 Follow 集的定义刚好与我们谈到的空符号串的处理有相关的地方？—— 空符号串 <code>ε</code> 如果被使用，说明语法树中 A 的右侧存在着另一个非终结符可以处理当前输入符号，而 <code>Follow(A)</code> 代表的又是语法推导中位于 A 的右侧的那些终结符，那么，<strong>重点来了</strong>，假设 <code>Follow(A)</code> 中刚好就包含当前输入符号，那么就说明 A 的推导的右侧存在着终结符 a，而这个 a 是由 A 右侧的非终结符推导得到的。换句话说，当 <code>Follow(A)</code> 中刚好就包含当前输入符号的时候，我们可以肯定，存在着某个非终结符可以处理当前输入符号，并使得 A 可以用空符号串 <code>ε</code> 进行代替，而无需去处理当前输入符号。</p><p>所以，我们通过求解 <code>Follow(A)</code> ，消除了<strong>考虑是否需要用空符号串替代 A </strong>的不确定性。我们可以看下面这个例子再来理解一下。假定有文法：</p><pre class="line-numbers language-js"><code class="language-js">S → aA<span class="token operator">|</span>d
A → bAS<span class="token operator">|</span>ε
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若输入符号串为 <code>abd</code>，尝试推导该符号串是否符合给定的文法：</p><ul><li>第一个输入符号是 a，程序经过判断，决定使用 <code>S → aA</code> 开始构造语法树，这样就处理了第一个输入符号 a；</li><li>第二个输入符号是 b，程序经过判断，决定使用 <code>A → bAS</code> 将 A 替换，这样就处理了第二个输入符号 b；</li><li>第三个输入符号是 d，程序此时如何判断呢？查看 <code>First(A)</code>，发现不包含 d，所以 A 是无法直接处理当前输入符号 d 的，那么它是否应该用 <code>ε</code> 替换掉，并让 S 去处理 d 呢？查看 <code>Follow(A)</code>，发现刚好是包含 d 的，所以这里用 <code>ε</code> 替换 A</li><li>当前输入符号还是 d，用 d 替换 S，成功处理完第三个输入符号 d。</li></ul><p><strong>③ 如果 First 集和 Follow 集有交集…….</strong></p><p>到了这里，可能会产生一个疑问：既然 A 的 First 集在某种程度上决定了非终结符 A 自身是否足以处理当前输入符号，而 A 的 Follow 集在某种程度上决定了 A 右侧的非终结符是否足以处理当前输入符号，那么如果 <code>First(A)</code> 和 <code>Follow(A)</code> 都包含了当前输入符号，好像就说明了 A 和右侧非终结符都能处理输入符号了？这时候要让谁来处理呢？其实这里又带来了一种不确定性，这同样是我们不希望看到的。</p><h3 id="3-LL-1-文法"><a href="#3-LL-1-文法" class="headerlink" title="3. LL(1) 文法"></a>3. LL(1) 文法</h3><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><p>上面说了这么多东西，又要求文法不存在左递归、又要求没有回溯，还要求非终结符的 <code>First(A)</code> 和 <code>Follow(A)</code> 最好没有交集，那么是否存在某种文法可以满足所有这些条件呢？—— 有的，那就是 <code>LL(1)</code> 文法。 <code>LL(1)</code> 文法是确定的，只有基于这种确定的文法，我们才能进行确定的自顶向下分析。联系上面我们分析导致文法不确定的因素的过程，可以给出 <code>LL(1)</code> 文法的定义如下：</p><ul><li><p>必须不包含左递归</p></li><li><p>对于每个非终结符，它的各个右部的 First 集两两不相交</p></li><li>对于每个非终结符，如果它的 First 集包含 <code>ε</code> ，则它的 First 集和 Follow 集不相交</li></ul><p>因为我们前面已经经过了分析，会发现这里要理解 <code>LL(1)</code> 文法的定义，相对容易很多，而且我们也知道它为什么要这么定义，对他的来龙去脉有一个清晰的理解。</p><h4 id="3-2-判断"><a href="#3-2-判断" class="headerlink" title="3.2 判断"></a>3.2 判断</h4><p>那么，如何判断一个文法是否属于 <code>LL(1)</code> 文法呢？我们可以选择用定义判断，也可以结合稍后介绍的 select 集进行判断。以下面这个文法为例：</p><pre class="line-numbers language-js"><code class="language-js">S → aA<span class="token operator">|</span>d
A → bAS<span class="token operator">|</span>ε
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>① 基于定义进行判断</strong></p><ul><li>显而易见，它不存在左递归</li><li>分析 S 的各个右部，aA 的 First 集为 <code>{a}</code>，d 的 First 集为 <code>{d}</code>，两个集合不相交；分析 A 的各个右部，bAS 的 First 集为 <code>{b}</code>，ε 的 First 集为 <code>{ε}</code>，两个集合也不相交。所以，文法的每个非终结符的候选 First 集两两都不相交</li><li>A 的 First 集为 <code>{ε,b}</code> ，它的 Follow 集为 <code>{ a,d,# }</code>，两者不相交（注意不要漏掉 #，因为 <code>S → aA</code> 也是 S 和 A 之间的相关推导 ）</li></ul><p>由于该文法符合 <code>LL(1)</code> 文法的定义，所以它属于 <code>LL(1)</code> 文法。</p><p><strong>② 基于 select 集进行判断</strong></p><p>对于给定文法的每一条产生式，select 集的规则如下：</p><ul><li>如果产生式右部无法推导出 ε：该产生式的 select 集为产生式右部的 First 集</li><li>如果产生式右部可以推导出 ε：该产生式的 select 集为产生式右部的 First 集去除 ε ，并上产生式左部的 Follow 集</li></ul><p>求解给定文法的每一条产生式，若左部相同的产生式两两之间的 select 集不相交，则该文法属于 <code>LL(1)</code> 文法。</p><p>以上面为例，我们可以得到如下四条产生式：</p><pre class="line-numbers language-js"><code class="language-js">S → aA
S → d
A → bAS
A → ε
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对应的 select 集为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">select</span><span class="token punctuation">(</span>S → aA<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">First</span><span class="token punctuation">(</span>aA<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">}</span>
<span class="token function">select</span><span class="token punctuation">(</span>S → d<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">First</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>d<span class="token punctuation">}</span>
<span class="token function">select</span><span class="token punctuation">(</span>A → bAS<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">First</span><span class="token punctuation">(</span>bAS<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>b<span class="token punctuation">}</span>
<span class="token function">select</span><span class="token punctuation">(</span>A → ε<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">First</span><span class="token punctuation">(</span>ε<span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">{</span>ε<span class="token punctuation">}</span><span class="token punctuation">)</span> U <span class="token function">Follow</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span>d<span class="token punctuation">,</span># <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对左部相同的产生式的 select 集，两两之间求交集：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">select</span><span class="token punctuation">(</span>S → aA<span class="token punctuation">)</span> U <span class="token function">select</span><span class="token punctuation">(</span>S → d<span class="token punctuation">)</span> <span class="token operator">=</span> Ø
<span class="token function">select</span><span class="token punctuation">(</span>A → bAS<span class="token punctuation">)</span> U <span class="token function">select</span><span class="token punctuation">(</span>A → ε<span class="token punctuation">)</span> <span class="token operator">=</span> Ø
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>发现都是不相交的，根据上面的规则，可以判断该文法属于 <code>LL(1)</code> 文法。</p><h3 id="4-递归下降分析程序"><a href="#4-递归下降分析程序" class="headerlink" title="4. 递归下降分析程序"></a>4. 递归下降分析程序</h3><blockquote><p>这一节没有重点讲解，可以略过。</p></blockquote><p>当一个文法满足 <code>LL(1)</code> 条件时，我们可以选择构造一个不带回溯的自上而下分析程序。这个分析程序由一组递归过程组成，每个过程对应文法的一个非终结符，这种分析程序称为递归下降分析器。如果用某种高级语言写出所有递归过程，那就可以用这个语言的编译习题来产生整个分析程序了。</p><h4 id="4-1-扩充的巴科斯范式"><a href="#4-1-扩充的巴科斯范式" class="headerlink" title="4.1 扩充的巴科斯范式"></a>4.1 扩充的巴科斯范式</h4><ul><li>用花括号 <code>{α}</code> 表示闭包运算 <code>α*</code></li><li>用 <code>{α}_n^0</code> 表示 <code>α</code> 可以任意重复 0 次到 n 次， <code>{α}_n^0 = α^0 = ε</code></li><li>用方括号 <code>[α]</code> 表示 <code>{α}_1^0</code> ，即表示 <code>α</code> 的出现可有可无（等价于 <code>α|ε</code> ）</li></ul><h4 id="4-2-编写递归下降分析程序"><a href="#4-2-编写递归下降分析程序" class="headerlink" title="4.2 编写递归下降分析程序"></a>4.2 编写递归下降分析程序</h4><p>对于给定的文法，可以利用扩充的巴科斯范式进行改写：</p><pre class="line-numbers language-js"><code class="language-js">E → T<span class="token operator">|</span>E <span class="token operator">+</span> T
T → F<span class="token operator">|</span>T <span class="token operator">*</span> F
F → <span class="token punctuation">(</span>E<span class="token punctuation">)</span><span class="token operator">|</span>i
<span class="token comment" spellcheck="true">// 改写为</span>
E → T<span class="token punctuation">{</span><span class="token operator">+</span>T<span class="token punctuation">}</span>
T → F<span class="token operator">|</span><span class="token punctuation">{</span><span class="token operator">*</span>F<span class="token punctuation">}</span>
F → <span class="token punctuation">(</span>E<span class="token punctuation">)</span><span class="token operator">|</span>i
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PS：也可以用语法图表示改写后的结果，这会更加直观：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/9.png" style="zoom:80%"></p><p>基于改写后的文法或者是语法图，可以构造如下的递归下降分析程序（ADVANCE 表示扫描下一个输入符号，SYM 表示当前输入符号，ERROR 表示出错纠察处理程序）：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/10.png" style="zoom:67%"></p><h3 id="5-预测分析程序"><a href="#5-预测分析程序" class="headerlink" title="5. 预测分析程序"></a>5. 预测分析程序</h3><p>使用高级语言的递归过程描述递归下降分析器，只有当具有实现这种过程的编译系统时才有实际意义，构造预测分析程序是实现 <code>LL(1)</code> 分析的另一种有效方式。</p><h4 id="4-1-主要流程"><a href="#4-1-主要流程" class="headerlink" title="4.1 主要流程"></a>4.1 主要流程</h4><p>借助 <code>LL(1)</code> 预测分析程序，可以进行语法分析：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/3.png" style="zoom:67%"></p><p>预测分析程序的核心是借助一张分析表以及一个栈。分析表是一个 <code>M[A,a]</code> 形式的矩阵，A 表示非终结符，a 表示终结符或者 #，矩阵的每一个元素 <code>M[A,a]</code> 都存放着一条关于 A 的产生式，表示当 A 面对输入符号 a 的时候应该使用什么样的右部去进行替换；元素也可能存放一个出错标志（在表中用空白表示），这时候表示分析出错：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/4.png" style="zoom:67%"></p><p>栈中一开始放的是栈底的 # 以及栈顶的文法开始符号，在预测分析程序运行的整个过程中，栈中元素会不断发生变动：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/5.png" style="zoom:67%"></p><p>当栈顶为 A，面对输入符号 a 的时候，这时候视情况有三种可能的操作：</p><ul><li><code>A = a = #</code>，此时成功完成分析，语法分析通过</li><li><code>A = a ≠ #</code>，此时 A 出栈，扫描下一个输入符号</li><li><code>A∈V_N</code>，则根据 <code>M[A,a]</code> 到分析表中查询对应元素，该元素可能为产生式或者一个错误标志：若为产生式，则栈顶元素出栈，让产生式右部逆序依次进栈；若为错误标志，则分析出错，语法分析不通过。</li></ul><h4 id="4-2-具体分析"><a href="#4-2-具体分析" class="headerlink" title="4.2 具体分析"></a>4.2 具体分析</h4><p>在正式进行预测分析之前，还需要解决几个问题：首先，文法未必是 <code>LL(1)</code> 文法，可能需要先对文法进行处理，消除左递归和回溯；其次，需要构造一张预测分析表以用于后续的预测分析，做完这些准备工作，最后才是预测分析。我们现在以一个例子来讲解整个流程。假设给定如下文法和输入符号串：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 文法</span>
E → E <span class="token operator">+</span> T<span class="token operator">|</span>T
T → T <span class="token operator">*</span> F<span class="token operator">|</span>F
F → i<span class="token operator">|</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 输入符号串</span>
i <span class="token operator">+</span> i <span class="token operator">*</span> i
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>符号串是否符合给定文法呢？我们试着用预测分析程序进行语法分析。</p><p><strong>① <code>LL(1)</code> 判断</strong></p><blockquote><p>有没有左递归？</p></blockquote><p>很明显，这个文法存在直接左递归，为了方便后续工作的开展，这里先消除左递归。根据左递归消除的规则，将原文法改写为如下的等价文法：</p><pre class="line-numbers language-html"><code class="language-html">E → TE'
E' → +TE'|ε
T → FT'
T' → *FT'|ε
F → i|(E)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>有没有回溯？</p></blockquote><p>尝试基于 select 集判断文法是否存在回溯。为了方便，这里先计算出 First 集和 Follow 集。</p><p>产生式右部的 First 集：</p><pre class="line-numbers language-html"><code class="language-html">First(TE') = {i,(}
First(+TE') = {+}
First(ε) = {ε}
First(*FT) = {*}
First((E)) = {(}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非终结符的 Follow 集：</p><ul><li>从 E 到 E，存在相关推导 <code>E ⇒ E 和 E ⇒ (E)T&#39;E&#39;</code>，所以 <code>Follow(E) = { ),# }</code></li><li>从 E 到 E’，存在相关推导 <code>E ⇒ TE&#39;</code> 和 <code>E ⇒ TE&#39; ⇒ T+TE&#39; ⇒ T+FT&#39;E&#39; ⇒ T+(E)T&#39;E&#39; ⇒ T+(TE&#39;)T&#39;E&#39;</code>，所以 <code>Follow(E&#39;) = { ),# }</code></li><li>从 E 到 T，存在相关推导 <code>E ⇒ TE&#39; ⇒ Tε ⇒ T</code> ， <code>E ⇒ TE&#39;⇒ T+TE&#39;</code> ， <code>E ⇒ TE&#39;⇒ T+TE&#39;⇒ FT&#39;+TE&#39; ⇒ (E)T&#39;+TE&#39; ⇒ (TE&#39;)T&#39;+TE&#39; ⇒ (Tε)T&#39;+TE&#39;⇒ (T)T&#39;+TE&#39;</code> ，所以 <code>Follow(T) = { +,),# }</code></li><li>从 E 到 T’，存在相关推导 <code>E ⇒ TE&#39; ⇒ FT&#39;E&#39; ⇒ FT&#39;ε</code> ， <code>E ⇒ TE&#39; ⇒ FT&#39;E&#39; ⇒ FT&#39;+TE‘</code>， <code>E ⇒ TE&#39; ⇒ FT&#39;E&#39; ⇒ FT&#39;ε ⇒ F*FT’ ⇒ F*(E)T&#39; ⇒ F*(TE&#39;)T&#39; ⇒ F*(FT&#39;E&#39;)T&#39; ⇒ F*(FT&#39;)T</code>， 所以 <code>Follow(T&#39;) = { +,),# }</code></li><li>从 E 到 F，存在相关推导 <code>E ⇒ TE&#39; ⇒ FT&#39;E ⇒ F*FT&#39;E&#39;</code>， <code>E ⇒ TE&#39; ⇒ FT&#39;E ⇒ F*FE&#39; ⇒ F*F</code>， <code>E ⇒ TE&#39; ⇒ FT&#39;E ⇒ F*FE&#39; ⇒ F*(E) ⇒ F*(TE&#39;) ⇒ F*(FT&#39;E&#39;) ⇒ F*(F)</code>，<code>E ⇒ TE&#39; ⇒ FT&#39;E ⇒ FT&#39;TE&#39;⇒ FT&#39;T+TE ⇒ FT&#39;FT&#39;+TE ⇒ FT&#39;F+TE</code> 所以 <code>Follow(T&#39;) = {*,#,),+}</code></li></ul><p>整个过程相当之麻烦，因为要尝试各种可能的组合，找出所有推导中每个非终结符后面可能跟着的终结符。但是我们可以稍微<strong>换个角度</strong>想一想，与其去求非终结符后面可能存在的终结符，不如先假设后面一定存在某个终结符，并尽可能地朝着那个方向进行替换。这并不会减轻我们的大部分工作，但是有目标总比没目标要来的轻松。</p><p>现在已经计算出 First 集和 Follow 集，接着计算各条产生式的 select 集就会轻松很多了：</p><pre class="line-numbers language-html"><code class="language-html">select(E → TE') = {i,(}
select(E' → +TE') = {+}
select(E' → ε) = { ε,),# }
select(T → FT') = {i,(}
select(T' → *FT') = {*}
select(T' → ε) = { ε,+,),# }
select(F → i) = {i}
select(F → (E)) = {(}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>左部相同的产生式，其 select 集两两之间不相交，所以可以确定该文法为 <code>LL(1)</code> 文法。</p><blockquote><p>若某个非终结符的 First 集存在空符号串，该 First 集和 Follow 集是否会相交？</p></blockquote><p>观察 <code>E&#39; → +TE&#39;|ε</code> 和 <code>T&#39; → *FT&#39;|ε</code> 这两条产生式，会发现 E‘ 和 T’ 这两个非终结符的 First 集存在空符号串 —— 所以要分别对 E‘ 和 T’ 求 First 集和 Follow 集，看是否会与各自的 First 集相交。</p><p>我们上面已经求了 Follow 集，分别是 <code>{ ),# }</code> 和 <code>{ #,),+ }</code>，这里可以求 First 集，分别是 <code>{+，ε}</code> 和 <code>{*,ε}</code>，可以看出 Follow 集和对应的 First 集不相交。</p><p>综上，我们已经将这个文法改写为等价的 <code>LL(1)</code> 文法。</p><p><strong>② 构造预测分析表</strong></p><p>我们在上面求出 select 集，不仅仅是为了检测文法是否属于 <code>LL(1)</code> 文法，也是为了构造预测分析表。要构造构造预测分析表，首先写好基本结构，即行头（非终结符）和列头（终结符）：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/7.png" style="zoom:67%"></p><p>如何填充矩阵的元素呢？我们把上面求出的 select 集拿过来：</p><pre class="line-numbers language-html"><code class="language-html">select(E → TE') = {i,(}
select(E' → +TE') = {+}
select(E' → ε) = { ε,),# }
select(T → FT') = {i,(}
select(T' → *FT') = {*}
select(T' → ε) = { ε,+,),# }
select(F → i) = {i}
select(F → (E)) = {(}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对每一个终结符 <code>x</code>，若终结符 <code>x</code> 存在于 <code>select(X → Y)</code> 中，则将产生式 <code>X → Y</code> 填入非终结符 <code>X</code> 对应于终结符 <code>x</code> 的矩阵元素中。再填充完所有能找到的元素之后，剩下未填充的一律留白，作为错误标志。</p><p>比如说，终结符 <code>i</code> 存在于 <code>select(E → TE&#39;) = {i,(}</code>，<code>select(T → FT&#39;) = {i,(}</code>，<code>select(F → i) = {i}</code> 中，那么就把 <code>E → TE&#39;</code> 填入 <code>E</code> 对应于 <code>i</code> 的矩阵元素中，把 <code>T → FT&#39;</code> 填入 <code>T</code> 对应于 <code>i</code> 的矩阵元素中，以此类推。所以，我们最终得到了如下的预测分析表：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/6.png" style="zoom:67%"></p><p><strong>③ 进行预测分析</strong></p><p>经过“长途跋涉”，终于可以针对输入符号串 <code>i + i * i#</code> 开始我们正式的预测分析过程了！首先准备一个栈、一个输入符号列表和一个所用产生式列表：</p><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">输入符号</th><th style="text-align:center">所用产生式</th></tr></thead><tbody><tr><td style="text-align:center">#E</td><td style="text-align:center">…….</td><td style="text-align:center">…….</td></tr></tbody></table><p>正如之前所说，一开始栈里是 <code>#E</code>，首先输入的符号是 i，对照预测分析表，找到我们要使用的产生式：</p><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">输入符号</th><th style="text-align:center">所用产生式</th></tr></thead><tbody><tr><td style="text-align:center">#E</td><td style="text-align:center">i</td><td style="text-align:center"><code>E → TE&#39;</code></td></tr></tbody></table><p>因为栈顶元素和输入符号不等，所以栈顶元素出栈，产生式右部逆序进栈，输入符号不变。此时再对照预测分析表，找到我们要使用的产生式：</p><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">输入符号</th><th style="text-align:center">所用产生式</th></tr></thead><tbody><tr><td style="text-align:center">#E</td><td style="text-align:center">i</td><td style="text-align:center"><code>E → TE&#39;</code></td></tr><tr><td style="text-align:center">#E’T</td><td style="text-align:center">i</td><td style="text-align:center"><code>T → FT&#39;</code></td></tr></tbody></table><p>同理，栈顶元素出栈，产生式右部逆序进栈，输入符号不变，改变所用产生式：</p><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">输入符号</th><th style="text-align:center">所用产生式</th></tr></thead><tbody><tr><td style="text-align:center">#E</td><td style="text-align:center">i</td><td style="text-align:center"><code>E → TE&#39;</code></td></tr><tr><td style="text-align:center">#E’T</td><td style="text-align:center">i</td><td style="text-align:center"><code>T → FT&#39;</code></td></tr><tr><td style="text-align:center">#E’T‘F</td><td style="text-align:center">i</td><td style="text-align:center"><code>F → i</code></td></tr></tbody></table><p>继续出栈和进栈：</p><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">输入符号</th><th style="text-align:center">所用产生式</th></tr></thead><tbody><tr><td style="text-align:center">#E</td><td style="text-align:center">i</td><td style="text-align:center"><code>E → TE&#39;</code></td></tr><tr><td style="text-align:center">#E’T</td><td style="text-align:center">i</td><td style="text-align:center"><code>T → FT&#39;</code></td></tr><tr><td style="text-align:center">#E’T‘F</td><td style="text-align:center">i</td><td style="text-align:center"><code>F → i</code></td></tr><tr><td style="text-align:center">#E’T‘i</td><td style="text-align:center">i</td><td style="text-align:center">匹配</td></tr></tbody></table><p>栈顶元素和输入符号匹配，且不等于 #，此时就让栈顶元素出栈，同时扫描下一个输入符号，找到对应的产生式：</p><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">输入符号</th><th style="text-align:center">所用产生式</th></tr></thead><tbody><tr><td style="text-align:center">#E</td><td style="text-align:center">i</td><td style="text-align:center"><code>E → TE&#39;</code></td></tr><tr><td style="text-align:center">#E’T</td><td style="text-align:center">i</td><td style="text-align:center"><code>T → FT&#39;</code></td></tr><tr><td style="text-align:center">#E’T‘F</td><td style="text-align:center">i</td><td style="text-align:center"><code>F → i</code></td></tr><tr><td style="text-align:center">#E’T‘i</td><td style="text-align:center">i</td><td style="text-align:center">匹配</td></tr><tr><td style="text-align:center">#E’T‘</td><td style="text-align:center">+</td><td style="text-align:center"><code>T&#39; → ε</code></td></tr></tbody></table><p>继续出栈和进栈：</p><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">输入符号</th><th style="text-align:center">所用产生式</th></tr></thead><tbody><tr><td style="text-align:center">#E</td><td style="text-align:center">i</td><td style="text-align:center"><code>E → TE&#39;</code></td></tr><tr><td style="text-align:center">#E’T</td><td style="text-align:center">i</td><td style="text-align:center"><code>T → FT&#39;</code></td></tr><tr><td style="text-align:center">#E’T‘F</td><td style="text-align:center">i</td><td style="text-align:center"><code>F → i</code></td></tr><tr><td style="text-align:center">#E’T‘i</td><td style="text-align:center">i</td><td style="text-align:center">匹配</td></tr><tr><td style="text-align:center">#E’T‘</td><td style="text-align:center">+</td><td style="text-align:center"><code>T&#39; → ε</code></td></tr><tr><td style="text-align:center">#E’</td><td style="text-align:center">+</td><td style="text-align:center"><code>E&#39; → +TE&#39;</code></td></tr></tbody></table><p>此后的过程类似，这里就不一一展示了。在某个时刻，我们到达下面这个状态：</p><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">输入符号</th><th style="text-align:center">所用产生式</th></tr></thead><tbody><tr><td style="text-align:center">#E</td><td style="text-align:center">i</td><td style="text-align:center"><code>E → TE&#39;</code></td></tr><tr><td style="text-align:center">#E’T</td><td style="text-align:center">i</td><td style="text-align:center"><code>T → FT&#39;</code></td></tr><tr><td style="text-align:center">#E’T‘F</td><td style="text-align:center">i</td><td style="text-align:center"><code>F → i</code></td></tr><tr><td style="text-align:center">#E’T‘i</td><td style="text-align:center">i</td><td style="text-align:center">匹配</td></tr><tr><td style="text-align:center">#E’T‘</td><td style="text-align:center">+</td><td style="text-align:center"><code>T&#39; → ε</code></td></tr><tr><td style="text-align:center">#E’</td><td style="text-align:center">+</td><td style="text-align:center"><code>E&#39; → +TE&#39;</code></td></tr><tr><td style="text-align:center">…….</td><td style="text-align:center">…….</td><td style="text-align:center">…….</td></tr><tr><td style="text-align:center">#E’</td><td style="text-align:center">#</td><td style="text-align:center"><code>E&#39; → ε</code></td></tr></tbody></table><p>在这个状态下继续往后执行：</p><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">输入符号</th><th style="text-align:center">所用产生式</th></tr></thead><tbody><tr><td style="text-align:center">…….</td><td style="text-align:center">…….</td><td style="text-align:center">…….</td></tr><tr><td style="text-align:center">#E’</td><td style="text-align:center">#</td><td style="text-align:center"><code>E&#39; → ε</code></td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">#</td><td style="text-align:center">匹配且等于 #</td></tr></tbody></table><p>这时候，栈顶元素等于输入符号等于 #，说明成功完成了分析，符号串是符合该文法的。</p><h4 id="4-3-错误处理"><a href="#4-3-错误处理" class="headerlink" title="4.3 错误处理"></a>4.3 错误处理</h4><p>具体对错误的处理，我们可以向预测分析表中引入同步符号。针对每一个非终结符 X，如果他的 Follow 集包含终结符 x，则把矩阵对应的元素 <code>[X,x]</code> 加上同步符号，表示将 x 加入 X 的同步符号集。因此，我们得到了如下的预测分析表：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/8.png" style="zoom:80%"></p><p>这样，在进行分析的时候，如果矩阵元素还是空，则跳过当前输入符号；如果矩阵元素为 synch，则弹出栈顶非终结符；如果栈顶终结符和输入符号不匹配，则弹出栈顶终结符。</p><h3 id="6-更简单地构造-Follow-集和分析表"><a href="#6-更简单地构造-Follow-集和分析表" class="headerlink" title="6. 更简单地构造 Follow 集和分析表"></a>6. 更简单地构造 Follow 集和分析表</h3><p>上面构造 Follow 集和分析表存在的问题：</p><ul><li>求解 Follow 集采用的是定义推导的方式，基本上需要穷举各种可能的情况，太过繁琐</li><li>构造分析表之前额外求解了 Select 集，其实这不是必要的，完全可以只通过 First 集和 Follow 集构造</li></ul><p>这里补充介绍更加简便的方法。</p><p>首先我们的目标文法不变，还是这个：</p><pre class="line-numbers language-html"><code class="language-html">E → TE'
E' → +TE'|ε
T → FT'
T' → *FT'|ε
F → i|(E)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为这次不使用 Select 集，所以只需要求解非终结符的 First 集，而不是产生式右部的 First 集。这里直接写结果：</p><pre class="line-numbers language-html"><code class="language-html">First(E) = First(T) = First(F) = {i,(}
First(E') = {+,ε}
First(T') = {*,ε}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-1-构造-Follow-集"><a href="#6-1-构造-Follow-集" class="headerlink" title="6.1 构造 Follow 集"></a>6.1 构造 Follow 集</h4><p>依次使用下面的规则构造各条产生式的 Follow 集：</p><p>① <code>#</code> 属于 <code>Follow(S)</code>（S 表示开始符号）</p><p>② 遍历每一条产生式，尝试将产生式用 <code>A -&gt; αBβ</code> 的格式代替，若符合格式，则有 <code>First(β)-{ε}∈Follow(B)</code></p><p>③ 遍历每一条产生式，尝试将产生式用 <code>A -&gt; αB</code> 的格式代替；或者用 <code>A -&gt; αBβ</code> 且 <code>ε∈First(β)</code>代替，若符合格式，则有 <code>Follow(A)∈Follow(B)</code></p><p>④ 综上上面所求的所有 Follow 集</p><p><strong>以上面的文法为例，尝试构造 Follow 集：</strong></p><p>① <code>#</code> 属于 <code>Follow(E)</code></p><p>② 遍历每一条产生式：</p><ul><li><code>E → TE&#39;</code>：E 对应 A，T 对应 B，E‘ 对应 β，所以 <code>First(E&#39;)-{ε}∈Follow(T)={+}</code></li><li><code>E&#39; → +TE&#39;|ε</code>：E’ 对应 A，T 对应 B（不能让 E‘ 对应 B，否则 β 为空，无意义），E’ 对应 β，后面的过程和上一条推导重复了，故忽略本条产生式</li><li><code>T → FT&#39;</code>：T 对应 A，F 对应 B，T‘ 对应 β，所以 <code>First(T&#39;)-{ε}∈Follow(F)={*}</code></li><li><code>T&#39; → *FT&#39;|ε</code>：T’ 对应 A，F 对应 B，T’ 对应 β，后面的过程和上一条推导重复了，故忽略本条产生式</li><li><code>F → (E)|i</code>：F 对应 A，E 对应 B，）对应 β，所以 <code>First())∈Follow(E)={)}</code>，加上在 ① 中求出的 <code>Follow(E)</code>，故 <code>Follow(E)={ #,) }</code></li></ul><p>③ 遍历每一条产生式：</p><ul><li><code>E → TE&#39;</code>：E 对应 A，T 对应 α，E‘ 对应 B，所以 <code>Follow(E)∈Follow(E&#39;)={ #,) }</code>；换种方式，E 对应 A，T 对应 B，E’ 对应 β，且 <code>ε∈First(E&#39;)</code>，所以 <code>Follow(E)∈Follow(T)={+,#,)}</code>；或者，E 对应 A，T 对应 α，E‘ 对应 B，且 <code>ε∈First(ε)</code>，所以 <code>Follow(E)∈Follow(E&#39;)={ #,) }</code>，这和最开始的推导重复了，故忽略之</li><li><code>T → FT&#39;</code>：T 对应 A，F 对应 α，T‘ 对应 B，所以 <code>Follow(T)∈Follow(T&#39;)={+}</code>；换种方式，类似上面的，可以推导得到 <code>Follow(F)={ *,+,),# }</code>，以及得到 <code>Follow(T&#39;)={ +,),# }</code></li><li><code>E&#39; → +TE&#39;|ε</code>：E’ 对应 A，+T 对应 α，E’ 对应 B，所以 <code>Follow(E&#39;)∈Follow(E&#39;)</code>，忽略之；换种方式，E’ 对应 A，+ 对应 α，T 对应 B，E‘ 对应 β，因为 <code>Follow(E&#39;)</code> 本身已经属于<code>Follow(T)</code>，故忽略之</li><li><code>T&#39; → *FT&#39;|ε</code>：整个过程类似上面的，没有得到新的推导结果，故忽略之</li><li><code>F → (E)|i</code>：F 对应 A，<code>(</code> 对应 α，E 对应 B， <code>)</code> 对应 β，但是 <code>)</code> 无法推导得到 <code>ε</code>，所以忽略之</li></ul><p>④ 综上，Follow 集如下：</p><pre class="line-numbers language-html"><code class="language-html">Follow(E) = Follow(E’) = { ),# }
Follow(T) = Follow(T’) = { +,),# }
Follow(F) = { *,+,),# }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-2-构造分析表"><a href="#6-2-构造分析表" class="headerlink" title="6.2 构造分析表"></a>6.2 构造分析表</h4><p>要构造构造预测分析表，首先写好基本结构，即行头（非终结符）和列头（终结符）：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/7.png" style="zoom:67%"></p><p>如何填充矩阵的元素呢？我们把上面求出的 First 集和 Follow 集拿过来：</p><pre class="line-numbers language-html"><code class="language-html">First(E) = First(T) = First(F) = {i,(}
First(E') = {+,ε}
First(T') = {*,ε}

Follow(E) = Follow(E’) = { ),# }
Follow(T) = Follow(T’) = { +,),# }
Follow(F) = { *,+,),# }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看 <code>[E,i]</code> 对应的单元格，将 <code>E → TE&#39;</code> 填入，查看 <code>[E,(]</code> 对应的单元格，同样将 <code>E → TE&#39;</code> 填入</li><li>查看 <code>[T,i]</code> 和 <code>[T,(]</code> 对应的单元格，这里和上面一样</li><li>查看 <code>[F,i]</code> 对应的单元格，将 <code>F → i</code> 填入；查看 <code>[F,(]</code> 对应的单元格，将 <code>F → (E)</code> 填入</li><li>查看 <code>[E’,+]</code> 对应的单元格，将 <code>E‘ → +TE’</code> 填入；查看 <code>[E‘,ε]</code> 对应的单元格，<strong>注意这里遇到了 ε，转到 Follow 集查看</strong>，来到 <code>Follow(E’)={ ),# }</code>，将 <code>[E’,)]</code> 和 <code>[E&#39;,#]</code> 对应的单元格都填入 <code>E&#39;-&gt;ε</code></li></ul><p>总之，优先以 First 集为准，查看每个单元格，并将相应的产生式放进去，若遇到 <code>ε</code>，则跳转到 Follow 集查看。后面的情况都是类似的，这里就不一一说明了，最后还没填充的单元格一律空着即可。</p><p>所以，我们最终得到了如下的预测分析表：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/6.png" style="zoom:67%"></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/05/13/F-%E8%AE%B0%E4%B8%A4%E9%81%93%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%A2%98/" rel="prev" title="记两道关于事件循环的题"><i class="fa fa-angle-double-left"></i>&nbsp记两道关于事件循环的题</a></div><div class="post-nav-next"><a href="/2020/05/05/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-12%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%88%E4%BA%8C%EF%BC%89/" rel="next" title="操作系统学习笔记-12：内存分配（二）：非连续分配">操作系统学习笔记-12：内存分配（二）：非连续分配&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-语法分析"><span class="toc-text">1. 语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-语法分析器"><span class="toc-text">1.1 语法分析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-语法分析的方法"><span class="toc-text">1.2 语法分析的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-自顶向下语法分析存在的问题"><span class="toc-text">2. 自顶向下语法分析存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-左递归"><span class="toc-text">2.1 左递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-回溯"><span class="toc-text">2.2 回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-空符号串"><span class="toc-text">2.3 空符号串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LL-1-文法"><span class="toc-text">3. LL(1) 文法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-定义"><span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-判断"><span class="toc-text">3.2 判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-递归下降分析程序"><span class="toc-text">4. 递归下降分析程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-扩充的巴科斯范式"><span class="toc-text">4.1 扩充的巴科斯范式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-编写递归下降分析程序"><span class="toc-text">4.2 编写递归下降分析程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-预测分析程序"><span class="toc-text">5. 预测分析程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-主要流程"><span class="toc-text">4.1 主要流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-具体分析"><span class="toc-text">4.2 具体分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-错误处理"><span class="toc-text">4.3 错误处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-更简单地构造-Follow-集和分析表"><span class="toc-text">6. 更简单地构造 Follow 集和分析表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-构造-Follow-集"><span class="toc-text">6.1 构造 Follow 集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-构造分析表"><span class="toc-text">6.2 构造分析表</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->