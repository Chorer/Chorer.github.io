<!-- build time:Sat Apr 17 2021 16:21:40 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">AJAX 与跨域通信（二）：跨域解决方案</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-11-07&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp14 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/AJAX/">AJAX</a> <a href="/tags/跨域/">跨域</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1.png" alt=""></p><a id="more"></a><p>本篇讲解常见的几种跨域方案：<code>JSONP</code>、<code>CORS</code>、图像Ping、<code>document.domain</code>、<code>window.name</code>。</p><p>开始之前，要先清楚一件事：</p><blockquote><p>跨域不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器，无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。</p></blockquote><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h3><p><code>&lt;link&gt;</code> 获取 CSS，<code>&lt;script&gt;</code> 获取 JS，<code>&lt;img&gt;</code> 获取图片，这些明明也是跨域获取资源，为什么不会被禁止呢？很简单，因为这些都不属于上述特定操作之一，这里请求资源压根没用到 AJAX 请求。再看看我们的需求，我们现在是要在 A 域中获取 B 域资源，那么我完全可以在 A 域中动态创建一个 <code>script</code> 并请求 B 域资源，然后，因为 A 域中的 js 和 <code>scirpt</code> 中的 js 是在同一个作用域中的，所以要在 A 域中展示 B 域的数据也完全不成问题。虽然说法比较简陋，但这就是 JSONP 的原理。下面我们来看看具体实现：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 1.回调函数</span>
<span class="token keyword">function</span> <span class="token function">handleResponse</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 2.动态创建 script </span>
<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://test.com/test?callback=handleResponse'</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>script<span class="token punctuation">,</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端：这段代码声明了一个用以接受数据的回调函数，之后动态创建了 <code>script</code> 并插入到 <code>body</code> 中，一旦执行遇到语句 <code>&lt;script src=&#39;http://test.com/test?callback=handleResponse&#39;&gt;&lt;/script&gt;</code>，就会向服务器发起一次携带参数的请求；</li><li>服务端：收到请求，拿到查询参数 callback 的值是 handleResponse，准备好数据 <code>data</code>，之后会生成一个对应的函数执行语句字符串，也就是 <code>handleResponse(data)</code>，这个语句返回给了客户端这边，客户端直接执行（注意：当前作用域确实声明了这个 handleResponse 函数），打印相关数据 —— 这里客户端其实已经拿到服务端的数据了，所以算是完成了一次跨域请求。</li></ul><p>JSONP 使用起来虽然很简单，但是有如下缺点：</p><ul><li>只能发送 GET 请求，无法发送 POST 请求</li><li>安全问题。万一服务端那边夹带恶意代码返回过来，那么客户端这边是会直接执行的，因此有安全隐患</li><li>无法监测 JSONP 请求是否成功或失败</li></ul><h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2. CORS"></a>2. CORS</h3><blockquote><p>CORS 即 Cross-origin resource sharing，跨域资源共享 ，是由 W3C 官方推广的允许通过 AJAX 技术跨域获取资源的规范 。</p></blockquote><p>CORS 的关键在于服务端，也就是客户端这边发送请求，服务端那边做一些<strong>判断</strong>（请求方是否在自己的“白名单”里？），如果没问题就返回数据，否则拒绝。</p><p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要<strong>同时满足</strong>以下两大条件，就属于简单请求：</p><ul><li>请求方法是 <strong>HEAD</strong>，<strong>GET</strong>，<strong>POST</strong> 请求的其中一种；</li><li>HTTP的头信息只限于以下字段：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type（只能为 <code>application/x-www-form-urlencoded</code>，<code>multipart/form-data</code> 和 <code>text/plain</code> 其中一种）</li></ul></li></ul><p>凡不同时满足以上两大条件的，都属于非简单请求。</p><p>下面我们看一下针对这两种请求，CORS 是怎么处理。</p><h4 id="2-1-简单请求"><a href="#2-1-简单请求" class="headerlink" title="2.1 简单请求"></a>2.1 简单请求</h4><p>首先是客户端的角度，发送请求时浏览器检测到这是一个简单请求，因此在请求头额外增加一个 <code>Origin</code>，它的值是请求代码所在的源，例如 <code>http://test.com</code>：</p><pre class="line-numbers language-js"><code class="language-js">GET <span class="token operator">/</span>cors HTTP<span class="token operator">/</span><span class="token number">1.1</span>
Origin<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>test<span class="token punctuation">.</span>com
Host<span class="token punctuation">:</span> target<span class="token punctuation">.</span>com
Accept<span class="token operator">-</span>Language<span class="token punctuation">:</span> en<span class="token operator">-</span>US
Connection<span class="token punctuation">:</span> keep<span class="token operator">-</span>alive
User<span class="token operator">-</span>Agent<span class="token punctuation">:</span> Mozilla<span class="token operator">/</span><span class="token number">5.0</span> <span class="token operator">...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是服务端的角度，服务端收到请求，首先检测请求报头的 <code>Origin</code> 是否在自己的许可范围内，</p><p>如果确实是许可的域，那么待会响应的时候，响应头会额外增加如下字段：</p><ul><li>Access-Control-Allow-Origin（必选） ：这个字段用来告知客户端，服务端能够接受的发送 AJAX 请求的域，因为此次请求得到许可，所以这里返回与先前请求报头中 <code>Origin</code> 匹配的 <code>http://test.com</code>。当然，也可以返回 <code>*</code>，表示接受任何域的 AJAX 请求（<code>*</code> 是通配的意思）。</li><li>Access-Control-Allow-Credentials （可选）：告知浏览器，是否允许客户端发送请求的时候携带 Cookie，true 表示允许，false 表示禁止，出于安全问题考虑（前面说过），CORS 默认不允许跨域 AJAX 请求携带 Cookie。</li><li>Access-Control-Expose-Headers（可选）：该字段用来告知客户端暴露了哪些可以获取的响应头字段。默认情况下，xhr 的 <code>getResponseHeader()</code> 方法只能拿到 6 个基本响应头字段，如果还想额外拿到其它字段，那么前端要和后端商量好，让后端在 <code>Access-Control-Expose-Headers</code> 指定好前端可以通过该方法获取的额外响应头字段。</li></ul><p>如果不是许可的域，那么这时候其实压根不会返回 <code>Access-Control-Allow-Origin</code> 这个响应头，而浏览器会捕获这次错误，如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2.png" alt=""></p><p>PS：虽然禁止跨域 AJAX 请求携带 Cookie 是为了安全考虑，但由于它在身份验证中的重要性，我们有时候还是得携带 Cookie 的。 具体方法是：</p><ul><li>客户端配置 <code>withCredentials</code> 属性：</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>服务端配置 <code>Access-Control-Allow-Credential</code> 为 true，配置 <code>Access-Control-Allow-Origin</code> 为指定的域（而不是 <code>*</code>），</li></ul><h4 id="2-2-非简单请求"><a href="#2-2-非简单请求" class="headerlink" title="2.2 非简单请求"></a>2.2 非简单请求</h4><p>非简单请求包括两次请求，第一次请求是 preflight request，也就是预检/查询请求，这次请求试探性地“询问”服务端，自己打算进行的非简单请求是否合法 —— 不管是否合法，服务端都会通过某种方式通知客户端，客户端基于这个结果，判断是否进行第二次真正的请求。</p><p>预检请求是这样的：</p><p>首先是客户端的角度，发送请求时浏览器检测到这是一个非简单请求，所以事先向服务端发送一个预检请求：</p><pre class="line-numbers language-js"><code class="language-js">OPTIONS <span class="token operator">/</span>cors HTTP<span class="token operator">/</span><span class="token number">1.1</span>
Origin<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>test<span class="token punctuation">.</span>com
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Method<span class="token punctuation">:</span> PUT
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Headers<span class="token punctuation">:</span> Custom<span class="token operator">-</span>Header1<span class="token punctuation">,</span>Custom<span class="token operator">-</span>Header2
Host<span class="token punctuation">:</span> target<span class="token punctuation">.</span>com
Accept<span class="token operator">-</span>Language<span class="token punctuation">:</span> en<span class="token operator">-</span>US
Connection<span class="token punctuation">:</span> keep<span class="token operator">-</span>alive
User<span class="token operator">-</span>Agent<span class="token punctuation">:</span> Mozilla<span class="token operator">/</span><span class="token number">5.0</span><span class="token operator">...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>注意，这里这个预检请求的请求方法是 <strong>OPTIONS</strong> 。</li><li><p>像之前的简单请求一样，这里浏览器会追加一个 <code>Origin</code>，表示请求代码所在的源</p></li><li><p>前面我们说过，非简单请求会多出额外的请求头字段，这里多出来的就是 <code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> ，这其实是告诉服务端，“我待会要进行的真正请求，请求方法是这里 <code>Access-Control-Request-Method</code> 指定的方法，然后自定义请求头字段是这里 <code>Access-Control-Request-Headers</code> 指定的头字段，你看看行不行，给我个回应“。</p></li></ul><p>好了，我们来看看服务器作何反应。来到服务端的角度，服务端收到这个请求，它会检测请求头中的信息，发现这个请求是合法的、没啥毛病，“好，我同意你的第二次请求”，不过光说不行，得在返回的响应头中告诉客户端这一点，此时响应头是这样的：</p><pre class="line-numbers language-js"><code class="language-js">HTTP<span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> OK
Date<span class="token punctuation">:</span> Mon<span class="token punctuation">,</span> <span class="token number">01</span> Dec <span class="token number">2008</span> <span class="token number">01</span><span class="token punctuation">:</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">39</span> GMT
Server<span class="token punctuation">:</span> Apache<span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">.</span><span class="token number">61</span>（Unix）
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>test<span class="token punctuation">.</span>com
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token punctuation">:</span> GET<span class="token punctuation">,</span> POST<span class="token punctuation">,</span> PUT
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token punctuation">:</span> Custom<span class="token operator">-</span>Header1<span class="token punctuation">,</span>Custom<span class="token operator">-</span>Header2
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Max<span class="token operator">-</span>Age<span class="token punctuation">:</span> <span class="token number">1728000</span>
Content<span class="token operator">-</span>type<span class="token punctuation">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token number">-8</span>
Content<span class="token operator">-</span>Encoding<span class="token punctuation">:</span> gzip
Content<span class="token operator">-</span>Length<span class="token punctuation">:</span> <span class="token number">0</span>
Keep<span class="token operator">-</span>Alive<span class="token punctuation">:</span> timeout<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token number">100</span>
Connection<span class="token punctuation">:</span> Keep<span class="token operator">-</span>Alive
Content<span class="token operator">-</span>Type<span class="token punctuation">:</span> text<span class="token operator">/</span>plain
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Access-Control-Allow-Origin：这里和之前一样，可以是 <a href="http://test.com" target="_blank" rel="noopener">http://test.com</a> 或者 <code>*</code>，也就是告诉客户端，“我给你的域下了许可证“</li><li>Access-Control-Allow-Methods：这里告诉客户端，服务端允许的跨域 AJAX 请求的类型，”虽然你刚才告诉我你准备进行的是 PUT 请求，不过你要进行 GET 或者 POST 请求，我也是允许的“</li><li>Access-Control-Allow-Headers：这里告诉客户端，服务端允许的发送请求时的自定义请求头</li><li>Access-Control-Max-Age: 这里告诉客户端预检请求的有效期，省去了多次的预检请求。也就是说，”我给你开个后门，1728000 秒内（20天内）你可以直接发送真正的 AJAX 请求，不用每次都来问我了“</li></ul><p>再回到客户端这边，客户端收到响应，知道服务端允许了自己的请求，于是进行第二次真正的 AJAX 跨域请求。此后每次 CORS 请求都相当于一次简单请求了。</p><p>但是，如果发现客户端的请求是不合法的，那么服务端虽然会返回正常响应，但不会返回 CORS 相关的响应头，而客户端这边”心领神会“，知道被拒绝了，所以由 xhr 对象捕获这个错误，如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/AJAX%20%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-3.png" alt=""></p><p>我们可以来解读一下这个报错：</p><p>不管预检请求成功还是失败，服务端都会返回一个响应。客户端针对这个响应会进行一次 access control check，检查响应是否携带 Access-Control-Allow-Origin 头部字段，如果没有的话，则此次 check 失败，预检请求失败，抛出错误。</p><h3 id="3-图像-Ping"><a href="#3-图像-Ping" class="headerlink" title="3. 图像 Ping"></a>3. 图像 Ping</h3><ul><li>图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式，请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，通常是像素图和 204 响应。浏览器虽然得不到任何具体数据，但由于可以监听 load 和 error 事件，所以能知道响应是什么时候接受到的。</li><li>图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数</li><li>缺点：单向通信，只支持 GET 请求；无法访问服务器的响应文本</li></ul><h3 id="4-document-domain"><a href="#4-document-domain" class="headerlink" title="4. document.domain"></a>4. document.domain</h3><p>介绍 document.domain 跨域之前，先解释一下域名的一些概念。</p><ul><li>顶级域名：诸如 .com、.cn、.net、.org 等都是顶级域名，也叫一级域名</li><li>二级域名：诸如 baidu.com、zhihu.com、mdn.org 等</li><li>父域名、子域名：这是相对的概念，诸如 .com 是 tool.com 的父域名，而 tool.com 的子域名是 editor.tool.com，editor.tool.com 的子域名是 <a href="http://www.editor.tool.com" target="_blank" rel="noopener">www.editor.tool.com</a></li></ul><p>document.domain 适用于<strong>主域相同、子域不同</strong>的两个域之间的跨域通信。假设我现在有一个A域为 <a href="http://www.test.com/a.html" target="_blank" rel="noopener">http://www.test.com/a.html</a> ，另一个B域为 <a href="http://test.com/b.html" target="_blank" rel="noopener">http://test.com/b.html</a> ，因为是不同源的（域名不相同），所以我不能在A域中拿到B域的东西，但是呢，我们注意到这两个域的主域是相同的，只是子域不同而已，所以我们可以用 document.domain 的方法实现跨域，具体来说，就是重新设置两个页面的 document.domain 为一个相同的值。</p><p>但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成<strong>自身或更高一级的父域，且主域必须始终保持相同</strong>。例如：a.b.test.com 中某个文档的 document.domain 可以设成a.b.test.com（自身）、b.test.com（上一级父域） 、test.com（上上一级父域）中的任意一个，但是不可以设成 c.a.b.test.com（下一级子域），因为这是当前域的子域，也不可以设成 baidu.com，因为主域已经不相同了，这里的主域必须始终保持为 test.com 不变。</p><p>来看代码：</p><p>A域 <a href="http://www.test.com/a.html" target="_blank" rel="noopener">http://www.test.com/a.html</a> ：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span> http://test.com/b.html<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myIframe<span class="token punctuation">"</span></span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'test.com'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置成主域（比自己高一级的父域）</span>
    <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myIframe'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contentWindow<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B域 <a href="http://test.com/b.html" target="_blank" rel="noopener">http://test.com/b.html</a> ：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'test.com'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 虽然本来就是 test.com，但还是要显式设置一次</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后，我们就可以在 A 域中拿到 B 域的东西了。注意，尽管这时候 document.domain 是一样的，但两个域之间只是可以交互而已，仍然不能发送 AJAX 请求。</p><h3 id="5-window-name"><a href="#5-window-name" class="headerlink" title="5. window.name"></a>5. window.name</h3><p>首先要明白一件事 —— window 对象有个 name 属性，在一个窗口的生命周期内，<code>window.name</code> 会被该窗口的所有页面所共享、所读写，不管这些页面是同源还是不同源。</p><p>那么，我们岂不是可以把数据放在 <code>window.name</code> 里，然后通过页面跳转把这些数据拿到自己这边来？有道理，不过每次要拿数据就得跳转页面，好像有点麻烦，不妨我们把这个页面跳转的过程放在 <code>iframe</code> 里进行。假定请求数据的页面是 a.html，存放数据的页面是 c.html，那么我们在 a.html 中通过 <code>iframe</code> 加载 c.html，这时候数据已经存放在 <code>iframe</code> 这个窗口的 <code>window.name</code> 里了，之后我们让其跳转到与 a.html 同源的 b.html，根据前面说的，<code>window.name</code> 仍然是被保留的、可访问的，那么 <code>window.name</code> 由 c 传递到了 b，并且由于此时 a.html、b.html 同源，所以 <code>window.name</code> 又可经由 b 传递给 a。</p><p>下面说说代码实现：</p><pre class="line-numbers language-html"><code class="language-html">// c.html
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">
    window<span class="token punctuation">.</span>name <span class="token operator">=</span> 我是要传递的 json 数据<span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html">// b.html
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    我只是一个中转站
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html">// a.html

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
<span class="token keyword">var</span> p <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> isFirst <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3001/c.html'</span><span class="token punctuation">;</span> 
iframe<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">'none'</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//监听 iframe 的两次加载（分别是加载 c.html 和 b.html 的时候）</span>
iframe<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>isFirst<span class="token punctuation">)</span><span class="token punctuation">{</span>
        iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/b.html'</span><span class="token punctuation">;</span>
        isFirst <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
        p<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 销毁iframe</span>
        iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span>
        iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
        iframe <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里动态创建了 <code>iframe</code>，并指定第一次加载的 <code>iframe</code> 是 c.html，一旦加载好（很显然这时候 <code>window.name</code> 的值已经记录在这个窗口里了），就执行回调函数，通过修改 src 让页面跳转到 b.html（这时候 <code>window.name</code> 的值传递给了 b.html），第二次触发执行回调函数，将最初的数据传递给 a.html。</p><p>注意两个地方：</p><ul><li>由于整个过程是悄悄进行的，我们给 <code>iframe</code> 设置 <code>display:none</code></li><li>拿到数据后记得销毁 <code>iframe</code>，防止内存泄露</li></ul><p>上面的写法不需要重写 onload 回调函数，只用一个 flag 标识第一和第二次加载；我们也可以采用下面的方法重写 onload 回调：</p><pre class="line-numbers language-js"><code class="language-js">iframe<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    iframe<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        p<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
        iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span>
        iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
        iframe <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:3000/b.html'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：</p><p>《JavaScript 高级程序设计》第三版<br><a href="https://juejin.im/post/5a274ae9f265da430a5071eb" target="_blank" rel="noopener">再也不学AJAX了！（三）跨域获取资源 ② - JSONP &amp; CORS</a><br><a href="https://www.cnblogs.com/2050/p/3191744.html" target="_blank" rel="noopener">js 中几种常用的跨域方法详解</a><br><a href="https://github.com/FatDong1/cross-domain" target="_blank" rel="noopener">cross-domain github demo</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/11/09/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%89%EF%BC%89/" rel="prev" title="AJAX 与跨域通信（三）：跨域解决方案"><i class="fa fa-angle-double-left"></i>&nbspAJAX 与跨域通信（三）：跨域解决方案</a></div><div class="post-nav-next"><a href="/2019/11/07/F-AJAX%E4%B8%8E%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%EF%BC%88%E4%B8%80%EF%BC%89/" rel="next" title="AJAX 与跨域通信（一）：AJAX 与同源策略">AJAX 与跨域通信（一）：AJAX 与同源策略&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JSONP"><span class="toc-text">1. JSONP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CORS"><span class="toc-text">2. CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-简单请求"><span class="toc-text">2.1 简单请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-非简单请求"><span class="toc-text">2.2 非简单请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-图像-Ping"><span class="toc-text">3. 图像 Ping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-document-domain"><span class="toc-text">4. document.domain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-window-name"><span class="toc-text">5. window.name</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->