<!-- build time:Thu Jul 16 2020 12:28:41 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">数据结构与算法笔记 cp2-2：线性表</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-09-23&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.9k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/数据结构/">数据结构</a> <a href="/tags/算法/">算法</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-0.jpg" alt=""><br><a id="more"></a></p><h2 id="线性表的链式存储结构-链表"><a href="#线性表的链式存储结构-链表" class="headerlink" title="线性表的链式存储结构 / 链表"></a>线性表的链式存储结构 / 链表</h2><h3 id="1-1-定义："><a href="#1-1-定义：" class="headerlink" title="1.1 定义："></a>1.1 定义：</h3><blockquote><p>线性表的链式存储结构不限制数据元素的物理存储状态，也就是说，其数据元素的物理位置是随机的。</p></blockquote><p>对于每一个元素来说，它需要存储自身信息在<strong>数据域</strong>中，还需要存储直接后继的位置信息在<strong>指针域</strong>中，这两部分信息共同构成一个结点（Node）。n 个结点就链结成一个<strong>链表</strong>，如果每一个结点只有一个指针域，那么它就是单链表。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-4.png" alt=""></p><p><strong>头指针</strong>：头指针保存第一个结点（首元结点）的存储位置，因为最后一个结点没有后继结点，所以它的指针域为空(<code>NULL</code> / <code>^</code>)。</p><p><strong>头结点</strong>：有时候，首元结点前还会设置一个头结点，有头结点的时候，头指针保存的是头结点的存储位置。对于头结点，其数据域不一定要包含信息，其指针域则保存的是首元结点的存储位置。如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-5.png" alt=""></p><p>Tip: 设计头结点是为了操作的统一。</p><p>链表并不是<strong>随机存取结构</strong>，并不能根据一个给定元素就能马上找到另一个目标元素，而是只能从头指针开始顺链查找，这称为<strong>顺序存取结构</strong>。</p><h3 id="1-2-单链表："><a href="#1-2-单链表：" class="headerlink" title="1.2 单链表："></a>1.2 单链表：</h3><p>在开始之前，我们还是先定义单链表中每个结点的结构：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Link<span class="token punctuation">{</span>
    <span class="token keyword">char</span> elem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数据域</span>
    <span class="token keyword">struct</span> Link <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指针域</span>
<span class="token punctuation">}</span>link<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// link为结点名，每个结点都是一个 link 结构体</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Tip：因为指针也是指向一个结点，这里尤其要注意将指针类型声明为 <code>struct Link</code></p><p><strong>(1) 初始化空表：</strong></p><pre class="line-numbers language-c"><code class="language-c">link <span class="token operator">*</span><span class="token function">initLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    link <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个头结点</span>
    link <span class="token operator">*</span>temp <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 声明头指针并指向头结点</span>
    temp<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 头结点的指针域置空</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(2) 整表创建：</strong></p><p>例如，创建一个存储 {1,2,3,4} 且无头结点的链表：</p><pre class="line-numbers language-c"><code class="language-c">link <span class="token operator">*</span><span class="token function">initLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里函数返回一个 link 类型的指针，所以函数名加 *</span>
    link <span class="token operator">*</span>temp <span class="token operator">=</span> <span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建首元结点</span>
    link <span class="token operator">*</span>p <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建头指针并指向首元结点</span>

    <span class="token comment" spellcheck="true">// 首元节点先初始化</span>
    temp<span class="token operator">-></span>elem <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    temp<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 从第二个节点开始创建</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true">// 创建一个新节点并初始化</span>
        link <span class="token operator">*</span>a<span class="token operator">=</span><span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        a<span class="token operator">-></span>elem<span class="token operator">=</span>i<span class="token punctuation">;</span>
        a<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 将temp节点与新建立的a节点建立逻辑关系</span>
        temp<span class="token operator">-></span>next<span class="token operator">=</span>a<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 指针temp每次都指向新链表的最后一个节点</span>
        temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//返回建立的节点，只返回头指针 p 即可，通过头指针即可找到整个链表</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(3) 查找元素：</strong></p><pre class="line-numbers language-c"><code class="language-c">p 为原链表，elem 表示被查找的元素
link <span class="token operator">*</span><span class="token function">selectElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 新建一个指针，直接指向首元结点</span>
    link <span class="token operator">*</span>t <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>t <span class="token operator">&amp;&amp;</span> t<span class="token operator">-></span>elem <span class="token operator">!=</span> elem<span class="token punctuation">)</span><span class="token punctuation">{</span>
        t<span class="token operator">=</span>t<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为存在头结点，所以这里首先获取首元结点，然后从首元结点开始依次往后面遍历，查找是否有符合的元素。如果查找成功，返回的 t 是元素的地址，查找失败则返回 NULL。</p><p><strong>(4) 修改元素：</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// change 表示目标结点在链表中的位置，newElem 为新的数据域的值</span>
link <span class="token operator">*</span><span class="token function">changeElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> change<span class="token punctuation">,</span><span class="token keyword">int</span> newElem<span class="token punctuation">)</span><span class="token punctuation">{</span>
    link <span class="token operator">*</span>temp <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 遍历到要修改的结点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>change<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    temp<span class="token operator">-></span>elem <span class="token operator">=</span> newElem<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(5) 删除元素：</strong><br>包括两步，一个是摘除结点并改变连接，一个是释放被摘除结点的内存。关键代码是：</p><pre class="line-numbers language-c"><code class="language-c">temp<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-6.png" alt=""></p><p>具体实现代码是：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//p为原链表，add 为要删除元素的位序</span>
link <span class="token operator">*</span><span class="token function">delElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// temp 首先指向首元结点</span>
    link <span class="token operator">*</span>temp <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 先寻找被删除结点的上一个结点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>add<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    link <span class="token operator">*</span>del <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 单独设置一个指针指向被删除结点，后面方便释放其内存</span>
    temp<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 手动释放该结点，防止内存泄漏</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这是没有头结点的情况，如果有头结点，循环判断应该是 i&lt;add，因为初始的 temp 指向的是头结点。</p><p><strong>(6) 插入元素：</strong><br>包括两步，一个是将插入位置后的结点作为新结点的 next，一个是将新结点作为插入位置前的结点的 next，也就是关键代码：</p><pre class="line-numbers language-c"><code class="language-c">new<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
temp<span class="token operator">-></span>next <span class="token operator">=</span> new<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如下图所示：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-7.png" alt=""></p><p>注意：这里顺序不能颠倒，如果是先确定插入位置前结点和新结点的连接，那么插入位置后结点将无法获取，因为其获取是依赖于插入位置前结点的next的，而这个next已经被覆盖。</p><p>具体代码为：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// p为原链表，elem表示新数据元素，add表示新元素插入的位置</span>
link <span class="token operator">*</span><span class="token function">insertElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{</span>
    link <span class="token operator">*</span>temp <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建指向首元结点的指针</span>
    <span class="token comment" spellcheck="true">// 遍历寻找插入位置前的结点</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>add<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"插入位置无效\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 创建新结点并初始化</span>
    link <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c<span class="token operator">-></span>elem <span class="token operator">=</span> elem<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 改变连接关系</span>
    c<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    temp<span class="token operator">-></span>next <span class="token operator">=</span> c<span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>if 语句用来判断 add 是否合法，因为如果 add 过大，那么一直遍历下去会得到一个 next 为 <code>NULL</code> 的temp，之后报错。</p><h3 id="1-3-循环链表："><a href="#1-3-循环链表：" class="headerlink" title="1.3 循环链表："></a>1.3 循环链表：</h3><p>当单链表中最后一个结点的指针域不为空，而是<strong>指向头结点</strong>的时候，就形成一个环，这叫循环链表。循环链表进行元素遍历的时候，循环终止条件不再是 <code>p-&gt;next = NULL</code>，而是 <code>p-&gt;next = L</code>。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-8.png" alt=""></p><p>如果使用尾指针，那么可以用 O(1) 的时间找到尾结点和首元结点，而且可以简化合并两个循环链表的过程：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-9.png" alt=""></p><p>对于上面这两个循环链表，合并的思路大概是：A表尾连B表头。所以这里要改变 rearA-&gt;next，事先要先保存一开始的 rearA-&gt;next，即A表的头结点，之后将B表的首元结点给 rearA-&gt;next；之后我们要将一开始保留的A表头结点作为 rearB-&gt;next，事先要先保存一开始的 rearA-&gt;next，即B表的头结点，方便最后释放内存。</p><p>用图片表示的思路是：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-10.png" alt=""></p><p>用代码表示的思路是：</p><pre class="line-numbers language-c"><code class="language-c">p <span class="token operator">=</span> rearA<span class="token operator">-></span>next<span class="token punctuation">;</span>
rearA<span class="token operator">-></span>next <span class="token operator">=</span> rearB<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
reerB<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-双向链表"><a href="#1-4-双向链表" class="headerlink" title="1.4 双向链表"></a>1.4 双向链表</h3><p>单链表的每一个结点中，额外多出一个指向前驱结点的指针域，这时候就成了双向链表。双向链表的尾结点指针域指向头结点时，就成了双向循环链表，如下图：</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-11.png" alt=""></p><p><strong>插入操作</strong></p><p>插入操作一定要注意顺序，我们可以先处理新结点的前驱和后继，之后再依次处理后结点、前结点。</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-12.png" alt=""></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 新结点的前驱后继</span>
s<span class="token operator">-></span>prior <span class="token operator">=</span> p<span class="token punctuation">;</span>
s<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 后结点</span>
p<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> s<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 前结点</span>
p<span class="token operator">-></span>next <span class="token operator">=</span> s<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除操作</strong></p><p>删除很简单，如下图把中间的 p 删除，那么对于后结点，我们要修复它的前驱指针；对于前结点，我们要修复它的后继指针，最后一步是释放被删除结点的内存</p><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%20cp2-2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8-13.png" alt=""></p><pre class="line-numbers language-c"><code class="language-c">p<span class="token operator">-></span>prior<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
p<span class="token operator">-></span>next<span class="token operator">-</span>prior <span class="token operator">=</span> p<span class="token operator">-></span>prior<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/09/28/F-%E7%94%A8%20key%20%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0/" rel="prev" title="用 :key 管理可复用元素"><i class="fa fa-angle-double-left"></i>&nbsp用 :key 管理可复用元素</a></div><div class="post-nav-next"><a href="/2019/09/22/CB-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0cp2-1/" rel="next" title="数据结构与算法笔记 cp2-1：线性表">数据结构与算法笔记 cp2-1：线性表&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表的链式存储结构-链表"><span class="toc-text">线性表的链式存储结构 &#x2F; 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-定义："><span class="toc-text">1.1 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-单链表："><span class="toc-text">1.2 单链表：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-循环链表："><span class="toc-text">1.3 循环链表：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-双向链表"><span class="toc-text">1.4 双向链表</span></a></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2020</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->