<!-- build time:Sun Sep 05 2021 16:01:26 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">原型式继承和类式继承</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-03-17&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.8k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp7 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%92%8C%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF/java-vs-javascript.jpg"></div><span id="more"></span><p>Java和JavaScript都是面向对象的语言，但二者的继承方式截然不同。前者采用类式继承（classical inheritence），也是大多数面向对象语言的继承方式。而后者采用原型式继承（prototype ineritence），因此称JavaScript为基于对象更加合适。</p><h3 id="javascript的继承">1.JavaScript的继承</h3><p>就JavaScript的继承来说，又可以分为es5的继承和es6的继承。参考阮一峰老师在《ES6标准入门》一书中所说的： &gt; 在ES6之前，class是保留字，ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><p>虽然在es6中引入了类的概念，但它其实只是简化了原来需要我们自己编写的原型链代码的语法糖，从而让js更趋向于传统的面向对象语言而已。要理解这个过程，首先要明白es6中的class做了什么。</p><h4 id="class到底做了什么">1.1 class到底做了什么：</h4><ul><li>首先看看class是什么东西</li></ul><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> Person<span class="op">&#123;</span>
    ......
<span class="op">&#125;</span>
<span class="kw">typeof</span> Person   <span class="co">//  function </span></code></pre></div><p>这里的class与java中的class不同，它并不是一个全新的数据类型，而是相当于原型继承中的构造函数。</p><ul><li>接着看看es5和es6在实现继承上的区别：</li></ul><p>es5：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Person</span>(name)<span class="op">&#123;</span>               <span class="co">//父类</span>
    <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> name<span class="op">;</span>
<span class="op">&#125;</span>
<span class="va">Person</span>.<span class="va">prototype</span>.<span class="at">showName</span> <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">name</span><span class="op">;</span>
<span class="op">&#125;;</span>
<span class="kw">function</span> <span class="at">SubPerson</span>(name<span class="op">,</span>job)<span class="op">&#123;</span>         <span class="co">// 子类</span>
    <span class="va">Person</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span>name)<span class="op">;</span>  <span class="co">// 子类继承父类的属性 需要将this指向父类中的name</span>
    <span class="kw">this</span>.<span class="at">job</span> <span class="op">=</span> job<span class="op">;</span>       <span class="co">// job是子类的新增属性</span>
<span class="op">&#125;</span>
<span class="va">SubPerson</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">Person</span>()<span class="op">;</span>  <span class="co">// 让子类继承父类的方法</span>
<span class="kw">var</span> p1 <span class="op">=</span> <span class="kw">new</span> <span class="at">SubPerson</span>(<span class="st">&#39;zcl&#39;</span>)<span class="op">;</span>      <span class="co">//实例化子类对象</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">p1</span>.<span class="at">name</span>)<span class="op">;</span>              <span class="co">// zcl（父类属性）</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">p1</span>.<span class="at">showName</span>())<span class="op">;</span>       <span class="co">// zcl（父类方法）</span></code></pre></div><p>es6：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> Person<span class="op">&#123;</span>                      <span class="co">// 父类</span>
    <span class="at">constructor</span>(name)<span class="op">&#123;</span>
        <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> name<span class="op">;</span>
    <span class="op">&#125;</span>
    <span class="at">showName</span>()<span class="op">&#123;</span>
        <span class="cf">return</span> <span class="kw">this</span>.<span class="at">name</span><span class="op">;</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">class</span> SubPerson <span class="kw">extends</span> Person<span class="op">&#123;</span>          <span class="co">//子类</span>
    <span class="at">constructor</span>(name<span class="op">,</span>job)<span class="op">&#123;</span>
        <span class="kw">super</span>(name)<span class="op">;</span>      <span class="co">// 用super来调用父类的构造函数</span>
        <span class="kw">this</span>.<span class="at">job</span> <span class="op">=</span> job<span class="op">;</span>    <span class="co">// job是子类的新增属性</span>
    <span class="op">&#125;</span>
    <span class="at">showJob</span>()<span class="op">&#123;</span>
        <span class="cf">return</span> <span class="kw">this</span>.<span class="at">job</span><span class="op">;</span>
    <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> p1 <span class="op">=</span> <span class="kw">new</span> <span class="at">SubPerson</span>(<span class="st">&#39;zcl&#39;</span><span class="op">,</span><span class="st">&#39;前端开发&#39;</span>)<span class="op">;</span>    <span class="co">//实例化子类对象</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">p1</span>.<span class="at">name</span>)<span class="op">;</span>  <span class="co">// zcl（父类属性）</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">p1</span>.<span class="at">showName</span>())<span class="op">;</span>  <span class="co">// zcl（父类方法）</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">p1</span>.<span class="at">job</span>)<span class="op">;</span> <span class="co">// 前端开发（子类属性）</span></code></pre></div><p>可以看到，es6中采用class后，大大简化了组合继承的步骤。</p><ul><li>class做了什么：</li></ul><p>1.定义父类时</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> Person<span class="op">&#123;</span>
    constructor<span class="op">&#123;</span> <span class="co">/*constructor*/</span> <span class="op">&#125;</span>
    method<span class="op">&#123;</span> <span class="co">/*method*/</span> <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="co">// 等价于</span>
<span class="kw">function</span> Person<span class="op">&#123;</span>
    <span class="co">/*constructor*/</span>
<span class="op">&#125;</span>
<span class="va">Person</span>.<span class="va">prototype</span>.<span class="at">method</span><span class="op">&#123;</span>
    <span class="co">/*method*/</span>
<span class="op">&#125;</span></code></pre></div><p>2.子类继承父类时：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">class</span> SubPerson <span class="kw">extends</span> Person<span class="op">&#123;</span>
    onstructor<span class="op">&#123;</span>
         <span class="kw">super</span>(...)
         <span class="co">/*constructor*/</span>       <span class="co">//子类新增属性</span>
         <span class="op">&#125;</span>
    method<span class="op">&#123;</span> <span class="co">/*method*/</span> <span class="op">&#125;</span>      <span class="co">//子类新增方法</span>
<span class="op">&#125;</span>
<span class="kw">var</span> subperson1 <span class="op">=</span> <span class="kw">new</span> <span class="at">SubPerson</span>()

<span class="co">// 等价于</span>

<span class="kw">function</span> SubPerson<span class="op">&#123;</span>
    <span class="va">Person</span>.<span class="at">call</span>(....)
    <span class="co">/*constructor*/</span>          <span class="co">//子类新增属性</span>
<span class="op">&#125;</span>
<span class="va">SubPerson</span>.<span class="at">prototype</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">Person</span>()
<span class="va">SubPerson</span>.<span class="va">prototype</span>.<span class="at">method</span><span class="op">=</span><span class="kw">function</span><span class="op">&#123;</span>
    <span class="co">/*method*/</span>               <span class="co">//子类新增方法</span>
<span class="op">&#125;</span>
<span class="kw">var</span> subperson1 <span class="op">=</span> <span class="kw">new</span> <span class="at">SubPerson</span>()</code></pre></div><p>对于es6继承而言，访问实例化的子类对象的属性或者方法时，依然是沿着原型链进行追溯，并且子类实例创建后，class SubPerson中的this依然会指向该子类，可以看出，这与es5的原型继承的一模一样的。</p><h4 id="关于this">1.2 关于this：</h4><p>es5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.call(this)）；es6的继承机制完全不同，实质是先通过调用super方法（super指向父类的构造函数）创造父类的实例对象this，然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加。</p><h3 id="java的继承">2.Java的继承</h3><p>首先了解java中创建对象的方式。java中，类一般包含field(变量)，constructor(构造方法)，method(其他方法)。</p><div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> Person&#123;              <span class="co">// 创建父类</span>
    <span class="kw">private</span> <span class="bu">String</span> name;   <span class="co">//  field</span>
    <span class="kw">public</span> <span class="bu">String</span> <span class="fu">getName</span>()&#123;    <span class="co">// method</span>
        <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">name</span>;
    &#125;;
    <span class="kw">public</span> <span class="fu">Person</span>(<span class="bu">String</span> name)&#123;  <span class="co">// constructor</span>
        <span class="kw">this</span>.<span class="fu">name</span> = name;
    &#125;;
&#125;</code></pre></div><p>接着实现继承</p><div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> SubPerson <span class="kw">extends</span> Person&#123;         <span class="co">// 创建子类</span>
    <span class="kw">private</span> <span class="dt">int</span> age;          <span class="co">// field</span>
    <span class="kw">public</span> <span class="bu">String</span> <span class="fu">getAge</span>()&#123;       <span class="co">// method</span>
        <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">age</span>;
    &#125;;
    <span class="kw">public</span> <span class="fu">SubPerson</span>(<span class="bu">String</span> name,<span class="dt">int</span> age)&#123;   <span class="co">// constructor</span>
        <span class="kw">super</span>(name);         <span class="co">// 通过super调用父类构造方法</span>
        <span class="kw">this</span>.<span class="fu">age</span> = age;
    &#125;;
    <span class="kw">public</span> <span class="bu">String</span> <span class="fu">getName</span>()&#123;  <span class="co">//重写父类方法，发生覆盖</span>
        <span class="kw">return</span> <span class="st">&quot;I am not &quot;</span>+<span class="kw">super</span>.<span class="fu">getName</span>()+<span class="st">&quot; but I am &quot;</span>+<span class="kw">this</span>.<span class="fu">name</span>; 
    &#125;
&#125;</code></pre></div><p>创建测试类</p><div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Public <span class="kw">class</span> Testclass&#123;
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args)&#123;
        Person person1 = <span class="kw">new</span> <span class="fu">Person</span>(<span class="st">&quot;father&quot;</span>)  
        <span class="co">//通过new一个构造方法创建父类实例</span>
        SubPerson subperson1 = <span class="kw">new</span> <span class="fu">SubPerson</span>(<span class="st">&quot;son&quot;</span>)  
        <span class="co">// 创建子类实例</span>
        <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(subperson1.<span class="fu">getName</span>());
        <span class="co">//-&gt;I am not father but I am son.</span>
    &#125;
&#125;</code></pre></div><h3 id="javascript的原型式继承与java的类式继承">3.JavaScript的原型式继承与Java的类式继承</h3><p>由上面分析可见，es6中的类式继承其实还是原型式继承。那么它与java中真正的类式继承相比，有什么区别呢？</p><ul><li>类式继承的方法都会存在父对象之中，每一次实例，都会将funciton保存在内存中，这会带来性能上的问题。</li><li>类式继承是不可变的。在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法；相反，原型继承是可以通过改变原型链进而对子类进行修改的。</li><li>类式继承可以实现多重继承（Java是通过接口来实现）；原型式继承一般来说是不支持多继承的（因为原型链），但可以通过Mixin变相实现多继承。</li></ul><h3 id="补充子类如何调用父类被覆盖的同名方法">4.补充：子类如何调用父类被覆盖的同名方法</h3><p>首先这是一个比较奇怪的需求，因为既然子类重写了父类方法，就说明父类方法无法实现我们的要求，反过来，假设父类方法可以实现要求，则没必要重写该方法。但是让我们设想一下，假定现在一定要通过子类调用父类被覆盖的那个方法，应该怎么做呢？</p><p>通过上面的例子可以看到，在java中，我们只能在子类的构造方法中通过super关键字调用父类方法，而无法直接用子类的实例调用那个方法，像“子类实例.super.父类方法”，这是无效的；但是在js中，我们是可以做到的。基本思路就是：将父类实例以属性的方式进行保存，且该属性是子类构造函数的原型对象的属性。</p><p>这其实和原型链有关。我们设想有父类A、子类B以及同名方法say，并且设定子类B的原型对象的superClass属性指向父类实例b。那么，子类实例a直接调用say方法，必然是调用重写之后的方法；当它想要调用被覆盖的方法时，我们只需要用<code>a.superClass.say()</code>即可-----对于实例a，我们知道它本身并不具备superClass属性，因此它将沿着自己的原型对象也即子类B的原型对象进行查找，刚好B的原型对象有一个指向b的superClass属性，所以我们拿来用，而b有被覆盖的say方法，所以这里顺利完成了被覆盖方法的调用。</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhy416011189/article/details/50980016?utm_source=blogxgwz0">附上CSDN的参考链接</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/03/18/G-%E6%B8%B8%E6%88%8F%E5%BE%80%E4%BA%8B/" rel="prev" title="游戏往事"><i class="fa fa-angle-double-left"></i>&nbsp游戏往事</a></div><div class="post-nav-next"><a href="/2019/03/17/F-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/" rel="next" title="经典面试题解析">经典面试题解析&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">1.JavaScript的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#class%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">1.1 class到底做了什么：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ethis"><span class="toc-text">1.2 关于this：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">2.Java的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF%E4%B8%8Ejava%E7%9A%84%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-text">3.JavaScript的原型式继承与Java的类式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E8%A2%AB%E8%A6%86%E7%9B%96%E7%9A%84%E5%90%8C%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-text">4.补充：子类如何调用父类被覆盖的同名方法</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->