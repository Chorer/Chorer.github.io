<!-- build time:Sun Sep 05 2021 14:32:52 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">深入理解变量对象、作用域链和闭包</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-04-10&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4.3k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp16 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/闭包/">闭包</a> <a href="/tags/变量对象/">变量对象</a> <a href="/tags/作用域链/">作用域链</a></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85-00.png"></div><span id="more"></span><p>执行上下文、执行栈、作用域链、闭包，这其实是一整套相关的东西，之前<a href="https://chorer.github.io/2019/03/04/F-%E9%97%AD%E5%8C%85/">转载的文章</a>也有讲到这些。下面两篇文章会更加详细地解释这些概念。 * <a href="https://chorer.github.io/2019/04/08/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/">深入理解执行上下文和执行栈</a> * <a href="https://chorer.github.io/2019/04/10/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/">深入理解变量对象、作用域链和闭包</a></p><h1 id="前言">1.前言</h1><p>首先引用下winter大的原话： &gt;在<span style="background-color:#fffa7d">ES3</span>中，执行上下文包含三个部分: 1.scope: 作用域，也常常被叫做作用域链。 2.variable object:变量对象，用于存储变量的对象。 3.this value: this值。 在<span style="background-color:#fffa7d">ES5</span>中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子: 1.lexical environment:词法环境，当获取变量时使用。 2.variable environment:变量环境，当声明变量时使用。 3.this value: this值。 在<span style="background-color:#fffa7d">ES2018</span>中，this值被归入lexical environment，同时增加了不少内容： 1.lexical environment:词法环境，当获取变量或者this值时使用。 2.variable environment:变量环境，当声明变量时使用。 3.......</p><blockquote><p>我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的ES2018中规定的术语定义。</p></blockquote><p>所以，你会看到本文讲解的部分与另一篇文章有出入（例如变量对象VS环境记录），只需要知道是不同时期的不同规范就行了，没必要深究。</p><h1 id="执行上下文">2.执行上下文</h1><p>每个执行上下文都有三个重要的属性：变量对象、作用域链、this。在执行上下文压栈后，将进行初始化，这个过程具体来说就是： * 创建变量对象 * 创建作用域链 * 确定 this 指向</p><p>用代码表示如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">ExecutionContext <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">VO</span><span class="op">:</span> <span class="op">&#123;</span>...<span class="op">&#125;,</span> <span class="co">// 或者 AO</span>
    <span class="kw">this</span><span class="op">:</span> thisValue<span class="op">,</span>
    <span class="dt">Scope</span><span class="op">:</span> [ <span class="co">// 所用域链</span>
      <span class="co">// 所有变量对象的列表</span>
      <span class="co">// 用于标识符查询</span>
    ]
<span class="op">&#125;;</span></code></pre></div><p>下面我们针对这三个东西一一进行解释。</p><h1 id="变量对象">3.变量对象</h1><h2 id="定义">3.1 定义</h2><p>变量对象即Variable object/VO，它是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 * 在全局执行上下文中，变量对象即全局对象（在浏览器中是window对象），它是可以访问的。 * 在函数执行上下文中，变量对象是不能直接访问的，此时由活动对象(Activation Object/AO)扮演变量对象的角色，也就是所谓的VO--&gt;AO。</p><p>总而言之，变量对象和活动对象的区别就是： 1、变量对象是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。 2、当进入到一个函数执行上下文后，这个变量对象才会被激活，成为活动对象，这时候活动对象上的各种属性才能被访问。</p><h2 id="从执行上下文看变量对象">3.2 从执行上下文看变量对象</h2><p>首先，执行上下文分为两个阶段： 1.进入执行上下文 2.代码执行</p><h3 id="进入执行上下文">3.2.1 进入执行上下文</h3><p>很明显，这个时候还没有执行代码。 此时的变量对象将包含（按照如下顺序初始化）：</p><p>1.<span style="background-color:#fffa7d">一个指向arguments对象的arguments变量</span>（如果是函数执行上下文）：具体地说，在变量对象内部将创建局部变量arguments和arguments对象，并使该变量指向该对象。arguments对象包括下列属性： * callee：指向当前函数的引用 * length： 真正传递的参数的个数 * properties-indexes：就是函数的参数值(按参数列表从左到右排列)</p><p>2.<span style="background-color:#fffa7d">函数的所有形参</span>（如果是函数执行上下文）：有实参则赋值，无实参则为undefined。 3.<span style="background-color:#fffa7d">函数声明</span>：如果声明的函数跟已经声明的形参在名称上是相同的，则完全替换这个形参变量。 4.<span style="background-color:#fffa7d">变量声明</span>：如果声明的变量跟已经声明的形参/函数在名称上是相同的，则变量声明不会干扰它们，仅赋值部分是生效的。</p><p>同时明确，变量对象将不包含： * 函数表达式（与函数声明相对） * 没有使用var声明的变量（这属于“全局式”的声明方式，只是给全局添加了一个属性，并不在变量对象中）</p><p>拿下面代码作为例子：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>(a)<span class="op">&#123;</span>
  <span class="kw">var</span> b <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>
  <span class="kw">function</span> <span class="at">c</span>()<span class="op">&#123;&#125;</span>
  <span class="kw">var</span> d <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;&#125;;</span>
  b <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>
<span class="op">&#125;</span>

<span class="at">foo</span>(<span class="dv">1</span>)<span class="op">;</span></code></pre></div><p>在调用函数 foo 后，将进入其对应的函数执行上下文，此时的变量对象（实际上是活动对象）根据上面的说法，应为：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">AO <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">arguments</span><span class="op">:</span> <span class="op">&#123;</span>
        <span class="dv">0</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span>
        <span class="dt">length</span><span class="op">:</span> <span class="dv">1</span>
    <span class="op">&#125;,</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span>
    <span class="dt">b</span><span class="op">:</span> <span class="kw">undefined</span><span class="op">,</span>
    <span class="dt">c</span><span class="op">:</span> reference to <span class="kw">function</span> <span class="at">c</span>()<span class="op">&#123;&#125;,</span>
    <span class="dt">d</span><span class="op">:</span> <span class="kw">undefined</span>
<span class="op">&#125;</span></code></pre></div><p>可以从 arguments 对象的<code>properties-indexes</code>属性或者 a 看出，形参此时已经赋值了，但是变量仍是<code>undefined</code>。</p><h3 id="代码执行">3.2.2 代码执行</h3><p>这个阶段会顺序执行代码，修改变量对象的值，执行完成后变量对象如下：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">AO <span class="op">=</span> <span class="op">&#123;</span>
    <span class="dt">arguments</span><span class="op">:</span> <span class="op">&#123;</span>
        <span class="dv">0</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span>
        <span class="dt">length</span><span class="op">:</span> <span class="dv">1</span>
    <span class="op">&#125;,</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span>
    <span class="dt">b</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span>
    <span class="dt">c</span><span class="op">:</span> reference to <span class="kw">function</span> <span class="at">c</span>()<span class="op">&#123;&#125;,</span>
    <span class="dt">d</span><span class="op">:</span> reference to FunctionExpression <span class="st">&quot;d&quot;</span>
<span class="op">&#125;</span></code></pre></div><p>前面说过，函数表达式和没有使用var声明的变量将不会包含在变量对象里，所以如果添加如下代码：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">(<span class="kw">function</span> <span class="at">x</span>()<span class="op">&#123;&#125;</span>)<span class="op">;</span>
e <span class="op">=</span> <span class="dv">1</span>；</code></pre></div><p>变量对象是不会变的</p><h1 id="作用域链">4.作用域链</h1><h2 id="定义-1">4.1 定义</h2><p>作用域链其实就是所有执行上下文的变量对象的列表。我们可以将其看作数组，并表示为：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> Scope <span class="op">=</span> [VO1<span class="op">,</span> VO2<span class="op">,</span> ...<span class="op">,</span> VOn]<span class="op">;</span></code></pre></div><p>具体来说，函数执行上下文的作用域链包括该上下文的活动对象和该上下文对应函数的内部<code>[[Scope]]</code>属性。表示为：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">Scope <span class="op">=</span> AO <span class="op">+</span> [[Scope]]</code></pre></div><h2 id="作用">4.2 作用：</h2><p>作用域链的作用是：在处理标识符的时候进行变量查询。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。</p><h2 id="scope和scope">4.3 <code>Scope</code>和<code>[[Scope]]</code>：</h2><p>前面我们说的<code>Scope</code>是执行上下文的属性，而<code>[[Scope]]</code>是函数的属性。 具体来说，<code>[[Scope]]</code>是一个包含了所有上层变量对象的分层链，它属于当前函数执行上下文，在函数创建伊始就存在了，并保存在函数中。</p><p>这里要注意的很重要的一点是：<code>[[Scope]]</code>是在函数创建的时候保存起来的——静态的（不变的），只有一次并且一直都存在——直到函数销毁。 比方说，哪怕函数永远都不能被调用到，<code>[[Scope]]</code>属性也已经保存在函数对象上了。</p><h2 id="从执行上下文看作用域链">4.4 从执行上下文看作用域链：</h2><p>下面用具体的例子回顾一下在执行上下文中，变量对象和作用域链的创建过程</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> 

<span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
  <span class="kw">var</span> y <span class="op">=</span> <span class="dv">20</span><span class="op">;</span>
  <span class="kw">function</span> <span class="at">bar</span>() <span class="op">&#123;</span>
    <span class="kw">var</span> z <span class="op">=</span> <span class="dv">30</span><span class="op">;</span>
    <span class="at">alert</span>(x <span class="op">+</span>  y <span class="op">+</span> z)<span class="op">;</span>
  <span class="op">&#125;</span> 
  <span class="at">bar</span>()<span class="op">;</span>
<span class="op">&#125;</span>

<span class="at">foo</span>()<span class="op">;</span> <span class="co">// 60</span></code></pre></div><p>首先进入全局执行上下文，创建变量对象（全局对象window）</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">globalContext</span>.<span class="at">VO</span> <span class="op">===</span> Global <span class="op">=</span> <span class="op">&#123;</span>
  <span class="dt">x</span><span class="op">:</span> <span class="kw">undefined</span>
  <span class="dt">foo</span><span class="op">:</span> <span class="op">&lt;</span>reference to <span class="kw">function</span><span class="op">&gt;</span>
<span class="op">&#125;;</span></code></pre></div><p>之后开始执行代码，变量对象变为：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">globalContext</span>.<span class="at">VO</span> <span class="op">===</span> Global <span class="op">=</span> <span class="op">&#123;</span>
  <span class="dt">x</span><span class="op">:</span> <span class="dv">10</span>
  <span class="dt">foo</span><span class="op">:</span> <span class="op">&lt;</span>reference to <span class="kw">function</span><span class="op">&gt;</span>
<span class="op">&#125;;</span></code></pre></div><p>其中，在创建foo函数时，确认它的<code>[[Scope]]</code>属性：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">foo</span>.[[Scope]] <span class="op">=</span> [
  <span class="va">globalContext</span>.<span class="at">VO</span>
]<span class="op">;</span></code></pre></div><p>之后，调用foo函数，进入其对应的函数执行上下文，此时函数的变量对象激活为活动对象：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">fooContext</span>.<span class="at">AO</span> <span class="op">=</span> <span class="op">&#123;</span>
  <span class="dt">y</span><span class="op">:</span> <span class="kw">undefined</span><span class="op">,</span>
  <span class="dt">bar</span><span class="op">:</span> <span class="op">&lt;</span>reference to <span class="kw">function</span><span class="op">&gt;</span>
<span class="op">&#125;;</span></code></pre></div><p>同时确认了foo函数执行上下文的作用域链：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">fooContext</span>.<span class="at">Scope</span> <span class="op">=</span> <span class="va">fooContext</span>.<span class="at">AO</span> <span class="op">+</span> <span class="va">foo</span>.[[Scope]] <span class="co">// i.e.:</span>
 
<span class="va">fooContext</span>.<span class="at">Scope</span> <span class="op">=</span> [
  <span class="va">fooContext</span>.<span class="at">AO</span><span class="op">,</span>
  <span class="va">globalContext</span>.<span class="at">VO</span>
]<span class="op">;</span></code></pre></div><p>之后开始执行代码，变量对象变为：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">fooContext</span>.<span class="at">AO</span> <span class="op">=</span> <span class="op">&#123;</span>
  <span class="dt">y</span><span class="op">:</span> <span class="dv">20</span><span class="op">,</span>
  <span class="dt">bar</span><span class="op">:</span> <span class="op">&lt;</span>reference to <span class="kw">function</span><span class="op">&gt;</span>
<span class="op">&#125;;</span></code></pre></div><p>其中，在创建bar函数时，确认它的<code>[[Scope]]</code>属性：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">bar</span>.[[Scope]] <span class="op">=</span> [
  <span class="va">fooContext</span>.<span class="at">AO</span><span class="op">,</span>
  <span class="va">globalContext</span>.<span class="at">VO</span>
]<span class="op">;</span></code></pre></div><p>之后，调用bar函数，进入bar函数对应的函数执行上下文，此时函数的变量对象激活为活动对象：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">barContext</span>.<span class="at">AO</span> <span class="op">=</span> <span class="op">&#123;</span>
  <span class="dt">z</span><span class="op">:</span> <span class="kw">undefined</span>
<span class="op">&#125;;</span></code></pre></div><p>同时确认了bar函数执行上下文的作用域链：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">barContext</span>.<span class="at">Scope</span> <span class="op">=</span> <span class="va">barContext</span>.<span class="at">AO</span> <span class="op">+</span> <span class="va">bar</span>.[[Scope]] <span class="co">// i.e.:</span>
 
<span class="va">barContext</span>.<span class="at">Scope</span> <span class="op">=</span> [
  <span class="va">barContext</span>.<span class="at">AO</span><span class="op">,</span>
  <span class="va">fooContext</span>.<span class="at">AO</span><span class="op">,</span>
  <span class="va">globalContext</span>.<span class="at">VO</span>
]<span class="op">;</span></code></pre></div><p>之后开始执行代码，变量对象变为：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">barContext</span>.<span class="at">AO</span> <span class="op">=</span> <span class="op">&#123;</span>
  <span class="dt">z</span><span class="op">:</span> <span class="dv">30</span>
<span class="op">&#125;;</span></code></pre></div><p>在运行<code>alert(x + y + z);</code>这一语句的时候，开始进行变量（或者说标识符）查询：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">-</span> <span class="st">&quot;x&quot;</span>
<span class="op">--</span> <span class="va">barContext</span>.<span class="at">AO</span> <span class="co">// not found</span>
<span class="op">--</span> <span class="va">fooContext</span>.<span class="at">AO</span> <span class="co">// not found</span>
<span class="op">--</span> <span class="va">globalContext</span>.<span class="at">VO</span> <span class="co">// found - 10</span></code></pre></div><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">-</span> <span class="st">&quot;y&quot;</span>
<span class="op">--</span> <span class="va">barContext</span>.<span class="at">AO</span> <span class="co">// not found</span>
<span class="op">--</span> <span class="va">fooContext</span>.<span class="at">AO</span> <span class="co">// found - 20</span></code></pre></div><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">-</span> <span class="st">&quot;z&quot;</span>
<span class="op">--</span> <span class="va">barContext</span>.<span class="at">AO</span> <span class="co">// found - 30</span></code></pre></div><blockquote><p>这里需要注意，由于确认执行上下文的作用域链时，总会将当前上下文的变量对象/活动对象推至作用域链的顶端( <code>Scope=当前活动对象+所有上层对象</code> )，所以变量查询也将从该变量对象开始，而全局对象则一直处于末端，是最后被查询的。</p></blockquote><p>bar执行完毕，出栈---&gt;foo执行完毕，出栈---&gt;回到全局执行上下文</p><h1 id="闭包">5.闭包</h1><h2 id="从向下funarg问题谈静态作用域">5.1 从向下Funarg问题谈静态作用域</h2><blockquote><p>“Funarg”即函数式参数，指的是值为函数的参数。如：</p></blockquote><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">exampleFunc</span>(funArg) <span class="op">&#123;</span>
  <span class="at">funArg</span>()<span class="op">;</span>
<span class="op">&#125;</span></code></pre></div><p>首先看下这段代码：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>
<span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
  <span class="va">console</span>.<span class="at">log</span>(x)<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">function</span> <span class="at">bar</span>(funArg) <span class="op">&#123;</span>
  <span class="kw">let</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span>
  <span class="at">funArg</span>()<span class="op">;</span> <span class="co">// 10, 而不是20！</span>
<span class="op">&#125;</span>
<span class="co">// 将 `foo` 作为实参传给 `bar`。</span>
<span class="at">bar</span>(foo)<span class="op">;</span></code></pre></div><p>对于函数foo，变量x就是自由变量。当foo函数被调用时，它在哪里解析x绑定呢？是从创建函数的外层作用域，还是从调用函数的外层作用域？ 这就是所谓的<span style="background-color:#fffa7d">向下funarg问题</span>(downwards funarg problem)，即在判断绑定的环境时的歧义性：它应该是创建时的环境，还是调用时的环境？</p><p>这是通过达成约定使用静态作用域来解决的。静态作用域也就是词法作用域（这也是词法环境这个名称的由来），它是通过捕获函数创建所在的环境来实现的，因而会到函数创建时保存起来的静态作用域链中进行变量查询。如果一个语言只通过查找源代码，就可以判断绑定在哪个环境中解析，那么该语言就实现了静态作用域。</p><p>与静态作用域相对的是动态作用域。动态作用域是在当前活跃的动态链（而不是在函数创建时保存起来的静态作用域链）中进行变量查询的。对于上面的代码，如果是动态作用域，将输出20而不是10。</p><h2 id="从向上funarg问题谈闭包">5.2 从向上Funarg问题谈闭包</h2><p>另一种Funarg问题是<span style="background-color:#fffa7d">向上funarg问题</span>(upwards funarg problem)。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
  <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>
  <span class="co">// 闭包，捕获`foo`的环境。</span>
  <span class="kw">function</span> <span class="at">bar</span>() <span class="op">&#123;</span>
    <span class="cf">return</span> x<span class="op">;</span>
  <span class="op">&#125;</span>
  <span class="co">// 向上funarg。</span>
  <span class="cf">return</span> bar<span class="op">;</span>
<span class="op">&#125;</span>
<span class="kw">let</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span>
<span class="co">// 调用`foo`来返回`bar`闭包。</span>
<span class="kw">let</span> bar <span class="op">=</span> <span class="at">foo</span>()<span class="op">;</span>
<span class="at">bar</span>()<span class="op">;</span> <span class="co">// 10，而不是20!</span></code></pre></div><p>除了判断绑定环境的歧义性，向上funarg问题面临的另一个问题是：如果JavaScript是面向堆栈的，那么foo函数在调用结束后，其执行上下文将带着变量对象销毁，这样一来，在我们调用bar函数时将发生错误（因为bar函数需要用到自由变量x，而该变量已经随着foo函数变量对象的销毁而消失了）。而且，在面向堆栈实现模型中，要想将bar函数返回根本是不可能的，因为它也是foo函数变量对象的一部分，也会随之销毁。</p><p>也就是说我们面临两个问题： * 绑定环境的歧义性 * 被引用的自由变量在上下文销毁后无法得到保留</p><p>为了解决这两类问题，引入了闭包的概念。</p><h2 id="闭包-1">5.3 闭包</h2><h3 id="定义-2">5.3.1 定义</h3><p>ECMAScript 中，闭包指的是：</p><ul><li><p>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p></li><li><p>从实践角度：以下函数才算是闭包： 1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 2.在代码中引用了自由变量</p></li></ul><p>JavaScript显然是支持词法作用域的（除了this），所以解决了向下Funarg问题；同时由于闭包的存在，即使创建闭包的执行上下文出栈后被销毁，其变量对象也依然存在，所以闭包函数依然有办法访问到该对象，这就解决了向上Funarg问题。 &gt;这个过程具体来说就是：通过某种方式（通常是返回值）调用闭包后，创建闭包对应的执行上下文并压栈，该上下文的属性<code>Scope</code>包括了闭包本身的变量对象和闭包的<code>[[Scope]]</code>属性，后者使得闭包执行时有机会访问到自由变量，因为<code>[[Scope]]</code>在闭包的词法创建阶段便已确定，并在那时候保存了其上层变量对象（上层，也就是闭包的父函数）。</p><h3 id="注意">5.3.2 注意</h3><p>不过这里需要注意，仅变量对象里被引用的自由变量依然存在，不需要用到的变量会被垃圾清除机制清除。可以用下面的代码做个测试：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> bar <span class="op">=</span> <span class="kw">function</span>() <span class="op">&#123;</span>
    <span class="kw">var</span> hello <span class="op">=</span> <span class="st">&quot;world&quot;</span>
    <span class="kw">var</span> unused <span class="op">=</span> <span class="st">&quot;nope&quot;</span>
    <span class="cf">return</span> <span class="kw">function</span>(s) <span class="op">&#123;</span> 
        <span class="va">console</span>.<span class="at">log</span>(hello)
        <span class="cf">debugger</span> 
        <span class="cf">return</span> s
    <span class="op">&#125;</span>
<span class="op">&#125;</span>
<span class="kw">var</span> g <span class="op">=</span> <span class="at">bar</span>()
<span class="at">g</span>(<span class="dv">1</span>)</code></pre></div><p>debugger 查看 closure，发现只有 hello 变量，而找不到 unused 变量：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85-2.png"></div><p>控制台中打印 hello 发现可以访问，但是打印 unused 变量时，会报错： <img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85-3.png"></p><p>另外一个需要注意的地方是：同一个上下文中可能存在多个闭包，而这些闭包是共用同一个<code>[[Scope]]</code>属性的。也就是说，某个闭包对其中的变量做修改会影响到其他闭包对该变量的读取：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> firstClosure<span class="op">;</span>
<span class="kw">var</span> secondClosure<span class="op">;</span>
 
<span class="kw">function</span> <span class="at">foo</span>() <span class="op">&#123;</span>
 
  <span class="kw">var</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
 
  firstClosure <span class="op">=</span> <span class="kw">function</span> () <span class="op">&#123;</span> <span class="cf">return</span> <span class="op">++</span>x<span class="op">;</span> <span class="op">&#125;;</span>
  secondClosure <span class="op">=</span> <span class="kw">function</span> () <span class="op">&#123;</span> <span class="cf">return</span> <span class="op">--</span>x<span class="op">;</span> <span class="op">&#125;;</span>
 
  x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// 对AO[&quot;x&quot;]产生了影响, 其值在两个闭包的[[Scope]]中</span>
 
  <span class="at">alert</span>(<span class="at">firstClosure</span>())<span class="op">;</span> <span class="co">// 3, 通过 firstClosure.[[Scope]]</span>
<span class="op">&#125;</span>
 
<span class="at">foo</span>()<span class="op">;</span>
 
<span class="at">alert</span>(<span class="at">firstClosure</span>())<span class="op">;</span> <span class="co">// 4</span>
<span class="at">alert</span>(<span class="at">secondClosure</span>())<span class="op">;</span> <span class="co">// 3</span></code></pre></div><p>这也可以解释经典的 for 循环问题：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> data <span class="op">=</span> []<span class="op">;</span>
 
<span class="cf">for</span>(<span class="kw">var</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> k<span class="op">++</span>) <span class="op">&#123;</span>
  data[k] <span class="op">=</span> <span class="kw">function</span>()<span class="op">&#123;</span>
    <span class="at">alert</span>(k)
  <span class="op">&#125;</span>
<span class="op">&#125;</span>
 
data[<span class="dv">0</span>]()<span class="op">;</span> <span class="co">// 3, 而不是 0</span>
data[<span class="dv">1</span>]()<span class="op">;</span> <span class="co">// 3, 而不是 1</span>
data[<span class="dv">2</span>]()<span class="op">;</span> <span class="co">// 3, 而不是 2</span></code></pre></div><p>每一个函数都是一个闭包，拥有同一个<code>[[Scope]]</code>属性，这个属性只包含一个变量对象，那就是全局对象，而全局对象包含了变量 k，这个 k 在循环跑完后变成了 3，所以闭包调用的时候统一输出 3。</p><blockquote><p>注意：每次赋值数组元素的时候，只是赋值 <code>function()&#123;alert(k)&#125;</code>，k 只有在执行的时候才会求值</p></blockquote><h3 id="闭包的运用">5.3.3 闭包的运用</h3><p>实际使用的时候，闭包可以创建出非常优雅的设计，允许对 funarg 上定义的多种计算方式进行定制。 如下就是数组排序的例子，它接受一个排序条件函数作为参数：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>].<span class="at">sort</span>(<span class="kw">function</span> (a<span class="op">,</span> b) <span class="op">&#123;</span>
  ... <span class="co">// 排序条件</span>
<span class="op">&#125;</span>)<span class="op">;</span></code></pre></div><p>同样的例子还有，数组的map方法（并非所有的实现都支持数组map方法，SpiderMonkey从1.6版本开始有支持），该方法根据函数中定义的条件将原数组映射到一个新的数组中：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>].<span class="at">map</span>(<span class="kw">function</span> (element) <span class="op">&#123;</span>
  <span class="cf">return</span> element <span class="op">*</span> <span class="dv">2</span><span class="op">;</span>
<span class="op">&#125;</span>)<span class="op">;</span> <span class="co">// [2, 4, 6]</span></code></pre></div><p>使用函数式参数，可以很方便的实现一个搜索方法，并且可以支持无穷多的搜索条件：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">someCollection</span>.<span class="at">find</span>(<span class="kw">function</span> (element) <span class="op">&#123;</span>
  <span class="cf">return</span> <span class="va">element</span>.<span class="at">someProperty</span> <span class="op">==</span> <span class="st">&#39;searchCondition&#39;</span><span class="op">;</span>
<span class="op">&#125;</span>)<span class="op">;</span></code></pre></div><p>还有应用函数，比如常见的forEach方法，将funarg应用到每个数组元素：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>].<span class="at">forEach</span>(<span class="kw">function</span> (element) <span class="op">&#123;</span>
  <span class="cf">if</span> (element <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>) <span class="op">&#123;</span>
    <span class="at">alert</span>(element)<span class="op">;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>)<span class="op">;</span> <span class="co">// 1, 3</span></code></pre></div><p>顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply 和 call 已经在讨论 this 的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在 apply 中是参数列表，在 call 中是独立的参数）：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">(<span class="kw">function</span> () <span class="op">&#123;</span>
  <span class="at">alert</span>([].<span class="va">join</span>.<span class="at">call</span>(arguments<span class="op">,</span> <span class="st">&#39;;&#39;</span>))<span class="op">;</span> <span class="co">// 1;2;3</span>
<span class="op">&#125;</span>).<span class="at">apply</span>(<span class="kw">this</span><span class="op">,</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span></code></pre></div><p>闭包还有另外一个非常重要的应用 —— 延迟调用：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> a <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>
<span class="at">setTimeout</span>(<span class="kw">function</span>()<span class="op">&#123;</span>
  <span class="at">alert</span>(a)<span class="op">;</span> <span class="co">// 10, 一秒钟后</span>
<span class="op">&#125;,</span> <span class="dv">1000</span>)<span class="op">;</span></code></pre></div><p>也可以用于回调函数：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">...
<span class="kw">var</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>
<span class="co">// only for example</span>
<span class="va">XMLHttpRequestObject</span>.<span class="at">onreadystatechange</span> <span class="op">=</span> <span class="kw">function</span> () <span class="op">&#123;</span>
  <span class="co">// 当数据就绪的时候，才会调用;</span>
  <span class="co">// 这里，不论是在哪个上下文中创建，变量“x”的值已经存在了</span>
  <span class="at">alert</span>(x)<span class="op">;</span> <span class="co">// 10</span>
<span class="op">&#125;;</span>
..</code></pre></div><p>还可以用于封装作用域来隐藏辅助对象：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> foo <span class="op">=</span> <span class="op">&#123;&#125;;</span>
 
<span class="co">// initialization</span>
(<span class="kw">function</span> (object) <span class="op">&#123;</span>
 
  <span class="kw">var</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>
 
  <span class="va">object</span>.<span class="at">getX</span> <span class="op">=</span> <span class="kw">function</span> <span class="at">_getX</span>() <span class="op">&#123;</span>
    <span class="cf">return</span> x<span class="op">;</span>
  <span class="op">&#125;;</span>
 
<span class="op">&#125;</span>)(foo)<span class="op">;</span>
 
<span class="at">alert</span>(<span class="va">foo</span>.<span class="at">getX</span>())<span class="op">;</span> <span class="co">// get closured &quot;x&quot; – 10</span></code></pre></div><p>参考： http://dmitrysoshnikov.com/ecmascript http://goddyzhao.tumblr.com/post/11311499651/closures</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/04/13/T-%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/" rel="prev" title="由一道题引发的思考"><i class="fa fa-angle-double-left"></i>&nbsp由一道题引发的思考</a></div><div class="post-nav-next"><a href="/2019/04/08/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/" rel="next" title="深入理解执行上下文和执行栈">深入理解执行上下文和执行栈&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">1.前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">2.执行上下文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.变量对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9C%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.2 从执行上下文看变量对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">3.2.1 进入执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="toc-text">3.2.2 代码执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">4.作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">4.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">4.2 作用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scope%E5%92%8Cscope"><span class="toc-text">4.3 Scope和[[Scope]]：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9C%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">4.4 从执行上下文看作用域链：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">5.闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%90%91%E4%B8%8Bfunarg%E9%97%AE%E9%A2%98%E8%B0%88%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">5.1 从向下Funarg问题谈静态作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%90%91%E4%B8%8Afunarg%E9%97%AE%E9%A2%98%E8%B0%88%E9%97%AD%E5%8C%85"><span class="toc-text">5.2 从向上Funarg问题谈闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85-1"><span class="toc-text">5.3 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-text">5.3.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">5.3.2 注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-text">5.3.3 闭包的运用</span></a></li></ol></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->