<!-- build time:Thu Aug 13 2020 16:18:50 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">聊一聊：一道 Promise 链式调用的题目</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2020-07-26&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp3.5k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp12 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Promise%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/0.jpg" alt=""></p><a id="more"></a><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>这是最近几天在掘金沸点看到的一道题目：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'外部promise'</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'外部第一个then'</span><span class="token punctuation">)</span>
    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'内部promise'</span><span class="token punctuation">)</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'内部第一个then'</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'内部第二个then'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'外部第二个then'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'外部第三个then'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'外部第四个then'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 输出结果是什么？</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一眼看到的时候，你觉得输出结果是什么呢？可以先花几分钟仔细想一想。</p><p>……..</p><p>……..</p><p>……..</p><p>……..</p><p>……..</p><p>公布答案：</p><pre class="line-numbers language-js"><code class="language-js">外部promise
外部第一个then
内部promise
内部第一个then
外部第二个then
外部第三个then
外部第四个then
内部第二个then
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不知道你有没有猜对？反正我猜错了。一开始我还以为是常规的 EventLoop 题目，无非就是考链式调用。但事实证明，它没有看上去那么简单。当时心里想的是，好奇怪，怎么和预想的不一样呢？</p><p>吃个午饭回来，本想继续看评论里有没有大神指点迷津或者是一起讨论下这道题，没想到的是，大神没出现，倒是出现了不少冷嘲热讽的人，大意是“写这样的代码就是菜，没有意义，不要浪费别人的时间”。又过了几分钟，发现楼主已经把帖子给删了。</p><p>…… 一时之间不知道说什么好，等到文章结束再来聊聊吧，我们还是先回到问题上。尽管这样的代码可能只是“为了面试而生”的，但我还是想弄清楚是怎么一回事，为何结果与猜想的不一样，于是这几天一直在翻阅网上的资料，请教网友们。到了今天，算是有点眉目了，所以在这里记录一下具体的分析过程。</p><p><strong>注意：</strong></p><ul><li>问题的解答来源于网上的相关文章和回答，我只是在此基础上整理分析思路和过程</li><li>文章不会讨论 Promise/A+ 实现，ECMAScript 规范解读，webkit 源码等内容，但底下会有相关链接，想继续深挖的朋友可以看看</li></ul><h4 id="先从简单的开始分析"><a href="#先从简单的开始分析" class="headerlink" title="先从简单的开始分析"></a>先从简单的开始分析</h4><p>在讨论这段代码之前，我们先从一段相对简单的代码开始分析：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span>
   <span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"外部第一个then"</span><span class="token punctuation">)</span>
   <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span>reject<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"promise2"</span><span class="token punctuation">)</span>
     <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"内部第一个then"</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"内部第二个then"</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"外部第二个then"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先说几个基本的结论：</p><ul><li><p><code>then</code> 的回调到底什么时候进入队列？</p><p>调用 <code>then</code>，里面的回调不一定会马上进入队列</p><ul><li>如果 <code>then</code> 前面的 promise 已经被 <code>resolve</code> ，那么调用 <code>then</code> 后，回调就会进入队列</li><li>如果 <code>then</code> 前面的 promise 还没有被 <code>resolve</code> ，那么调用 <code>then</code> 后，回调不会进入队列，而是先暂时存着，等待 promsie 被 <code>resolve</code> 之后再进队列。</li></ul></li><li><p><code>then</code> 前面的 promise 怎么才算被 <code>resolve</code> 呢？</p><ul><li>如果 promsie 是实例化形成的，那么调用 <code>resolve()</code> 后它就被 <code>resolve</code> 了</li><li>如果 promise 是 <code>then</code> 返回的，那么 <code>then</code> 的回调执行完毕之后它就被 <code>resolve</code> 了。</li></ul></li><li><p>promise 被 <code>resolve</code> 之后会做什么？</p><ul><li>会把此前和该 promise 挂钩的 <code>then</code> 的回调全部放入队列</li></ul></li></ul><p>明确这几点之后，我们再来逐步分析这段代码：</p><ol><li>执行宏任务，实例化 Promise，打印 <code>promise1</code>，之后调用了 <code>resolve</code>，该 promise 被 <code>resolve</code></li><li>外部第一个 <code>then</code> 执行，对应的回调马上进队列</li><li>外部第二个 <code>then</code> 执行，但是由于外部第一个 <code>then</code> 的回调还没执行，所以它返回的 promise 还没 <code>resolve</code>，所以外部第二个 <code>then</code> 的回调暂时放着，不进队列</li><li>执行微任务，即外部第一个 <code>then</code> 的回调，打印 <code>外部第一个 then</code></li><li>实例化第二个 Promsie，打印 <code>promise2</code>，之后调用了 <code>resolve</code>，该 promise 被 <code>resolve</code></li><li>内部第一个 <code>then</code> 执行，对应的回调马上进队列</li><li>内部第二个 <code>then</code> 执行，但是由于内部第一个 <code>then</code> 的回调还没执行，所以内部第一个 <code>then</code> 返回的 promsie 还没 <code>resolve</code>，导致内部第二个 <code>then</code> 执行的回调暂时放着，不进队列</li><li>到这里，外部第一个 <code>then</code> 的回调其实已经执行完毕，所以外部第一个 <code>then</code> 返回的 promsie 被 <code>resolve</code>了，一旦被 <code>resolve</code>，和它挂钩的 <code>then</code> 的回调全部放入队列，所以外部第二个 <code>then</code> 的回调进队列</li><li>执行宏任务，无宏任务</li><li>执行微任务，队头是内部第一个 <code>then</code> ，于是打印 <code>内部第一个 then</code>，由于内部第一个 <code>then</code> 的回调执行完毕，所以它返回的 promise 被 <code>resolve</code> 了，使得内部第二个 <code>then</code> 的回调进入队列</li><li>接着继续按队列执行，打印 <code>外部第二个then</code>，使得这个 <code>then</code> 返回的 promise 被 <code>resolve</code>，不过它没有后续的 <code>then</code> ，所以不管它接着继续按队列执行，打印最后的 <code>内部第二个then</code></li></ol><p>综上，执行顺序为：</p><pre class="line-numbers language-js"><code class="language-js">promise1  
外部第一个then  
promise2   
内部第一个then  
外部第二个then   
内部第二个then
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="再看题目"><a href="#再看题目" class="headerlink" title="再看题目"></a>再看题目</h4><p>那么，按照这个思路分析的话，文章开头那段代码的输出结果是什么呢？由于思路差不多，这里就直接写结果了：</p><pre class="line-numbers language-js"><code class="language-js">外部promise
外部第一个then
内部promise
内部第一个then
外部第二个then
内部第二个then
外部第三个then
外部第四个then
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，这个结果是错误的，下面才是正确的结果：</p><pre class="line-numbers language-js"><code class="language-js">外部promise
外部第一个then
内部promise
内部第一个then
外部第二个then
外部第三个then
外部第四个then
内部第二个then
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在一开始分析的时候，我忽略了 <code>return Promise.resolve()</code> 这个语句，以为它就只是同步返回一个 Promise 实例而已，但实际上， <code>then</code> 的回调的返回值是需要引起关注的。</p><p>前面说过，如果 promise 是 <code>then</code> 返回的，那么 <code>then</code> 的回调执行完毕之后它就被 <code>resolve</code> 了，这里其实要细分情况：</p><ul><li><p>如果 <code>then</code> 的回调返回的不是一个 <code>thenable</code> （具有 <code>then</code> 方法的 <code>object</code>），那么，这个返回值将被 <code>then</code> 返回的 promise 用来进行 <code>resolve</code>。而这个 promise 一旦被 <code>resolve</code>，则后面调用 <code>then</code> 的时候，<code>then</code> 的回调可以马上进入队列（严格地说，进入队列的不是回调，而是用于调用回调的某个微任务）。</p></li><li><p>如果 <code>then</code> 的回调返回的是一个 <code>thenable</code> ，比如说返回一个 promise_0，那么，<strong>这个 promise_0 会直接决定 <code>then</code> 返回的 promise_1 的状态（pending，resolve，reject）</strong>。而且，即使 promise_0 本身已经被 <code>resolve</code> 了，promise_1 也不会马上被 <code>resolve</code>，具体地说，需要经历下面的过程：</p><p>在返回 promise_0 之后，会生成一个微任务并放入队列中，这个微任务可以近似理解为如下代码：</p></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token function">microTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    promise_0<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        promise_1<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它所做的事情，就是调用 promise_0 的 <code>then</code> 方法，从而将 <code>then</code> 的回调放入队列中，而直到回调被执行的时候，promise_1 才终于被 <code>resolve</code> 或者 <code>reject</code>，它后面的 <code>then</code> 的回调才终于有机会进入队列。</p><p>在清楚这一点之后，我们再从头到尾分析一下这段代码：</p><ol><li><p>整体代码作为宏任务执行：实例化 promise，输出 <code>外部promise</code>，之后调用 <code>resolve</code>，promise 到达 <code>resolved</code> 状态</p></li><li><p>执行外部第一个 <code>then</code>，由于 <code>then</code> 前面的 promsie 已经被 <code>resolve</code>，所以 <code>then</code> 的回调进入队列。后面虽然相继执行了外部第二个、第三个、第四个 <code>then</code>，但由于每个 <code>then</code> 前面的 promise 都还没有 <code>resolve</code>，所以他们的回调都不会进入队列。</p><blockquote><p>此时的队列：外部第一个 <code>then</code> 的回调</p></blockquote></li><li><p>宏任务执行完毕，查看微任务并执行：队列取出外部第一个 <code>then</code> 的回调执行，输出 <code>外部第一个then</code>，接着实例化 promise，输出 <code>内部promise</code>，之后调用 <code>resolve</code>，该 promise 达到 <code>resolved</code> 状态</p><blockquote><p>此时的队列：空</p></blockquote></li><li><p>执行内部第一个 <code>then</code>，由于 <code>then</code> 前面的 promsie 已经被 <code>resolve</code>，所以 <code>then</code> 的回调进入队列；执行内部第二个 <code>then</code>，由于内部第一个 <code>then</code> 尚未 <code>resolve</code>，所以它的回调暂时不进入队列</p><blockquote><p>此时的队列： 内部第一个 <code>then</code> 的回调</p></blockquote></li><li><p>到这里，外部第一个 <code>then</code> 的回调执行完毕，并且返回一个非 <code>thenable</code>（返回<code>undefined</code>），所以这个 <code>then</code> 返回的 promise 被 <code>resolve</code>，使得外部第二个 <code>then</code> 的回调进入队列。</p><blockquote><p>此时的队列：内部第一个 <code>then</code> 的回调 → 外部第二个 <code>then</code> 的回调</p></blockquote></li><li><p>执行内部第一个 <code>then</code> 的回调，输出 <code>内部第一个then</code>，接着执行 <code>retrun Promise.resolve()</code>，按照前面说的，这会往队列中放入一个新生成的微任务</p><blockquote><p>此时的队列： 外部第二个 <code>then</code> 的回调 → microTask</p></blockquote></li><li><p><strong>记住，内部第一个then的回调虽然执行完毕了，但是 <code>then</code> 返回的 promise 还没有 <code>resolve</code></strong>，所以，内部第二个 <code>then</code> 的回调还不会进入队列。接着执行外部第二个 <code>then</code> 的回调，输出 <code>外部第二个then</code>，同时，外部第三个 <code>then</code> 的回调进入队列</p><blockquote><p>此时的队列：microTask → 外部第三个 <code>then</code> 的回调</p></blockquote><p>微任务执行完毕，第二轮事件循环结束。</p></li><li><p>执行 microTask，这将执行此前内部第一个 <code>then</code> 的回调返回的 promsie_0 的 <code>then</code> 方法，那么 <code>then</code> 的回调是否会马上进入队列呢？会的，因为 promsie_0 已经处于 <code>resolved</code> 状态</p><blockquote><p>此时的队列：外部第三个 <code>then</code> 的回调 → promsie_0 的 <code>then</code> 的回调</p></blockquote></li><li><p>执行外部第三个 <code>then</code> 的回调，输出 <code>外部第三个then</code>，同时，外部第四个 <code>then</code> 的回调进入队列</p><blockquote><p>此时的队列：promsie_0 的 <code>then</code> 的回调 → 外部第四个 <code>then</code> 的回调</p></blockquote></li><li><p>执行 promsie_0 的 <code>then</code> 的回调，这将会 <code>resolve</code> 内部第一个 <code>then</code> 返回的 promise_1。由于这个 <code>then</code> 被 <code>resolve</code> 了，所以后面跟着的内部第二个 <code>then</code> 的回调得以进入队列</p><blockquote><p>此时的队列： 外部第四个 <code>then</code> 的回调 → 内部第二个 <code>then</code> 的回调</p></blockquote></li><li><p>执行外部第四个 <code>then</code> 的回调，输出 <code>外部第四个then</code>。同时，外部第四个 <code>then</code> 返回的 promise 被 <code>resolve</code>，不过它后面没有跟着额外的 <code>then</code>，所以不再往队列中增加新的回调</p><blockquote><p>此时的队列：内部第二个 <code>then</code> 的回调</p></blockquote></li></ol><ol start="12"><li><p>执行内部第二个 <code>then</code> 的回调，输出 <code>内部第二个then</code>。同时，这个 <code>then</code> 返回的 promise 被 <code>resolve</code>，不过它后面没有跟着额外的 <code>then</code>，所以不再往队列中增加新的回调</p><blockquote><p>此时的队列：空</p></blockquote></li></ol><p>整段代码的事件循环其实只有一轮，宏任务的执行负责分发微任务到队列中，而微任务在执行的时候又会产生其它微任务，后面其实一直都是在处理微任务了，直到清空队列，没有额外的微任务或者宏任务需要执行了，整段代码也就结束了。</p><p>综上，最终的输出是：</p><pre class="line-numbers language-js"><code class="language-js">外部promise
外部第一个then
内部promise
内部第一个then
外部第二个then
外部第三个then
外部第四个then
内部第二个then
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与实际的输出结果完全一致。</p><p>这样分析就结束了。其实核心就在于<strong>判断 <code>then</code> 的回调进入队列的时机</strong>，而它入队的时机又取决于前面 promise_1 被 <code>resolve</code> 的时机。一开始认为在同步执行 <code>return Promise.resolve()</code> （记作 promise_0）的时候，前面 <code>then</code> 的回调就执行完毕了， promise_1 就已经被 <code>resolve</code> 了。但实际上，如果回调返回的是一个 <code>thenable</code>，则属于特殊情况，它会导致生成一个新的微任务放到队列中， promise_1 也因此不会马上被 <code>resolve</code>，而是等到 promise_0 的 <code>then</code> 的回调被执行的时候，才会被 <code>resolve</code>。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>分析思路基本是参考思否的 @fefe 大佬的，他在回答中提到了规范的一些内容，不过我没有了解过 Promise 的内部实现，也没有研读过 spec，所以这篇文章就没办法往深的地方写了，也不会涉及原理，但如果你想从事件循环的角度分析这段代码，应该还是能提供一点帮助的。各位如果想继续深入挖掘的话，可以阅读文末链接的几篇文章。</p><p>最后想谈谈楼主删帖这件事情。我觉得在技术社区提问之前，如果能确保：</p><ul><li>自己花时间思考过</li><li>网上所能找到的资料暂时不能解惑</li></ul><p>而在提问的时候，能确保：</p><ul><li>描述问题准确、重点突出</li></ul><p>那么这个提问毫无疑问就已经是合格的了，甚至说已经超出了一般提问的水平（因为上面说的几点，其实有很多人是做不到的）。但我看到的却是，这样的一个提问受到了一些人的冷嘲热讽，这种现象发生在一个技术社区，并不正常。</p><p>不瞒各位，我偶尔也会在 StackOverflow 上问一些比较小白的问题，但从不会有人吐槽说 “You are foolish”。我知道，也许真有人会这么想，但他们不会说出来，这对我来说是最大的善意了。国内技术社区缺乏的，往往并不是技术，而是一颗包容心以及足够友善的氛围。自己技术提高了，看一些问题自然会觉得很简单，但说实话，这不是你挖苦别人的资本，大家都是一步一个脚印慢慢走过来的。</p><p>参考链接：</p><p><a href="https://segmentfault.com/q/1010000023372044?_ea=56749665" target="_blank" rel="noopener">关于promise输出顺序的疑问</a></p><p><a href="https://juejin.im/post/5dc028dcf265da4d4b5fe94f#heading-6" target="_blank" rel="noopener">深度揭秘 Promise 微任务注册和执行过程</a></p><p><a href="https://juejin.im/post/5dabf847e51d4524d674881c#comment" target="_blank" rel="noopener">Promise 链式调用顺序引发的思考</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2020/07/27/F-concurrently%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E8%BF%9E%E8%BD%BD%E5%90%AF%E5%8A%A8/" rel="prev" title="concurrently 实现前后端连载启动"><i class="fa fa-angle-double-left"></i>&nbspconcurrently 实现前后端连载启动</a></div><div class="post-nav-next"><a href="/2020/07/22/T-%E5%85%B3%E4%BA%8E%E5%A4%A7%E4%BA%8C%E4%B8%8B%E7%9A%84%E6%80%BB%E7%BB%93/" rel="next" title="关于大二下的总结">关于大二下的总结&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#问题"><span class="toc-text">问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#先从简单的开始分析"><span class="toc-text">先从简单的开始分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#再看题目"><span class="toc-text">再看题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最后"><span class="toc-text">最后</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2020</span> My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue" target="_blank" rel="noopener">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->