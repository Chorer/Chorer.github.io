<!-- build time:Fri Sep 27 2019 23:14:01 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Chor&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third party/pace-theme-flash.css"><link rel="icon" href="/images/me.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-atom-dark.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="header"><div class="header_top"><span class="theme"><i class="fa fa-bars"></i> <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">HOME</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">CATEGORIES</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">ARCHIVES</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">TAGS</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">ABOUT</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="/" class="logo">Chor&#39;s Blog</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">深入理解变量对象、作用域链和闭包</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-04-10&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp4.2k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp15 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/闭包/">闭包</a> <a href="/tags/变量对象/">变量对象</a> <a href="/tags/作用域链/">作用域链</a></div></div><div class="post-content"><p>执行上下文、执行栈、作用域链、闭包，这其实是一整套相关的东西，之前<a href="https://chorer.github.io/2019/03/04/F-%E9%97%AD%E5%8C%85/">转载的文章</a>也有讲到这些。下面两篇文章会更加详细地解释这些概念。</p><ul><li><a href="https://chorer.github.io/2019/04/08/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/">深入理解执行上下文和执行栈</a></li><li><a href="https://chorer.github.io/2019/04/10/F-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/">深入理解变量对象、作用域链和闭包</a></li></ul><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/深入理解变量对象作用域链和闭包-1.png" alt=""></p><a id="more"></a><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>首先引用下winter大的原话：</p><blockquote><p>在<span style="background-color:#fffa7d">ES3</span>中，执行上下文包含三个部分:<br>1.scope: 作用域，也常常被叫做作用域链。<br>2.variable object:变量对象，用于存储变量的对象。<br>3.this value: this值。<br>在<span style="background-color:#fffa7d">ES5</span>中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子:<br>1.lexical environment:词法环境，当获取变量时使用。<br>2.variable environment:变量环境，当声明变量时使用。<br>3.this value: this值。<br>在<span style="background-color:#fffa7d">ES2018</span>中，this值被归入lexical environment,同时增加了不少内容：<br>1.lexical environment:词法环境，当获取变量或者this值时使用。<br>2.variable environment:变量环境，当声明变量时使用。<br>3…….</p></blockquote><blockquote><p>我们在这里介绍执行上下文的各个版本定义，是考虑到你可能会从各种网上的文章中接触这些概念，如果不把它们理清楚，我们就很难分辨对错。如果是我们自己使用，我建议统一使用最新的ES2018中规定的术语定义。</p></blockquote><p>所以，你会看到本文讲解的部分与另一篇文章有出入（例如变量对象VS环境记录），只需要知道是不同时期的不同规范就行了，没必要深究。</p><h1 id="2-执行上下文"><a href="#2-执行上下文" class="headerlink" title="2.执行上下文"></a>2.执行上下文</h1><p>每个执行上下文都有三个重要的属性：变量对象、作用域链、this。在执行上下文压栈后，将进行初始化，这个过程具体来说就是：</p><ul><li>创建变量对象</li><li>创建作用域链</li><li>确定this指向</li></ul><p>用代码表示如下：</p><pre class="line-numbers language-js"><code class="language-js">ExecutionContext <span class="token operator">=</span> <span class="token punctuation">{</span>
    VO<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 或者 AO</span>
    <span class="token keyword">this</span><span class="token punctuation">:</span> thisValue<span class="token punctuation">,</span>
    Scope<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token comment" spellcheck="true">// 所用域链</span>
      <span class="token comment" spellcheck="true">// 所有变量对象的列表</span>
      <span class="token comment" spellcheck="true">// 用于标识符查询</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们针对这三个东西一一进行解释。</p><h1 id="3-变量对象"><a href="#3-变量对象" class="headerlink" title="3.变量对象"></a>3.变量对象</h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h2><p>变量对象即Variable object/VO，它是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p><ul><li>在全局执行上下文中，变量对象即全局对象（在浏览器中是window对象），它是可以访问的。</li><li>在函数执行上下文中，变量对象是不能直接访问的，此时由活动对象(Activation Object/AO)扮演变量对象的角色，也就是所谓的VO–&gt;AO。</li></ul><p>总而言之，变量对象和活动对象的区别就是：<br>1、变量对象是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。<br>2、当进入到一个函数执行上下文后，这个变量对象才会被激活，成为活动对象，这时候活动对象上的各种属性才能被访问。</p><h2 id="3-2-从执行上下文看变量对象"><a href="#3-2-从执行上下文看变量对象" class="headerlink" title="3.2 从执行上下文看变量对象"></a>3.2 从执行上下文看变量对象</h2><p>首先，执行上下文分为两个阶段：<br>1.进入执行上下文<br>2.代码执行</p><h3 id="3-2-1-进入执行上下文"><a href="#3-2-1-进入执行上下文" class="headerlink" title="3.2.1 进入执行上下文"></a>3.2.1 进入执行上下文</h3><p>很明显，这个时候还没有执行代码。<br>此时的变量对象将包含（按照如下顺序初始化）：</p><p>1.<span style="background-color:#fffa7d">一个指向arguments对象的arguments变量</span>（如果是函数执行上下文）：具体地说，在变量对象内部将创建局部变量arguments和arguments对象，并使该变量指向该对象。arguments对象包括下列属性：</p><ul><li>callee：指向当前函数的引用</li><li>length： 真正传递的参数的个数</li><li>properties-indexes：就是函数的参数值(按参数列表从左到右排列)</li></ul><p>2.<span style="background-color:#fffa7d">函数的所有形参</span>（如果是函数执行上下文）：有实参则赋值，无实参则为undefined。<br>3.<span style="background-color:#fffa7d">函数声明</span>：如果声明的函数跟已经声明的形参在名称上是相同的，则完全替换这个形参变量。<br>4.<span style="background-color:#fffa7d">变量声明</span>：如果声明的变量跟已经声明的形参/函数在名称上是相同的，则变量声明不会干扰它们，仅赋值部分是生效的。</p><p>同时明确，变量对象将不包含：</p><ul><li>函数表达式（与函数声明相对）</li><li>没有使用var声明的变量（这属于“全局式”的声明方式，只是给全局添加了一个属性，并不在变量对象中）</li></ul><p>拿下面代码作为例子：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在调用函数foo后，将进入其对应的函数执行上下文，此时的变量对象（实际上是活动对象）根据上面的说法，应为：</p><pre class="line-numbers language-js"><code class="language-js">AO <span class="token operator">=</span> <span class="token punctuation">{</span>
    arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        length<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>
    c<span class="token punctuation">:</span> reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    d<span class="token punctuation">:</span> undefined
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以从arguments对象的<code>properties-indexes</code>属性或者a看出，形参此时已经赋值了，但是变量仍是<code>undefined</code>。</p><h3 id="3-2-2-代码执行"><a href="#3-2-2-代码执行" class="headerlink" title="3.2.2 代码执行"></a>3.2.2 代码执行</h3><p>这个阶段会顺序执行代码，修改变量对象的值，执行完成后变量对象如下：</p><pre class="line-numbers language-js"><code class="language-js">AO <span class="token operator">=</span> <span class="token punctuation">{</span>
    arguments<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        length<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    c<span class="token punctuation">:</span> reference to <span class="token keyword">function</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    d<span class="token punctuation">:</span> reference to FunctionExpression <span class="token string">"d"</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面说过，函数表达式和没有使用var声明的变量将不会包含在变量对象里，所以如果添加如下代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
e <span class="token operator">=</span> <span class="token number">1</span>；
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>变量对象是不会变的</p><h1 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4.作用域链"></a>4.作用域链</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><p>作用域链其实就是所有执行上下文的变量对象的列表。我们可以将其看作数组，并表示为：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> Scope <span class="token operator">=</span> <span class="token punctuation">[</span>VO1<span class="token punctuation">,</span> VO2<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">,</span> VOn<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体来说，函数执行上下文的作用域链包括该上下文的活动对象和该上下文对应函数的内部<code>[[Scope]]</code>属性。表示为：</p><pre class="line-numbers language-js"><code class="language-js">Scope <span class="token operator">=</span> AO <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-2-作用："><a href="#4-2-作用：" class="headerlink" title="4.2 作用："></a>4.2 作用：</h2><p>作用域链的作用是：在处理标识符的时候进行变量查询。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。</p><h2 id="4-3-Scope和-Scope-："><a href="#4-3-Scope和-Scope-：" class="headerlink" title="4.3 Scope和[[Scope]]："></a>4.3 <code>Scope</code>和<code>[[Scope]]</code>：</h2><p>前面我们说的<code>Scope</code>是执行上下文的属性，而<code>[[Scope]]</code>是函数的属性。<br>具体来说，<code>[[Scope]]</code>是一个包含了所有上层变量对象的分层链，它属于当前函数执行上下文，在函数创建伊始就存在了，并保存在函数中。</p><p>这里要注意的很重要的一点是：<code>[[Scope]]</code>是在函数创建的时候保存起来的——静态的（不变的），只有一次并且一直都存在——直到函数销毁。 比方说，哪怕函数永远都不能被调用到，<code>[[Scope]]</code>属性也已经保存在函数对象上了。</p><h2 id="4-4-从执行上下文看作用域链："><a href="#4-4-从执行上下文看作用域链：" class="headerlink" title="4.4 从执行上下文看作用域链："></a>4.4 从执行上下文看作用域链：</h2><p>下面用具体的例子回顾一下在执行上下文中，变量对象和作用域链的创建过程</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> 

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>x <span class="token operator">+</span>  y <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 60</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先进入全局执行上下文，创建变量对象（全局对象window）</p><pre class="line-numbers language-js"><code class="language-js">globalContext<span class="token punctuation">.</span>VO <span class="token operator">===</span> Global <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token punctuation">:</span> undefined
  foo<span class="token punctuation">:</span> <span class="token operator">&lt;</span>reference to <span class="token keyword">function</span><span class="token operator">></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之后开始执行代码，变量对象变为：</p><pre class="line-numbers language-js"><code class="language-js">globalContext<span class="token punctuation">.</span>VO <span class="token operator">===</span> Global <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token punctuation">:</span> <span class="token number">10</span>
  foo<span class="token punctuation">:</span> <span class="token operator">&lt;</span>reference to <span class="token keyword">function</span><span class="token operator">></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，在创建foo函数时，确认它的<code>[[Scope]]</code>属性：</p><pre class="line-numbers language-js"><code class="language-js">foo<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  globalContext<span class="token punctuation">.</span>VO
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之后，调用foo函数，进入其对应的函数执行上下文，此时函数的变量对象激活为活动对象：</p><pre class="line-numbers language-js"><code class="language-js">fooContext<span class="token punctuation">.</span>AO <span class="token operator">=</span> <span class="token punctuation">{</span>
  y<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>
  bar<span class="token punctuation">:</span> <span class="token operator">&lt;</span>reference to <span class="token keyword">function</span><span class="token operator">></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同时确认了foo函数执行上下文的作用域链：</p><pre class="line-numbers language-js"><code class="language-js">fooContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> fooContext<span class="token punctuation">.</span>AO <span class="token operator">+</span> foo<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// i.e.:</span>

fooContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> <span class="token punctuation">[</span>
  fooContext<span class="token punctuation">.</span>AO<span class="token punctuation">,</span>
  globalContext<span class="token punctuation">.</span>VO
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后开始执行代码，变量对象变为：</p><pre class="line-numbers language-js"><code class="language-js">fooContext<span class="token punctuation">.</span>AO <span class="token operator">=</span> <span class="token punctuation">{</span>
  y<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  bar<span class="token punctuation">:</span> <span class="token operator">&lt;</span>reference to <span class="token keyword">function</span><span class="token operator">></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，在创建bar函数时，确认它的<code>[[Scope]]</code>属性：</p><pre class="line-numbers language-js"><code class="language-js">bar<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  fooContext<span class="token punctuation">.</span>AO<span class="token punctuation">,</span>
  globalContext<span class="token punctuation">.</span>VO
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之后，调用bar函数，进入bar函数对应的函数执行上下文，此时函数的变量对象激活为活动对象：</p><pre class="line-numbers language-js"><code class="language-js">barContext<span class="token punctuation">.</span>AO <span class="token operator">=</span> <span class="token punctuation">{</span>
  z<span class="token punctuation">:</span> undefined
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同时确认了bar函数执行上下文的作用域链：</p><pre class="line-numbers language-js"><code class="language-js">barContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> barContext<span class="token punctuation">.</span>AO <span class="token operator">+</span> bar<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// i.e.:</span>

barContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> <span class="token punctuation">[</span>
  barContext<span class="token punctuation">.</span>AO<span class="token punctuation">,</span>
  fooContext<span class="token punctuation">.</span>AO<span class="token punctuation">,</span>
  globalContext<span class="token punctuation">.</span>VO
<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后开始执行代码，变量对象变为：</p><pre class="line-numbers language-js"><code class="language-js">barContext<span class="token punctuation">.</span>AO <span class="token operator">=</span> <span class="token punctuation">{</span>
  z<span class="token punctuation">:</span> <span class="token number">30</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在运行<code>alert(x + y + z);</code>这一语句的时候，开始进行变量（或者说标识符）查询：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">-</span> <span class="token string">"x"</span>
<span class="token operator">--</span> barContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// not found</span>
<span class="token operator">--</span> fooContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// not found</span>
<span class="token operator">--</span> globalContext<span class="token punctuation">.</span>VO <span class="token comment" spellcheck="true">// found - 10</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">-</span> <span class="token string">"y"</span>
<span class="token operator">--</span> barContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// not found</span>
<span class="token operator">--</span> fooContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// found - 20</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">-</span> <span class="token string">"z"</span>
<span class="token operator">--</span> barContext<span class="token punctuation">.</span>AO <span class="token comment" spellcheck="true">// found - 30</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>这里需要注意，由于确认执行上下文的作用域链时，总会将当前上下文的变量对象/活动对象推至作用域链的顶端( <code>Scope=当前活动对象+所有上层对象</code> )，所以变量查询也将从该变量对象开始，而全局对象则一直处于末端，是最后被查询的。</p></blockquote><p>bar执行完毕，出栈—&gt;foo执行完毕，出栈—&gt;回到全局执行上下文</p><h1 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5.闭包"></a>5.闭包</h1><h2 id="5-1-从向下Funarg问题谈静态作用域"><a href="#5-1-从向下Funarg问题谈静态作用域" class="headerlink" title="5.1 从向下Funarg问题谈静态作用域"></a>5.1 从向下Funarg问题谈静态作用域</h2><blockquote><p>“Funarg”即函数式参数，指的是值为函数的参数。如：</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">exampleFunc</span><span class="token punctuation">(</span>funArg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">funArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先看下这段代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>funArg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  <span class="token function">funArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10, 而不是20!</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 将 `foo` 作为实参传给 `bar`。</span>
<span class="token function">bar</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于函数foo，变量x就是自由变量。当foo函数被调用时，它在哪里解析x绑定呢？是从创建函数的外层作用域，还是从调用函数的外层作用域？<br>这就是所谓的<span style="background-color:#fffa7d">向下funarg问题</span>(downwards funarg problem)，即在判断绑定的环境时的歧义性：它应该是创建时的环境，还是调用时的环境？</p><p>这是通过达成约定使用静态作用域来解决的。静态作用域也就是词法作用域（这也是词法环境这个名称的由来），它是通过捕获函数创建所在的环境来实现的，因而会到函数创建时保存起来的静态作用域链中进行变量查询。如果一个语言只通过查找源代码，就可以判断绑定在哪个环境中解析，那么该语言就实现了静态作用域。</p><p>与静态作用域相对的是动态作用域。动态作用域是在当前活跃的动态链（而不是在函数创建时保存起来的静态作用域链）中进行变量查询的。对于上面的代码，如果是动态作用域，将输出20而不是10。</p><h2 id="5-2-从向上Funarg问题谈闭包"><a href="#5-2-从向上Funarg问题谈闭包" class="headerlink" title="5.2 从向上Funarg问题谈闭包"></a>5.2 从向上Funarg问题谈闭包</h2><p>另一种Funarg问题是<span style="background-color:#fffa7d">向上funarg问题</span>(upwards funarg problem)。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 闭包，捕获`foo`的环境。</span>
  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 向上funarg。</span>
  <span class="token keyword">return</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 调用`foo`来返回`bar`闭包。</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10，而不是20!</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了判断绑定环境的歧义性，向上funarg问题面临的另一个问题是：如果JavaScript是面向堆栈的，那么foo函数在调用结束后，其执行上下文将带着变量对象销毁，这样一来，在我们调用bar函数时将发生错误（因为bar函数需要用到自由变量x，而该变量已经随着foo函数变量对象的销毁而消失了）。而且，在面向堆栈实现模型中，要想将bar函数返回根本是不可能的，因为它也是foo函数变量对象的一部分，也会随之销毁。</p><p>也就是说我们面临两个问题：</p><ul><li>绑定环境的歧义性</li><li>被引用的自由变量在上下文销毁后无法得到保留</li></ul><p>为了解决这两类问题，引入了闭包的概念。</p><h2 id="5-3-闭包"><a href="#5-3-闭包" class="headerlink" title="5.3 闭包"></a>5.3 闭包</h2><h3 id="5-3-1-定义"><a href="#5-3-1-定义" class="headerlink" title="5.3.1 定义"></a>5.3.1 定义</h3><p>ECMAScript中，闭包指的是：</p><ul><li><p>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p></li><li><p>从实践角度：以下函数才算是闭包：<br>1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）<br>2.在代码中引用了自由变量</p></li></ul><p>JavaScript显然是支持词法作用域的（除了this），所以解决了向下Funarg问题；同时由于闭包的存在，即使创建闭包的执行上下文出栈后被销毁，其变量对象也依然存在，所以闭包函数依然有办法访问到该对象，这就解决了向上Funarg问题。</p><blockquote><p>这个过程具体来说就是：通过某种方式（通常是返回值）调用闭包后，创建闭包对应的执行上下文并压栈，该上下文的属性<code>Scope</code>包括了闭包本身的变量对象和闭包的<code>[[Scope]]</code>属性，后者使得闭包执行时有机会访问到自由变量，因为<code>[[Scope]]</code>在闭包的词法创建阶段便已确定，并在那时候保存了其上层变量对象（上层，也就是闭包的父函数）。</p></blockquote><h3 id="5-3-2-注意"><a href="#5-3-2-注意" class="headerlink" title="5.3.2 注意"></a>5.3.2 注意</h3><p>不过这里需要注意，仅变量对象里被引用的自由变量依然存在，不需要用到的变量会被垃圾清除机制清除。可以用下面的代码做个测试：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> hello <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> unused <span class="token operator">=</span> <span class="token string">"nope"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">debugger</span><span class="token punctuation">;</span> <span class="token keyword">return</span> s<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">g</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>debugger查看closure，发现只有hello变量，而找不到unused变量:</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/深入理解变量对象作用域链和闭包-2.png" alt=""></p><p>在控制台打印unused变量时，报错：<br><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/深入理解变量对象作用域链和闭包-3.png" alt=""></p><p>另外一个需要注意的地方是：同一个上下文中可能存在多个闭包，而这些闭包是共用同一个<code>[[Scope]]</code>属性的。也就是说，某个闭包对其中的变量做修改会影响到其他闭包对该变量的读取：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> firstClosure<span class="token punctuation">;</span>
<span class="token keyword">var</span> secondClosure<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

  firstClosure <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  secondClosure <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">--</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对AO["x"]产生了影响, 其值在两个闭包的[[Scope]]中</span>

  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">firstClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3, 通过 firstClosure.[[Scope]]</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">firstClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">secondClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也可以解释经典的for循环问题：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3, 而不是 0</span>
data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3, 而不是 1</span>
data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3, 而不是 2</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一个函数都是一个闭包，拥有同一个<code>[[Scope]]</code>属性，这个属性包含了全局对象，而全局对象包含了变量k，这个k在循环跑完后变成了3，所以闭包调用的时候统一输出3。</p><h3 id="5-3-3-闭包的运用"><a href="#5-3-3-闭包的运用" class="headerlink" title="5.3.3 闭包的运用"></a>5.3.3 闭包的运用</h3><p>实际使用的时候，闭包可以创建出非常优雅的设计，允许对funarg上定义的多种计算方式进行定制。 如下就是数组排序的例子，它接受一个排序条件函数作为参数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token comment" spellcheck="true">// 排序条件</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同样的例子还有，数组的map方法（并非所有的实现都支持数组map方法，SpiderMonkey从1.6版本开始有支持），该方法根据函数中定义的条件将原数组映射到一个新的数组中：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> element <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [2, 4, 6]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用函数式参数，可以很方便的实现一个搜索方法，并且可以支持无穷多的搜索条件：</p><pre class="line-numbers language-js"><code class="language-js">someCollection<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> element<span class="token punctuation">.</span>someProperty <span class="token operator">==</span> <span class="token string">'searchCondition'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>还有应用函数，比如常见的forEach方法，将funarg应用到每个数组元素：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1, 3</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>join<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1;2;3</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>闭包还有另外一个非常重要的应用 —— 延迟调用：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10, 一秒钟后</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>也可以用于回调函数：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">...</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// only for example</span>
xmlHttpRequestObject<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 当数据就绪的时候，才会调用;</span>
  <span class="token comment" spellcheck="true">// 这里，不论是在哪个上下文中创建，变量“x”的值已经存在了</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还可以用于封装作用域来隐藏辅助对象：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// initialization</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

  object<span class="token punctuation">.</span>getX <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">_getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// get closured "x" – 10</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<br><a href="http://dmitrysoshnikov.com/ecmascript" target="_blank" rel="noopener">http://dmitrysoshnikov.com/ecmascript</a><br><a href="http://goddyzhao.tumblr.com/post/11311499651/closures" target="_blank" rel="noopener">http://goddyzhao.tumblr.com/post/11311499651/closures</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/04/13/T-由一道题引发的思考/" rel="prev" title="由一道题引发的思考"><i class="fa fa-angle-double-left"></i>&nbsp由一道题引发的思考</a></div><div class="post-nav-next"><a href="/2019/04/08/F-深入理解执行上下文和执行栈/" rel="next" title="深入理解执行上下文和执行栈">深入理解执行上下文和执行栈&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top"><i class="fa fa-th-large"></i>Catalog</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-前言"><span class="toc-text">1.前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-执行上下文"><span class="toc-text">2.执行上下文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-变量对象"><span class="toc-text">3.变量对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-定义"><span class="toc-text">3.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-从执行上下文看变量对象"><span class="toc-text">3.2 从执行上下文看变量对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-进入执行上下文"><span class="toc-text">3.2.1 进入执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-代码执行"><span class="toc-text">3.2.2 代码执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-作用域链"><span class="toc-text">4.作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-定义"><span class="toc-text">4.1 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-作用："><span class="toc-text">4.2 作用：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Scope和-Scope-："><span class="toc-text">4.3 Scope和[[Scope]]：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-从执行上下文看作用域链："><span class="toc-text">4.4 从执行上下文看作用域链：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-闭包"><span class="toc-text">5.闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-从向下Funarg问题谈静态作用域"><span class="toc-text">5.1 从向下Funarg问题谈静态作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-从向上Funarg问题谈闭包"><span class="toc-text">5.2 从向上Funarg问题谈闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-闭包"><span class="toc-text">5.3 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-定义"><span class="toc-text">5.3.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-注意"><span class="toc-text">5.3.2 注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-闭包的运用"><span class="toc-text">5.3.3 闭包的运用</span></a></li></ol></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/search.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300,"vOffset":-120,"hOffset":-5},"mobile":{"show":false},"react":{"opacityDefault":1000,"opacityOnHover":1000},"log":false});</script></body></html><!-- rebuild by neat -->