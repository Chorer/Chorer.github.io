<!-- build time:Mon Nov 04 2019 18:02:26 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Chor&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third party/pace-theme-flash.css"><link rel="icon" href="/images/me.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script><script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><i class="fa fa-bars"></i> <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">HOME</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">CATEGORIES</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">ARCHIVES</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">TAGS</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">ABOUT</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="/" class="logo">Chor&#39;s Blog</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">原型式继承和类式继承</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-03-17&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp1.7k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp6 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><p>Java和JavaScript都是面向对象的语言，但二者的继承方式截然不同。前者采用类式继承（classical inheritence），也是大多数面向对象语言的继承方式。而后者采用原型式继承（prototype ineritence），因此称JavaScript为基于对象更加合适。<br><a id="more"></a></p><h3 id="1-JavaScript的继承"><a href="#1-JavaScript的继承" class="headerlink" title="1.JavaScript的继承"></a>1.JavaScript的继承</h3><p>就JavaScript的继承来说，又可以分为es5的继承和es6的继承。参考阮一峰老师在《ES6标准入门》一书中所说的：</p><blockquote><p>在ES6之前，class是保留字，ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p></blockquote><p>虽然在es6中引入了类的概念，但它其实只是简化了原来需要我们自己编写的原型链代码的语法糖，从而让js更趋向于传统的面向对象语言而已。要理解这个过程，首先要明白es6中的class做了什么。</p><h4 id="1-1-class到底做了什么："><a href="#1-1-class到底做了什么：" class="headerlink" title="1.1 class到底做了什么："></a>1.1 class到底做了什么：</h4><ul><li>首先看看class是什么东西</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token operator">...</span>
<span class="token punctuation">}</span>
<span class="token keyword">typeof</span> Person   <span class="token comment" spellcheck="true">//  function </span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里的class与java中的class不同，它并不是一个全新的数据类型，而是相当于原型继承中的构造函数。</p><ul><li>接着看看es5和es6在实现继承上的区别：</li></ul><p>es5：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//父类</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">SubPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 子类</span>
    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 子类继承父类的属性 需要将this指向父类中的name</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// job是子类的新增属性</span>
<span class="token punctuation">}</span>
SubPerson<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 让子类继承父类的方法</span>
<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token string">'zcl'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//实例化子类对象</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// zcl（父类属性）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// zcl（父类方法）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>es6：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>                      <span class="token comment" spellcheck="true">// 父类</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">SubPerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//子类</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 用super来调用父类的构造函数</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// job是子类的新增属性</span>
    <span class="token punctuation">}</span>
    <span class="token function">showJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>job<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token string">'zcl'</span><span class="token punctuation">,</span><span class="token string">'前端开发'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//实例化子类对象</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// zcl（父类属性）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// zcl（父类方法）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 前端开发（子类属性）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，es6中采用class后，大大简化了组合继承的步骤。</p><ul><li>class做了什么：</li></ul><p>1.定义父类时</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    constructor<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*constructor*/</span> <span class="token punctuation">}</span>
    method<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*method*/</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 等价于</span>
<span class="token keyword">function</span> Person<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/*constructor*/</span>
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>method<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/*method*/</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.子类继承父类时：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">SubPerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    onstructor<span class="token punctuation">{</span>
         <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
         <span class="token comment" spellcheck="true">/*constructor*/</span>       <span class="token comment" spellcheck="true">//子类新增属性</span>
         <span class="token punctuation">}</span>
    method<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*method*/</span> <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//子类新增方法</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> subperson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 等价于</span>

<span class="token keyword">function</span> SubPerson<span class="token punctuation">{</span>
    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">/*constructor*/</span>          <span class="token comment" spellcheck="true">//子类新增属性</span>
<span class="token punctuation">}</span>
SubPerson<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
SubPerson<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>method<span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/*method*/</span>               <span class="token comment" spellcheck="true">//子类新增方法</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> subperson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于es6继承而言，访问实例化的子类对象的属性或者方法时，依然是沿着原型链进行追溯，并且子类实例创建后，class SubPerson中的this依然会指向该子类，可以看出，这与es5的原型继承的一模一样的。</p><h4 id="1-2-关于this："><a href="#1-2-关于this：" class="headerlink" title="1.2 关于this："></a>1.2 关于this：</h4><p>es5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.call(this)）；es6的继承机制完全不同，实质是先通过调用super方法（super指向父类的构造函数）创造父类的实例对象this，然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加。</p><h3 id="2-Java的继承"><a href="#2-Java的继承" class="headerlink" title="2.Java的继承"></a>2.Java的继承</h3><p>首先了解java中创建对象的方式。java中，类一般包含field(变量)，constructor(构造方法)，method(其他方法)。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">// 创建父类</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//  field</span>
    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// method</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// constructor</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着实现继承</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SubPerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 创建子类</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// field</span>
    <span class="token keyword">public</span> String <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// method</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">SubPerson</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// constructor</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 通过super调用父类构造方法</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//重写父类方法，发生覆盖</span>
        <span class="token keyword">return</span> <span class="token string">"I am not "</span><span class="token operator">+</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" but I am "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建测试类</p><pre class="line-numbers language-java"><code class="language-java">Public <span class="token keyword">class</span> <span class="token class-name">Testclass</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        Person person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"father"</span><span class="token punctuation">)</span>  
        <span class="token comment" spellcheck="true">//通过new一个构造方法创建父类实例</span>
        SubPerson subperson1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubPerson</span><span class="token punctuation">(</span><span class="token string">"son"</span><span class="token punctuation">)</span>  
        <span class="token comment" spellcheck="true">// 创建子类实例</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subperson1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//->I am not father but I am son.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-JavaScript的原型式继承与Java的类式继承"><a href="#3-JavaScript的原型式继承与Java的类式继承" class="headerlink" title="3.JavaScript的原型式继承与Java的类式继承"></a>3.JavaScript的原型式继承与Java的类式继承</h3><p>由上面分析可见，es6中的类式继承其实还是原型式继承。那么它与java中真正的类式继承相比，有什么区别呢？</p><ul><li>类式继承的方法都会存在父对象之中，每一次实例，都会将funciton保存在内存中，这会带来性能上的问题。</li><li>类式继承是不可变的。在运行时，无法修改或者添加新的方法，这种方式是一种固步自封的死方法；相反，原型继承是可以通过改变原型链进而对子类进行修改的。</li><li>类式继承可以实现多重继承（Java是通过接口来实现）；原型式继承一般来说是不支持多继承的（因为原型链），但可以通过Mixin变相实现多继承。</li></ul><h3 id="4-补充：子类如何调用父类被覆盖的同名方法"><a href="#4-补充：子类如何调用父类被覆盖的同名方法" class="headerlink" title="4.补充：子类如何调用父类被覆盖的同名方法"></a>4.补充：子类如何调用父类被覆盖的同名方法</h3><p>首先这是一个比较奇怪的需求，因为既然子类重写了父类方法，就说明父类方法无法实现我们的要求，反过来，假设父类方法可以实现要求，则没必要重写该方法。但是让我们设想一下，假定现在一定要通过子类调用父类被覆盖的那个方法，应该怎么做呢？</p><p>通过上面的例子可以看到，在java中，我们只能在子类的构造方法中通过super关键字调用父类方法，而无法直接用子类的实例调用那个方法，像“子类实例.super.父类方法”，这是无效的；但是在js中，我们是可以做到的。基本思路就是：将父类实例以属性的方式进行保存，且该属性是子类构造函数的原型对象的属性。</p><p>这其实和原型链有关。我们设想有父类A、子类B以及同名方法say，并且设定子类B的原型对象的superClass属性指向父类实例b。那么，子类实例a直接调用say方法，必然是调用重写之后的方法；当它想要调用被覆盖的方法时，我们只需要用<code>a.superClass.say()</code>即可—–对于实例a，我们知道它本身并不具备superClass属性，因此它将沿着自己的原型对象也即子类B的原型对象进行查找，刚好B的原型对象有一个指向b的superClass属性，所以我们拿来用，而b有被覆盖的say方法，所以这里顺利完成了被覆盖方法的调用。</p><p><a href="https://blog.csdn.net/zhy416011189/article/details/50980016?utm_source=blogxgwz0" target="_blank" rel="noopener">附上CSDN的参考链接</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/03/18/G-游戏往事/" rel="prev" title="游戏往事"><i class="fa fa-angle-double-left"></i>&nbsp游戏往事</a></div><div class="post-nav-next"><a href="/2019/03/17/T-Stack Overflow提问指南和必备术语汇总/" rel="next" title="如何在 Stack Overflow 规范提问">如何在 Stack Overflow 规范提问&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JavaScript的继承"><span class="toc-text">1.JavaScript的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-class到底做了什么："><span class="toc-text">1.1 class到底做了什么：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-关于this："><span class="toc-text">1.2 关于this：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java的继承"><span class="toc-text">2.Java的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JavaScript的原型式继承与Java的类式继承"><span class="toc-text">3.JavaScript的原型式继承与Java的类式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-补充：子类如何调用父类被覆盖的同名方法"><span class="toc-text">4.补充：子类如何调用父类被覆盖的同名方法</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->