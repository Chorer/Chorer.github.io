<!-- build time:Fri Dec 10 2021 20:28:06 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/prism.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">TypeScript 官方手册翻译计划【二】：普通类型</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2021-11-18&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp6.7k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp26 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/TypeScript/">TypeScript</a> <a href="/tags/documentation/">documentation</a></div></div><div class="post-content"><p><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/TypeScript%20%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/banner.jpeg" alt=""></p><span id="more"></span><blockquote><ul><li><p><strong>说明</strong>：目前网上没有 TypeScript 最新官方文档的中文翻译，所以有了这么一个翻译计划。因为我也是 TypeScript 的初学者，所以无法保证翻译百分之百准确，若有错误，欢迎评论区指出；</p></li><li><p><strong>翻译内容</strong>：暂定翻译内容为 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/intro.html">TypeScript Handbook</a>，后续有空会补充翻译文档的其它部分；</p></li><li><p><strong>项目地址</strong>：<a target="_blank" rel="noopener" href="https://github.com/Chorer/TypeScript-Doc-Zh">TypeScript-Doc-Zh</a>，如果对你有帮助，可以点一个 star ~</p></li></ul></blockquote><p>本章节官方文档地址：<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html">Everyday Types</a></p><h2 id="普通类型"><a class="markdownIt-Anchor" href="#普通类型"></a> 普通类型</h2><p>在这一章中，我们的内容会涉及到 JavaScript 代码中最常见的一些数据类型，同时也会解释这些类型在 TypeScript 中的对应描述方式。本章节并不会详尽介绍所有类型，在后续章节中我们还会介绍更多命名和使用其它类型的方法。</p><p>类型不仅可以出现在类型注解中，还可以出现在许多其它地方。在学习类型本身的同时，我们也会学习如何在某些地方使用这些类型去组成新的结构。</p><p>首先，我们先来回顾一下编写 JavaScript 或者 TypeScript 代码时最基础和最常用的类型。它们稍后将成为更复杂类型的核心组成部分。</p><h3 id="原始类型string-number-和-boolean"><a class="markdownIt-Anchor" href="#原始类型string-number-和-boolean"></a> 原始类型：<code>string</code>、<code>number</code> 和 <code>boolean</code></h3><p>JavaScript 有三种很常用的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">原始类型</a>：<code>string</code>、<code>number</code> 和 <code>boolean</code>。每一种类型在 TypeScript 中都有相对应的类型。正如你所料，它们的名字就和使用 JavaScript 的 <code>typeof</code> 运算符得到的字符串一样：</p><ul><li><code>string</code> 表示类似 <code>&quot;Hello, world!&quot;</code> 这样的字符串值</li><li><code>number</code> 表示类似 <code>42</code> 这样的数值。对于整数，JavaScript 没有特殊的运行时值，所以也就没有 <code>int</code> 或者 <code>float</code> 类型 —— 所有的数字都是 <code>number</code> 类型</li><li><code>boolean</code> 表示布尔值 <code>true</code> 和 <code>false</code></li></ul><blockquote><p>类型名 <code>String</code>、<code>Number</code> 和 <code>Boolean</code>（大写字母开头）也是合法的，但它们指的是在代码中很少出现的内建类型。请始终使用 <code>string</code>、<code>number</code> 和 <code>boolean</code></p></blockquote><h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3><p>为了表示类似 <code>[1,2,3]</code> 这样的数组类型，你可以使用语法 <code>number[]</code>。这种语法也可以用于任意类型（比如 <code>string[]</code> 表示数组元素都是字符串类型）。它还有另一种写法是 <code>Array&lt;number&gt;</code>，两者效果是一样的。在后续讲解泛型的时候，我们会再详细介绍 <code>T&lt;U&gt;</code> 语法。</p><blockquote><p>注意 <code>[number]</code>和普通数组不同，它表示的是<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types">元组</a></p></blockquote><h3 id="any"><a class="markdownIt-Anchor" href="#any"></a> <code>any</code></h3><p>TypeScript 还有一种特殊的 <code>any</code> 类型。当你不想要让某个值引起类型检查错误的时候，可以使用 <code>any</code>。</p><p>当某个值是 <code>any</code> 类型的时候，你可以访问它的任意属性（这些属性也会是 <code>any</code> 类型），可以将它作为函数调用，可以将它赋值给任意类型的值（或者把任意类型的值赋值给它），或者是任何语法上合规的操作：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let obj: any &#x3D; &#123; x: 0 &#125;;
&#x2F;&#x2F; 下面所有代码都不会引起编译错误。使用 any 将会忽略类型检查，并且假定了
&#x2F;&#x2F; 你比 TypeScript 更了解当前环境
obj.foo();
obj();
obj.bar &#x3D; 100;
obj &#x3D; &quot;hello&quot;;
const n: number &#x3D; obj;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你不想要写一长串类型让 TypeScript 确信某行代码没问题的时候，<code>any</code> 类型很管用。</p><h4 id="noimplicitany"><a class="markdownIt-Anchor" href="#noimplicitany"></a> <code>noImplicitAny</code></h4><p>当你没有显式指定一个类型，同时 TypeScript 也无法从上下文中进行类型推断的时候，编译器会默认将其作为 <code>any</code> 类型处理。</p><p>不过，通常你会避免这种情况的发生，因为 <code>any</code> 是会绕过类型检查的。启用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#noImplicitAny">noImplicitAny</a> 配置项可以将任意隐式推断得到的 <code>any</code> 标记为一个错误。</p><h3 id="变量的类型注解"><a class="markdownIt-Anchor" href="#变量的类型注解"></a> 变量的类型注解</h3><p>当你使用 <code>const</code>、<code>var</code> 或者 <code>let</code> 声明变量的时候，你可以选择性地添加一个类型注解以显式指定变量的类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let myName: string &#x3D; &#39;Alice&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>TypeScript 没有采用类似 <code>int x = 0</code> 这样“在表达式左边声明类型”的风格。类型注解总是跟在要声明类型的东西后面。</p></blockquote><p>不过，在大多数情况下，注解并不是必需的。TypeScript 会尽可能地在你的代码中自动进行类型推断。举个例子，变量的类型是基于它的初始值推断出来的：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 不需要添加类型注解 —— myName 会被自动推断为 string 类型
let myName &#x3D; &#39;Alice&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>多数情况下，你不需要刻意去学习类型推断的规则。如果你还是初学者，请尝试尽可能少地使用类型注解 —— 你可能会惊讶地发现，TypeScript 完全理解所发生的事情所需要的注解是如此之少。</p><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><p>函数是 JavaScript 中传递数据的主要方式。TypeScript 允许你指定函数的输入和输出的类型。</p><h4 id="参数类型注解"><a class="markdownIt-Anchor" href="#参数类型注解"></a> 参数类型注解</h4><p>当你声明一个函数的时候，你可以在每个参数后面添加类型注解，从而声明函数可以接受什么类型的参数。参数的类型注解跟在每个参数名字的后面：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 参数类型注解
function greet(name: string)&#123;
    console.log(&#39;Hello, &#39; + name.toUpperCase() + &#39;!!&#39;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当函数的某个参数有类型注解的时候，TypeScript 会对传递给函数的实参进行类型检查：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 如果执行，会有一个运行时错误！
greet(42);
&#x2F;&#x2F; Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>即使没有给参数添加类型注解，TypeScript 也会检查你传递的参数的个数是否正确</p></blockquote><h4 id="返回值类型注解"><a class="markdownIt-Anchor" href="#返回值类型注解"></a> 返回值类型注解</h4><p>你也可以给返回值添加类型注解。返回值类型注解出现在参数列表后面：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function getFavourNumber(): number &#123;
    return 26;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>和变量的类型注解一样，通常情况下我们不需要给返回值添加一个类型注解，因为 TypeScript 会基于 <code>return</code> 语句推断出函数返回值的类型。上述例子中的类型注解不会改变任何事情。一些代码库会显式指定返回值的类型，这可能是出于文档编写的需要，或者是为了防止意外的修改，或者只是个人喜好。</p><h4 id="匿名函数"><a class="markdownIt-Anchor" href="#匿名函数"></a> 匿名函数</h4><p>匿名函数和函数声明有点不同。当一个函数出现在某个地方，且 TypeScript 可以推断它是如何被调用的时候，该函数的参数会被自动分配类型。</p><p>比如：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 这里没有类型注解，但 TypeScript 仍能在后续代码找出 bug
const names &#x3D; [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;];
 
&#x2F;&#x2F; 基于上下文推断匿名函数参数的类型
names.forEach(function (s) &#123;
  console.log(s.toUppercase());
  			   ^^^^^^^^^^^^  
&#x2F;&#x2F; Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?
&#125;);
 
&#x2F;&#x2F; 对于箭头函数，也可以正确推断
names.forEach((s) &#x3D;&gt; &#123;
  console.log(s.toUppercase());
    		   ^^^^^^^^^^^^^
&#x2F;&#x2F;Property &#39;toUppercase&#39; does not exist on type &#39;string&#39;. Did you mean &#39;toUpperCase&#39;?
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即使这里没有给参数 <code>s</code> 添加类型注解，TypeScript 也可以基于 <code>forEach</code> 函数的类型，以及对于 <code>name</code> 数组类型的推断，来决定 <code>s</code> 的类型。</p><p>这个过程叫做<strong>上下文类型推断</strong>，因为函数调用时所处的上下文决定了它的参数的类型。</p><p>和推断规则类似，你不需要刻意学习这个过程是怎么发生的，但明确这个过程确实会发生之后，你自然就清楚什么时候不需要添加类型注解了。稍后我们会看到更多的例子，了解到一个值所处的上下文是如何影响它的类型的。</p><h3 id="对象类型"><a class="markdownIt-Anchor" href="#对象类型"></a> 对象类型</h3><p>除了原始类型之外，最常见的类型就是对象类型了。它指的是任意包含属性的 JavaScript 值。要定义一个对象类型，只需要简单地列举它的属性和类型即可。</p><p>举个例子，下面是一个接受对象类型作为参数的函数：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 参数的类型注解是一个对象类型
function printCoord(pt: &#123; x: number; y: number &#125;) &#123;
  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);
  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);
&#125;
printCoord(&#123; x: 3, y: 7 &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我们为参数添加的类型注解是一个包含 <code>x</code> 和 <code>y</code> 两个属性（类型都是 <code>number</code>）的对象。你可以使用 <code>,</code> 或者 <code>;</code> 分隔每个属性，最后一个属性的分隔符可加可不加。</p><p>每个属性的类型部分同样也是可选的，如果你没有指定类型，那么它会采用 <code>any</code> 类型。</p><h4 id="可选属性"><a class="markdownIt-Anchor" href="#可选属性"></a> 可选属性</h4><p>对象类型也可以指定某些或者全部属性是可选的。你只需要在对应的属性名后面添加一个 <code>?</code> 即可：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printName(obj: &#123; first: string; last?: string &#125;) &#123;
  &#x2F;&#x2F; ...
&#125;
&#x2F;&#x2F; 下面两种写法都行
printName(&#123; first: &quot;Bob&quot; &#125;);
printName(&#123; first: &quot;Alice&quot;, last: &quot;Alisson&quot; &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 JavaScript 中，如果你访问了一个不存在的属性，你将会得到 <code>undefined</code> 而不是一个运行时错误。因此，在你读取一个可选属性的时候，你需要在使用它之前检查它是否为 <code>undefined</code>。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printName(obj: &#123; first: string; last?: string &#125;) &#123;
  &#x2F;&#x2F; 如果 obj.last 没有对应的值，可能会报错！
  console.log(obj.last.toUpperCase());
&#x2F;&#x2F; Object is possibly &#39;undefined&#39;.
  if (obj.last !&#x3D;&#x3D; undefined) &#123;
    &#x2F;&#x2F; OK
    console.log(obj.last.toUpperCase());
  &#125;
 
  &#x2F;&#x2F; 下面是使用现代 JavaScript 语法的另一种安全写法：
  console.log(obj.last?.toUpperCase());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="联合类型"><a class="markdownIt-Anchor" href="#联合类型"></a> 联合类型</h3><p>TypeScript 的类型系统允许你基于既有的类型使用大量的运算符创建新的类型。既然我们已经知道了如何编写基本的类型，是时候开始用一种有趣的方式将它们结合起来了。</p><h4 id="定义一个联合类型"><a class="markdownIt-Anchor" href="#定义一个联合类型"></a> 定义一个联合类型</h4><p>第一种结合类型的方式就是使用联合类型。联合类型由两个或者两个以上的类型组成，它代表的是可以取这些类型中任意一种类型的值。每一种类型称为联合类型的成员。</p><p>我们来编写一个可以处理字符串或者数字的函数：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printId(id: number | string) &#123;
  console.log(&quot;Your ID is: &quot; + id);
&#125;
&#x2F;&#x2F; OK
printId(101);
&#x2F;&#x2F; OK
printId(&quot;202&quot;);
&#x2F;&#x2F; 报错
printId(&#123; myID: 22342 &#125;);
&#x2F;&#x2F; Argument of type &#39;&#123; myID: number; &#125;&#39; is not assignable to parameter of type &#39;string | number&#39;.
&#x2F;&#x2F;  Type &#39;&#123; myID: number; &#125;&#39; is not assignable to type &#39;number&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用联合类型"><a class="markdownIt-Anchor" href="#使用联合类型"></a> 使用联合类型</h4><p>提供一个匹配联合类型的值非常简单 —— 只需要提供一个与联合类型某个成员相匹配的类型即可。如果有一个值是联合类型，你要怎么使用它呢？</p><p>TypeScript 会限制你对联合类型可以采取的操作，仅当该操作对于联合类型的每个成员都生效的时候，操作才会生效。举个例子，如果你有联合类型 <code>string | number</code>，那么你将无法使用只能由 <code>string</code> 调用的方法：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printId(id: number | string) &#123;
  console.log(id.toUpperCase());
&#x2F;&#x2F; Property &#39;toUpperCase&#39; does not exist on type &#39;string | number&#39;.
&#x2F;&#x2F;  Property &#39;toUpperCase&#39; does not exist on type &#39;number&#39;.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方案就是在代码中去收窄联合类型，这和没有使用类型注解的 JavaScript 的做法一样。当 TypeScript 能够基于代码结构推断出一个更具体的类型时，就会发生收窄。</p><p>举个例子，TypeScript 知道只有 <code>string</code> 类型的值使用 <code>typeof</code> 之后会返回 <code>&quot;string&quot;</code>：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printId(id: number | string) &#123;
  if (typeof id &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;
    &#x2F;&#x2F; 在这个分支中，id 的类型是 string
    console.log(id.toUpperCase());
  &#125; else &#123;
    &#x2F;&#x2F; 这里，id 的类型是 number
    console.log(id);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个例子是使用类似 <code>Array.isArray</code> 这样的函数：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function welcomePeople(x: string[] | string) &#123;
  if (Array.isArray(x)) &#123;
    &#x2F;&#x2F; 这里，x 是 string[]
    console.log(&quot;Hello, &quot; + x.join(&quot; and &quot;));
  &#125; else &#123;
    &#x2F;&#x2F; 这里，x 是 string
    console.log(&quot;Welcome lone traveler &quot; + x);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，在 <code>else</code> 分支中，我们不需要做额外的判断 —— 如果 <code>x</code> 不是 <code>string[]</code>，那它就一定是 <code>string</code>。</p><p>有时候，联合类型的所有成员可能存在共性。举个例子，数组和字符串都有 <code>slice</code> 方法。如果一个联合类型的每个成员都有一个公共的属性，那么你可以不需要进行收窄，直接使用该属性：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 返回值会被推断为 number[] | string
function getFirstThree(x: number[] | string) &#123;
  return x.slice(0, 3);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>联合类型的各个类型的属性存在交集，你可能会觉得有点困惑。实际上这并不让人意外，“联合”这个名词来自于类型理论。联合类型 <code>number | string</code> 是由每个类型的值的联合组成的。假设给定两个集合以及各自对应的事实，那么只有事实的交集可以应用于集合的交集本身。举个例子，有一个屋子的人都很高，而且戴帽子，另一个屋子的人都是西班牙人，而且也戴帽子，那么两个屋子的人放到一起，我们可以得到的唯一事实就是：每个人肯定都戴着帽子。</p></blockquote><h3 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h3><p>目前为止，我们都是在类型注解中直接使用对象类型或者联合类型的。这很方便，但通常情况下，我们更希望通过一个单独的名字多次引用某个类型。</p><p>类型别名就是用来做这个的 —— 它可以作为指代任意一种类型的名字。类型别名的语法如下：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type Point &#x3D; &#123;
  x: number;
  y: number;
&#125;;
 
&#x2F;&#x2F; 效果和之前的例子完全一样
function printCoord(pt: Point) &#123;
  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);
  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);
&#125;
 
printCoord(&#123; x: 100, y: 100 &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不止是对象类型，你可以给任意一种类型使用类型别名。举个例子，你可以命名联合类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type ID &#x3D; number | string;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，别名就只是别名而已 —— 你不能使用类型别名去创建同一类型的不同“版本”。当你使用别名的时候，效果就和你直接编写实际的类型一样。换句话说，代码看起来是不合法的，但在 TypeScript 里这是没问题的，不管是别名还是实际类型，都指向同一个类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">type UserInputSanitizedString &#x3D; string;
 
function sanitizeInput(str: string): UserInputSanitizedString &#123;
  return sanitize(str);
&#125;
 
&#x2F;&#x2F; 创建一个输入
let userInput &#x3D; sanitizeInput(getInput());
 
&#x2F;&#x2F; 可以重新给它赋值一个字符串
userInput &#x3D; &quot;new input&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><p>接口声明是另一种命名对象类型的方式：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Point &#123;
  x: number;
  y: number;
&#125;
 
function printCoord(pt: Point) &#123;
  console.log(&quot;The coordinate&#39;s x value is &quot; + pt.x);
  console.log(&quot;The coordinate&#39;s y value is &quot; + pt.y);
&#125;
 
printCoord(&#123; x: 100, y: 100 &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就和上面使用类型别名一样，这个例子也可以正常运行，它的效果和直接使用一个匿名对象类型一样。TypeScript 只关心我们传递给 <code>printCoord</code> 的值的结构 —— 它只关心这个值是否有期望的属性。正是因为这种只关注类型的结构和能力的特点，所以我们说 TypeScript 是一个结构性的、类型性的类型系统。</p><h4 id="类型别名和接口的区别"><a class="markdownIt-Anchor" href="#类型别名和接口的区别"></a> 类型别名和接口的区别</h4><p>类型别名和接口很相似，多数情况下你可以任意选择其中一个去使用。接口的所有特性几乎都可以在类型别名中使用。两者关键的区别在于类型别名无法再次“打开”并添加新的属性，而接口总是可以拓展的。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 接口可以自由拓展
interface Animal &#123;
  name: string
&#125;

interface Bear extends Animal &#123;
  honey: boolean
&#125;

const bear &#x3D; getBear() 
bear.name
bear.honey

&#x2F;&#x2F; 类型别名需要通过交集进行拓展
type Animal &#x3D; &#123;
  name: string
&#125;

type Bear &#x3D; Animal &amp; &#123; 
  honey: boolean 
&#125;

const bear &#x3D; getBear();
bear.name;
bear.honey;

&#x2F;&#x2F; 向既有的接口添加新的属性
interface Window &#123;
  title: string
&#125;

interface Window &#123;
  ts: TypeScriptAPI
&#125;

const src &#x3D; &#39;const a &#x3D; &quot;Hello World&quot;&#39;;
window.ts.transpileModule(src, &#123;&#125;);

&#x2F;&#x2F; 类型别名一旦创建，就不能再修改了
type Window &#x3D; &#123;
  title: string
&#125;

type Window &#x3D; &#123;
  ts: TypeScriptAPI
&#125;

 &#x2F;&#x2F; Error: Duplicate identifier &#39;Window&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在稍后的章节中，你会学到更多关于这方面的知识，所以现在还不太理解也没关系。</p><ul><li>在 TypeScript 4.2 版本之前，类型别名的名字可能会出现在报错信息中，有时会代替等效的匿名类型（可能需要，也可能不需要）。而接口的名字则始终出现在报错信息中</li><li>类型别名无法进行<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play?#code/PTAEEEDtQS0gXApgJwGYEMDGjSfdAIx2UQFoB7AB0UkQBMAoEUfO0Wgd1ADd0AbAK6IAzizp16ALgYM4SNFhwBZdAFtV-UAG8GoPaADmNAcMmhh8ZHAMMAvjLkoM2UCvWad+0ARL0A-GYWVpA29gyY5JAWLJAwGnxmbvGgALzauvpGkCZmAEQAjABMAMwALLkANBl6zABi6DB8okR4Jjg+iPSgABboovDk3jjo5pbW1d6+dGb5djLwAJ7UoABKiJTwjThpnpnGpqPBoTLMAJrkArj4kOTwYmycPOhW6AR8IrDQ8N04wmo4HHQCwYi2Waw2W1S6S8HX8gTGITsQA">声明合并，但接口可以</a></li><li>接口只能用于<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA">声明对象的形状，无法为原始类型命名</a></li><li>在报错信息中，接口的名字将始终以原始形式出现，但只限于它们作为名字被使用的时候</li></ul><p>大多数情况下，你可以根据个人喜好选择其中一种使用，TypeScript 也会告诉你它是否需要使用另一种声明方式。如果你喜欢启发式，那你可以使用接口，等到需要使用其他特性的时候，再使用类型别名。</p><h3 id="类型断言"><a class="markdownIt-Anchor" href="#类型断言"></a> 类型断言</h3><p>有时候，你会比 TypeScript 更了解某个值的类型。</p><p>举个例子，如果你使用 <code>document.getElementById</code>，那么 TypeScript 只知道这个调用会返回某个 <code>HTMLElement</code>，但你却知道你的页面始终存在一个给定 ID 的 <code>HTMLCanvasElement</code>。</p><p>在这种情况下，你可以使用类型断言去指定一个更具体的类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const myCanvas &#x3D; document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就像类型注解一样，编译器最终会移除类型断言，保证它不会影响到代码的运行时行为。</p><p>你也可以使用等效的尖括号语法（前提是代码不是在一个 <code>.tsx</code> 文件中）：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const myCanvas &#x3D; &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>记住：因为编译期间会移除类型断言，所以不存在和类型断言相关的运行时检查。即使类型断言是错误的，也不会抛出异常或者产生 <code>null</code></p></blockquote><p>TypeScript 只允许断言之后的类型比之前的类型更具体或者更不具体。这个规则可以防止出现下面这样“不可能存在的”强制类型转换：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const x &#x3D; &quot;hello&quot; as number;
&#x2F;&#x2F; 类型 &quot;string&quot; 到类型 &quot;number&quot; 的转换可能是错误的，因为两种类型不能充分重叠。如果这是有意的，请先将表达式转换为 &quot;unknown&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有时候，这个规则可能过于保守了，会阻碍我们进行更复杂的有效转换操作。如果是这样，那么可以使用两步断言，先断言为 <code>any</code>（或者 <code>unknown</code>，稍后再介绍），再断言为期望的类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const a &#x3D; (expr as any) as T;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="字面量类型"><a class="markdownIt-Anchor" href="#字面量类型"></a> 字面量类型</h3><p>除了通用的 <code>string</code> 和 <code>number</code> 类型之外，我们也可以将具体的字符串或者数字看作一种类型。</p><p>怎么理解呢？其实我们只需要考虑 JavaScript 声明变量的不同方式即可。<code>var</code> 和 <code>let</code> 声明的变量都可以修改，但 <code>const</code> 不行。这种特点反映在 TypeScript 是如何为字面量创建类型的。</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let changingString &#x3D; &quot;Hello World&quot;;
changingString &#x3D; &quot;Olá Mundo&quot;;
&#x2F;&#x2F; 因为 changingString 可以表示任意可能的字符串，这是 TypeScript 
&#x2F;&#x2F; 在类型系统中描述它的方式
changingString;
^^^^^^^^^^^^^^
    &#x2F;&#x2F; let changingString: string
      
let changingString: string
 
const constantString &#x3D; &quot;Hello World&quot;;
&#x2F;&#x2F; 因为 constantString 只能表示一种可能的字符串，所以它有一个
&#x2F;&#x2F; 字面量类型的表示形式
constantString;
^^^^^^^^^^^^^^^
    &#x2F;&#x2F; const constantString: &quot;Hello World&quot;
      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只是单独使用的话，字面量类型的用处并不大：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">let x: &quot;hello&quot; &#x3D; &quot;hello&quot;;
&#x2F;&#x2F; OK
x &#x3D; &quot;hello&quot;;
&#x2F;&#x2F; ...
x &#x3D; &quot;howdy&quot;;
&#x2F;&#x2F; Type &#39;&quot;howdy&quot;&#39; is not assignable to type &#39;&quot;hello&quot;&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子中，变量只有一个可能的值，这是没有意义的！</p><p>但是通过将字面量类型结合为联合类型，你可以表示一个更有实用价值的概念 —— 举个例子，声明一个只接受某些固定值的函数：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function printText(s: string, alignment: &quot;left&quot; | &quot;right&quot; | &quot;center&quot;) &#123;
  &#x2F;&#x2F; ...
&#125;
printText(&quot;Hello, world&quot;, &quot;left&quot;);
printText(&quot;G&#39;day, mate&quot;, &quot;centre&quot;);
						^^^^^^		
&#x2F;&#x2F; Argument of type &#39;&quot;centre&quot;&#39; is not assignable to parameter of type &#39;&quot;left&quot; | &quot;right&quot; | &quot;center&quot;&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数值型字面量类型也同理：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function compare(a: string, b: string): -1 | 0 | 1 &#123;
  return a &#x3D;&#x3D;&#x3D; b ? 0 : a &gt; b ? 1 : -1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，联合类型中也可以包含非字面量类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">interface Options &#123;
  width: number;
&#125;
function configure(x: Options | &quot;auto&quot;) &#123;
  &#x2F;&#x2F; ...
&#125;
configure(&#123; width: 100 &#125;);
configure(&quot;auto&quot;);
configure(&quot;automatic&quot;);
		  ^^^^^^^^^^	
&#x2F;&#x2F; Argument of type &#39;&quot;automatic&quot;&#39; is not assignable to parameter of type &#39;Options | &quot;auto&quot;&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一种字面量类型：布尔值字面量。只有两种布尔值字面量类型，也就是 <code>true</code> 和 <code>false</code>。<code>boolean</code> 类型本身其实就是联合类型 <code>true | false</code> 的一个别名。</p><h4 id="字面量推断"><a class="markdownIt-Anchor" href="#字面量推断"></a> 字面量推断</h4><p>当你初始化一个变量为某个对象的时候，TypeScript 会假定该对象的属性稍后可能会发生变化。比如下面的代码：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const obj &#x3D; &#123; counter: 0 &#125;;
if (someCondition) &#123;
  obj.counter &#x3D; 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>TypeScript 不觉得将之前值为 0 的属性赋值为 1 是一个错误。另一种理解角度是，<code>obj.counter</code> 必须是 <code>number</code> 类型，而不是 0，因为类型可以用来决定读写行为。</p><p>对于字符串也同理：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125;;
handleRequest(req.url, req.method);
&#x2F;&#x2F; Argument of type &#39;string&#39; is not assignable to parameter of type &#39;&quot;GET&quot; | &quot;POST&quot;&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(译者注：这里的 <code>handleRequest</code> 签名为 <code>(url: string, method: &quot;GET&quot; | &quot;POST&quot;) =&gt; void</code>)</p><p>在上面的例子中，<code>req.method</code> 被推断为 <code>string</code>，而不是 <code>&quot;GET&quot;</code>。因为在创建 <code>req</code> 和调用 <code>handleRequest</code> 之间可能会执行其它代码，<code>req.method</code> 也许会被赋值为类似 <code>&quot;GUESS&quot;</code> 这样的字符串，因此 TypeScript 会认为这样的代码是存在错误的。</p><p>有两种方式可以解决这个问题：</p><ol><li><p>通过添加类型断言改变类型的推断结果：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 方法一：
const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; as &quot;GET&quot; &#125;;
&#x2F;&#x2F; 方法二：
handleRequest(req.url, req.method as &quot;GET&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>方法一表示“我有意让 <code>req.method</code> 一直采用字面量类型 <code>&quot;GET&quot;</code>”，从而阻止后续将其赋值为其它字符串；方法二表示“出于某种理由，我确信 <code>req.method</code> 的值一定是<code>“GET”</code>”。</p></li><li><p>你还可以使用 <code>as const</code> 将整个对象转化为字面量类型：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const req &#x3D; &#123; url: &quot;https:&#x2F;&#x2F;example.com&quot;, method: &quot;GET&quot; &#125; as const;
handleRequest(req.url, req.method);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>as const</code> 后缀和 <code>const</code> 的效果很像，但用于类型系统中。它可以确保对象的所有属性都被赋予了一个字面量类型，而不是采用类似 <code>string</code> 或者 <code>number</code> 这样较为通用的类型。</p></li></ol><h3 id="null-和-undefined"><a class="markdownIt-Anchor" href="#null-和-undefined"></a> <code>null</code> 和 <code>undefined</code></h3><p>JavaScript 中有两个原始值用于表示缺少的或者没有初始化的值：<code>null</code> 和 <code>undefined</code>。</p><p>TypeScript 对应地也有两个名字和它们一样的类型。它们的行为取决于你是否启用了 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictNullChecks">strictNullChecks</a> 选项。</p><h4 id="禁用-strictnullchecks"><a class="markdownIt-Anchor" href="#禁用-strictnullchecks"></a> 禁用 <code>strictNullChecks</code></h4><p>禁用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictNullChecks">strictNullChecks</a> 选项之后，你仍然可以正常访问可能为 <code>null</code> 和 <code>undefined</code> 的值，这两个值也可以被赋值给任何一种类型。这种行为表现和缺少空值检查的语言（比如 C#、Java）很像。缺少对这些值的检查可能是大量 bug 的来源，在可行的前提下，我们推荐开发者始终启用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictNullChecks">strictNullChecks</a> 选项。</p><h4 id="启用-strictnullchecks"><a class="markdownIt-Anchor" href="#启用-strictnullchecks"></a> 启用 <code>strictNullChecks</code></h4><p>启用 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#strictNullChecks">strictNullChecks</a> 选项之后，当一个值是 <code>null</code> 或者 <code>undefined</code> 的时候，你需要在使用该值的方法或者属性之前首先对其进行检查。就和使用可选属性之前先检查它是否为 <code>undefined</code> 一样，我们可以使用类型收窄去检查某个值是否可能为 <code>null</code>：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function doSomething(x: string | null) &#123;
  if (x &#x3D;&#x3D;&#x3D; null) &#123;
    &#x2F;&#x2F; do nothing
  &#125; else &#123;
    console.log(&quot;Hello, &quot; + x.toUpperCase());
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="非空值断言操作符-后缀"><a class="markdownIt-Anchor" href="#非空值断言操作符-后缀"></a> 非空值断言操作符（<code>!</code> 后缀）</h4><p>TypeScript 也提供了一种特殊的语法，可以在不显式进行检查的情况下，将 <code>null</code> 和 <code>undefined</code> 从类型中排除。在任意表达式后面添加后缀 <code>!</code>，可以有效地断言某个值不可能为 <code>null</code> 或者 <code>undefined</code>：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">function liveDangerously(x?: number | null) &#123;
  &#x2F;&#x2F; 不会报错
  console.log(x!.toFixed());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>和其它的类型断言一样，非空值断言也不会改变代码的运行时行为，所以切记：仅在你确定某个值不可能为 <code>null</code> 或者 <code>undefined</code> 的时候，才去使用 <code>!</code>。</p><h3 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h3><p>枚举是 TypeScript 添加到 JavaScript 中的一项特性。它允许描述一个值，该值可以是一组可能的命名常量中的一个。与大多数的 TypeScript 特性不同，枚举不是在类型层面添加到 JavaScript 中的，而是添加到语言本身和它的运行时中。正因如此，你应该了解这个特性的存在，但除非你确定，否则你可能需要推迟使用它。你可以在<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/enums.html">枚举引用页面</a>中了解到有关枚举的更多信息。</p><h3 id="其它不常见的原始类型"><a class="markdownIt-Anchor" href="#其它不常见的原始类型"></a> 其它不常见的原始类型</h3><p>值得一提的是，JavaScript 的其它原始类型在类型系统中也有对应的表示形式。不过在这里我们不会深入进行探讨。</p><h4 id="bigint"><a class="markdownIt-Anchor" href="#bigint"></a> BigInt</h4><p>ES2020 引入了 <code>BigInt</code>，用于表示 JavaScript 中非常大的整数：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">&#x2F;&#x2F; 通过 BigInt 函数创建大整数
const oneHundred: bigint &#x3D; BigInt(100);
 
&#x2F;&#x2F; 通过字面量语法创建大整数
const anotherHundred: bigint &#x3D; 100n;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以在 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint">TypeScript 3.2 发布日志</a> 中了解到关于 BigInt 的更多信息。</p><h4 id="symbol"><a class="markdownIt-Anchor" href="#symbol"></a> symbol</h4><p>在 JavaScript 中，我们可以通过函数 <code>Symbol()</code> 创建一个全局唯一的引用：</p><pre class="line-numbers language-ts" data-language="ts"><code class="language-ts">const firstName &#x3D; Symbol(&quot;name&quot;);
const secondName &#x3D; Symbol(&quot;name&quot;);
 
if (firstName &#x3D;&#x3D;&#x3D; secondName) &#123;
&#x2F;&#x2F; 此条件将始终返回 &quot;false&quot;，因为类型 &quot;typeof firstName&quot; 和 &quot;typeof secondName&quot; 没有重叠。    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以在 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/symbols.html">Symbol 引用页面</a> 了解到更多相关信息。</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2021/11/19/F-TypeScript%20%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92%E3%80%90%E4%B8%89%E3%80%91%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%94%B6%E7%BC%A9/" rel="prev" title="TypeScript 官方手册翻译计划【三】：类型收缩"><i class="fa fa-angle-double-left"></i>&nbspTypeScript 官方手册翻译计划【三】：类型收缩</a></div><div class="post-nav-next"><a href="/2021/11/17/F-TypeScript%20%E5%AE%98%E6%96%B9%E6%89%8B%E5%86%8C%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92%E3%80%90%E4%B8%80%E3%80%91%EF%BC%9A%E5%9F%BA%E7%A1%80/" rel="next" title="TypeScript 官方手册翻译计划【一】：基础">TypeScript 官方手册翻译计划【一】：基础&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E5%9E%8B"><span class="toc-text">普通类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8Bstring-number-%E5%92%8C-boolean"><span class="toc-text">原始类型：string、number 和 boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#any"><span class="toc-text">any</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#noimplicitany"><span class="toc-text">noImplicitAny</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-text">变量的类型注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-text">参数类型注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-text">返回值类型注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">匿名函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text">对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-text">可选属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">联合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">定义一个联合类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">使用联合类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">类型别名和接口的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">字面量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E6%8E%A8%E6%96%AD"><span class="toc-text">字面量推断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E5%92%8C-undefined"><span class="toc-text">null 和 undefined</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E7%94%A8-strictnullchecks"><span class="toc-text">禁用 strictNullChecks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E7%94%A8-strictnullchecks"><span class="toc-text">启用 strictNullChecks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E5%80%BC%E6%96%AD%E8%A8%80%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%90%8E%E7%BC%80"><span class="toc-text">非空值断言操作符（! 后缀）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E4%B8%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-text">其它不常见的原始类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bigint"><span class="toc-text">BigInt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symbol"><span class="toc-text">symbol</span></a></li></ol></li></ol></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>function send_valine_Server(){var e="desp=",t=document.title,n=t.indexOf("|"),a=(t.substring(0,n),document.URL),s=new Date,l=document.getElementsByClassName("vnick vinput")[0].value||"Anonymous",i=(document.getElementsByClassName("vmail vinput")[0].value,document.getElementsByClassName("vlink vinput")[0].value,document.getElementsByClassName("veditor vinput")[0].value),o=e+"文章："+a+"\n\n昵称："+l+"\n\n留言："+i+"\n\n时间："+s.toLocaleString(),v=new XMLHttpRequest;v.open("POST","https://sc.ftqq.com/"+SCKEY_Server+".send",!0),v.setRequestHeader("Content-type","application/x-www-form-urlencoded"),v.send(title1+"&"+o)}new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0});var title1="text=你的博客有新的评论",SCKEY_Server="SCT99005TwWJDrDKdBwQGK0YmcPRAsr4B",ValineButton=document.getElementsByClassName("vsubmit vbtn")[0];ValineButton.onclick=send_valine_Server</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/prism.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:150,height:300,vOffset:-120,hOffset:-5},mobile:{show:!1},react:{opacityDefault:1e3,opacityOnHover:1e3},log:!1})</script></body></html><!-- rebuild by neat -->