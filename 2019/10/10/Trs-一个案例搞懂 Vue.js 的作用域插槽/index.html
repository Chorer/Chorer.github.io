<!-- build time:Tue Oct 22 2019 13:45:56 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Chor&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third party/pace-theme-flash.css"><link rel="icon" href="/images/me.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"></head><body><header class="header"><div class="header_top"><span class="theme"><i class="fa fa-bars"></i> <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">HOME</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">CATEGORIES</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">ARCHIVES</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">TAGS</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">ABOUT</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a href="/" class="logo">Chor&#39;s Blog</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">「译」一个案例搞懂 Vue.js 的作用域插槽</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-10-10&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp9 mins&nbsp&nbsp&nbsp</span><div class="post-tags"></div></div><div class="post-content"><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/一个案例搞懂%20Vue.js%20的作用域插槽-1.webp" alt=""><br><a id="more"></a></p><blockquote><ul><li>原文地址：<a href="https://vuejsdevelopers.com/2017/10/02/vue-js-scoped-slots/" target="_blank" rel="noopener">Getting Your Head Around Vue.js Scoped Slots</a></li><li>原文作者：Anthony Gore</li><li>译者：Chor</li></ul></blockquote><p>作用域插槽是 Vue.js 中一个很有用的特性，可以显著提高组件的通用性和可复用性。问题在于，它实在不太好理解。尝试搞清楚父子作用域之间错综复杂的关系，其痛苦程度不亚于求解一个棘手的数学方程。</p><p>当你无法理解一个东西的时候，最好的办法就是在解决问题的过程中体会它的应用。本文将向你展示如何使用作用域插槽构建一个可复用的列表组件。</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/一个案例搞懂%20Vue.js%20的作用域插槽-2.png" alt=""></p><blockquote><p>注意: 完整代码可以去 <a href="https://codepen.io/anthonygore/pen/zExPZX" target="_blank" rel="noopener">Codepen</a> 查看</p></blockquote><h2 id="最基础的组件"><a href="#最基础的组件" class="headerlink" title="最基础的组件"></a>最基础的组件</h2><p>我们即将构建的组件叫做 <code>my-list</code> ，用来展示一系列的项目。它的特别之处就在于，你可以在每次使用组件的时候自定义列表项目的渲染方式。</p><p>我们先从最简单的单个列表开始：一个包含几何图形名字和边数的数组。</p><p><em>app.js</em></p><pre><code class="js">Vue.component(&#39;my-list&#39;, {
  template: &#39;#my-list&#39;,
  data() {
    return {
      title: &#39;Shapes&#39;,
      shapes: [ 
        { name: &#39;Square&#39;, sides: 4 }, 
        { name: &#39;Hexagon&#39;, sides: 6 }, 
        { name: &#39;Triangle&#39;, sides: 3 }
      ]
    };
  }
});

new Vue({
  el: &#39;#app&#39;
});
</code></pre><p><em>index.html</em></p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;
  &lt;my-list&gt;&lt;/my-list&gt;
&lt;/div&gt;

&lt;script type=&quot;text/x-template&quot; id=&quot;my-list&quot;&gt;
  &lt;div class=&quot;my-list&quot;&gt;
    &lt;div class=&quot;title&quot;&gt;{{ title }}&lt;/div&gt;
    &lt;div class=&quot;list&quot;&gt;
      &lt;div class=&quot;list-item&quot; v-for=&quot;shape in shapes&quot;&gt;
        &lt;div&gt;{{ shape.name }} &lt;small&gt;({{ shape.sides }} sides)&lt;/small&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;
</code></pre><p>在加上一点样式，大概就会是下图这个样子：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/一个案例搞懂%20Vue.js%20的作用域插槽-3.png" alt=""></p><h2 id="更通用的-my-list"><a href="#更通用的-my-list" class="headerlink" title="更通用的 my-list"></a>更通用的 <code>my-list</code></h2><p>现在我们想要让 <code>my-list</code> 更加通用，可以渲染任何类型的列表。这次我们展示的是一堆颜色的名字以及对应的颜色方块。</p><p>为此，我们需要将上例列表独有的数据进行抽象化。由于列表中的项目可能有不同的结构，我们将会给 <code>my-list</code> 一个插槽，让父组件来定义列表的展示方式。</p><p><em>app.js</em></p><pre><code class="js">Vue.component(&#39;my-list&#39;, {
  template: &#39;#my-list&#39;,
  props: [ &#39;title&#39; ]
});
</code></pre><p><em>index.html</em></p><pre><code class="html">&lt;script type=&quot;text/x-template&quot; id=&quot;my-list&quot;&gt;
  &lt;div class=&quot;my-list&quot;&gt;
    &lt;div class=&quot;title&quot;&gt;{{ title }}&lt;/div&gt;
    &lt;div class=&quot;list&quot;&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;
</code></pre><p>现在，我们在根实例中创建 <code>my-list</code> 组件的两个实例，分别展示两个测试用例列表：lists:</p><p><em>app.js</em></p><pre><code class="js">new Vue({
  el: &#39;#app&#39;,
  data: {
    shapes: [ 
      { name: &#39;Square&#39;, sides: 4 }, 
      { name: &#39;Hexagon&#39;, sides: 6 }, 
      { name: &#39;Triangle&#39;, sides: 3 }
    ],
    colors: [
      { name: &#39;Yellow&#39;, hex: &#39;#F4D03F&#39;, },
      { name: &#39;Green&#39;, hex: &#39;#229954&#39; },
      { name: &#39;Purple&#39;, hex: &#39;#9B59B6&#39; }
    ]
  }
});
</code></pre><pre><code class="html">&lt;div id=&quot;app&quot;&gt;
  &lt;my-list :title=&quot;Shapes&quot;&gt;
    &lt;div class=&quot;list-item&quot; v-for=&quot;item in shapes&quot;&gt;
      &lt;div&gt;{{ shape.name }} &lt;small&gt;({{ shape.sides }} sides)&lt;/small&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/my-list&gt;
  &lt;my-list :title=&quot;Colors&quot;&gt;
    &lt;div class=&quot;list-item&quot; v-for=&quot;color in colors&quot;&gt;
      &lt;div&gt;
        &lt;div class=&quot;swatch&quot; :style=&quot;{ background: color.hex }&quot;&gt;&lt;/div&gt;
        {{ color.name }}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/my-list&gt;
&lt;/div&gt;
</code></pre><p>效果如下图：</p><p><img src="https://raw.githubusercontent.com/Chorer/MyBlog-Pic/master/Myblogs/一个案例搞懂%20Vue.js%20的作用域插槽-4.png" alt=""></p><h2 id="大材小用的组件"><a href="#大材小用的组件" class="headerlink" title="大材小用的组件"></a>大材小用的组件</h2><p>我们刚才创建的组件确实符合要求，但那段代码算不上很好。<code>my-list</code> 本来应该是一个展示列表的组件，但我们却把渲染列表需要的逻辑部分抽象到了父组件中，这样一来，子组件在这里只不过是用来包裹列表而已，未免显得大材小用了。</p><p>更糟糕的是，在两个组件的声明中存在着大量重复代码（例如，<code>&lt;div class=&quot;list-item&quot; v-for=&quot;item in ...&quot;&gt;</code>）。如果我们能够在子组件中编写这些代码，那么子组件就不再是“打酱油的角色”了。</p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>普通插槽无法满足我们的需求，这时候，<strong>作用域插槽</strong>就派上用场了。作用域插槽允许你传递一个模板而不是已经渲染好的元素给插槽。之所以叫做”作用域“插槽，是因为模板虽然是在父级作用域中渲染的，却能拿到子组件的数据。</p><p>例如，带有作用域插槽的组件 <code>child</code> 大概是下面这个样子：</p><pre><code class="html">&lt;div&gt;
  &lt;slot my-prop=&quot;Hello from child&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre><p>使用这个组件的父组件将会在插槽中声明一个 <code>template</code> 元素。这个模板元素会有一个 <code>scope</code> （译者注：Vue 2.6 后改为 <code>v-slot</code> 属性）属性指向一个对象，任何添加到插槽（位于子组件模板）中的属性都会作为这个对象的属性。</p><pre><code class="html">&lt;child&gt;
  &lt;template scope=&quot;props&quot;&gt;
    &lt;span&gt;Hello from parent&lt;/span&gt;
    &lt;span&gt;{{ props.my-prop }}&lt;/span&gt;
  &lt;/template&gt;
&lt;/child&gt;
</code></pre><p>将会渲染成：</p><pre><code class="html">&lt;div&gt;
  &lt;span&gt;Hello from parent&lt;/span&gt;
  &lt;span&gt;Hello from child&lt;/span&gt;
&lt;/div&gt;
</code></pre><h2 id="在-my-list-中使用作用域插槽"><a href="#在-my-list-中使用作用域插槽" class="headerlink" title="在 my-list 中使用作用域插槽"></a>在 <code>my-list</code> 中使用作用域插槽</h2><p>我们将两个列表数组通过 <code>props</code> 传递给 <code>my-list</code>。之后将普通插槽替换为作用域插槽，这样，<code>my-list</code> 就能够负责迭代列表项目，同时父组件依然能够定义每个项目具体的展示方式。</p><p><em>index.html</em></p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;
  &lt;my-list title=&quot;Shapes&quot; :items=&quot;shapes&quot;&gt;
    &lt;!--在这里书写 template--&gt;
  &lt;/my-list&gt;
  &lt;my-list title=&quot;Colors&quot; :items=&quot;colors&quot;&gt;
    &lt;!--在这里书写 template--&gt;
  &lt;/my-list&gt;   
&lt;/div&gt;
</code></pre><p>接着我们让 <code>my-list</code> 迭代项目。在 <code>v-for</code> 循环中，<code>item</code> 是当前迭代项目的别名。我们可以创建一个插槽并通过 <code>v-bind=&quot;item&quot;</code> 将那个项目绑定到插槽中。</p><p><em>app.js</em></p><pre><code class="js">Vue.component(&#39;my-list&#39;, {
  template: &#39;#my-list&#39;,
  props: [ &#39;title&#39;, &#39;items&#39; ]
});
</code></pre><p><em>index.html</em></p><pre><code class="html">&lt;script type=&quot;text/x-template&quot; id=&quot;my-list&quot;&gt;
  &lt;div class=&quot;my-list&quot;&gt;
    &lt;div class=&quot;title&quot;&gt;{{ title }}&lt;/div&gt;
    &lt;div class=&quot;list&quot;&gt;
      &lt;div v-for=&quot;item in items&quot;&gt;
        &lt;slot v-bind=&quot;item&quot;&gt;&lt;/slot&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;
</code></pre><blockquote><p>注意：也许你之前没见过不带参数的 <code>v-bind</code> 用法。这种用法将会把整个对象的所以属性都绑定到当前元素上。在涉及作用域插槽时，这种用法很常见，因为绑定的对象可能有很多属性，而一一将它们列举出来并手动绑定显然太麻烦了。</p></blockquote><p>现在，回到根实例这里来，在 <code>my-list</code> 的插槽中声明一个模板。首先看一下几何图形列表（第一个例子中的列表），我们声明的模板必须带有一个 <code>scope</code> 属性，这里将其赋值为 <code>shape</code>。<code>shape</code> 这个别名可以让我们访问作用域插槽。在模板中，我们可以继续沿用最初例子中的标记来展示项目。</p><pre><code class="html">&lt;my-list title=&quot;Shapes&quot; :items=&quot;shapes&quot;&gt;
  &lt;template scope=&quot;shape&quot;&gt;
    &lt;div&gt;{{ shape.name }} &lt;small&gt;({{ shape.sides }} sides)&lt;/small&gt;&lt;/div&gt;
  &lt;/template&gt;
&lt;/my-list&gt;
</code></pre><p>整个模板大概是下面这样：</p><pre><code class="html">&lt;div id=&quot;app&quot;&gt;
  &lt;my-list title=&quot;Shapes&quot; :items=&quot;shapes&quot;&gt;
    &lt;template scope=&quot;shape&quot;&gt;
      &lt;div&gt;{{ shape.name }} &lt;small&gt;({{ shape.sides }} sides)&lt;/small&gt;&lt;/div&gt;
    &lt;/template&gt;
  &lt;/my-list&gt;
  &lt;my-list title=&quot;Colors&quot; :items=&quot;colors&quot;&gt;
    &lt;template scope=&quot;color&quot;&gt;
      &lt;div&gt;
        &lt;div class=&quot;swatch&quot; :style=&quot;{ background: color.hex }&quot;&gt;&lt;/div&gt;
        {{ color.name }}
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/my-list&gt;   
&lt;/div&gt;
</code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>虽然用上作用域插槽之后，代码量并未减少，但是我们将通用的功能都交由子组件负责，这显著提高了代码的健壮性。</p><p>完整代码的 Codepen 在这里：</p><p><a href="https://codepen.io/anthonygore/pen/zExPZX" target="_blank" rel="noopener">https://codepen.io/anthonygore/pen/zExPZX</a></p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/10/13/F-file 协议导致的跨域问题以及解决方案/" rel="prev" title="file 协议导致的跨域问题以及解决方案"><i class="fa fa-angle-double-left"></i>&nbspfile 协议导致的跨域问题以及解决方案</a></div><div class="post-nav-next"><a href="/2019/10/08/F-Vue 组件（四）：组件插槽/" rel="next" title="Vue 组件（四）：组件插槽">Vue 组件（四）：组件插槽&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top"><i class="fa fa-th-large"></i>Catalog</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#最基础的组件"><span class="toc-text">最基础的组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更通用的-my-list"><span class="toc-text">更通用的 my-list</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大材小用的组件"><span class="toc-text">大材小用的组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域插槽"><span class="toc-text">作用域插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在-my-list-中使用作用域插槽"><span class="toc-text">在 my-list 中使用作用域插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"mm",pageSize:10,visitor:!0})</script></section></main><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - 2019 My Blog</p><p class="a">Powered by <a href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/search.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300,"vOffset":-120,"hOffset":-5},"mobile":{"show":false},"react":{"opacityDefault":1000,"opacityOnHover":1000},"log":false});</script></body></html><!-- rebuild by neat -->