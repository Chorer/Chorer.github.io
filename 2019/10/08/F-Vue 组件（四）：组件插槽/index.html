<!-- build time:Sun Sep 05 2021 16:01:26 GMT+0800 (中国标准时间) --><!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scaleable=0" name="viewport"><title>Focus on FE learning</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/third%20party/jquery.fancybox.css"><link rel="stylesheet" href="/css/third%20party/pace-theme-flash.css"><link rel="icon" href="/images/kour.gif"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-xonokai.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head><body><header class="header"><div class="header_top"><span class="theme"><a href="/">Chor's blog</a></span><nav class="navbar"><ul class="menu"><li class="menu-item"><i class="fa fa-home"></i> <a href="/" class="menu-item-link">首页</a></li><li class="menu-item"><i class="fa fa-folder-open"></i> <a href="/categories" class="menu-item-link">分类</a></li><li class="menu-item"><i class="fa fa-archive"></i> <a href="/archives" class="menu-item-link">归档</a></li><li class="menu-item"><i class="fa fa-tags"></i> <a href="/tags" class="menu-item-link">标签</a></li><li class="menu-item"><i class="fa fa-user"></i> <a href="/about" class="menu-item-link">关于</a></li></ul></nav></div><i id="homelink" data-link="https://chorer.github.io/"></i><div class="header_bottom"><div class="blog-title"><a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue" class="logo">Focus on FE learning</a><div class="descrs"><div class="descr">个人博客</div><div class="descr">" Do what you love,Love what you do "</div></div><div class="blog-down"><a href="javascript:void(0);"><i class="fa fa-angle-double-down fa-2x"></i></a></div></div></div></header><main class="main"><section class="posts"><article class="post_full"><h1 class="post-title"><div class="post-title-link">Vue 组件（四）：组件插槽</div></h1><div class="post-info"><div class="post-date"><i class="fa fa-calendar"></i>&nbsp2019-10-08&nbsp&nbsp&nbsp</div><span class="post-words"><i class="fa fa-pencil-square-o"></i>&nbsp2.4k&nbspwords&nbsp&nbsp </span><span class="post-time"><i class="fa fa-clock-o"></i>&nbsp9 mins&nbsp&nbsp&nbsp</span><div class="post-tags"><i class="fa fa-tags"></i> <a href="/tags/Vue/">Vue</a> <a href="/tags/组件/">组件</a></div></div><div class="post-content"><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-1.png"></div><span id="more"></span><p>今天刚学到作用域插槽的概念，结果跑到官网文档一看： &gt;在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除且仍在文档中的特性。</p><p>看到这里，突然有了一点想法。 为什么知识越学越多，因为学习的速度很难赶上技术迭代的速度，而且你越晚学习越会有这种感觉。Vue 3.0 的源码在前几天公布（国庆期间）了，根据群里大佬的说法，明年第一季度很可能就正式发布 3.0，似乎暗示着又一波学习热潮即将到来。工作以后和业务打交道，其实很少有时间可以学习了，所以现在 —— 大学的时间真的很宝贵，得好好珍惜。</p><h2 id="为什么需要插槽">为什么需要插槽？</h2><p>我们先来看下这幅图：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-2.png"></div><p>可以看到，每个页面都有对应的 <code>nav-bar</code>，所以这应该是一个可以复用的组件。问题是怎么复用呢？统一封装成一个组件肯定不行，因为这些 <code>nav-bar</code> 结构和内容并不完全相同；针对每个页面都封装一个组件也不行，因为它们有相同的结构和内容，这不利于复用。</p><p>所以我们需要的其实是一个足够灵活的组件，其内容可以更进一步地自定义，就像是积木一样，对于同一个位置 C，我们可以安插 A ，也可以安插 B。而<strong>插槽(slot)</strong> 就是用来实现这种灵活性的。</p><p>插槽是子组件暴露的一个让父组件传入自定义内容的接口。我们可以形象地把它理解成电脑的各种接口，提供了各种扩展。</p><h2 id="单个插槽">单个插槽</h2><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">// 子组件
<span class="kw">&lt;template&gt;</span>
  <span class="kw">&lt;slot&gt;&lt;/slot&gt;</span>
<span class="kw">&lt;/template&gt;</span>

// 父组件
<span class="kw">&lt;template&gt;</span>
  <span class="kw">&lt;cpn&gt;</span>
    <span class="kw">&lt;span&gt;</span>我是父组件传给子组件插槽的内容<span class="kw">&lt;span&gt;</span>
  <span class="kw">&lt;/cpn&gt;</span>
<span class="kw">&lt;/template&gt;</span></code></pre></div><p><code>&lt;slot&gt;&lt;/slot&gt;</code> 相当于一个空缺，等待父组件给它填充内容。当然也可以给 <code>&lt;slot&gt;&lt;/slot&gt;</code> 指定默认值，例如 <code>&lt;slot&gt;我是默认值&lt;/slot&gt;</code>，这种情况下，其将在父组件未传入内容时（即 <code>&lt;cpn&gt;&lt;/cpn&gt;</code>）得到应用。</p><p>子组件可有多个 <code>slot</code>，这些 <code>slot</code> 都将使用父组件传入的内容。</p><h2 id="具名插槽">具名插槽</h2><p>大部分时候，我们需要给特定的插槽传入特定的内容，所以每个插槽必须得有一个名字作为标识，这时候就要使用具名插槽了。具体来说，就是给 <code>slot</code> 添加 <code>name</code> 属性，之后在父组件中真正传入内容的时候，将内容包裹在有 <code>slot=&quot;name&quot;</code> 属性的元素中。 假设我们要用同一个组件实现下面三种不同效果：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-3.png"></div><p>那么，首先会想到给这个子组件三个插槽，由于特定的插槽要传入特定的内容，所以我们这里使用具名插槽。代码如下：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--父组件模板--&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;cpn&gt;</span>
    <span class="kw">&lt;span</span><span class="ot"> slot=</span><span class="st">&quot;right&quot;</span><span class="kw">&gt;</span>5<span class="kw">&lt;/span&gt;</span>
  <span class="kw">&lt;/cpn&gt;</span>
  <span class="kw">&lt;cpn&gt;</span>
    <span class="kw">&lt;span</span><span class="ot"> slot=</span><span class="st">&quot;left&quot;</span><span class="kw">&gt;</span>4<span class="kw">&lt;/span&gt;</span>
    <span class="kw">&lt;span</span><span class="ot"> slot=</span><span class="st">&quot;right&quot;</span><span class="kw">&gt;</span>6<span class="kw">&lt;/span&gt;</span>
  <span class="kw">&lt;/cpn&gt;</span>
  <span class="kw">&lt;cpn&gt;</span>
    <span class="kw">&lt;span</span><span class="ot"> slot=</span><span class="st">&quot;center&quot;</span><span class="kw">&gt;</span>3<span class="kw">&lt;/span&gt;</span>
    <span class="kw">&lt;span</span><span class="ot"> slot=</span><span class="st">&quot;right&quot;</span><span class="kw">&gt;</span>7<span class="kw">&lt;/span&gt;</span>
  <span class="kw">&lt;/cpn&gt;</span>
<span class="kw">&lt;/div&gt;</span>

<span class="co">&lt;!--子组件模板--&gt;</span>
<span class="kw">&lt;template</span><span class="ot"> id=</span><span class="st">&quot;cpn&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;div&gt;</span>
    <span class="kw">&lt;h2&gt;</span>我是子组件<span class="kw">&lt;/h2&gt;</span>
    <span class="kw">&lt;slot</span><span class="ot"> name=</span><span class="st">&quot;left&quot;</span><span class="kw">&gt;</span>1<span class="kw">&lt;/slot&gt;</span>
    <span class="kw">&lt;slot</span><span class="ot"> name=</span><span class="st">&quot;center&quot;</span><span class="kw">&gt;</span>2<span class="kw">&lt;/slot&gt;</span>
    <span class="kw">&lt;slot</span><span class="ot"> name=</span><span class="st">&quot;right&quot;</span><span class="kw">&gt;</span>3<span class="kw">&lt;/slot&gt;</span>
  <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/template&gt;</span></code></pre></div><p>效果为：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-4.png"></div><p><em>注意</em>： * Vue 2.6.0 之后改 <code>slot</code> 为 <code>v-slot</code>，且必须绑定在一个 <code>template</code> 元素上：</p><p>```html <span slot="right">5</span></p><p></p><p><template v-slot:right><span>5</span></template>```</p><ul><li>另外，我们可以将 <code>v-slot:right</code> 直接缩写为 <code>#right</code>，注意这仅适用于 <code>v-slot</code> 有参数的情况，例如 <code>v-slot=&quot;xxx&quot;</code> 是不能缩写的。</li></ul><h2 id="编译作用域">编译作用域</h2><p>关于编译作用域，只需要记住一条规则： &gt;父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p><p>来看一个例子：</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--HTML--&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;cpn</span><span class="ot"> v-if=</span><span class="st">&quot;isShow&quot;</span><span class="kw">&gt;&lt;/cpn&gt;</span>
<span class="kw">&lt;/div&gt;</span>  </code></pre></div><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// JS</span>
<span class="kw">const</span> app <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">&#123;</span>
  <span class="dt">el</span><span class="op">:</span><span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">components</span><span class="op">:&#123;</span>
    <span class="dt">cpn</span><span class="op">:&#123;</span>
      <span class="dt">template</span><span class="op">:</span><span class="st">&quot;#cpn&quot;</span><span class="op">,</span>
      <span class="at">data</span>()<span class="op">&#123;</span>
        <span class="cf">return</span> <span class="op">&#123;</span>
          <span class="dt">isShow</span><span class="op">:</span><span class="kw">true</span>
        <span class="op">&#125;</span>
      <span class="op">&#125;</span>
    <span class="op">&#125;</span>
  <span class="op">&#125;,</span>
  <span class="dt">data</span><span class="op">:&#123;</span>
    <span class="dt">isShow</span><span class="op">:</span><span class="kw">false</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>)</code></pre></div><p>对于这个例子，组件最后到底会不会显示（渲染）呢？ 答案是不会。尽管父组件和子组件都有 <code>isShow</code> 这个变量，且后者为 <code>true</code>，但子组件是存在于父级模板中的，其内容是在父级作用域中编译的，只能识别父级作用域中为 <code>false</code> 的那个 <code>isShow</code>。</p><p>在这里，我们知道父模板无法直接访问子组件中的数据，但是有了<strong>作用域插槽</strong>之后，又不一样了。</p><h2 id="作用域插槽">作用域插槽</h2><p>我们先来设想一种情况。假定子组件中有数据：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">languages<span class="op">:</span>[<span class="st">&quot;Java&quot;</span><span class="op">,</span><span class="st">&quot;C&quot;</span><span class="op">,</span><span class="st">&quot;Python&quot;</span><span class="op">,</span><span class="st">&quot;Swift&quot;</span>]</code></pre></div><p>然后，现在要求在父组件中以不同的形式将这些数据进行展示，可能是列表，也可能是互相之间以斜杆分隔。如下图：</p><div class="figure"><img src="https://myblog-1258623898.cos.ap-chengdu.myqcloud.com/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD/Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD-6.png"></div><p>首先，数据的呈现方式不同，也即 HTML 结构不同，因此不能直接在子组件模板中书写结构，这时候想到了应该给子组件一个插槽，后面在父组件模板中再定义结构。但这样一来，父组件无可避免地要使用子组件的数据，而前面说过编译作用域的问题，所以这里的父组件实际上是无法拿到子组件数据的。怎么办呢？</p><p>这时候，作用域插槽就派上用场了。作用域插槽可以理解为是带数据的插槽，它允许我们<strong>在父组件模板中访问子组件的数据</strong>。典型的应用场景就是，数据在子组件中，但是渲染数据的工作必须由父组件完成。</p><p>实现分为两步：</p><ul><li>将子组件数据绑定给 <code>slot</code> 上的属性（成为 <code>插槽 prop</code>）</li><li>父组件模板中通过 <code>slot-scope</code> 拿到 <code>slot</code> 对象（准确地说是包含所有 <code>插槽prop</code> 的对象）并进行属性访问</li></ul><p>以这道题为例：</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// JS</span>
<span class="kw">const</span> app <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">&#123;</span>
  <span class="dt">el</span><span class="op">:</span><span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">components</span><span class="op">:&#123;</span>
    <span class="dt">cpn</span><span class="op">:&#123;</span>
      <span class="dt">template</span><span class="op">:</span><span class="st">&quot;#cpn&quot;</span><span class="op">,</span>
      <span class="at">data</span>()<span class="op">&#123;</span>
        <span class="cf">return</span> <span class="op">&#123;</span>
          <span class="dt">languages</span><span class="op">:</span>[<span class="st">&quot;Java&quot;</span><span class="op">,</span><span class="st">&quot;C&quot;</span><span class="op">,</span><span class="st">&quot;Python&quot;</span><span class="op">,</span><span class="st">&quot;Swift&quot;</span>]
        <span class="op">&#125;</span>
      <span class="op">&#125;</span>
    <span class="op">&#125;</span>
  <span class="op">&#125;</span>
<span class="op">&#125;</span>)</code></pre></div><p>首先，我们通过 <code>:lang=&quot;languages&quot;</code> 将子组件的 <code>languages</code> 绑定到 <code>slot</code> 的 <code>lang</code> 属性中。</p><div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--子组件模板--&gt;</span>
<span class="kw">&lt;template</span><span class="ot"> id=</span><span class="st">&quot;cpn&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;div&gt;</span>
    <span class="kw">&lt;h2&gt;</span>展示方式：<span class="kw">&lt;/h2&gt;</span>
    <span class="kw">&lt;slot</span><span class="ot"> :lang=</span><span class="st">&quot;languages&quot;</span><span class="kw">&gt;&lt;/slot&gt;</span>
  <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/template&gt;</span></code></pre></div><p>接着，父组件模板中给插槽传入 <code>template</code>，这个 <code>template</code> 带有 <code>slot-scope=&quot;obj&quot;</code>，使得我们可以通过 <code>obj.lang</code> 访问到子组件数据。</p><div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">&lt;</span>div id<span class="op">=</span><span class="st">&quot;app&quot;</span><span class="op">&gt;</span>
  <span class="op">&lt;!--</span>展示方式一<span class="op">--&gt;</span>
  <span class="op">&lt;</span>cpn<span class="op">&gt;</span>
    <span class="op">&lt;</span>template slot<span class="op">-</span>scope<span class="op">=</span><span class="st">&quot;obj&quot;</span><span class="op">&gt;</span>
      <span class="op">&lt;</span>ul<span class="op">&gt;</span>
        <span class="op">&lt;</span>li v<span class="op">-</span><span class="cf">for</span><span class="op">=</span><span class="st">&quot;item in obj.lang&quot;</span><span class="op">&gt;&lt;!--</span>swig￼<span class="dv">0</span><span class="op">--&gt;&lt;</span><span class="ss">/li&gt;</span>
<span class="ss">      &lt;/ul</span><span class="op">&gt;</span>
    <span class="op">&lt;</span><span class="ss">/template&gt;</span>
<span class="ss">  &lt;/cpn</span><span class="op">&gt;</span>
  <span class="op">&lt;!--</span>展示方式二<span class="op">--&gt;</span>
  <span class="op">&lt;</span>cpn<span class="op">&gt;</span>
    <span class="op">&lt;</span>template slot<span class="op">-</span>scope<span class="op">=</span><span class="st">&quot;obj&quot;</span><span class="op">&gt;</span>
        <span class="op">&lt;!--</span>swig￼<span class="dv">1</span><span class="op">--&gt;</span>
    <span class="op">&lt;</span><span class="ss">/template&gt;</span>
<span class="ss">  &lt;/cpn</span><span class="op">&gt;</span>
  <span class="op">&lt;!--</span>展示方式三<span class="op">--&gt;</span>
  <span class="op">&lt;</span>cpn<span class="op">&gt;</span>
    <span class="op">&lt;</span>template slot<span class="op">-</span>scope<span class="op">=</span><span class="st">&quot;obj&quot;</span><span class="op">&gt;</span>
        <span class="op">&lt;!--</span>swig￼<span class="dv">2</span><span class="op">--&gt;</span>
    <span class="op">&lt;</span><span class="ss">/template&gt;</span>
<span class="ss">  &lt;/cpn</span><span class="op">&gt;</span>
<span class="op">&lt;</span><span class="ss">/div&gt;  </span></code></pre></div><p>最终实现我们想要的效果。 当然，关于作用域插槽还有一些地方需要注意：</p><ul><li><p>如果数据过多，不可能一一绑定，这时候直接 <code>v-bind</code> 到一个属性就行，这个操作等同于手动绑定所有数据，方便了我们的访问。上例如果是 <code>&lt;slot v-bind:obj&gt;&lt;/slot&gt;</code>，后面直接 <code>obj.languages</code> 就能拿到数据了</p></li><li><p>Vue 2.6.0 之后，改 <code>slot-scope</code> 为 <code>v-slot</code>，对于像上面一样的匿名插槽，只需要使用 <code>v-slot=&quot;obj&quot;</code>；对于具名插槽，则使用 <code>v-slot:name=&quot;obj&quot;</code>。当然，<code>v-slot:name</code> 依然是表示具名插槽。</p></li><li><p>正如前面所说，<code>v-slot:name=&quot;obj&quot;</code> 也可以缩写为 <code>#name=&quot;obj&quot;</code></p></li><li><p>另外，还有解构插槽、动态插槽名等，具体可以看<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95">文档</a>。</p></li></ul><p>关于作用域插槽的应用，还有一个不错的案例，具体可以看下我之前翻译的一篇<a target="_blank" rel="noopener" href="https://juejin.im/post/5d9f200d6fb9a04e19505221">文章</a>。我觉得里面有句话说得很有道理： &gt;A good approach when you can't understand something easily is to try put it to use in solving a problem.</p><p>大意是：当知识难以理解的时候，最好的办法就是拿它去解决问题。</p><p>我在这篇文章中其实也是尽量按照这个思路布局的，首先是刻意制造了一个问题，按照常规的思路没办法解决，接着引出相关概念，在实际情境中体会它的应用，这时候会有一种“噢，原来xxx可以解决这类型问题”的感觉，我觉得这或许是一种不错的学习方式，毕竟很多东西是为了解决问题而存在的，若能从最初问题产生的源头开始思考，兴许我们可以更好地理解它。</p></div><div class="post-nav"><div class="post-nav-prev"><a href="/2019/10/10/Trs-%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%90%9E%E6%87%82%20Vue.js%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/" rel="prev" title="「译」一个案例搞懂 Vue.js 的作用域插槽"><i class="fa fa-angle-double-left"></i>&nbsp「译」一个案例搞懂 Vue.js 的作用域插槽</a></div><div class="post-nav-next"><a href="/2019/10/04/F-Vue%20%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/" rel="next" title="Vue 组件（三）：关于单向数据流的简单理解">Vue 组件（三）：关于单向数据流的简单理解&nbsp<i class="fa fa-angle-double-right"></i></a></div><div class="clear"></div></div></article><div class="post-toc"><div class="toc-top">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8F%92%E6%A7%BD"><span class="toc-text">为什么需要插槽？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E6%8F%92%E6%A7%BD"><span class="toc-text">单个插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="toc-text">具名插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">编译作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"><span class="toc-text">作用域插槽</span></a></li></ol></div><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"c9Ume1Givsusy6VyqV87iT2z-gzGzoHsz",appKey:"5F7jhJfENet59xDteaKqobSK",notify:!1,verify:!1,placeholder:"Just talk here......",avatar:"retro",pageSize:10,visitor:!0})</script></section></main><script>var user=[1,2,3,4]</script><footer class="footer"><div class="footer-info"><p>Copyright © 2018 - <span>2021</span> My Blog</p><p class="a">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a> | Theme - <a target="_blank" rel="noopener" href="https://github.com/Chorer/hexo-theme-PureBlue">PureBlue</a></p></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/js/navbar.js"></script><script src="/js/pace.min.js"></script><script src="/js/code.js"></script><script src="/js/load.js"></script><script src="/js/search.js"></script><script src="/js/post-except.js"></script><script src="/js/jquery.fancybox.js"></script><script src="/js/jquery.fancyboxStart.js"></script><script src="/js/toc.js"></script><script src="/js/jquery.toTop.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.2.0/dist/vanilla-back-to-top.min.js"></script><script src="/js/IndexToTop.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5cd8f8959eacf92e"></script></body></html><!-- rebuild by neat -->